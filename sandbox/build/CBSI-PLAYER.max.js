/**
 * CBSI-PLAYER v2.8.3
 * Built 03/20/2018 at 1:09:27 PM (EDT)
 * Includes:
 *   - hls.js v0.8.9
 */
(function(){var define, require;
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash include="noConflict,compact,drop,indexOf,pull,sortBy,without,every,find,forEach,includes,map,some,debounce,throttle,clone,cloneDeep,isArray,isBoolean,isDate,isEmpty,isFunction,isNull,isNumber,isNaN,isUndefined,isObject,isPlainObject,isString,indexOf,assign,extend,get,forOwn,omitBy,capitalize,endsWith,has,inRange,min,padStart,round,startsWith,template,toJSON" --development --source-map --output lib/lodash.js`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.5';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reUnescapedHtml = /[&<>"']/g,
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /*--------------------------------------------------------------------------*/

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /** Used to restore the original `_` reference in `_.noConflict`. */
  var oldDash = root._;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice,
      spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
      symIterator = Symbol ? Symbol.iterator : undefined,
      symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  var defineProperty = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeCeil = Math.ceil,
      nativeFloor = Math.floor,
      nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object),
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeNow = Date.now,
      nativeReverse = arrayProto.reverse;

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');

  /** Used to store function metadata. */
  var metaMap = WeakMap && new WeakMap;

  /** Used to lookup unminified function names. */
  var realNames = {};

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit method
   * chain sequences. Methods that operate on and return arrays, collections,
   * and functions can be chained together. Methods that retrieve a single value
   * or may return a primitive value will automatically end the chain sequence
   * and return the unwrapped value. Otherwise, the value must be unwrapped
   * with `_#value`.
   *
   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
   * enabled using `_.chain`.
   *
   * The execution of chained methods is lazy, that is, it's deferred until
   * `_#value` is implicitly or explicitly called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion.
   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
   * the creation of intermediate arrays and can greatly reduce the number of
   * iteratee executions. Sections of a chain sequence qualify for shortcut
   * fusion if the section is applied to an array and iteratees accept only
   * one argument. The heuristic for whether a section qualifies for shortcut
   * fusion is subject to change.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
   * `zipObject`, `zipObjectDeep`, and `zipWith`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
   * `upperFirst`, `value`, and `words`
   *
   * @name _
   * @constructor
   * @category Seq
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // Returns an unwrapped value.
   * wrapped.reduce(_.add);
   * // => 6
   *
   * // Returns a wrapped value.
   * var squares = wrapped.map(square);
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash(value) {
    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
      if (value instanceof LodashWrapper) {
        return value;
      }
      if (hasOwnProperty.call(value, '__wrapped__')) {
        return wrapperClone(value);
      }
    }
    return new LodashWrapper(value);
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /**
   * The function whose prototype chain sequence wrappers inherit from.
   *
   * @private
   */
  function baseLodash() {
    // No operation performed.
  }

  /**
   * The base constructor for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap.
   * @param {boolean} [chainAll] Enable explicit method chain sequences.
   */
  function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = undefined;
  }

  /**
   * By default, the template delimiters used by lodash are like those in
   * embedded Ruby (ERB) as well as ES2015 template strings. Change the
   * following template settings to use alternative delimiters.
   *
   * @static
   * @memberOf _
   * @type {Object}
   */
  lodash.templateSettings = {

    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'escape': reEscape,

    /**
     * Used to detect code to be evaluated.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'evaluate': reEvaluate,

    /**
     * Used to detect `data` property values to inject.
     *
     * @memberOf _.templateSettings
     * @type {RegExp}
     */
    'interpolate': reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @memberOf _.templateSettings
     * @type {string}
     */
    'variable': '',

    /**
     * Used to import variables into the compiled template.
     *
     * @memberOf _.templateSettings
     * @type {Object}
     */
    'imports': {

      /**
       * A reference to the `lodash` function.
       *
       * @memberOf _.templateSettings.imports
       * @type {Function}
       */
      '_': lodash
    }
  };

  // Ensure wrappers are instances of `baseLodash`.
  lodash.prototype = baseLodash.prototype;
  lodash.prototype.constructor = lodash;

  LodashWrapper.prototype = baseCreate(baseLodash.prototype);
  LodashWrapper.prototype.constructor = LodashWrapper;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
   *
   * @private
   * @constructor
   * @param {*} value The value to wrap.
   */
  function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH;
    this.__views__ = [];
  }

  /**
   * Creates a clone of the lazy wrapper object.
   *
   * @private
   * @name clone
   * @memberOf LazyWrapper
   * @returns {Object} Returns the cloned `LazyWrapper` object.
   */
  function lazyClone() {
    var result = new LazyWrapper(this.__wrapped__);
    result.__actions__ = copyArray(this.__actions__);
    result.__dir__ = this.__dir__;
    result.__filtered__ = this.__filtered__;
    result.__iteratees__ = copyArray(this.__iteratees__);
    result.__takeCount__ = this.__takeCount__;
    result.__views__ = copyArray(this.__views__);
    return result;
  }

  /**
   * Reverses the direction of lazy iteration.
   *
   * @private
   * @name reverse
   * @memberOf LazyWrapper
   * @returns {Object} Returns the new reversed `LazyWrapper` object.
   */
  function lazyReverse() {
    if (this.__filtered__) {
      var result = new LazyWrapper(this);
      result.__dir__ = -1;
      result.__filtered__ = true;
    } else {
      result = this.clone();
      result.__dir__ *= -1;
    }
    return result;
  }

  /**
   * Extracts the unwrapped value from its lazy wrapper.
   *
   * @private
   * @name value
   * @memberOf LazyWrapper
   * @returns {*} Returns the unwrapped value.
   */
  function lazyValue() {
    var array = this.__wrapped__.value(),
        dir = this.__dir__,
        isArr = isArray(array),
        isRight = dir < 0,
        arrLength = isArr ? array.length : 0,
        view = getView(0, arrLength, this.__views__),
        start = view.start,
        end = view.end,
        length = end - start,
        index = isRight ? end : (start - 1),
        iteratees = this.__iteratees__,
        iterLength = iteratees.length,
        resIndex = 0,
        takeCount = nativeMin(length, this.__takeCount__);

    if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
      return baseWrapperValue(array, this.__actions__);
    }
    var result = [];

    outer:
    while (length-- && resIndex < takeCount) {
      index += dir;

      var iterIndex = -1,
          value = array[index];

      while (++iterIndex < iterLength) {
        var data = iteratees[iterIndex],
            iteratee = data.iteratee,
            type = data.type,
            computed = iteratee(value);

        if (type == LAZY_MAP_FLAG) {
          value = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result[resIndex++] = value;
    }
    return result;
  }

  // Ensure `LazyWrapper` is an instance of `baseLodash`.
  LazyWrapper.prototype = baseCreate(baseLodash.prototype);
  LazyWrapper.prototype.constructor = LazyWrapper;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map || ListCache),
      'string': new Hash
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /*------------------------------------------------------------------------*/

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * The base implementation of `_.at` without support for individual paths.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {string[]} paths The property paths to pick.
   * @returns {Array} Returns the picked elements.
   */
  function baseAt(object, paths) {
    var index = -1,
        length = paths.length,
        result = Array(length),
        skip = object == null;

    while (++index < length) {
      result[index] = skip ? undefined : get(object, paths[index]);
    }
    return result;
  }

  /**
   * The base implementation of `_.clamp` which doesn't coerce arguments.
   *
   * @private
   * @param {number} number The number to clamp.
   * @param {number} [lower] The lower bound.
   * @param {number} upper The upper bound.
   * @returns {number} Returns the clamped number.
   */
  function baseClamp(number, lower, upper) {
    if (number === number) {
      if (upper !== undefined) {
        number = number <= upper ? number : upper;
      }
      if (lower !== undefined) {
        number = number >= lower ? number : lower;
      }
    }
    return number;
  }

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        result = (isFlat || isFunc) ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat
            ? copySymbolsIn(value, baseAssignIn(result, value))
            : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });

      return result;
    }

    if (isMap(value)) {
      value.forEach(function(subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });

      return result;
    }

    var keysFunc = isFull
      ? (isFlat ? getAllKeysIn : getAllKeys)
      : (isFlat ? keysIn : keys);

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function(subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    }
    else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee == null ? value : iteratee(value);

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      }
      else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = createBaseEach(baseForOwn);

  /**
   * The base implementation of `_.every` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`
   */
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }

  /**
   * The base implementation of methods like `_.max` and `_.min` which accepts a
   * `comparator` to determine the extremum value.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The iteratee invoked per iteration.
   * @param {Function} comparator The comparator used to compare values.
   * @returns {*} Returns the extremum value.
   */
  function baseExtremum(array, iteratee, comparator) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      var value = array[index],
          current = iteratee(value);

      if (current != null && (computed === undefined
            ? (current === current && !isSymbol(current))
            : comparator(current, computed)
          )) {
        var computed = current,
            result = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;

    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  /**
   * The base implementation of `_.functions` which creates an array of
   * `object` function property names filtered from `props`.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Array} props The property names to filter.
   * @returns {Array} Returns the function names.
   */
  function baseFunctions(object, props) {
    return arrayFilter(props, function(key) {
      return isFunction(object[key]);
    });
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * The base implementation of `_.has` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHas(object, key) {
    return object != null && hasOwnProperty.call(object, key);
  }

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  /**
   * The base implementation of `_.inRange` which doesn't coerce arguments.
   *
   * @private
   * @param {number} number The number to check.
   * @param {number} start The start of the range.
   * @param {number} end The end of the range.
   * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
   */
  function baseInRange(number, start, end) {
    return number >= nativeMin(start, end) && number < nativeMax(start, end);
  }

  /**
   * The base implementation of `_.invoke` without support for individual
   * method arguments.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the method to invoke.
   * @param {Array} args The arguments to invoke the method with.
   * @returns {*} Returns the result of the invoked method.
   */
  function baseInvoke(object, path, args) {
    path = castPath(path, object);
    object = parent(object, path);
    var func = object == null ? object : object[toKey(last(path))];
    return func == null ? undefined : apply(func, object, args);
  }

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  /**
   * The base implementation of `_.isDate` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
   */
  function baseIsDate(value) {
    return isObjectLike(value) && baseGetTag(value) == dateTag;
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : getTag(object),
        othTag = othIsArr ? arrayTag : getTag(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return (objIsArr || isTypedArray(object))
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == 'object') {
      return isArray(value)
        ? baseMatchesProperty(value[0], value[1])
        : baseMatches(value);
    }
    return property(value);
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */
  function baseLt(value, other) {
    return value < other;
  }

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];

    baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn(object, path)
        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  /**
   * The base implementation of `_.orderBy` without param guards.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
   * @param {string[]} orders The sort orders of `iteratees`.
   * @returns {Array} Returns the new sorted array.
   */
  function baseOrderBy(collection, iteratees, orders) {
    var index = -1;
    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

    var result = baseMap(collection, function(value, key, collection) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { 'criteria': criteria, 'index': ++index, 'value': value };
    });

    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }

  /**
   * The base implementation of  `_.pickBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @param {Function} predicate The function invoked per property.
   * @returns {Object} Returns the new object.
   */
  function basePickBy(object, paths, predicate) {
    var index = -1,
        length = paths.length,
        result = {};

    while (++index < length) {
      var path = paths[index],
          value = baseGet(object, path);

      if (predicate(value, path)) {
        baseSet(result, castPath(path, object), value);
      }
    }
    return result;
  }

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }

  /**
   * The base implementation of `_.pullAllBy` without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to remove.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns `array`.
   */
  function basePullAll(array, values, iteratee, comparator) {
    var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
        index = -1,
        length = values.length,
        seen = array;

    if (array === values) {
      values = copyArray(values);
    }
    if (iteratee) {
      seen = arrayMap(array, baseUnary(iteratee));
    }
    while (++index < length) {
      var fromIndex = 0,
          value = values[index],
          computed = iteratee ? iteratee(value) : value;

      while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
        if (seen !== array) {
          splice.call(seen, fromIndex, 1);
        }
        splice.call(array, fromIndex, 1);
      }
    }
    return array;
  }

  /**
   * The base implementation of `_.repeat` which doesn't coerce arguments.
   *
   * @private
   * @param {string} string The string to repeat.
   * @param {number} n The number of times to repeat the string.
   * @returns {string} Returns the repeated string.
   */
  function baseRepeat(string, n) {
    var result = '';
    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    // Leverage the exponentiation by squaring algorithm for a faster repeat.
    // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string += string;
      }
    } while (n);

    return result;
  }

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }

  /**
   * The base implementation of `_.set`.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {Array|string} path The path of the property to set.
   * @param {*} value The value to set.
   * @param {Function} [customizer] The function to customize path creation.
   * @returns {Object} Returns `object`.
   */
  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        lastIndex = length - 1,
        nested = object;

    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
          newValue = value;

      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : undefined;
        if (newValue === undefined) {
          newValue = isObject(objValue)
            ? objValue
            : (isIndex(path[index + 1]) ? [] : {});
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }

  /**
   * The base implementation of `setData` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */
  var baseSetData = !metaMap ? identity : function(func, data) {
    metaMap.set(func, data);
    return func;
  };

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * The base implementation of `_.some` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function baseSome(collection, predicate) {
    var result;

    baseEach(collection, function(value, index, collection) {
      result = predicate(value, index, collection);
      return !result;
    });
    return !!result;
  }

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * The base implementation of `wrapperValue` which returns the result of
   * performing a sequence of actions on the unwrapped `value`, where each
   * successive action is supplied the return value of the previous.
   *
   * @private
   * @param {*} value The unwrapped value.
   * @param {Array} actions Actions to perform to resolve the unwrapped value.
   * @returns {*} Returns the resolved value.
   */
  function baseWrapperValue(value, actions) {
    var result = value;
    if (result instanceof LazyWrapper) {
      result = result.value();
    }
    return arrayReduce(actions, function(result, action) {
      return action.func.apply(action.thisArg, arrayPush([result], action.args));
    }, result);
  }

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : baseSlice(array, start, end);
  }

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = isSymbol(value);

      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = isSymbol(other);

      if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
          (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
          (valIsNull && othIsDefined && othIsReflexive) ||
          (!valIsDefined && othIsReflexive) ||
          !valIsReflexive) {
        return 1;
      }
      if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
          (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
          (othIsNull && valIsDefined && valIsReflexive) ||
          (!othIsDefined && valIsReflexive) ||
          !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * Used by `_.orderBy` to compare multiple properties of a value to another
   * and stable sort them.
   *
   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
   * specify an order of "desc" for descending or "asc" for ascending sort order
   * of corresponding values.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {boolean[]|string[]} orders The order to sort by for each property.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultiple(object, other, orders) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length,
        ordersLength = orders.length;

    while (++index < length) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == 'desc' ? -1 : 1);
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Creates an array that is the composition of partially applied arguments,
   * placeholders, and provided arguments into a single array of arguments.
   *
   * @private
   * @param {Array} args The provided arguments.
   * @param {Array} partials The arguments to prepend to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @params {boolean} [isCurried] Specify composing for a curried function.
   * @returns {Array} Returns the new array of composed arguments.
   */
  function composeArgs(args, partials, holders, isCurried) {
    var argsIndex = -1,
        argsLength = args.length,
        holdersLength = holders.length,
        leftIndex = -1,
        leftLength = partials.length,
        rangeLength = nativeMax(argsLength - holdersLength, 0),
        result = Array(leftLength + rangeLength),
        isUncurried = !isCurried;

    while (++leftIndex < leftLength) {
      result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
    }
    while (rangeLength--) {
      result[leftIndex++] = args[argsIndex++];
    }
    return result;
  }

  /**
   * This function is like `composeArgs` except that the arguments composition
   * is tailored for `_.partialRight`.
   *
   * @private
   * @param {Array} args The provided arguments.
   * @param {Array} partials The arguments to append to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @params {boolean} [isCurried] Specify composing for a curried function.
   * @returns {Array} Returns the new array of composed arguments.
   */
  function composeArgsRight(args, partials, holders, isCurried) {
    var argsIndex = -1,
        argsLength = args.length,
        holdersIndex = -1,
        holdersLength = holders.length,
        rightIndex = -1,
        rightLength = partials.length,
        rangeLength = nativeMax(argsLength - holdersLength, 0),
        result = Array(rangeLength + rightLength),
        isUncurried = !isCurried;

    while (++argsIndex < rangeLength) {
      result[argsIndex] = args[argsIndex];
    }
    var offset = argsIndex;
    while (++rightIndex < rightLength) {
      result[offset + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
      if (isUncurried || argsIndex < argsLength) {
        result[offset + holders[holdersIndex]] = args[argsIndex++];
      }
    }
    return result;
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString(string);

      var strSymbols = hasUnicode(string)
        ? stringToArray(string)
        : undefined;

      var chr = strSymbols
        ? strSymbols[0]
        : string.charAt(0);

      var trailing = strSymbols
        ? castSlice(strSymbols, 1).join('')
        : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  /**
   * Creates a function that produces an instance of `Ctor` regardless of
   * whether it was invoked as part of a `new` expression or by `call` or `apply`.
   *
   * @private
   * @param {Function} Ctor The constructor to wrap.
   * @returns {Function} Returns the new wrapped function.
   */
  function createCtor(Ctor) {
    return function() {
      // Use a `switch` statement to work with class constructors. See
      // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
      // for more details.
      var args = arguments;
      switch (args.length) {
        case 0: return new Ctor;
        case 1: return new Ctor(args[0]);
        case 2: return new Ctor(args[0], args[1]);
        case 3: return new Ctor(args[0], args[1], args[2]);
        case 4: return new Ctor(args[0], args[1], args[2], args[3]);
        case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
        case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
      }
      var thisBinding = baseCreate(Ctor.prototype),
          result = Ctor.apply(thisBinding, args);

      // Mimic the constructor's `return` behavior.
      // See https://es5.github.io/#x13.2.2 for more details.
      return isObject(result) ? result : thisBinding;
    };
  }

  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = getIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) { return iteratee(iterable[key], key, iterable); };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }

  /**
   * Creates a function that wraps `func` to invoke it with optional `this`
   * binding of `thisArg`, partial application, and currying.
   *
   * @private
   * @param {Function|string} func The function or method name to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to prepend to those provided to
   *  the new function.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [partialsRight] The arguments to append to those provided
   *  to the new function.
   * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & WRAP_ARY_FLAG,
        isBind = bitmask & WRAP_BIND_FLAG,
        isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
        isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
        isFlip = bitmask & WRAP_FLIP_FLAG,
        Ctor = isBindKey ? undefined : createCtor(func);

    function wrapper() {
      var length = arguments.length,
          args = Array(length),
          index = length;

      while (index--) {
        args[index] = arguments[index];
      }
      if (isCurried) {
        var placeholder = getHolder(wrapper),
            holdersCount = countHolders(args, placeholder);
      }
      if (partials) {
        args = composeArgs(args, partials, holders, isCurried);
      }
      if (partialsRight) {
        args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
      }
      length -= holdersCount;
      if (isCurried && length < arity) {
        var newHolders = replaceHolders(args, placeholder);
        return createRecurry(
          func, bitmask, createHybrid, wrapper.placeholder, thisArg,
          args, newHolders, argPos, ary, arity - length
        );
      }
      var thisBinding = isBind ? thisArg : this,
          fn = isBindKey ? thisBinding[func] : func;

      length = args.length;
      if (argPos) {
        args = reorder(args, argPos);
      } else if (isFlip && length > 1) {
        args.reverse();
      }
      if (isAry && ary < length) {
        args.length = ary;
      }
      if (this && this !== root && this instanceof wrapper) {
        fn = Ctor || createCtor(fn);
      }
      return fn.apply(thisBinding, args);
    }
    return wrapper;
  }

  /**
   * Creates the padding for `string` based on `length`. The `chars` string
   * is truncated if the number of characters exceeds `length`.
   *
   * @private
   * @param {number} length The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padding for `string`.
   */
  function createPadding(length, chars) {
    chars = chars === undefined ? ' ' : baseToString(chars);

    var charsLength = chars.length;
    if (charsLength < 2) {
      return charsLength ? baseRepeat(chars, length) : chars;
    }
    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
    return hasUnicode(chars)
      ? castSlice(stringToArray(result), 0, length).join('')
      : result.slice(0, length);
  }

  /**
   * Creates a function that wraps `func` to continue currying.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {Function} wrapFunc The function to create the `func` wrapper.
   * @param {*} placeholder The placeholder value.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to prepend to those provided to
   *  the new function.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
    var isCurry = bitmask & WRAP_CURRY_FLAG,
        newHolders = isCurry ? holders : undefined,
        newHoldersRight = isCurry ? undefined : holders,
        newPartials = isCurry ? partials : undefined,
        newPartialsRight = isCurry ? undefined : partials;

    bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
      bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
    }
    var newData = [
      func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
      newHoldersRight, argPos, ary, arity
    ];

    var result = wrapFunc.apply(undefined, newData);
    if (isLaziable(func)) {
      setData(result, newData);
    }
    result.placeholder = placeholder;
    return setWrapToString(result, func, bitmask);
  }

  /**
   * Creates a function like `_.round`.
   *
   * @private
   * @param {string} methodName The name of the `Math` method to use when rounding.
   * @returns {Function} Returns the new round function.
   */
  function createRound(methodName) {
    var func = Math[methodName];
    return function(number, precision) {
      number = toNumber(number);
      precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
      if (precision) {
        // Shift with exponential notation to avoid floating-point issues.
        // See [MDN](https://mdn.io/round#Examples) for more details.
        var pair = (toString(number) + 'e').split('e'),
            value = func(pair[0] + 'e' + (+pair[1] + precision));

        pair = (toString(value) + 'e').split('e');
        return +(pair[0] + 'e' + (+pair[1] - precision));
      }
      return func(number);
    };
  }

  /**
   * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
   * of source objects to the destination object for all destination properties
   * that resolve to `undefined`.
   *
   * @private
   * @param {*} objValue The destination value.
   * @param {*} srcValue The source value.
   * @param {string} key The key of the property to assign.
   * @param {Object} object The parent object of `objValue`.
   * @returns {*} Returns the value to assign.
   */
  function customDefaultsAssignIn(objValue, srcValue, key, object) {
    if (objValue === undefined ||
        (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
      return srcValue;
    }
    return objValue;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */
  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }

  /**
   * Gets metadata for `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {*} Returns the metadata for `func`.
   */
  var getData = !metaMap ? noop : function(func) {
    return metaMap.get(func);
  };

  /**
   * Gets the name of `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {string} Returns the function name.
   */
  function getFuncName(func) {
    var result = (func.name + ''),
        array = realNames[result],
        length = hasOwnProperty.call(realNames, result) ? array.length : 0;

    while (length--) {
      var data = array[length],
          otherFunc = data.func;
      if (otherFunc == null || otherFunc == func) {
        return data.name;
      }
    }
    return result;
  }

  /**
   * Gets the argument placeholder value for `func`.
   *
   * @private
   * @param {Function} func The function to inspect.
   * @returns {*} Returns the placeholder value.
   */
  function getHolder(func) {
    var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
    return object.placeholder;
  }

  /**
   * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
   * this function returns the custom method, otherwise it returns `baseIteratee`.
   * If arguments are provided, the chosen function is invoked with them and
   * its result is returned.
   *
   * @private
   * @param {*} [value] The value to convert to an iteratee.
   * @param {number} [arity] The arity of the created iteratee.
   * @returns {Function} Returns the chosen function or its result.
   */
  function getIteratee() {
    var result = lodash.iteratee || iteratee;
    result = result === iteratee ? baseIteratee : result;
    return arguments.length ? result(arguments[0], arguments[1]) : result;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
      (Map && getTag(new Map) != mapTag) ||
      (Promise && getTag(Promise.resolve()) != promiseTag) ||
      (Set && getTag(new Set) != setTag) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Gets the view, applying any `transforms` to the `start` and `end` positions.
   *
   * @private
   * @param {number} start The start of the view.
   * @param {number} end The end of the view.
   * @param {Array} transforms The transformations to apply to the view.
   * @returns {Object} Returns an object containing the `start` and `end`
   *  positions of the view.
   */
  function getView(start, end, transforms) {
    var index = -1,
        length = transforms.length;

    while (++index < length) {
      var data = transforms[index],
          size = data.size;

      switch (data.type) {
        case 'drop':      start += size; break;
        case 'dropRight': end -= size; break;
        case 'take':      end = nativeMin(end, start + size); break;
        case 'takeRight': start = nativeMax(start, end - size); break;
      }
    }
    return { 'start': start, 'end': end };
  }

  /**
   * Extracts wrapper details from the `source` body comment.
   *
   * @private
   * @param {string} source The source to inspect.
   * @returns {Array} Returns the wrapper details.
   */
  function getWrapDetails(source) {
    var match = source.match(reWrapDetails);
    return match ? match[1].split(reSplitDetails) : [];
  }

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) &&
      (isArray(object) || isArguments(object));
  }

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag: case float64Tag:
      case int8Tag: case int16Tag: case int32Tag:
      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return new Ctor;

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return new Ctor;

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  /**
   * Inserts wrapper `details` in a comment at the top of the `source` body.
   *
   * @private
   * @param {string} source The source to modify.
   * @returns {Array} details The details to insert.
   * @returns {string} Returns the modified source.
   */
  function insertWrapDetails(source, details) {
    var length = details.length;
    if (!length) {
      return source;
    }
    var lastIndex = length - 1;
    details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
    details = details.join(length > 2 ? ', ' : ' ');
    return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
  }

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) ||
      !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Checks if `func` has a lazy counterpart.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
   *  else `false`.
   */
  function isLaziable(func) {
    var funcName = getFuncName(func),
        other = lodash[funcName];

    if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
      return false;
    }
    if (func === other) {
      return true;
    }
    var data = getData(other);
    return !!data && func === data[0];
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    return value === proto;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  /**
   * Gets the parent value at `path` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} path The path to get the parent value of.
   * @returns {*} Returns the parent value.
   */
  function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  }

  /**
   * Reorder `array` according to the specified indexes where the element at
   * the first index is assigned as the first element, the element at
   * the second index is assigned as the second element, and so on.
   *
   * @private
   * @param {Array} array The array to reorder.
   * @param {Array} indexes The arranged array indexes.
   * @returns {Array} Returns `array`.
   */
  function reorder(array, indexes) {
    var arrLength = array.length,
        length = nativeMin(indexes.length, arrLength),
        oldArray = copyArray(array);

    while (length--) {
      var index = indexes[length];
      array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
    }
    return array;
  }

  /**
   * Sets metadata for `func`.
   *
   * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
   * period of time, it will trip its breaker and transition to an identity
   * function to avoid garbage collection pauses in V8. See
   * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
   * for more details.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */
  var setData = shortOut(baseSetData);

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = shortOut(baseSetToString);

  /**
   * Sets the `toString` method of `wrapper` to mimic the source of `reference`
   * with wrapper details in a comment at the top of the source body.
   *
   * @private
   * @param {Function} wrapper The function to modify.
   * @param {Function} reference The reference function.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @returns {Function} Returns `wrapper`.
   */
  function setWrapToString(wrapper, reference, bitmask) {
    var source = (reference + '');
    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
  }

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Updates wrapper `details` based on `bitmask` flags.
   *
   * @private
   * @returns {Array} details The details to modify.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @returns {Array} Returns `details`.
   */
  function updateWrapDetails(details, bitmask) {
    arrayEach(wrapFlags, function(pair) {
      var value = '_.' + pair[0];
      if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
        details.push(value);
      }
    });
    return details.sort();
  }

  /**
   * Creates a clone of `wrapper`.
   *
   * @private
   * @param {Object} wrapper The wrapper to clone.
   * @returns {Object} Returns the cloned wrapper.
   */
  function wrapperClone(wrapper) {
    if (wrapper instanceof LazyWrapper) {
      return wrapper.clone();
    }
    var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = copyArray(wrapper.__actions__);
    result.__index__  = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `""`, `undefined`, and `NaN` are falsey.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to compact.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact(array) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * Creates a slice of `array` with `n` elements dropped from the beginning.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Array
   * @param {Array} array The array to query.
   * @param {number} [n=1] The number of elements to drop.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the slice of `array`.
   * @example
   *
   * _.drop([1, 2, 3]);
   * // => [2, 3]
   *
   * _.drop([1, 2, 3], 2);
   * // => [3]
   *
   * _.drop([1, 2, 3], 5);
   * // => []
   *
   * _.drop([1, 2, 3], 0);
   * // => [1, 2, 3]
   */
  function drop(array, n, guard) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return [];
    }
    n = (guard || n === undefined) ? 1 : toInteger(n);
    return baseSlice(array, n < 0 ? 0 : n, length);
  }

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, getIteratee(predicate, 3), index);
  }

  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }

  /**
   * Gets the index at which the first occurrence of `value` is found in `array`
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. If `fromIndex` is negative, it's used as the
   * offset from the end of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   * @example
   *
   * _.indexOf([1, 2, 1, 2], 2);
   * // => 1
   *
   * // Search from the `fromIndex`.
   * _.indexOf([1, 2, 1, 2], 2, 2);
   * // => 3
   */
  function indexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseIndexOf(array, value, index);
  }

  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  /**
   * Removes all given values from `array` using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
   * to remove elements from an array by predicate.
   *
   * @static
   * @memberOf _
   * @since 2.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {...*} [values] The values to remove.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
   *
   * _.pull(array, 'a', 'c');
   * console.log(array);
   * // => ['b', 'b']
   */
  var pull = baseRest(pullAll);

  /**
   * This method is like `_.pull` except that it accepts an array of values to remove.
   *
   * **Note:** Unlike `_.difference`, this method mutates `array`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @param {Array} values The values to remove.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
   *
   * _.pullAll(array, ['a', 'c']);
   * console.log(array);
   * // => ['b', 'b']
   */
  function pullAll(array, values) {
    return (array && array.length && values && values.length)
      ? basePullAll(array, values)
      : array;
  }

  /**
   * Reverses `array` so that the first element becomes the last, the second
   * element becomes the second to last, and so on.
   *
   * **Note:** This method mutates `array` and is based on
   * [`Array#reverse`](https://mdn.io/Array/reverse).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to modify.
   * @returns {Array} Returns `array`.
   * @example
   *
   * var array = [1, 2, 3];
   *
   * _.reverse(array);
   * // => [3, 2, 1]
   *
   * console.log(array);
   * // => [3, 2, 1]
   */
  function reverse(array) {
    return array == null ? array : nativeReverse.call(array);
  }

  /**
   * Creates an array excluding all given values using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * **Note:** Unlike `_.pull`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...*} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.difference, _.xor
   * @example
   *
   * _.without([2, 1, 2, 3], 1, 2);
   * // => [3]
   */
  var without = baseRest(function(array, values) {
    return isArrayLikeObject(array)
      ? baseDifference(array, values)
      : [];
  });

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` wrapper instance that wraps `value` with explicit method
   * chain sequences enabled. The result of such sequences must be unwrapped
   * with `_#value`.
   *
   * @static
   * @memberOf _
   * @since 1.3.0
   * @category Seq
   * @param {*} value The value to wrap.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36 },
   *   { 'user': 'fred',    'age': 40 },
   *   { 'user': 'pebbles', 'age': 1 }
   * ];
   *
   * var youngest = _
   *   .chain(users)
   *   .sortBy('age')
   *   .map(function(o) {
   *     return o.user + ' is ' + o.age;
   *   })
   *   .head()
   *   .value();
   * // => 'pebbles is 1'
   */
  function chain(value) {
    var result = lodash(value);
    result.__chain__ = true;
    return result;
  }

  /**
   * This method invokes `interceptor` and returns `value`. The interceptor
   * is invoked with one argument; (value). The purpose of this method is to
   * "tap into" a method chain sequence in order to modify intermediate results.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns `value`.
   * @example
   *
   * _([1, 2, 3])
   *  .tap(function(array) {
   *    // Mutate input array.
   *    array.pop();
   *  })
   *  .reverse()
   *  .value();
   * // => [2, 1]
   */
  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }

  /**
   * This method is like `_.tap` except that it returns the result of `interceptor`.
   * The purpose of this method is to "pass thru" values replacing intermediate
   * results in a method chain sequence.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Seq
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns the result of `interceptor`.
   * @example
   *
   * _('  abc  ')
   *  .chain()
   *  .trim()
   *  .thru(function(value) {
   *    return [value];
   *  })
   *  .value();
   * // => ['abc']
   */
  function thru(value, interceptor) {
    return interceptor(value);
  }

  /**
   * This method is the wrapper version of `_.at`.
   *
   * @name at
   * @memberOf _
   * @since 1.0.0
   * @category Seq
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
   *
   * _(object).at(['a[0].b.c', 'a[1]']).value();
   * // => [3, 4]
   */
  var wrapperAt = flatRest(function(paths) {
    var length = paths.length,
        start = length ? paths[0] : 0,
        value = this.__wrapped__,
        interceptor = function(object) { return baseAt(object, paths); };

    if (length > 1 || this.__actions__.length ||
        !(value instanceof LazyWrapper) || !isIndex(start)) {
      return this.thru(interceptor);
    }
    value = value.slice(start, +start + (length ? 1 : 0));
    value.__actions__.push({
      'func': thru,
      'args': [interceptor],
      'thisArg': undefined
    });
    return new LodashWrapper(value, this.__chain__).thru(function(array) {
      if (length && !array.length) {
        array.push(undefined);
      }
      return array;
    });
  });

  /**
   * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
   *
   * @name chain
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 }
   * ];
   *
   * // A sequence without explicit chaining.
   * _(users).head();
   * // => { 'user': 'barney', 'age': 36 }
   *
   * // A sequence with explicit chaining.
   * _(users)
   *   .chain()
   *   .head()
   *   .pick('user')
   *   .value();
   * // => { 'user': 'barney' }
   */
  function wrapperChain() {
    return chain(this);
  }

  /**
   * Executes the chain sequence and returns the wrapped result.
   *
   * @name commit
   * @memberOf _
   * @since 3.2.0
   * @category Seq
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var array = [1, 2];
   * var wrapped = _(array).push(3);
   *
   * console.log(array);
   * // => [1, 2]
   *
   * wrapped = wrapped.commit();
   * console.log(array);
   * // => [1, 2, 3]
   *
   * wrapped.last();
   * // => 3
   *
   * console.log(array);
   * // => [1, 2, 3]
   */
  function wrapperCommit() {
    return new LodashWrapper(this.value(), this.__chain__);
  }

  /**
   * Gets the next value on a wrapped object following the
   * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
   *
   * @name next
   * @memberOf _
   * @since 4.0.0
   * @category Seq
   * @returns {Object} Returns the next iterator value.
   * @example
   *
   * var wrapped = _([1, 2]);
   *
   * wrapped.next();
   * // => { 'done': false, 'value': 1 }
   *
   * wrapped.next();
   * // => { 'done': false, 'value': 2 }
   *
   * wrapped.next();
   * // => { 'done': true, 'value': undefined }
   */
  function wrapperNext() {
    if (this.__values__ === undefined) {
      this.__values__ = toArray(this.value());
    }
    var done = this.__index__ >= this.__values__.length,
        value = done ? undefined : this.__values__[this.__index__++];

    return { 'done': done, 'value': value };
  }

  /**
   * Enables the wrapper to be iterable.
   *
   * @name Symbol.iterator
   * @memberOf _
   * @since 4.0.0
   * @category Seq
   * @returns {Object} Returns the wrapper object.
   * @example
   *
   * var wrapped = _([1, 2]);
   *
   * wrapped[Symbol.iterator]() === wrapped;
   * // => true
   *
   * Array.from(wrapped);
   * // => [1, 2]
   */
  function wrapperToIterator() {
    return this;
  }

  /**
   * Creates a clone of the chain sequence planting `value` as the wrapped value.
   *
   * @name plant
   * @memberOf _
   * @since 3.2.0
   * @category Seq
   * @param {*} value The value to plant.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2]).map(square);
   * var other = wrapped.plant([3, 4]);
   *
   * other.value();
   * // => [9, 16]
   *
   * wrapped.value();
   * // => [1, 4]
   */
  function wrapperPlant(value) {
    var result,
        parent = this;

    while (parent instanceof baseLodash) {
      var clone = wrapperClone(parent);
      clone.__index__ = 0;
      clone.__values__ = undefined;
      if (result) {
        previous.__wrapped__ = clone;
      } else {
        result = clone;
      }
      var previous = clone;
      parent = parent.__wrapped__;
    }
    previous.__wrapped__ = value;
    return result;
  }

  /**
   * This method is the wrapper version of `_.reverse`.
   *
   * **Note:** This method mutates the wrapped array.
   *
   * @name reverse
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var array = [1, 2, 3];
   *
   * _(array).reverse().value()
   * // => [3, 2, 1]
   *
   * console.log(array);
   * // => [3, 2, 1]
   */
  function wrapperReverse() {
    var value = this.__wrapped__;
    if (value instanceof LazyWrapper) {
      var wrapped = value;
      if (this.__actions__.length) {
        wrapped = new LazyWrapper(this);
      }
      wrapped = wrapped.reverse();
      wrapped.__actions__.push({
        'func': thru,
        'args': [reverse],
        'thisArg': undefined
      });
      return new LodashWrapper(wrapped, this.__chain__);
    }
    return this.thru(reverse);
  }

  /**
   * Executes the chain sequence to resolve the unwrapped value.
   *
   * @name value
   * @memberOf _
   * @since 0.1.0
   * @alias toJSON, valueOf
   * @category Seq
   * @returns {*} Returns the resolved unwrapped value.
   * @example
   *
   * _([1, 2, 3]).value();
   * // => [1, 2, 3]
   */
  function wrapperValue() {
    return baseWrapperValue(this.__wrapped__, this.__actions__);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Checks if `predicate` returns truthy for **all** elements of `collection`.
   * Iteration is stopped once `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * **Note:** This method returns `true` for
   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
   * elements of empty collections.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': false },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.every(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.every(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.every(users, 'active');
   * // => false
   */
  function every(collection, predicate, guard) {
    var func = isArray(collection) ? arrayEvery : baseEvery;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }
    return func(collection, getIteratee(predicate, 3));
  }

  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */
  var find = createFind(findIndex);

  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */
  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, getIteratee(iteratee, 3));
  }

  /**
   * Checks if `value` is in `collection`. If `collection` is a string, it's
   * checked for a substring of `value`, otherwise
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * is used for equality comparisons. If `fromIndex` is negative, it's used as
   * the offset from the end of `collection`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {boolean} Returns `true` if `value` is found, else `false`.
   * @example
   *
   * _.includes([1, 2, 3], 1);
   * // => true
   *
   * _.includes([1, 2, 3], 1, 2);
   * // => false
   *
   * _.includes({ 'a': 1, 'b': 2 }, 1);
   * // => true
   *
   * _.includes('abcd', 'bc');
   * // => true
   */
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection)
      ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
      : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
  }

  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, getIteratee(iteratee, 3));
  }

  /**
   * Checks if `predicate` returns truthy for **any** element of `collection`.
   * Iteration is stopped once `predicate` returns truthy. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var users = [
   *   { 'user': 'barney', 'active': true },
   *   { 'user': 'fred',   'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.some(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.some(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.some(users, 'active');
   * // => true
   */
  function some(collection, predicate, guard) {
    var func = isArray(collection) ? arraySome : baseSome;
    if (guard && isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }
    return func(collection, getIteratee(predicate, 3));
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection thru each iteratee. This method
   * performs a stable sort, that is, it preserves the original sort order of
   * equal elements. The iteratees are invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {...(Function|Function[])} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 34 }
   * ];
   *
   * _.sortBy(users, [function(o) { return o.user; }]);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   *
   * _.sortBy(users, ['user', 'age']);
   * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
   */
  var sortBy = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length = iteratees.length;
    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });

  /*------------------------------------------------------------------------*/

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root.Date.now();
  };

  /*------------------------------------------------------------------------*/

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  /**
   * Creates a function that negates the result of the predicate `func`. The
   * `func` predicate is invoked with the `this` binding and arguments of the
   * created function.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {Function} predicate The predicate to negate.
   * @returns {Function} Returns the new negated function.
   * @example
   *
   * function isEven(n) {
   *   return n % 2 == 0;
   * }
   *
   * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
   * // => [1, 3, 5]
   */
  function negate(predicate) {
    if (typeof predicate != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    return function() {
      var args = arguments;
      switch (args.length) {
        case 0: return !predicate.call(this);
        case 1: return !predicate.call(this, args[0]);
        case 2: return !predicate.call(this, args[0], args[1]);
        case 3: return !predicate.call(this, args[0], args[1], args[2]);
      }
      return !predicate.apply(this, args);
    };
  }

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a shallow clone of `value`.
   *
   * **Note:** This method is loosely based on the
   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
   * and supports cloning arrays, array buffers, booleans, date objects, maps,
   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
   * arrays. The own enumerable properties of `arguments` objects are cloned
   * as plain objects. An empty object is returned for uncloneable values such
   * as error objects, functions, DOM nodes, and WeakMaps.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to clone.
   * @returns {*} Returns the cloned value.
   * @see _.cloneDeep
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var shallow = _.clone(objects);
   * console.log(shallow[0] === objects[0]);
   * // => true
   */
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * Checks if `value` is classified as a boolean primitive or object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
   * @example
   *
   * _.isBoolean(false);
   * // => true
   *
   * _.isBoolean(null);
   * // => false
   */
  function isBoolean(value) {
    return value === true || value === false ||
      (isObjectLike(value) && baseGetTag(value) == boolTag);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Checks if `value` is classified as a `Date` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
   * @example
   *
   * _.isDate(new Date);
   * // => true
   *
   * _.isDate('Mon April 23 2012');
   * // => false
   */
  var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

  /**
   * Checks if `value` is an empty object, collection, map, or set.
   *
   * Objects are considered empty if they have no own enumerable string keyed
   * properties.
   *
   * Array-like values such as `arguments` objects, arrays, buffers, strings, or
   * jQuery-like collections are considered empty if they have a `length` of `0`.
   * Similarly, maps and sets are considered empty if they have a `size` of `0`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty(null);
   * // => true
   *
   * _.isEmpty(true);
   * // => true
   *
   * _.isEmpty(1);
   * // => true
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({ 'a': 1 });
   * // => false
   */
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) &&
        (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
          isBuffer(value) || isTypedArray(value) || isArguments(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
   * `SyntaxError`, `TypeError`, or `URIError` object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
   * @example
   *
   * _.isError(new Error);
   * // => true
   *
   * _.isError(Error);
   * // => false
   */
  function isError(value) {
    if (!isObjectLike(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == errorTag || tag == domExcTag ||
      (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /**
   * Checks if `value` is `NaN`.
   *
   * **Note:** This method is based on
   * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
   * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
   * `undefined` and other non-number values.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */
  function isNaN(value) {
    // An `NaN` primitive is the only value that is not equal to itself.
    // Perform the `toStringTag` check first to avoid errors with some
    // ActiveX objects in IE.
    return isNumber(value) && value != +value;
  }

  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(void 0);
   * // => false
   */
  function isNull(value) {
    return value === null;
  }

  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */
  function isNumber(value) {
    return typeof value == 'number' ||
      (isObjectLike(value) && baseGetTag(value) == numberTag);
  }

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString;
  }

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' ||
      (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag);
  }

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   *
   * _.isUndefined(null);
   * // => false
   */
  function isUndefined(value) {
    return value === undefined;
  }

  /**
   * Converts `value` to an array.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Array} Returns the converted array.
   * @example
   *
   * _.toArray({ 'a': 1, 'b': 2 });
   * // => [1, 2]
   *
   * _.toArray('abc');
   * // => ['a', 'b', 'c']
   *
   * _.toArray(1);
   * // => []
   *
   * _.toArray(null);
   * // => []
   */
  function toArray(value) {
    if (!value) {
      return [];
    }
    if (isArrayLike(value)) {
      return isString(value) ? stringToArray(value) : copyArray(value);
    }
    if (symIterator && value[symIterator]) {
      return iteratorToArray(value[symIterator]());
    }
    var tag = getTag(value),
        func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

    return func(value);
  }

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;

    return result === result ? (remainder ? result - remainder : result) : 0;
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable string keyed properties of source objects to the
   * destination object. Source objects are applied from left to right.
   * Subsequent sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object` and is loosely based on
   * [`Object.assign`](https://mdn.io/Object/assign).
   *
   * @static
   * @memberOf _
   * @since 0.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assignIn
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assign({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'c': 3 }
   */
  var assign = createAssigner(function(object, source) {
    if (isPrototype(source) || isArrayLike(source)) {
      copyObject(source, keys(source), object);
      return;
    }
    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        assignValue(object, key, source[key]);
      }
    }
  });

  /**
   * This method is like `_.assign` except that it iterates over own and
   * inherited source properties.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extend
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assign
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assignIn({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
   */
  var assignIn = createAssigner(function(object, source) {
    copyObject(source, keysIn(source), object);
  });

  /**
   * This method is like `_.assignIn` except that it accepts `customizer`
   * which is invoked to produce the assigned values. If `customizer` returns
   * `undefined`, assignment is handled by the method instead. The `customizer`
   * is invoked with five arguments: (objValue, srcValue, key, object, source).
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extendWith
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} sources The source objects.
   * @param {Function} [customizer] The function to customize assigned values.
   * @returns {Object} Returns `object`.
   * @see _.assignWith
   * @example
   *
   * function customizer(objValue, srcValue) {
   *   return _.isUndefined(objValue) ? srcValue : objValue;
   * }
   *
   * var defaults = _.partialRight(_.assignInWith, customizer);
   *
   * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
   * // => { 'a': 1, 'b': 2 }
   */
  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
  });

  /**
   * Iterates over own enumerable string keyed properties of an object and
   * invokes `iteratee` for each property. The iteratee is invoked with three
   * arguments: (value, key, object). Iteratee functions may exit iteration
   * early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @since 0.3.0
   * @category Object
   * @param {Object} object The object to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Object} Returns `object`.
   * @see _.forOwnRight
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.forOwn(new Foo, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */
  function forOwn(object, iteratee) {
    return object && baseForOwn(object, getIteratee(iteratee, 3));
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * Checks if `path` is a direct property of `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = { 'a': { 'b': 2 } };
   * var other = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.has(object, 'a');
   * // => true
   *
   * _.has(object, 'a.b');
   * // => true
   *
   * _.has(object, ['a', 'b']);
   * // => true
   *
   * _.has(other, 'a');
   * // => false
   */
  function has(object, path) {
    return object != null && hasPath(object, path, baseHas);
  }

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * The opposite of `_.pickBy`; this method creates an object composed of
   * the own and inherited enumerable string keyed properties of `object` that
   * `predicate` doesn't return truthy for. The predicate is invoked with two
   * arguments: (value, key).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The source object.
   * @param {Function} [predicate=_.identity] The function invoked per property.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.omitBy(object, _.isNumber);
   * // => { 'b': '2' }
   */
  function omitBy(object, predicate) {
    return pickBy(object, negate(getIteratee(predicate)));
  }

  /**
   * Creates an object composed of the `object` properties `predicate` returns
   * truthy for. The predicate is invoked with two arguments: (value, key).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The source object.
   * @param {Function} [predicate=_.identity] The function invoked per property.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pickBy(object, _.isNumber);
   * // => { 'a': 1, 'c': 3 }
   */
  function pickBy(object, predicate) {
    if (object == null) {
      return {};
    }
    var props = arrayMap(getAllKeysIn(object), function(prop) {
      return [prop];
    });
    predicate = getIteratee(predicate);
    return basePickBy(object, props, function(value, path) {
      return predicate(value, path[0]);
    });
  }

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /*------------------------------------------------------------------------*/

  /**
   * Checks if `n` is between `start` and up to, but not including, `end`. If
   * `end` is not specified, it's set to `start` with `start` then set to `0`.
   * If `start` is greater than `end` the params are swapped to support
   * negative ranges.
   *
   * @static
   * @memberOf _
   * @since 3.3.0
   * @category Number
   * @param {number} number The number to check.
   * @param {number} [start=0] The start of the range.
   * @param {number} end The end of the range.
   * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
   * @see _.range, _.rangeRight
   * @example
   *
   * _.inRange(3, 2, 4);
   * // => true
   *
   * _.inRange(4, 8);
   * // => true
   *
   * _.inRange(4, 2);
   * // => false
   *
   * _.inRange(2, 2);
   * // => false
   *
   * _.inRange(1.2, 2);
   * // => true
   *
   * _.inRange(5.2, 4);
   * // => false
   *
   * _.inRange(-3, -2, -6);
   * // => true
   */
  function inRange(number, start, end) {
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    number = toNumber(number);
    return baseInRange(number, start, end);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }

  /**
   * Checks if `string` ends with the given target string.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {string} [target] The string to search for.
   * @param {number} [position=string.length] The position to search up to.
   * @returns {boolean} Returns `true` if `string` ends with `target`,
   *  else `false`.
   * @example
   *
   * _.endsWith('abc', 'c');
   * // => true
   *
   * _.endsWith('abc', 'b');
   * // => false
   *
   * _.endsWith('abc', 'b', 2);
   * // => true
   */
  function endsWith(string, target, position) {
    string = toString(string);
    target = baseToString(target);

    var length = string.length;
    position = position === undefined
      ? length
      : baseClamp(toInteger(position), 0, length);

    var end = position;
    position -= target.length;
    return position >= 0 && string.slice(position, end) == target;
  }

  /**
   * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
   * corresponding HTML entities.
   *
   * **Note:** No other characters are escaped. To escape additional
   * characters use a third-party library like [_he_](https://mths.be/he).
   *
   * Though the ">" character is escaped for symmetry, characters like
   * ">" and "/" don't need escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value. See
   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   *
   * When working with HTML you should always
   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
   * XSS vectors.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('fred, barney, & pebbles');
   * // => 'fred, barney, &amp; pebbles'
   */
  function escape(string) {
    string = toString(string);
    return (string && reHasUnescapedHtml.test(string))
      ? string.replace(reUnescapedHtml, escapeHtmlChar)
      : string;
  }

  /**
   * Pads `string` on the left side if it's shorter than `length`. Padding
   * characters are truncated if they exceed `length`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to pad.
   * @param {number} [length=0] The padding length.
   * @param {string} [chars=' '] The string used as padding.
   * @returns {string} Returns the padded string.
   * @example
   *
   * _.padStart('abc', 6);
   * // => '   abc'
   *
   * _.padStart('abc', 6, '_-');
   * // => '_-_abc'
   *
   * _.padStart('abc', 3);
   * // => 'abc'
   */
  function padStart(string, length, chars) {
    string = toString(string);
    length = toInteger(length);

    var strLength = length ? stringSize(string) : 0;
    return (length && strLength < length)
      ? (createPadding(length - strLength, chars) + string)
      : string;
  }

  /**
   * Checks if `string` starts with the given target string.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {string} [target] The string to search for.
   * @param {number} [position=0] The position to search from.
   * @returns {boolean} Returns `true` if `string` starts with `target`,
   *  else `false`.
   * @example
   *
   * _.startsWith('abc', 'a');
   * // => true
   *
   * _.startsWith('abc', 'b');
   * // => false
   *
   * _.startsWith('abc', 'b', 1);
   * // => true
   */
  function startsWith(string, target, position) {
    string = toString(string);
    position = position == null
      ? 0
      : baseClamp(toInteger(position), 0, string.length);

    target = baseToString(target);
    return string.slice(position, position + target.length) == target;
  }

  /**
   * Creates a compiled template function that can interpolate data properties
   * in "interpolate" delimiters, HTML-escape interpolated data properties in
   * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
   * properties may be accessed as free variables in the template. If a setting
   * object is given, it takes precedence over `_.templateSettings` values.
   *
   * **Note:** In the development build `_.template` utilizes
   * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
   * for easier debugging.
   *
   * For more information on precompiling templates see
   * [lodash's custom builds documentation](https://lodash.com/custom-builds).
   *
   * For more information on Chrome extension sandboxes see
   * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The template string.
   * @param {Object} [options={}] The options object.
   * @param {RegExp} [options.escape=_.templateSettings.escape]
   *  The HTML "escape" delimiter.
   * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
   *  The "evaluate" delimiter.
   * @param {Object} [options.imports=_.templateSettings.imports]
   *  An object to import into the template as free variables.
   * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
   *  The "interpolate" delimiter.
   * @param {string} [options.sourceURL='lodash.templateSources[n]']
   *  The sourceURL of the compiled template.
   * @param {string} [options.variable='obj']
   *  The data object variable name.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Function} Returns the compiled template function.
   * @example
   *
   * // Use the "interpolate" delimiter to create a compiled template.
   * var compiled = _.template('hello <%= user %>!');
   * compiled({ 'user': 'fred' });
   * // => 'hello fred!'
   *
   * // Use the HTML "escape" delimiter to escape data property values.
   * var compiled = _.template('<b><%- value %></b>');
   * compiled({ 'value': '<script>' });
   * // => '<b>&lt;script&gt;</b>'
   *
   * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
   * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the internal `print` function in "evaluate" delimiters.
   * var compiled = _.template('<% print("hello " + user); %>!');
   * compiled({ 'user': 'barney' });
   * // => 'hello barney!'
   *
   * // Use the ES template literal delimiter as an "interpolate" delimiter.
   * // Disable support by replacing the "interpolate" delimiter.
   * var compiled = _.template('hello ${ user }!');
   * compiled({ 'user': 'pebbles' });
   * // => 'hello pebbles!'
   *
   * // Use backslashes to treat delimiters as plain text.
   * var compiled = _.template('<%= "\\<%- value %\\>" %>');
   * compiled({ 'value': 'ignored' });
   * // => '<%- value %>'
   *
   * // Use the `imports` option to import `jQuery` as `jq`.
   * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
   * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
   * compiled({ 'users': ['fred', 'barney'] });
   * // => '<li>fred</li><li>barney</li>'
   *
   * // Use the `sourceURL` option to specify a custom sourceURL for the template.
   * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
   * compiled(data);
   * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
   *
   * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
   * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
   * compiled.source;
   * // => function(data) {
   * //   var __t, __p = '';
   * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
   * //   return __p;
   * // }
   *
   * // Use custom template delimiters.
   * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
   * var compiled = _.template('hello {{ user }}!');
   * compiled({ 'user': 'mustache' });
   * // => 'hello mustache!'
   *
   * // Use the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and stack traces.
   * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
   *   var JST = {\
   *     "main": ' + _.template(mainText).source + '\
   *   };\
   * ');
   */
  function template(string, options, guard) {
    // Based on John Resig's `tmpl` implementation
    // (http://ejohn.org/blog/javascript-micro-templating/)
    // and Laura Doktorova's doT.js (https://github.com/olado/doT).
    var settings = lodash.templateSettings;

    if (guard && isIterateeCall(string, options, guard)) {
      options = undefined;
    }
    string = toString(string);
    options = assignInWith({}, options, settings, customDefaultsAssignIn);

    var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
        importsKeys = keys(imports),
        importsValues = baseValues(imports, importsKeys);

    var isEscaping,
        isEvaluating,
        index = 0,
        interpolate = options.interpolate || reNoMatch,
        source = "__p += '";

    // Compile the regexp to match each delimiter.
    var reDelimiters = RegExp(
      (options.escape || reNoMatch).source + '|' +
      interpolate.source + '|' +
      (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
      (options.evaluate || reNoMatch).source + '|$'
    , 'g');

    // Use a sourceURL for easier debugging.
    var sourceURL = '//# sourceURL=' +
      ('sourceURL' in options
        ? options.sourceURL
        : ('lodash.templateSources[' + (++templateCounter) + ']')
      ) + '\n';

    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
      interpolateValue || (interpolateValue = esTemplateValue);

      // Escape characters that can't be included in string literals.
      source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

      // Replace delimiters with snippets.
      if (escapeValue) {
        isEscaping = true;
        source += "' +\n__e(" + escapeValue + ") +\n'";
      }
      if (evaluateValue) {
        isEvaluating = true;
        source += "';\n" + evaluateValue + ";\n__p += '";
      }
      if (interpolateValue) {
        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
      }
      index = offset + match.length;

      // The JS engine embedded in Adobe products needs `match` returned in
      // order to produce the correct `offset` value.
      return match;
    });

    source += "';\n";

    // If `variable` is not specified wrap a with-statement around the generated
    // code to add the data object to the top of the scope chain.
    var variable = options.variable;
    if (!variable) {
      source = 'with (obj) {\n' + source + '\n}\n';
    }
    // Cleanup code by stripping empty strings.
    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
      .replace(reEmptyStringMiddle, '$1')
      .replace(reEmptyStringTrailing, '$1;');

    // Frame code as the function body.
    source = 'function(' + (variable || 'obj') + ') {\n' +
      (variable
        ? ''
        : 'obj || (obj = {});\n'
      ) +
      "var __t, __p = ''" +
      (isEscaping
         ? ', __e = _.escape'
         : ''
      ) +
      (isEvaluating
        ? ', __j = Array.prototype.join;\n' +
          "function print() { __p += __j.call(arguments, '') }\n"
        : ';\n'
      ) +
      source +
      'return __p\n}';

    var result = attempt(function() {
      return Function(importsKeys, sourceURL + 'return ' + source)
        .apply(undefined, importsValues);
    });

    // Provide the compiled function's source by its `toString` method or
    // the `source` property as a convenience for inlining compiled templates.
    result.source = source;
    if (isError(result)) {
      throw result;
    }
    return result;
  }

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = createCaseFirst('toUpperCase');

  /*------------------------------------------------------------------------*/

  /**
   * Attempts to invoke `func`, returning either the result or the caught error
   * object. Any additional arguments are provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Util
   * @param {Function} func The function to attempt.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {*} Returns the `func` result or error object.
   * @example
   *
   * // Avoid throwing errors for invalid selectors.
   * var elements = _.attempt(function(selector) {
   *   return document.querySelectorAll(selector);
   * }, '>_>');
   *
   * if (_.isError(elements)) {
   *   elements = [];
   * }
   */
  var attempt = baseRest(function(func, args) {
    try {
      return apply(func, undefined, args);
    } catch (e) {
      return isError(e) ? e : new Error(e);
    }
  });

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Creates a function that invokes `func` with the arguments of the created
   * function. If `func` is a property name, the created function returns the
   * property value for a given element. If `func` is an array or object, the
   * created function returns `true` for elements that contain the equivalent
   * source properties, otherwise it returns `false`.
   *
   * @static
   * @since 4.0.0
   * @memberOf _
   * @category Util
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @returns {Function} Returns the callback.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, _.iteratee(['user', 'fred']));
   * // => [{ 'user': 'fred', 'age': 40 }]
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, _.iteratee('user'));
   * // => ['barney', 'fred']
   *
   * // Create custom iteratee shorthands.
   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
   *     return func.test(string);
   *   };
   * });
   *
   * _.filter(['abc', 'def'], /ef/);
   * // => ['def']
   */
  function iteratee(func) {
    return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
  }

  /**
   * Adds all own enumerable string keyed function properties of a source
   * object to the destination object. If `object` is a function, then methods
   * are added to its prototype as well.
   *
   * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
   * avoid conflicts caused by modifying the original.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {Function|Object} [object=lodash] The destination object.
   * @param {Object} source The object of functions to add.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
   * @returns {Function|Object} Returns `object`.
   * @example
   *
   * function vowels(string) {
   *   return _.filter(string, function(v) {
   *     return /[aeiou]/i.test(v);
   *   });
   * }
   *
   * _.mixin({ 'vowels': vowels });
   * _.vowels('fred');
   * // => ['e']
   *
   * _('fred').vowels().value();
   * // => ['e']
   *
   * _.mixin({ 'vowels': vowels }, { 'chain': false });
   * _('fred').vowels();
   * // => ['e']
   */
  function mixin(object, source, options) {
    var props = keys(source),
        methodNames = baseFunctions(source, props);

    if (options == null &&
        !(isObject(source) && (methodNames.length || !props.length))) {
      options = source;
      source = object;
      object = this;
      methodNames = baseFunctions(source, keys(source));
    }
    var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
        isFunc = isFunction(object);

    arrayEach(methodNames, function(methodName) {
      var func = source[methodName];
      object[methodName] = func;
      if (isFunc) {
        object.prototype[methodName] = function() {
          var chainAll = this.__chain__;
          if (chain || chainAll) {
            var result = object(this.__wrapped__),
                actions = result.__actions__ = copyArray(this.__actions__);

            actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
            result.__chain__ = chainAll;
            return result;
          }
          return func.apply(object, arrayPush([this.value()], arguments));
        };
      }
    });

    return object;
  }

  /**
   * Reverts the `_` variable to its previous value and returns a reference to
   * the `lodash` function.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @returns {Function} Returns the `lodash` function.
   * @example
   *
   * var lodash = _.noConflict();
   */
  function noConflict() {
    if (root._ === this) {
      root._ = oldDash;
    }
    return this;
  }

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Computes the minimum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // => 2
   *
   * _.min([]);
   * // => undefined
   */
  function min(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseLt)
      : undefined;
  }

  /**
   * Computes `number` rounded to `precision`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Math
   * @param {number} number The number to round.
   * @param {number} [precision=0] The precision to round to.
   * @returns {number} Returns the rounded number.
   * @example
   *
   * _.round(4.006);
   * // => 4
   *
   * _.round(4.006, 2);
   * // => 4.01
   *
   * _.round(4060, -2);
   * // => 4100
   */
  var round = createRound('round');

  /*------------------------------------------------------------------------*/

  // Add methods that return wrapped values in chain sequences.
  lodash.assign = assign;
  lodash.assignIn = assignIn;
  lodash.assignInWith = assignInWith;
  lodash.chain = chain;
  lodash.compact = compact;
  lodash.constant = constant;
  lodash.debounce = debounce;
  lodash.drop = drop;
  lodash.flatten = flatten;
  lodash.iteratee = iteratee;
  lodash.keys = keys;
  lodash.keysIn = keysIn;
  lodash.map = map;
  lodash.memoize = memoize;
  lodash.mixin = mixin;
  lodash.negate = negate;
  lodash.omitBy = omitBy;
  lodash.pickBy = pickBy;
  lodash.property = property;
  lodash.pull = pull;
  lodash.pullAll = pullAll;
  lodash.reverse = reverse;
  lodash.sortBy = sortBy;
  lodash.tap = tap;
  lodash.throttle = throttle;
  lodash.thru = thru;
  lodash.toArray = toArray;
  lodash.values = values;
  lodash.without = without;

  // Add aliases.
  lodash.extend = assignIn;
  lodash.extendWith = assignInWith;

  // Add methods to `lodash.prototype`.
  mixin(lodash, lodash);

  /*------------------------------------------------------------------------*/

  // Add methods that return unwrapped values in chain sequences.
  lodash.attempt = attempt;
  lodash.capitalize = capitalize;
  lodash.clone = clone;
  lodash.cloneDeep = cloneDeep;
  lodash.endsWith = endsWith;
  lodash.eq = eq;
  lodash.escape = escape;
  lodash.every = every;
  lodash.find = find;
  lodash.findIndex = findIndex;
  lodash.forEach = forEach;
  lodash.forOwn = forOwn;
  lodash.get = get;
  lodash.has = has;
  lodash.hasIn = hasIn;
  lodash.identity = identity;
  lodash.includes = includes;
  lodash.indexOf = indexOf;
  lodash.inRange = inRange;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isArrayLike = isArrayLike;
  lodash.isArrayLikeObject = isArrayLikeObject;
  lodash.isBoolean = isBoolean;
  lodash.isBuffer = isBuffer;
  lodash.isDate = isDate;
  lodash.isEmpty = isEmpty;
  lodash.isError = isError;
  lodash.isFunction = isFunction;
  lodash.isLength = isLength;
  lodash.isMap = isMap;
  lodash.isNaN = isNaN;
  lodash.isNull = isNull;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isObjectLike = isObjectLike;
  lodash.isPlainObject = isPlainObject;
  lodash.isSet = isSet;
  lodash.isString = isString;
  lodash.isSymbol = isSymbol;
  lodash.isTypedArray = isTypedArray;
  lodash.isUndefined = isUndefined;
  lodash.last = last;
  lodash.min = min;
  lodash.stubArray = stubArray;
  lodash.stubFalse = stubFalse;
  lodash.noConflict = noConflict;
  lodash.noop = noop;
  lodash.now = now;
  lodash.padStart = padStart;
  lodash.round = round;
  lodash.some = some;
  lodash.startsWith = startsWith;
  lodash.template = template;
  lodash.toFinite = toFinite;
  lodash.toInteger = toInteger;
  lodash.toNumber = toNumber;
  lodash.toString = toString;
  lodash.upperFirst = upperFirst;

  // Add aliases.
  lodash.each = forEach;

  mixin(lodash, (function() {
    var source = {};
    baseForOwn(lodash, function(func, methodName) {
      if (!hasOwnProperty.call(lodash.prototype, methodName)) {
        source[methodName] = func;
      }
    });
    return source;
  }()), { 'chain': false });

  /*------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type {string}
   */
  lodash.VERSION = VERSION;

  // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
  arrayEach(['drop', 'take'], function(methodName, index) {
    LazyWrapper.prototype[methodName] = function(n) {
      n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

      var result = (this.__filtered__ && !index)
        ? new LazyWrapper(this)
        : this.clone();

      if (result.__filtered__) {
        result.__takeCount__ = nativeMin(n, result.__takeCount__);
      } else {
        result.__views__.push({
          'size': nativeMin(n, MAX_ARRAY_LENGTH),
          'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
        });
      }
      return result;
    };

    LazyWrapper.prototype[methodName + 'Right'] = function(n) {
      return this.reverse()[methodName](n).reverse();
    };
  });

  // Add `LazyWrapper` methods that accept an `iteratee` value.
  arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
    var type = index + 1,
        isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

    LazyWrapper.prototype[methodName] = function(iteratee) {
      var result = this.clone();
      result.__iteratees__.push({
        'iteratee': getIteratee(iteratee, 3),
        'type': type
      });
      result.__filtered__ = result.__filtered__ || isFilter;
      return result;
    };
  });

  // Add `LazyWrapper` methods for `_.head` and `_.last`.
  arrayEach(['head', 'last'], function(methodName, index) {
    var takeName = 'take' + (index ? 'Right' : '');

    LazyWrapper.prototype[methodName] = function() {
      return this[takeName](1).value()[0];
    };
  });

  // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
  arrayEach(['initial', 'tail'], function(methodName, index) {
    var dropName = 'drop' + (index ? '' : 'Right');

    LazyWrapper.prototype[methodName] = function() {
      return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
    };
  });

  LazyWrapper.prototype.compact = function() {
    return this.filter(identity);
  };

  LazyWrapper.prototype.find = function(predicate) {
    return this.filter(predicate).head();
  };

  LazyWrapper.prototype.findLast = function(predicate) {
    return this.reverse().find(predicate);
  };

  LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
    if (typeof path == 'function') {
      return new LazyWrapper(this);
    }
    return this.map(function(value) {
      return baseInvoke(value, path, args);
    });
  });

  LazyWrapper.prototype.reject = function(predicate) {
    return this.filter(negate(getIteratee(predicate)));
  };

  LazyWrapper.prototype.slice = function(start, end) {
    start = toInteger(start);

    var result = this;
    if (result.__filtered__ && (start > 0 || end < 0)) {
      return new LazyWrapper(result);
    }
    if (start < 0) {
      result = result.takeRight(-start);
    } else if (start) {
      result = result.drop(start);
    }
    if (end !== undefined) {
      end = toInteger(end);
      result = end < 0 ? result.dropRight(-end) : result.take(end - start);
    }
    return result;
  };

  LazyWrapper.prototype.takeRightWhile = function(predicate) {
    return this.reverse().takeWhile(predicate).reverse();
  };

  LazyWrapper.prototype.toArray = function() {
    return this.take(MAX_ARRAY_LENGTH);
  };

  // Add `LazyWrapper` methods to `lodash.prototype`.
  baseForOwn(LazyWrapper.prototype, function(func, methodName) {
    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
        isTaker = /^(?:head|last)$/.test(methodName),
        lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
        retUnwrapped = isTaker || /^find/.test(methodName);

    if (!lodashFunc) {
      return;
    }
    lodash.prototype[methodName] = function() {
      var value = this.__wrapped__,
          args = isTaker ? [1] : arguments,
          isLazy = value instanceof LazyWrapper,
          iteratee = args[0],
          useLazy = isLazy || isArray(value);

      var interceptor = function(value) {
        var result = lodashFunc.apply(lodash, arrayPush([value], args));
        return (isTaker && chainAll) ? result[0] : result;
      };

      if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
        // Avoid lazy use if the iteratee has a "length" value other than `1`.
        isLazy = useLazy = false;
      }
      var chainAll = this.__chain__,
          isHybrid = !!this.__actions__.length,
          isUnwrapped = retUnwrapped && !chainAll,
          onlyLazy = isLazy && !isHybrid;

      if (!retUnwrapped && useLazy) {
        value = onlyLazy ? value : new LazyWrapper(this);
        var result = func.apply(value, args);
        result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
        return new LodashWrapper(result, chainAll);
      }
      if (isUnwrapped && onlyLazy) {
        return func.apply(this, args);
      }
      result = this.thru(interceptor);
      return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
    };
  });

  // Add `Array` methods to `lodash.prototype`.
  arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
    var func = arrayProto[methodName],
        chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
        retUnwrapped = /^(?:pop|shift)$/.test(methodName);

    lodash.prototype[methodName] = function() {
      var args = arguments;
      if (retUnwrapped && !this.__chain__) {
        var value = this.value();
        return func.apply(isArray(value) ? value : [], args);
      }
      return this[chainName](function(value) {
        return func.apply(isArray(value) ? value : [], args);
      });
    };
  });

  // Map minified method names to their real names.
  baseForOwn(LazyWrapper.prototype, function(func, methodName) {
    var lodashFunc = lodash[methodName];
    if (lodashFunc) {
      var key = (lodashFunc.name + ''),
          names = realNames[key] || (realNames[key] = []);

      names.push({ 'name': methodName, 'func': lodashFunc });
    }
  });

  realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
    'name': 'wrapper',
    'func': undefined
  }];

  // Add methods to `LazyWrapper`.
  LazyWrapper.prototype.clone = lazyClone;
  LazyWrapper.prototype.reverse = lazyReverse;
  LazyWrapper.prototype.value = lazyValue;

  // Add chain sequence methods to the `lodash` wrapper.
  lodash.prototype.chain = wrapperChain;
  lodash.prototype.commit = wrapperCommit;
  lodash.prototype.next = wrapperNext;
  lodash.prototype.plant = wrapperPlant;
  lodash.prototype.reverse = wrapperReverse;
  lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

  // Add lazy aliases.
  lodash.prototype.first = lodash.prototype.head;

  if (symIterator) {
    lodash.prototype[symIterator] = wrapperToIterator;
  }

  /*--------------------------------------------------------------------------*/

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = lodash;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return lodash;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = lodash)._ = lodash;
    // Export for CommonJS support.
    freeExports._ = lodash;
  }
  else {
    // Export to the global object.
    root._ = lodash;
  }
}.call(this));

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Hls"] = factory();
	else
		root["Hls"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return enableLogs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return logger; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function noop() {}

var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};

var exportedLogger = fakeLogger;

/*globals self: false */

//let lastCallTime;
// function formatMsgWithTimeInfo(type, msg) {
//   const now = Date.now();
//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
//   lastCallTime = now;
//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
//   return msg;
// }

function formatMsg(type, msg) {
  msg = '[' + type + '] > ' + msg;
  return msg;
}

function consolePrintFn(type) {
  var func = self.console[type];
  if (func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args[0]) {
        args[0] = formatMsg(type, args[0]);
      }
      func.apply(self.console, args);
    };
  }
  return noop;
}

function exportLoggerFunctions(debugConfig) {
  for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    functions[_key2 - 1] = arguments[_key2];
  }

  functions.forEach(function (type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}

var enableLogs = function enableLogs(debugConfig) {
  if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
    exportLoggerFunctions(debugConfig,
    // Remove out from list here to hard-disable a log-level
    //'trace',
    'debug', 'log', 'info', 'warn', 'error');
    // Some browsers don't allow to use bind on console object anyway
    // fallback to default if needed
    try {
      exportedLogger.log();
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
};

var logger = exportedLogger;

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  // fired before MediaSource is attaching to media element - data: { media }
  MEDIA_ATTACHING: 'hlsMediaAttaching',
  // fired when MediaSource has been succesfully attached to media element - data: { }
  MEDIA_ATTACHED: 'hlsMediaAttached',
  // fired before detaching MediaSource from media element - data: { }
  MEDIA_DETACHING: 'hlsMediaDetaching',
  // fired when MediaSource has been detached from media element - data: { }
  MEDIA_DETACHED: 'hlsMediaDetached',
  // fired when we buffer is going to be reset - data: { }
  BUFFER_RESET: 'hlsBufferReset',
  // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
  BUFFER_CODECS: 'hlsBufferCodecs',
  // fired when sourcebuffers have been created - data: { tracks : tracks }
  BUFFER_CREATED: 'hlsBufferCreated',
  // fired when we append a segment to the buffer - data: { segment: segment object }
  BUFFER_APPENDING: 'hlsBufferAppending',
  // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
  BUFFER_APPENDED: 'hlsBufferAppended',
  // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
  BUFFER_EOS: 'hlsBufferEos',
  // fired when the media buffer should be flushed - data { startOffset, endOffset }
  BUFFER_FLUSHING: 'hlsBufferFlushing',
  // fired when the media buffer has been flushed - data: { }
  BUFFER_FLUSHED: 'hlsBufferFlushed',
  // fired to signal that a manifest loading starts - data: { url : manifestURL}
  MANIFEST_LOADING: 'hlsManifestLoading',
  // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
  MANIFEST_LOADED: 'hlsManifestLoaded',
  // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
  MANIFEST_PARSED: 'hlsManifestParsed',
  // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
  LEVEL_SWITCH: 'hlsLevelSwitch',
  // fired when a level switch is requested - data: { level : id of new level }
  LEVEL_SWITCHING: 'hlsLevelSwitching',
  // fired when a level switch is effective - data: { level : id of new level }
  LEVEL_SWITCHED: 'hlsLevelSwitched',
  // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
  LEVEL_LOADING: 'hlsLevelLoading',
  // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
  LEVEL_LOADED: 'hlsLevelLoaded',
  // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
  LEVEL_UPDATED: 'hlsLevelUpdated',
  // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
  LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
  // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
  AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
  // fired when an audio track switch occurs - data: { id : audio track id } // deprecated in favor AUDIO_TRACK_SWITCHING
  AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
  // fired when an audio track switching is requested - data: { id : audio track id }
  AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
  // fired when an audio track switch actually occurs - data: { id : audio track id }
  AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
  // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
  AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
  // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
  AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
  // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
  SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
  // fired when an subtitle track switch occurs - data: { id : subtitle track id }
  SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
  // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
  SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
  // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
  SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
  // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
  SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
  // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
  INIT_PTS_FOUND: 'hlsInitPtsFound',
  // fired when a fragment loading starts - data: { frag : fragment object }
  FRAG_LOADING: 'hlsFragLoading',
  // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
  FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
  // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
  FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
  // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
  FRAG_LOADED: 'hlsFragLoaded',
  // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
  FRAG_DECRYPTED: 'hlsFragDecrypted',
  // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
  FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
  // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
  FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
  // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
  FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
  // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
  FRAG_PARSING_DATA: 'hlsFragParsingData',
  // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
  FRAG_PARSED: 'hlsFragParsed',
  // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
  FRAG_BUFFERED: 'hlsFragBuffered',
  // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
  FRAG_CHANGED: 'hlsFragChanged',
  // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
  FPS_DROP: 'hlsFpsDrop',
  //triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
  FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
  // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
  ERROR: 'hlsError',
  // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
  DESTROYING: 'hlsDestroying',
  // fired when a decrypt key loading starts - data: { frag : fragment object }
  KEY_LOADING: 'hlsKeyLoading',
  // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
  KEY_LOADED: 'hlsKeyLoaded',
  // fired upon stream controller state transitions - data: { previousState, nextState }
  STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
});

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ErrorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorDetails; });
var ErrorTypes = {
  // Identifier for a network error (loading error / timeout ...)
  NETWORK_ERROR: 'networkError',
  // Identifier for a media Error (video/parsing/mediasource error)
  MEDIA_ERROR: 'mediaError',
  // Identifier for a mux Error (demuxing/remuxing)
  MUX_ERROR: 'muxError',
  // Identifier for all other errors
  OTHER_ERROR: 'otherError'
};

var ErrorDetails = {
  // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_ERROR: 'manifestLoadError',
  // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
  // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
  MANIFEST_PARSING_ERROR: 'manifestParsingError',
  // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
  // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_ERROR: 'levelLoadError',
  // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
  // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
  LEVEL_SWITCH_ERROR: 'levelSwitchError',
  // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
  // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
  AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
  // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  FRAG_LOAD_ERROR: 'fragLoadError',
  // Identifier for fragment loop loading error - data: { frag : fragment object}
  FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
  // Identifier for fragment load timeout error - data: { frag : fragment object}
  FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
  // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
  FRAG_DECRYPT_ERROR: 'fragDecryptError',
  // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
  // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
  FRAG_PARSING_ERROR: 'fragParsingError',
  // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
  REMUX_ALLOC_ERROR: 'remuxAllocError',
  // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
  KEY_LOAD_ERROR: 'keyLoadError',
  // Identifier for decrypt key load timeout error - data: { frag : fragment object}
  KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
  // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
  BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
  // Identifier for a buffer append error - data: append error description
  BUFFER_APPEND_ERROR: 'bufferAppendError',
  // Identifier for a buffer appending error event - data: appending error description
  BUFFER_APPENDING_ERROR: 'bufferAppendingError',
  // Identifier for a buffer stalled error event
  BUFFER_STALLED_ERROR: 'bufferStalledError',
  // Identifier for a buffer full event
  BUFFER_FULL_ERROR: 'bufferFullError',
  // Identifier for a buffer seek over hole event
  BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
  // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
  BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
  // Identifier for an internal exception happening inside hls.js while handling an event
  INTERNAL_EXCEPTION: 'internalException'
};

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return utf8ArrayToStr; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ID3 parser
 */
var ID3 = function () {
  function ID3() {
    _classCallCheck(this, ID3);
  }

  /**
   * Returns true if an ID3 header can be found at offset in data
   * @param {Uint8Array} data - The data to search in
   * @param {number} offset - The offset at which to start searching
   * @return {boolean} - True if an ID3 header is found
   */
  ID3.isHeader = function isHeader(data, offset) {
    /*
    * http://id3.org/id3v2.3.0
    * [0]     = 'I'
    * [1]     = 'D'
    * [2]     = '3'
    * [3,4]   = {Version}
    * [5]     = {Flags}
    * [6-9]   = {ID3 Size}
    *
    * An ID3v2 tag can be detected with the following pattern:
    *  $49 44 33 yy yy xx zz zz zz zz
    * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80
    */
    if (offset + 10 <= data.length) {
      //look for 'ID3' identifier
      if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {
        //check version is within range
        if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
          //check size is within range
          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
            return true;
          }
        }
      }
    }

    return false;
  };

  /**
   * Returns true if an ID3 footer can be found at offset in data
   * @param {Uint8Array} data - The data to search in
   * @param {number} offset - The offset at which to start searching
   * @return {boolean} - True if an ID3 footer is found
   */


  ID3.isFooter = function isFooter(data, offset) {
    /*
    * The footer is a copy of the header, but with a different identifier
    */
    if (offset + 10 <= data.length) {
      //look for '3DI' identifier
      if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {
        //check version is within range
        if (data[offset + 3] < 0xFF && data[offset + 4] < 0xFF) {
          //check size is within range
          if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {
            return true;
          }
        }
      }
    }

    return false;
  };

  /**
   * Returns any adjacent ID3 tags found in data starting at offset, as one block of data
   * @param {Uint8Array} data - The data to search in
   * @param {number} offset - The offset at which to start searching
   * @return {Uint8Array} - The block of data containing any ID3 tags found
   */


  ID3.getID3Data = function getID3Data(data, offset) {
    var front = offset;
    var length = 0;

    while (ID3.isHeader(data, offset)) {
      //ID3 header is 10 bytes
      length += 10;

      var size = ID3._readSize(data, offset + 6);
      length += size;

      if (ID3.isFooter(data, offset + 10)) {
        //ID3 footer is 10 bytes
        length += 10;
      }

      offset += length;
    }

    if (length > 0) {
      return data.subarray(front, front + length);
    }

    return undefined;
  };

  ID3._readSize = function _readSize(data, offset) {
    var size = 0;
    size = (data[offset] & 0x7f) << 21;
    size |= (data[offset + 1] & 0x7f) << 14;
    size |= (data[offset + 2] & 0x7f) << 7;
    size |= data[offset + 3] & 0x7f;
    return size;
  };

  /**
   * Searches for the Elementary Stream timestamp found in the ID3 data chunk
   * @param {Uint8Array} data - Block of data containing one or more ID3 tags
   * @return {number} - The timestamp
   */


  ID3.getTimeStamp = function getTimeStamp(data) {
    var frames = ID3.getID3Frames(data);
    for (var i = 0; i < frames.length; i++) {
      var frame = frames[i];
      if (ID3.isTimeStampFrame(frame)) {
        return ID3._readTimeStamp(frame);
      }
    }

    return undefined;
  };

  /**
   * Returns true if the ID3 frame is an Elementary Stream timestamp frame
   * @param {ID3 frame} frame
   */


  ID3.isTimeStampFrame = function isTimeStampFrame(frame) {
    return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';
  };

  ID3._getFrameData = function _getFrameData(data) {
    /*
    Frame ID       $xx xx xx xx (four characters)
    Size           $xx xx xx xx
    Flags          $xx xx
    */
    var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
    var size = ID3._readSize(data, 4);

    //skip frame id, size, and flags
    var offset = 10;

    return { type: type, size: size, data: data.subarray(offset, offset + size) };
  };

  /**
   * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
   * @param {Uint8Array} id3Data - The ID3 data containing one or more ID3 tags
   * @return {ID3 frame[]} - Array of ID3 frame objects
   */


  ID3.getID3Frames = function getID3Frames(id3Data) {
    var offset = 0;
    var frames = [];

    while (ID3.isHeader(id3Data, offset)) {
      var size = ID3._readSize(id3Data, offset + 6);
      //skip past ID3 header
      offset += 10;
      var end = offset + size;
      //loop through frames in the ID3 tag
      while (offset + 8 < end) {
        var frameData = ID3._getFrameData(id3Data.subarray(offset));
        var frame = ID3._decodeFrame(frameData);
        if (frame) {
          frames.push(frame);
        }
        //skip frame header and frame data
        offset += frameData.size + 10;
      }

      if (ID3.isFooter(id3Data, offset)) {
        offset += 10;
      }
    }

    return frames;
  };

  ID3._decodeFrame = function _decodeFrame(frame) {
    if (frame.type === 'PRIV') {
      return ID3._decodePrivFrame(frame);
    } else if (frame.type[0] === 'T') {
      return ID3._decodeTextFrame(frame);
    } else if (frame.type[0] === 'W') {
      return ID3._decodeURLFrame(frame);
    }

    return undefined;
  };

  ID3._readTimeStamp = function _readTimeStamp(timeStampFrame) {
    if (timeStampFrame.data.byteLength === 8) {
      var data = new Uint8Array(timeStampFrame.data);
      // timestamp is 33 bit expressed as a big-endian eight-octet number,
      // with the upper 31 bits set to zero.
      var pts33Bit = data[3] & 0x1;
      var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
      timestamp /= 45;

      if (pts33Bit) {
        timestamp += 47721858.84; // 2^32 / 90
      }

      return Math.round(timestamp);
    }

    return undefined;
  };

  ID3._decodePrivFrame = function _decodePrivFrame(frame) {
    /*
    Format: <text string>\0<binary data>
    */
    if (frame.size < 2) {
      return undefined;
    }

    var owner = ID3._utf8ArrayToStr(frame.data, true);
    var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));

    return { key: frame.type, info: owner, data: privateData.buffer };
  };

  ID3._decodeTextFrame = function _decodeTextFrame(frame) {
    if (frame.size < 2) {
      return undefined;
    }

    if (frame.type === 'TXXX') {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{Value}
      */
      var index = 1;
      var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

      index += description.length + 1;
      var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

      return { key: frame.type, info: description, data: value };
    } else {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Value}
      */
      var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
      return { key: frame.type, data: text };
    }
  };

  ID3._decodeURLFrame = function _decodeURLFrame(frame) {
    if (frame.type === 'WXXX') {
      /*
      Format:
      [0]   = {Text Encoding}
      [1-?] = {Description}\0{URL}
      */
      if (frame.size < 2) {
        return undefined;
      }

      var index = 1;
      var description = ID3._utf8ArrayToStr(frame.data.subarray(index));

      index += description.length + 1;
      var value = ID3._utf8ArrayToStr(frame.data.subarray(index));

      return { key: frame.type, info: description, data: value };
    } else {
      /*
      Format:
      [0-?] = {URL}
      */
      var url = ID3._utf8ArrayToStr(frame.data);
      return { key: frame.type, data: url };
    }
  };

  // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
  // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
  /* utf.js - UTF-8 <=> UTF-16 convertion
   *
   * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
   * Version: 1.0
   * LastModified: Dec 25 1999
   * This library is free.  You can redistribute it and/or modify it.
   */


  ID3._utf8ArrayToStr = function _utf8ArrayToStr(array) {
    var exitOnNull = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


    var len = array.length;
    var c = void 0;
    var char2 = void 0;
    var char3 = void 0;
    var out = '';
    var i = 0;
    while (i < len) {
      c = array[i++];
      if (c === 0x00 && exitOnNull) {
        return out;
      } else if (c === 0x00 || c === 0x03) {
        // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it
        continue;
      }
      switch (c >> 4) {
        case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:
          // 0xxxxxxx
          out += String.fromCharCode(c);
          break;
        case 12:case 13:
          // 110x xxxx   10xx xxxx
          char2 = array[i++];
          out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
          break;
        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
          break;
        default:
      }
    }
    return out;
  };

  return ID3;
}();

var utf8ArrayToStr = ID3._utf8ArrayToStr;

/* harmony default export */ __webpack_exports__["a"] = (ID3);



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./src/crypt/aes-crypto.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESCrypto = function () {
  function AESCrypto(subtle, iv) {
    _classCallCheck(this, AESCrypto);

    this.subtle = subtle;
    this.aesIV = iv;
  }

  AESCrypto.prototype.decrypt = function decrypt(data, key) {
    return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
  };

  return AESCrypto;
}();

/* harmony default export */ var aes_crypto = (AESCrypto);
// CONCATENATED MODULE: ./src/crypt/fast-aes-key.js
function fast_aes_key__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastAESKey = function () {
  function FastAESKey(subtle, key) {
    fast_aes_key__classCallCheck(this, FastAESKey);

    this.subtle = subtle;
    this.key = key;
  }

  FastAESKey.prototype.expandKey = function expandKey() {
    return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
  };

  return FastAESKey;
}();

/* harmony default export */ var fast_aes_key = (FastAESKey);
// CONCATENATED MODULE: ./src/crypt/aes-decryptor.js
function aes_decryptor__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AESDecryptor = function () {
  function AESDecryptor() {
    aes_decryptor__classCallCheck(this, AESDecryptor);

    // Static after running initTable
    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);

    // Changes during runtime
    this.key = new Uint32Array(0);

    this.initTable();
  }

  // Using view.getUint32() also swaps the byte order.


  AESDecryptor.prototype.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
    var view = new DataView(arrayBuffer);
    var newArray = new Uint32Array(4);
    for (var i = 0; i < 4; i++) {
      newArray[i] = view.getUint32(i * 4);
    }
    return newArray;
  };

  AESDecryptor.prototype.initTable = function initTable() {
    var sBox = this.sBox;
    var invSBox = this.invSBox;
    var subMix = this.subMix;
    var subMix0 = subMix[0];
    var subMix1 = subMix[1];
    var subMix2 = subMix[2];
    var subMix3 = subMix[3];
    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];

    var d = new Uint32Array(256);
    var x = 0;
    var xi = 0;
    var i = 0;
    for (i = 0; i < 256; i++) {
      if (i < 128) {
        d[i] = i << 1;
      } else {
        d[i] = i << 1 ^ 0x11b;
      }
    }

    for (i = 0; i < 256; i++) {
      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
      sBox[x] = sx;
      invSBox[sx] = x;

      // Compute multiplication
      var x2 = d[x];
      var x4 = d[x2];
      var x8 = d[x4];

      // Compute sub/invSub bytes, mix columns tables
      var t = d[sx] * 0x101 ^ sx * 0x1010100;
      subMix0[x] = t << 24 | t >>> 8;
      subMix1[x] = t << 16 | t >>> 16;
      subMix2[x] = t << 8 | t >>> 24;
      subMix3[x] = t;

      // Compute inv sub bytes, inv mix columns tables
      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
      invSubMix0[sx] = t << 24 | t >>> 8;
      invSubMix1[sx] = t << 16 | t >>> 16;
      invSubMix2[sx] = t << 8 | t >>> 24;
      invSubMix3[sx] = t;

      // Compute next counter
      if (!x) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }
  };

  AESDecryptor.prototype.expandKey = function expandKey(keyBuffer) {
    // convert keyBuffer to Uint32Array
    var key = this.uint8ArrayToUint32Array_(keyBuffer);
    var sameKey = true;
    var offset = 0;

    while (offset < key.length && sameKey) {
      sameKey = key[offset] === this.key[offset];
      offset++;
    }

    if (sameKey) {
      return;
    }

    this.key = key;
    var keySize = this.keySize = key.length;

    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
      throw new Error('Invalid aes key size=' + keySize);
    }

    var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
    var ksRow = void 0;
    var invKsRow = void 0;

    var keySchedule = this.keySchedule = new Uint32Array(ksRows);
    var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
    var sbox = this.sBox;
    var rcon = this.rcon;

    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];

    var prev = void 0;
    var t = void 0;

    for (ksRow = 0; ksRow < ksRows; ksRow++) {
      if (ksRow < keySize) {
        prev = keySchedule[ksRow] = key[ksRow];
        continue;
      }
      t = prev;

      if (ksRow % keySize === 0) {
        // Rot word
        t = t << 8 | t >>> 24;

        // Sub word
        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];

        // Mix Rcon
        t ^= rcon[ksRow / keySize | 0] << 24;
      } else if (keySize > 6 && ksRow % keySize === 4) {
        // Sub word
        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
      }

      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
    }

    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
      ksRow = ksRows - invKsRow;
      if (invKsRow & 3) {
        t = keySchedule[ksRow];
      } else {
        t = keySchedule[ksRow - 4];
      }

      if (invKsRow < 4 || ksRow <= 4) {
        invKeySchedule[invKsRow] = t;
      } else {
        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
      }

      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
    }
  };

  // Adding this as a method greatly improves performance.


  AESDecryptor.prototype.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
  };

  AESDecryptor.prototype.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {
    var nRounds = this.keySize + 6;
    var invKeySchedule = this.invKeySchedule;
    var invSBOX = this.invSBox;

    var invSubMix = this.invSubMix;
    var invSubMix0 = invSubMix[0];
    var invSubMix1 = invSubMix[1];
    var invSubMix2 = invSubMix[2];
    var invSubMix3 = invSubMix[3];

    var initVector = this.uint8ArrayToUint32Array_(aesIV);
    var initVector0 = initVector[0];
    var initVector1 = initVector[1];
    var initVector2 = initVector[2];
    var initVector3 = initVector[3];

    var inputInt32 = new Int32Array(inputArrayBuffer);
    var outputInt32 = new Int32Array(inputInt32.length);

    var t0 = void 0,
        t1 = void 0,
        t2 = void 0,
        t3 = void 0;
    var s0 = void 0,
        s1 = void 0,
        s2 = void 0,
        s3 = void 0;
    var inputWords0 = void 0,
        inputWords1 = void 0,
        inputWords2 = void 0,
        inputWords3 = void 0;

    var ksRow, i;
    var swapWord = this.networkToHostOrderSwap;

    while (offset < inputInt32.length) {
      inputWords0 = swapWord(inputInt32[offset]);
      inputWords1 = swapWord(inputInt32[offset + 1]);
      inputWords2 = swapWord(inputInt32[offset + 2]);
      inputWords3 = swapWord(inputInt32[offset + 3]);

      s0 = inputWords0 ^ invKeySchedule[0];
      s1 = inputWords3 ^ invKeySchedule[1];
      s2 = inputWords2 ^ invKeySchedule[2];
      s3 = inputWords1 ^ invKeySchedule[3];

      ksRow = 4;

      // Iterate through the rounds of decryption
      for (i = 1; i < nRounds; i++) {
        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
        // Update state
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;

        ksRow = ksRow + 4;
      }

      // Shift rows, sub bytes, add round key
      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
      ksRow = ksRow + 3;

      // Write
      outputInt32[offset] = swapWord(t0 ^ initVector0);
      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);

      // reset initVector to last 4 unsigned int
      initVector0 = inputWords0;
      initVector1 = inputWords1;
      initVector2 = inputWords2;
      initVector3 = inputWords3;

      offset = offset + 4;
    }

    return outputInt32.buffer;
  };

  AESDecryptor.prototype.destroy = function destroy() {
    this.key = undefined;
    this.keySize = undefined;
    this.ksRows = undefined;

    this.sBox = undefined;
    this.invSBox = undefined;
    this.subMix = undefined;
    this.invSubMix = undefined;
    this.keySchedule = undefined;
    this.invKeySchedule = undefined;

    this.rcon = undefined;
  };

  return AESDecryptor;
}();

/* harmony default export */ var aes_decryptor = (AESDecryptor);
// EXTERNAL MODULE: ./src/errors.js
var errors = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/logger.js
var logger = __webpack_require__(0);

// CONCATENATED MODULE: ./src/crypt/decrypter.js
function decrypter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }








/*globals self: false */

var decrypter_Decrypter = function () {
  function Decrypter(observer, config) {
    decrypter__classCallCheck(this, Decrypter);

    this.observer = observer;
    this.config = config;
    this.logEnabled = true;
    try {
      var browserCrypto = crypto ? crypto : self.crypto;
      this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
    } catch (e) {}
    this.disableWebCrypto = !this.subtle;
  }

  Decrypter.prototype.isSync = function isSync() {
    return this.disableWebCrypto && this.config.enableSoftwareAES;
  };

  Decrypter.prototype.decrypt = function decrypt(data, key, iv, callback) {
    var _this = this;

    if (this.disableWebCrypto && this.config.enableSoftwareAES) {
      if (this.logEnabled) {
        logger["b" /* logger */].log('JS AES decrypt');
        this.logEnabled = false;
      }
      var decryptor = this.decryptor;
      if (!decryptor) {
        this.decryptor = decryptor = new aes_decryptor();
      }
      decryptor.expandKey(key);
      callback(decryptor.decrypt(data, 0, iv));
    } else {
      if (this.logEnabled) {
        logger["b" /* logger */].log('WebCrypto AES decrypt');
        this.logEnabled = false;
      }
      var subtle = this.subtle;
      if (this.key !== key) {
        this.key = key;
        this.fastAesKey = new fast_aes_key(subtle, key);
      }

      this.fastAesKey.expandKey().then(function (aesKey) {
        // decrypt using web crypto
        var crypto = new aes_crypto(subtle, iv);
        crypto.decrypt(data, aesKey).catch(function (err) {
          _this.onWebCryptoError(err, data, key, iv, callback);
        }).then(function (result) {
          callback(result);
        });
      }).catch(function (err) {
        _this.onWebCryptoError(err, data, key, iv, callback);
      });
    }
  };

  Decrypter.prototype.onWebCryptoError = function onWebCryptoError(err, data, key, iv, callback) {
    if (this.config.enableSoftwareAES) {
      logger["b" /* logger */].log('WebCrypto Error, disable WebCrypto API');
      this.disableWebCrypto = true;
      this.logEnabled = true;
      this.decrypt(data, key, iv, callback);
    } else {
      logger["b" /* logger */].error('decrypting error : ' + err.message);
      this.observer.trigger(Event.ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
    }
  };

  Decrypter.prototype.destroy = function destroy() {
    var decryptor = this.decryptor;
    if (decryptor) {
      decryptor.destroy();
      this.decryptor = undefined;
    }
  };

  return Decrypter;
}();

/* harmony default export */ var decrypter = __webpack_exports__["a"] = (decrypter_Decrypter);

/***/ }),
/* 5 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// see https://tools.ietf.org/html/rfc1808

/* jshint ignore:start */
(function(root) {
/* jshint ignore:end */

  var URL_REGEX = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
  var FIRST_SEGMENT_REGEX = /^([^\/;?#]*)(.*)$/;
  var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
  var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;

  var URLToolkit = { // jshint ignore:line
    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
    // E.g
    // With opts.alwaysNormalize = false (default, spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
    // With opts.alwaysNormalize = true (default, not spec compliant)
    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
      opts = opts || {};
      // remove any remaining space and CRLF
      baseURL = baseURL.trim();
      relativeURL = relativeURL.trim();
      if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
          return baseURL;
        }
        var basePartsForNormalise = this.parseURL(baseURL);
        if (!baseParts) {
          throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
        return URLToolkit.buildURLFromParts(basePartsForNormalise);
      }
      var relativeParts = this.parseURL(relativeURL);
      if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
      }
      if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
          return relativeURL;
        }
        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
        return URLToolkit.buildURLFromParts(relativeParts);
      }
      var baseParts = this.parseURL(baseURL);
      if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
      }
      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
      }
      if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
      }
      var builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment
      };
      if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
          if (!relativeParts.path) {
            // 5) If the embedded URL path is empty (and not preceded by a
            // slash), then the embedded URL inherits the base URL path
            builtParts.path = baseParts.path;
            // 5a) if the embedded URL's <params> is non-empty, we skip to
            // step 7; otherwise, it inherits the <params> of the base
            // URL (if any) and
            if (!relativeParts.params) {
              builtParts.params = baseParts.params;
              // 5b) if the embedded URL's <query> is non-empty, we skip to
              // step 7; otherwise, it inherits the <query> of the base
              // URL (if any) and we skip to step 7.
              if (!relativeParts.query) {
                builtParts.query = baseParts.query;
              }
            }
          } else {
            // 6) The last segment of the base URL's path (anything
            // following the rightmost slash "/", or the entire path if no
            // slash is present) is removed and the embedded URL's path is
            // appended in its place.
            var baseURLPath = baseParts.path;
            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
            builtParts.path = URLToolkit.normalizePath(newPath);
          }
        }
      }
      if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
      }
      return URLToolkit.buildURLFromParts(builtParts);
    },
    parseURL: function(url) {
      var parts = URL_REGEX.exec(url);
      if (!parts) {
        return null;
      }
      return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
      };
    },
    normalizePath: function(path) {
      // The following operations are
      // then applied, in order, to the new path:
      // 6a) All occurrences of "./", where "." is a complete path
      // segment, are removed.
      // 6b) If the path ends with "." as a complete path segment,
      // that "." is removed.
      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
      // 6c) All occurrences of "<segment>/../", where <segment> is a
      // complete path segment not equal to "..", are removed.
      // Removal of these path segments is performed iteratively,
      // removing the leftmost matching pattern on each iteration,
      // until no matching pattern remains.
      // 6d) If the path ends with "<segment>/..", where <segment> is a
      // complete path segment not equal to "..", that
      // "<segment>/.." is removed.
      while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
      return path.split('').reverse().join('');
    },
    buildURLFromParts: function(parts) {
      return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
    }
  };

/* jshint ignore:start */
  if(true)
    module.exports = URLToolkit;
  else if(typeof define === 'function' && define.amd)
    define([], function() { return URLToolkit; });
  else if(typeof exports === 'object')
    exports["URLToolkit"] = URLToolkit;
  else
    root["URLToolkit"] = URLToolkit;
})(this);
/* jshint ignore:end */


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./src/events.js
var events = __webpack_require__(1);

// EXTERNAL MODULE: ./src/errors.js
var errors = __webpack_require__(2);

// EXTERNAL MODULE: ./src/crypt/decrypter.js + 3 modules
var crypt_decrypter = __webpack_require__(4);

// EXTERNAL MODULE: ./src/utils/logger.js
var logger = __webpack_require__(0);

// CONCATENATED MODULE: ./src/demux/adts.js
/**
 *  ADTS parser helper
 */



function getAudioConfig(observer, data, offset, audioCodec) {
  var adtsObjectType,
      // :int
  adtsSampleingIndex,
      // :int
  adtsExtensionSampleingIndex,
      // :int
  adtsChanelConfig,
      // :int
  config,
      userAgent = navigator.userAgent.toLowerCase(),
      manifestCodec = audioCodec,
      adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
  // byte 2
  adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
  adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
  if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
    observer.trigger(Event.ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
    return;
  }
  adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
  // byte 3
  adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
  logger["b" /* logger */].log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
  if (/firefox/i.test(userAgent)) {
    if (adtsSampleingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4);
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
    // Android : always use AAC
  } else if (userAgent.indexOf('android') !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSampleingIndex = adtsSampleingIndex;
  } else {
    /*  for other browsers (Chrome/Vivaldi/Opera ...)
        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
    */
    adtsObjectType = 5;
    config = new Array(4);
    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
      // there is a factor 2 between frame sample rate and output sample rate
      // multiply frequency by 2 (see table below, equivalent to substract 3)
      adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
    } else {
      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }
      adtsExtensionSampleingIndex = adtsSampleingIndex;
    }
  }
  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
      ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
    Audio Profile / Audio Object Type
    0: Null
    1: AAC Main
    2: AAC LC (Low Complexity)
    3: AAC SSR (Scalable Sample Rate)
    4: AAC LTP (Long Term Prediction)
    5: SBR (Spectral Band Replication)
    6: AAC Scalable
   sampling freq
    0: 96000 Hz
    1: 88200 Hz
    2: 64000 Hz
    3: 48000 Hz
    4: 44100 Hz
    5: 32000 Hz
    6: 24000 Hz
    7: 22050 Hz
    8: 16000 Hz
    9: 12000 Hz
    10: 11025 Hz
    11: 8000 Hz
    12: 7350 Hz
    13: Reserved
    14: Reserved
    15: frequency is written explictly
    Channel Configurations
    These are the channel configurations:
    0: Defined in AOT Specifc Config
    1: 1 channel: front-center
    2: 2 channels: front-left, front-right
  */
  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
  config[0] = adtsObjectType << 3;
  // samplingFrequencyIndex
  config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
  config[1] |= (adtsSampleingIndex & 0x01) << 7;
  // channelConfiguration
  config[1] |= adtsChanelConfig << 3;
  if (adtsObjectType === 5) {
    // adtsExtensionSampleingIndex
    config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
    config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
    config[2] |= 2 << 2;
    config[3] = 0;
  }
  return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
}

function isHeaderPattern(data, offset) {
  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;
}

function getHeaderLength(data, offset) {
  return !!(data[offset + 1] & 0x01) ? 7 : 9;
}

function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
}

function isHeader(data, offset) {
  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
  // Layer bits (position 14 and 15) in header should be always 0 for ADTS
  // More info https://wiki.multimedia.cx/index.php?title=ADTS
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    return true;
  }
  return false;
}

function adts_probe(data, offset) {
  // same as isHeader but we also check that ADTS frame follows last ADTS frame
  // or end of data is reached
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    // ADTS header Length
    var headerLength = getHeaderLength(data, offset);
    // ADTS frame Length
    var frameLength = headerLength;
    if (offset + 5 < data.length) {
      frameLength = getFullFrameLength(data, offset);
    }
    var newOffset = offset + frameLength;
    if (newOffset === data.length || newOffset + 1 < data.length && isHeaderPattern(data, newOffset)) {
      return true;
    }
  }
  return false;
}

function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    var config = getAudioConfig(observer, data, offset, audioCodec);
    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    logger["b" /* logger */].log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
  }
}

function getFrameDuration(samplerate) {
  return 1024 * 90000 / samplerate;
}

function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
  var headerLength, frameLength, stamp;
  var length = data.length;

  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
  headerLength = getHeaderLength(data, offset);
  // retrieve frame size
  frameLength = getFullFrameLength(data, offset);
  frameLength -= headerLength;

  if (frameLength > 0 && offset + headerLength + frameLength <= length) {
    stamp = pts + frameIndex * frameDuration;
    //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    return { headerLength: headerLength, frameLength: frameLength, stamp: stamp };
  }

  return undefined;
}

function appendFrame(track, data, offset, pts, frameIndex) {
  var frameDuration = getFrameDuration(track.samplerate);
  var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
  if (header) {
    var stamp = header.stamp;
    var headerLength = header.headerLength;
    var frameLength = header.frameLength;

    //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
    var aacSample = {
      unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
      pts: stamp,
      dts: stamp
    };

    track.samples.push(aacSample);
    track.len += frameLength;

    return { sample: aacSample, length: frameLength + headerLength };
  }

  return undefined;
}
// EXTERNAL MODULE: ./src/demux/id3.js
var id3 = __webpack_require__(3);

// CONCATENATED MODULE: ./src/demux/aacdemuxer.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * AAC demuxer
 */




var aacdemuxer_AACDemuxer = function () {
  function AACDemuxer(observer, remuxer, config) {
    _classCallCheck(this, AACDemuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  AACDemuxer.prototype.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
    this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
  };

  AACDemuxer.prototype.resetTimeStamp = function resetTimeStamp() {};

  AACDemuxer.probe = function probe(data) {
    if (!data) {
      return false;
    }
    // Check for the ADTS sync word
    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1
    // Layer bits (position 14 and 15) in header should be always 0 for ADTS
    // More info https://wiki.multimedia.cx/index.php?title=ADTS
    var id3Data = id3["a" /* default */].getID3Data(data, 0) || [];
    var offset = id3Data.length;

    for (var length = data.length; offset < length; offset++) {
      if (adts_probe(data, offset)) {
        logger["b" /* logger */].log('ADTS sync word found !');
        return true;
      }
    }
    return false;
  };

  // feed incoming data to the front of the parsing pipeline


  AACDemuxer.prototype.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
    var track = this._audioTrack;
    var id3Data = id3["a" /* default */].getID3Data(data, 0) || [];
    var timestamp = id3["a" /* default */].getTimeStamp(id3Data);
    var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
    var frameIndex = 0;
    var stamp = pts;
    var length = data.length;
    var offset = id3Data.length;

    var id3Samples = [{ pts: stamp, dts: stamp, data: id3Data }];

    while (offset < length - 1) {
      if (isHeader(data, offset) && offset + 5 < length) {
        initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
        var frame = appendFrame(track, data, offset, pts, frameIndex);
        if (frame) {
          offset += frame.length;
          stamp = frame.sample.pts;
          frameIndex++;
        } else {
          logger["b" /* logger */].log('Unable to parse AAC frame');
          break;
        }
      } else if (id3["a" /* default */].isHeader(data, offset)) {
        id3Data = id3["a" /* default */].getID3Data(data, offset);
        id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
        offset += id3Data.length;
      } else {
        //nothing found, keep looking
        offset++;
      }
    }

    this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
  };

  AACDemuxer.prototype.destroy = function destroy() {};

  return AACDemuxer;
}();

/* harmony default export */ var aacdemuxer = (aacdemuxer_AACDemuxer);
// CONCATENATED MODULE: ./src/demux/mp4demuxer.js
function mp4demuxer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * MP4 demuxer
 */



var UINT32_MAX = Math.pow(2, 32) - 1;

var mp4demuxer_MP4Demuxer = function () {
  function MP4Demuxer(observer, remuxer) {
    mp4demuxer__classCallCheck(this, MP4Demuxer);

    this.observer = observer;
    this.remuxer = remuxer;
  }

  MP4Demuxer.prototype.resetTimeStamp = function resetTimeStamp(initPTS) {
    this.initPTS = initPTS;
  };

  MP4Demuxer.prototype.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
    //jshint unused:false
    if (initSegment && initSegment.byteLength) {
      var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);

      // default audio codec if nothing specified
      // TODO : extract that from initsegment
      if (audioCodec == null) {
        audioCodec = 'mp4a.40.5';
      }
      if (videoCodec == null) {
        videoCodec = 'avc1.42e01e';
      }
      var tracks = {};
      if (initData.audio && initData.video) {
        tracks.audiovideo = { container: 'video/mp4', codec: audioCodec + ',' + videoCodec, initSegment: duration ? initSegment : null };
      } else {
        if (initData.audio) {
          tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: duration ? initSegment : null };
        }
        if (initData.video) {
          tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: duration ? initSegment : null };
        }
      }
      this.observer.trigger(events["a" /* default */].FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
    } else {
      if (audioCodec) {
        this.audioCodec = audioCodec;
      }
      if (videoCodec) {
        this.videoCodec = videoCodec;
      }
    }
  };

  MP4Demuxer.probe = function probe(data) {
    // ensure we find a moof box in the first 16 kB
    return MP4Demuxer.findBox({ data: data, start: 0, end: Math.min(data.length, 16384) }, ['moof']).length > 0;
  };

  MP4Demuxer.bin2str = function bin2str(buffer) {
    return String.fromCharCode.apply(null, buffer);
  };

  MP4Demuxer.readUint32 = function readUint32(buffer, offset) {
    if (buffer.data) {
      offset += buffer.start;
      buffer = buffer.data;
    }

    var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
    return val < 0 ? 4294967296 + val : val;
  };

  MP4Demuxer.writeUint32 = function writeUint32(buffer, offset, value) {
    if (buffer.data) {
      offset += buffer.start;
      buffer = buffer.data;
    }
    buffer[offset] = value >> 24;
    buffer[offset + 1] = value >> 16 & 0xff;
    buffer[offset + 2] = value >> 8 & 0xff;
    buffer[offset + 3] = value & 0xff;
  };

  // Find the data for a box specified by its path


  MP4Demuxer.findBox = function findBox(data, path) {
    var results = [],
        i,
        size,
        type,
        end,
        subresults,
        start,
        endbox;

    if (data.data) {
      start = data.start;
      end = data.end;
      data = data.data;
    } else {
      start = 0;
      end = data.byteLength;
    }

    if (!path.length) {
      // short-circuit the search for empty paths
      return null;
    }

    for (i = start; i < end;) {
      size = MP4Demuxer.readUint32(data, i);
      type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
      endbox = size > 1 ? i + size : end;

      if (type === path[0]) {

        if (path.length === 1) {
          // this is the end of the path and we've found the box we were
          // looking for
          results.push({ data: data, start: i + 8, end: endbox });
        } else {
          // recursively search for the next box along the path
          subresults = MP4Demuxer.findBox({ data: data, start: i + 8, end: endbox }, path.slice(1));
          if (subresults.length) {
            results = results.concat(subresults);
          }
        }
      }
      i = endbox;
    }

    // we've finished searching all of data
    return results;
  };

  /**
   * Parses an MP4 initialization segment and extracts stream type and
   * timescale values for any declared tracks. Timescale values indicate the
   * number of clock ticks per second to assume for time-based values
   * elsewhere in the MP4.
   *
   * To determine the start time of an MP4, you need two pieces of
   * information: the timescale unit and the earliest base media decode
   * time. Multiple timescales can be specified within an MP4 but the
   * base media decode time is always expressed in the timescale from
   * the media header box for the track:
   * ```
   * moov > trak > mdia > mdhd.timescale
   * moov > trak > mdia > hdlr
   * ```
   * @param init {Uint8Array} the bytes of the init segment
   * @return {object} a hash of track type to timescale values or null if
   * the init segment is malformed.
   */


  MP4Demuxer.parseInitSegment = function parseInitSegment(initSegment) {
    var result = [];
    var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);

    traks.forEach(function (trak) {
      var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
      if (tkhd) {
        var version = tkhd.data[tkhd.start];
        var index = version === 0 ? 12 : 20;
        var trackId = MP4Demuxer.readUint32(tkhd, index);

        var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
        if (mdhd) {
          version = mdhd.data[mdhd.start];
          index = version === 0 ? 12 : 20;
          var timescale = MP4Demuxer.readUint32(mdhd, index);

          var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
          if (hdlr) {
            var hdlrType = MP4Demuxer.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
            var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
            if (type) {
              // extract codec info. TODO : parse codec details to be able to build MIME type
              var codecBox = MP4Demuxer.findBox(trak, ['mdia', 'minf', 'stbl', 'stsd']);
              if (codecBox.length) {
                codecBox = codecBox[0];
                var codecType = MP4Demuxer.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                logger["b" /* logger */].log('MP4Demuxer:' + type + ':' + codecType + ' found');
              }
              result[trackId] = { timescale: timescale, type: type };
              result[type] = { timescale: timescale, id: trackId };
            }
          }
        }
      }
    });
    return result;
  };

  /**
   * Determine the base media decode start time, in seconds, for an MP4
   * fragment. If multiple fragments are specified, the earliest time is
   * returned.
   *
   * The base media decode time can be parsed from track fragment
   * metadata:
   * ```
   * moof > traf > tfdt.baseMediaDecodeTime
   * ```
   * It requires the timescale value from the mdhd to interpret.
   *
   * @param timescale {object} a hash of track ids to timescale values.
   * @return {number} the earliest base media decode start time for the
   * fragment, in seconds
   */


  MP4Demuxer.getStartDTS = function getStartDTS(initData, fragment) {
    var trafs, baseTimes, result;

    // we need info from two childrend of each track fragment box
    trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);

    // determine the start times for each track
    baseTimes = [].concat.apply([], trafs.map(function (traf) {
      return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
        var id, scale, baseTime;

        // get the track id from the tfhd
        id = MP4Demuxer.readUint32(tfhd, 4);
        // assume a 90kHz clock if no timescale was specified
        scale = initData[id].timescale || 90e3;

        // get the base media decode time from the tfdt
        baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
          var version, result;

          version = tfdt.data[tfdt.start];
          result = MP4Demuxer.readUint32(tfdt, 4);
          if (version === 1) {
            result *= Math.pow(2, 32);

            result += MP4Demuxer.readUint32(tfdt, 8);
          }
          return result;
        })[0];
        // convert base time to seconds
        return baseTime / scale;
      });
    }));

    // return the minimum
    result = Math.min.apply(null, baseTimes);
    return isFinite(result) ? result : 0;
  };

  MP4Demuxer.offsetStartDTS = function offsetStartDTS(initData, fragment, timeOffset) {
    MP4Demuxer.findBox(fragment, ['moof', 'traf']).map(function (traf) {
      return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
        // get the track id from the tfhd
        var id = MP4Demuxer.readUint32(tfhd, 4);
        // assume a 90kHz clock if no timescale was specified
        var timescale = initData[id].timescale || 90e3;

        // get the base media decode time from the tfdt
        MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
          var version = tfdt.data[tfdt.start];
          var baseMediaDecodeTime = MP4Demuxer.readUint32(tfdt, 4);
          if (version === 0) {
            MP4Demuxer.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
          } else {
            baseMediaDecodeTime *= Math.pow(2, 32);
            baseMediaDecodeTime += MP4Demuxer.readUint32(tfdt, 8);
            baseMediaDecodeTime -= timeOffset * timescale;
            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
            var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
            var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
            MP4Demuxer.writeUint32(tfdt, 4, upper);
            MP4Demuxer.writeUint32(tfdt, 8, lower);
          }
        });
      });
    });
  };

  // feed incoming data to the front of the parsing pipeline


  MP4Demuxer.prototype.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
    var initData = this.initData;
    if (!initData) {
      this.resetInitSegment(data, this.audioCodec, this.videoCodec);
      initData = this.initData;
    }
    var startDTS = void 0,
        initPTS = this.initPTS;
    if (initPTS === undefined) {
      var _startDTS = MP4Demuxer.getStartDTS(initData, data);
      this.initPTS = initPTS = _startDTS - timeOffset;
      this.observer.trigger(events["a" /* default */].INIT_PTS_FOUND, { initPTS: initPTS });
    }
    MP4Demuxer.offsetStartDTS(initData, data, initPTS);
    startDTS = MP4Demuxer.getStartDTS(initData, data);
    this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
  };

  MP4Demuxer.prototype.destroy = function destroy() {};

  return MP4Demuxer;
}();

/* harmony default export */ var mp4demuxer = (mp4demuxer_MP4Demuxer);
// CONCATENATED MODULE: ./src/demux/mpegaudio.js
/**
 *  MPEG parser helper
 */

var MpegAudio = {

    BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],

    SamplingRateMap: [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000],

    SamplesCoefficients: [
    // MPEG 2.5
    [0, // Reserved
    72, // Layer3
    144, // Layer2
    12 // Layer1
    ],
    // Reserved
    [0, // Reserved
    0, // Layer3
    0, // Layer2
    0 // Layer1
    ],
    // MPEG 2
    [0, // Reserved
    72, // Layer3
    144, // Layer2
    12 // Layer1
    ],
    // MPEG 1
    [0, // Reserved
    144, // Layer3
    144, // Layer2
    12 // Layer1
    ]],

    BytesInSlot: [0, // Reserved
    1, // Layer3
    1, // Layer2
    4 // Layer1
    ],

    appendFrame: function appendFrame(track, data, offset, pts, frameIndex) {
        // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
        if (offset + 24 > data.length) {
            return undefined;
        }

        var header = this.parseHeader(data, offset);
        if (header && offset + header.frameLength <= data.length) {
            var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
            var stamp = pts + frameIndex * frameDuration;
            var sample = { unit: data.subarray(offset, offset + header.frameLength), pts: stamp, dts: stamp };

            track.config = [];
            track.channelCount = header.channelCount;
            track.samplerate = header.sampleRate;
            track.samples.push(sample);
            track.len += header.frameLength;

            return { sample: sample, length: header.frameLength };
        }

        return undefined;
    },

    parseHeader: function parseHeader(data, offset) {
        var headerB = data[offset + 1] >> 3 & 3;
        var headerC = data[offset + 1] >> 1 & 3;
        var headerE = data[offset + 2] >> 4 & 15;
        var headerF = data[offset + 2] >> 2 & 3;
        var headerG = data[offset + 2] >> 1 & 1;
        if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
            var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
            var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
            var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
            var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
            var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
            var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
            var bytesInSlot = MpegAudio.BytesInSlot[headerC];
            var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
            var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;

            return { sampleRate: sampleRate, channelCount: channelCount, frameLength: frameLength, samplesPerFrame: samplesPerFrame };
        }

        return undefined;
    },

    isHeaderPattern: function isHeaderPattern(data, offset) {
        return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;
    },

    isHeader: function isHeader(data, offset) {
        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
        // More info http://www.mp3-tech.org/programmer/frame_header.html
        if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
            return true;
        }
        return false;
    },

    probe: function probe(data, offset) {
        // same as isHeader but we also check that MPEG frame follows last MPEG frame
        // or end of data is reached
        if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
            // MPEG header Length
            var headerLength = 4;
            // MPEG frame Length
            var header = this.parseHeader(data, offset);
            var frameLength = headerLength;
            if (header && header.frameLength) {
                frameLength = header.frameLength;
            }
            var newOffset = offset + frameLength;
            if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) {
                return true;
            }
        }
        return false;
    }
};

/* harmony default export */ var mpegaudio = (MpegAudio);
// CONCATENATED MODULE: ./src/demux/exp-golomb.js
function exp_golomb__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
*/



var exp_golomb_ExpGolomb = function () {
  function ExpGolomb(data) {
    exp_golomb__classCallCheck(this, ExpGolomb);

    this.data = data;
    // the number of bytes left to examine in this.data
    this.bytesAvailable = data.byteLength;
    // the current word being examined
    this.word = 0; // :uint
    // the number of bits left to examine in the current word
    this.bitsAvailable = 0; // :uint
  }

  // ():void


  ExpGolomb.prototype.loadWord = function loadWord() {
    var data = this.data,
        bytesAvailable = this.bytesAvailable,
        position = data.byteLength - bytesAvailable,
        workingBytes = new Uint8Array(4),
        availableBytes = Math.min(4, bytesAvailable);
    if (availableBytes === 0) {
      throw new Error('no bytes available');
    }
    workingBytes.set(data.subarray(position, position + availableBytes));
    this.word = new DataView(workingBytes.buffer).getUint32(0);
    // track the amount of this.data that has been processed
    this.bitsAvailable = availableBytes * 8;
    this.bytesAvailable -= availableBytes;
  };

  // (count:int):void


  ExpGolomb.prototype.skipBits = function skipBits(count) {
    var skipBytes; // :int
    if (this.bitsAvailable > count) {
      this.word <<= count;
      this.bitsAvailable -= count;
    } else {
      count -= this.bitsAvailable;
      skipBytes = count >> 3;
      count -= skipBytes >> 3;
      this.bytesAvailable -= skipBytes;
      this.loadWord();
      this.word <<= count;
      this.bitsAvailable -= count;
    }
  };

  // (size:int):uint


  ExpGolomb.prototype.readBits = function readBits(size) {
    var bits = Math.min(this.bitsAvailable, size),
        // :uint
    valu = this.word >>> 32 - bits; // :uint
    if (size > 32) {
      logger["b" /* logger */].error('Cannot read more than 32 bits at a time');
    }
    this.bitsAvailable -= bits;
    if (this.bitsAvailable > 0) {
      this.word <<= bits;
    } else if (this.bytesAvailable > 0) {
      this.loadWord();
    }
    bits = size - bits;
    if (bits > 0 && this.bitsAvailable) {
      return valu << bits | this.readBits(bits);
    } else {
      return valu;
    }
  };

  // ():uint


  ExpGolomb.prototype.skipLZ = function skipLZ() {
    var leadingZeroCount; // :uint
    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
      if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
        // the first bit of working word is 1
        this.word <<= leadingZeroCount;
        this.bitsAvailable -= leadingZeroCount;
        return leadingZeroCount;
      }
    }
    // we exhausted word and still have not found a 1
    this.loadWord();
    return leadingZeroCount + this.skipLZ();
  };

  // ():void


  ExpGolomb.prototype.skipUEG = function skipUEG() {
    this.skipBits(1 + this.skipLZ());
  };

  // ():void


  ExpGolomb.prototype.skipEG = function skipEG() {
    this.skipBits(1 + this.skipLZ());
  };

  // ():uint


  ExpGolomb.prototype.readUEG = function readUEG() {
    var clz = this.skipLZ(); // :uint
    return this.readBits(clz + 1) - 1;
  };

  // ():int


  ExpGolomb.prototype.readEG = function readEG() {
    var valu = this.readUEG(); // :int
    if (0x01 & valu) {
      // the number is odd if the low order bit is set
      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
    } else {
      return -1 * (valu >>> 1); // divide by two then make it negative
    }
  };

  // Some convenience functions
  // :Boolean


  ExpGolomb.prototype.readBoolean = function readBoolean() {
    return 1 === this.readBits(1);
  };

  // ():int


  ExpGolomb.prototype.readUByte = function readUByte() {
    return this.readBits(8);
  };

  // ():int


  ExpGolomb.prototype.readUShort = function readUShort() {
    return this.readBits(16);
  };
  // ():int


  ExpGolomb.prototype.readUInt = function readUInt() {
    return this.readBits(32);
  };

  /**
   * Advance the ExpGolomb decoder past a scaling list. The scaling
   * list is optionally transmitted as part of a sequence parameter
   * set and is not relevant to transmuxing.
   * @param count {number} the number of entries in this scaling list
   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
   */


  ExpGolomb.prototype.skipScalingList = function skipScalingList(count) {
    var lastScale = 8,
        nextScale = 8,
        j,
        deltaScale;
    for (j = 0; j < count; j++) {
      if (nextScale !== 0) {
        deltaScale = this.readEG();
        nextScale = (lastScale + deltaScale + 256) % 256;
      }
      lastScale = nextScale === 0 ? lastScale : nextScale;
    }
  };

  /**
   * Read a sequence parameter set and return some interesting video
   * properties. A sequence parameter set is the H264 metadata that
   * describes the properties of upcoming video frames.
   * @param data {Uint8Array} the bytes of a sequence parameter set
   * @return {object} an object with configuration parsed from the
   * sequence parameter set, including the dimensions of the
   * associated video frames.
   */


  ExpGolomb.prototype.readSPS = function readSPS() {
    var frameCropLeftOffset = 0,
        frameCropRightOffset = 0,
        frameCropTopOffset = 0,
        frameCropBottomOffset = 0,
        profileIdc,
        profileCompat,
        levelIdc,
        numRefFramesInPicOrderCntCycle,
        picWidthInMbsMinus1,
        picHeightInMapUnitsMinus1,
        frameMbsOnlyFlag,
        scalingListCount,
        i,
        readUByte = this.readUByte.bind(this),
        readBits = this.readBits.bind(this),
        readUEG = this.readUEG.bind(this),
        readBoolean = this.readBoolean.bind(this),
        skipBits = this.skipBits.bind(this),
        skipEG = this.skipEG.bind(this),
        skipUEG = this.skipUEG.bind(this),
        skipScalingList = this.skipScalingList.bind(this);

    readUByte();
    profileIdc = readUByte(); // profile_idc
    profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
    skipBits(3); // reserved_zero_3bits u(3),
    levelIdc = readUByte(); //level_idc u(8)
    skipUEG(); // seq_parameter_set_id
    // some profiles have more optional data we don't need
    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
      var chromaFormatIdc = readUEG();
      if (chromaFormatIdc === 3) {
        skipBits(1); // separate_colour_plane_flag
      }
      skipUEG(); // bit_depth_luma_minus8
      skipUEG(); // bit_depth_chroma_minus8
      skipBits(1); // qpprime_y_zero_transform_bypass_flag
      if (readBoolean()) {
        // seq_scaling_matrix_present_flag
        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
        for (i = 0; i < scalingListCount; i++) {
          if (readBoolean()) {
            // seq_scaling_list_present_flag[ i ]
            if (i < 6) {
              skipScalingList(16);
            } else {
              skipScalingList(64);
            }
          }
        }
      }
    }
    skipUEG(); // log2_max_frame_num_minus4
    var picOrderCntType = readUEG();
    if (picOrderCntType === 0) {
      readUEG(); //log2_max_pic_order_cnt_lsb_minus4
    } else if (picOrderCntType === 1) {
      skipBits(1); // delta_pic_order_always_zero_flag
      skipEG(); // offset_for_non_ref_pic
      skipEG(); // offset_for_top_to_bottom_field
      numRefFramesInPicOrderCntCycle = readUEG();
      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
        skipEG(); // offset_for_ref_frame[ i ]
      }
    }
    skipUEG(); // max_num_ref_frames
    skipBits(1); // gaps_in_frame_num_value_allowed_flag
    picWidthInMbsMinus1 = readUEG();
    picHeightInMapUnitsMinus1 = readUEG();
    frameMbsOnlyFlag = readBits(1);
    if (frameMbsOnlyFlag === 0) {
      skipBits(1); // mb_adaptive_frame_field_flag
    }
    skipBits(1); // direct_8x8_inference_flag
    if (readBoolean()) {
      // frame_cropping_flag
      frameCropLeftOffset = readUEG();
      frameCropRightOffset = readUEG();
      frameCropTopOffset = readUEG();
      frameCropBottomOffset = readUEG();
    }
    var pixelRatio = [1, 1];
    if (readBoolean()) {
      // vui_parameters_present_flag
      if (readBoolean()) {
        // aspect_ratio_info_present_flag
        var aspectRatioIdc = readUByte();
        switch (aspectRatioIdc) {
          case 1:
            pixelRatio = [1, 1];break;
          case 2:
            pixelRatio = [12, 11];break;
          case 3:
            pixelRatio = [10, 11];break;
          case 4:
            pixelRatio = [16, 11];break;
          case 5:
            pixelRatio = [40, 33];break;
          case 6:
            pixelRatio = [24, 11];break;
          case 7:
            pixelRatio = [20, 11];break;
          case 8:
            pixelRatio = [32, 11];break;
          case 9:
            pixelRatio = [80, 33];break;
          case 10:
            pixelRatio = [18, 11];break;
          case 11:
            pixelRatio = [15, 11];break;
          case 12:
            pixelRatio = [64, 33];break;
          case 13:
            pixelRatio = [160, 99];break;
          case 14:
            pixelRatio = [4, 3];break;
          case 15:
            pixelRatio = [3, 2];break;
          case 16:
            pixelRatio = [2, 1];break;
          case 255:
            {
              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
              break;
            }
        }
      }
    }
    return {
      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
      pixelRatio: pixelRatio
    };
  };

  ExpGolomb.prototype.readSliceType = function readSliceType() {
    // skip NALu type
    this.readUByte();
    // discard first_mb_in_slice
    this.readUEG();
    // return slice_type
    return this.readUEG();
  };

  return ExpGolomb;
}();

/* harmony default export */ var exp_golomb = (exp_golomb_ExpGolomb);
// CONCATENATED MODULE: ./src/demux/sample-aes.js
function sample_aes__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * SAMPLE-AES decrypter
*/



var sample_aes_SampleAesDecrypter = function () {
  function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
    sample_aes__classCallCheck(this, SampleAesDecrypter);

    this.decryptdata = decryptdata;
    this.discardEPB = discardEPB;
    this.decrypter = new crypt_decrypter["a" /* default */](observer, config);
  }

  SampleAesDecrypter.prototype.decryptBuffer = function decryptBuffer(encryptedData, callback) {
    this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
  };

  // AAC - encrypt all full 16 bytes blocks starting from offset 16


  SampleAesDecrypter.prototype.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback, sync) {
    var curUnit = samples[sampleIndex].unit;
    var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
    var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);

    var localthis = this;
    this.decryptBuffer(encryptedBuffer, function (decryptedData) {
      decryptedData = new Uint8Array(decryptedData);
      curUnit.set(decryptedData, 16);

      if (!sync) {
        localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
      }
    });
  };

  SampleAesDecrypter.prototype.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
    for (;; sampleIndex++) {
      if (sampleIndex >= samples.length) {
        callback();
        return;
      }

      if (samples[sampleIndex].unit.length < 32) {
        continue;
      }

      var sync = this.decrypter.isSync();

      this.decryptAacSample(samples, sampleIndex, callback, sync);

      if (!sync) {
        return;
      }
    }
  };

  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32


  SampleAesDecrypter.prototype.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
    var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
    var encryptedData = new Int8Array(encryptedDataLen);
    var outputPos = 0;
    for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
    }
    return encryptedData;
  };

  SampleAesDecrypter.prototype.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
    decryptedData = new Uint8Array(decryptedData);
    var inputPos = 0;
    for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
      decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
    }
    return decodedData;
  };

  SampleAesDecrypter.prototype.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
    var decodedData = this.discardEPB(curUnit.data);
    var encryptedData = this.getAvcEncryptedData(decodedData);
    var localthis = this;

    this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
      curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);

      if (!sync) {
        localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
      }
    });
  };

  SampleAesDecrypter.prototype.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
    for (;; sampleIndex++, unitIndex = 0) {
      if (sampleIndex >= samples.length) {
        callback();
        return;
      }

      var curUnits = samples[sampleIndex].units;
      for (;; unitIndex++) {
        if (unitIndex >= curUnits.length) {
          break;
        }

        var curUnit = curUnits[unitIndex];
        if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
          continue;
        }

        var sync = this.decrypter.isSync();

        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);

        if (!sync) {
          return;
        }
      }
    }
  };

  return SampleAesDecrypter;
}();

/* harmony default export */ var sample_aes = (sample_aes_SampleAesDecrypter);
// CONCATENATED MODULE: ./src/demux/tsdemuxer.js
function tsdemuxer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * highly optimized TS demuxer:
 * parse PAT, PMT
 * extract PES packet from audio and video PIDs
 * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
 * trigger the remuxer upon parsing completion
 * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
 * it also controls the remuxing process :
 * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
*/






// import Hex from '../utils/hex';



// We are using fixed track IDs for driving the MP4 remuxer
// instead of following the TS PIDs.
// There is no reason not to do this and some browsers/SourceBuffer-demuxers
// may not like if there are TrackID "switches"
// See https://github.com/video-dev/hls.js/issues/1331
// Here we are mapping our internal track types to constant MP4 track IDs
// With MSE currently one can only have one track of each, and we are muxing
// whatever video/audio rendition in them.
var RemuxerTrackIdConfig = {
  video: 0,
  audio: 1,
  id3: 2,
  text: 3
};

var tsdemuxer_TSDemuxer = function () {
  function TSDemuxer(observer, remuxer, config, typeSupported) {
    tsdemuxer__classCallCheck(this, TSDemuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.remuxer = remuxer;
    this.sampleAes = null;
  }

  TSDemuxer.prototype.setDecryptData = function setDecryptData(decryptdata) {
    if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
      this.sampleAes = new sample_aes(this.observer, this.config, decryptdata, this.discardEPB);
    } else {
      this.sampleAes = null;
    }
  };

  TSDemuxer.probe = function probe(data) {
    var syncOffset = TSDemuxer._syncOffset(data);
    if (syncOffset < 0) {
      return false;
    } else {
      if (syncOffset) {
        logger["b" /* logger */].warn('MPEG2-TS detected but first sync word found @ offset ' + syncOffset + ', junk ahead ?');
      }
      return true;
    }
  };

  TSDemuxer._syncOffset = function _syncOffset(data) {
    // scan 1000 first bytes
    var scanwindow = Math.min(1000, data.length - 3 * 188);
    var i = 0;
    while (i < scanwindow) {
      // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
      if (data[i] === 0x47 && data[i + 188] === 0x47 && data[i + 2 * 188] === 0x47) {
        return i;
      } else {
        i++;
      }
    }
    return -1;
  };

  /**
   * Creates a track model internal to demuxer used to drive remuxing input
   *
   * @param {string} type 'audio' | 'video' | 'id3' | 'text'
   * @param {number} duration
   * @return {object} TSDemuxer's internal track model
   */


  TSDemuxer.createTrack = function createTrack(type, duration) {
    return {
      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,
      type: type,
      id: RemuxerTrackIdConfig[type],
      pid: -1,
      inputTimeScale: 90000,
      sequenceNumber: 0,
      samples: [],
      len: 0,
      dropped: type === 'video' ? 0 : undefined,
      isAAC: type === 'audio' ? true : undefined,
      duration: type === 'audio' ? duration : undefined
    };
  };

  /**
   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)
   * Resets all internal track instances of the demuxer.
   *
   * @override Implements generic demuxing/remuxing interface (see DemuxerInline)
   * @param {object} initSegment
   * @param {string} audioCodec
   * @param {string} videoCodec
   * @param {number} duration (in TS timescale = 90kHz)
   */


  TSDemuxer.prototype.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
    this.pmtParsed = false;
    this._pmtId = -1;

    this._avcTrack = TSDemuxer.createTrack('video', duration);
    this._audioTrack = TSDemuxer.createTrack('audio', duration);
    this._id3Track = TSDemuxer.createTrack('id3', duration);
    this._txtTrack = TSDemuxer.createTrack('text', duration);

    // flush any partial content
    this.aacOverFlow = null;
    this.aacLastPTS = null;
    this.avcSample = null;
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this._duration = duration;
  };

  /**
   *
   * @override
   */


  TSDemuxer.prototype.resetTimeStamp = function resetTimeStamp() {};

  // feed incoming data to the front of the parsing pipeline


  TSDemuxer.prototype.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
    var start,
        len = data.length,
        stt,
        pid,
        atf,
        offset,
        pes,
        unknownPIDs = false;
    this.contiguous = contiguous;
    var pmtParsed = this.pmtParsed,
        avcTrack = this._avcTrack,
        audioTrack = this._audioTrack,
        id3Track = this._id3Track,
        avcId = avcTrack.pid,
        audioId = audioTrack.pid,
        id3Id = id3Track.pid,
        pmtId = this._pmtId,
        avcData = avcTrack.pesData,
        audioData = audioTrack.pesData,
        id3Data = id3Track.pesData,
        parsePAT = this._parsePAT,
        parsePMT = this._parsePMT,
        parsePES = this._parsePES,
        parseAVCPES = this._parseAVCPES.bind(this),
        parseAACPES = this._parseAACPES.bind(this),
        parseMPEGPES = this._parseMPEGPES.bind(this),
        parseID3PES = this._parseID3PES.bind(this);

    var syncOffset = TSDemuxer._syncOffset(data);

    // don't parse last TS packet if incomplete
    len -= (len + syncOffset) % 188;

    // loop through TS packets
    for (start = syncOffset; start < len; start += 188) {
      if (data[start] === 0x47) {
        stt = !!(data[start + 1] & 0x40);
        // pid is a 13-bit field starting at the last bit of TS[1]
        pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
        atf = (data[start + 3] & 0x30) >> 4;
        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
        if (atf > 1) {
          offset = start + 5 + data[start + 4];
          // continue if there is only adaptation field
          if (offset === start + 188) {
            continue;
          }
        } else {
          offset = start + 4;
        }
        switch (pid) {
          case avcId:
            if (stt) {
              if (avcData && (pes = parsePES(avcData))) {
                parseAVCPES(pes, false);
              }
              avcData = { data: [], size: 0 };
            }
            if (avcData) {
              avcData.data.push(data.subarray(offset, start + 188));
              avcData.size += start + 188 - offset;
            }
            break;
          case audioId:
            if (stt) {
              if (audioData && (pes = parsePES(audioData))) {
                if (audioTrack.isAAC) {
                  parseAACPES(pes);
                } else {
                  parseMPEGPES(pes);
                }
              }
              audioData = { data: [], size: 0 };
            }
            if (audioData) {
              audioData.data.push(data.subarray(offset, start + 188));
              audioData.size += start + 188 - offset;
            }
            break;
          case id3Id:
            if (stt) {
              if (id3Data && (pes = parsePES(id3Data))) {
                parseID3PES(pes);
              }
              id3Data = { data: [], size: 0 };
            }
            if (id3Data) {
              id3Data.data.push(data.subarray(offset, start + 188));
              id3Data.size += start + 188 - offset;
            }
            break;
          case 0:
            if (stt) {
              offset += data[offset] + 1;
            }
            pmtId = this._pmtId = parsePAT(data, offset);
            break;
          case pmtId:
            if (stt) {
              offset += data[offset] + 1;
            }
            var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);

            // only update track id if track PID found while parsing PMT
            // this is to avoid resetting the PID to -1 in case
            // track PID transiently disappears from the stream
            // this could happen in case of transient missing audio samples for example
            // NOTE this is only the PID of the track as found in TS,
            // but we are not using this for MP4 track IDs.
            avcId = parsedPIDs.avc;
            if (avcId > 0) {
              avcTrack.pid = avcId;
            }
            audioId = parsedPIDs.audio;
            if (audioId > 0) {
              audioTrack.pid = audioId;
              audioTrack.isAAC = parsedPIDs.isAAC;
            }
            id3Id = parsedPIDs.id3;
            if (id3Id > 0) {
              id3Track.pid = id3Id;
            }
            if (unknownPIDs && !pmtParsed) {
              logger["b" /* logger */].log('reparse from beginning');
              unknownPIDs = false;
              // we set it to -188, the += 188 in the for loop will reset start to 0
              start = syncOffset - 188;
            }
            pmtParsed = this.pmtParsed = true;
            break;
          case 17:
          case 0x1fff:
            break;
          default:
            unknownPIDs = true;
            break;
        }
      } else {
        this.observer.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
      }
    }
    // try to parse last PES packets
    if (avcData && (pes = parsePES(avcData))) {
      parseAVCPES(pes, true);
      avcTrack.pesData = null;
    } else {
      // either avcData null or PES truncated, keep it for next frag parsing
      avcTrack.pesData = avcData;
    }

    if (audioData && (pes = parsePES(audioData))) {
      if (audioTrack.isAAC) {
        parseAACPES(pes);
      } else {
        parseMPEGPES(pes);
      }
      audioTrack.pesData = null;
    } else {
      if (audioData && audioData.size) {
        logger["b" /* logger */].log('last AAC PES packet truncated,might overlap between fragments');
      }
      // either audioData null or PES truncated, keep it for next frag parsing
      audioTrack.pesData = audioData;
    }

    if (id3Data && (pes = parsePES(id3Data))) {
      parseID3PES(pes);
      id3Track.pesData = null;
    } else {
      // either id3Data null or PES truncated, keep it for next frag parsing
      id3Track.pesData = id3Data;
    }

    if (this.sampleAes == null) {
      this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
    } else {
      this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
    }
  };

  TSDemuxer.prototype.decryptAndRemux = function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
    if (audioTrack.samples && audioTrack.isAAC) {
      var localthis = this;
      this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
        localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      });
    } else {
      this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
    }
  };

  TSDemuxer.prototype.decryptAndRemuxAvc = function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
    if (videoTrack.samples) {
      var localthis = this;
      this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
        localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
      });
    } else {
      this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
    }
  };

  TSDemuxer.prototype.destroy = function destroy() {
    this._initPTS = this._initDTS = undefined;
    this._duration = 0;
  };

  TSDemuxer.prototype._parsePAT = function _parsePAT(data, offset) {
    // skip the PSI header and parse the first PMT entry
    return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
    //logger.log('PMT PID:'  + this._pmtId);
  };

  TSDemuxer.prototype._parsePMT = function _parsePMT(data, offset, mpegSupported, isSampleAes) {
    var sectionLength,
        tableEnd,
        programInfoLength,
        pid,
        result = { audio: -1, avc: -1, id3: -1, isAAC: true };
    sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
    tableEnd = offset + 3 + sectionLength - 4;
    // to determine where the table is, we have to figure out how
    // long the program info descriptors are
    programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
    // advance the offset to the first entry in the mapping table
    offset += 12 + programInfoLength;
    while (offset < tableEnd) {
      pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
      switch (data[offset]) {
        case 0xcf:
          // SAMPLE-AES AAC
          if (!isSampleAes) {
            logger["b" /* logger */].log('unkown stream type:' + data[offset]);
            break;
          }
        /* falls through */

        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
        case 0x0f:
          //logger.log('AAC PID:'  + pid);
          if (result.audio === -1) {
            result.audio = pid;
          }
          break;

        // Packetized metadata (ID3)
        case 0x15:
          //logger.log('ID3 PID:'  + pid);
          if (result.id3 === -1) {
            result.id3 = pid;
          }
          break;

        case 0xdb:
          // SAMPLE-AES AVC
          if (!isSampleAes) {
            logger["b" /* logger */].log('unkown stream type:' + data[offset]);
            break;
          }
        /* falls through */

        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
        case 0x1b:
          //logger.log('AVC PID:'  + pid);
          if (result.avc === -1) {
            result.avc = pid;
          }
          break;

        // ISO/IEC 11172-3 (MPEG-1 audio)
        // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
        case 0x03:
        case 0x04:
          //logger.log('MPEG PID:'  + pid);
          if (!mpegSupported) {
            logger["b" /* logger */].log('MPEG audio found, not supported in this browser for now');
          } else if (result.audio === -1) {
            result.audio = pid;
            result.isAAC = false;
          }
          break;

        case 0x24:
          logger["b" /* logger */].warn('HEVC stream type found, not supported for now');
          break;

        default:
          logger["b" /* logger */].log('unkown stream type:' + data[offset]);
          break;
      }
      // move to the next table entry
      // skip past the elementary stream descriptors, if present
      offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
    }
    return result;
  };

  TSDemuxer.prototype._parsePES = function _parsePES(stream) {
    var i = 0,
        frag,
        pesFlags,
        pesPrefix,
        pesLen,
        pesHdrLen,
        pesData,
        pesPts,
        pesDts,
        payloadStartOffset,
        data = stream.data;
    // safety check
    if (!stream || stream.size === 0) {
      return null;
    }

    // we might need up to 19 bytes to read PES header
    // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
    // usually only one merge is needed (and this is rare ...)
    while (data[0].length < 19 && data.length > 1) {
      var newData = new Uint8Array(data[0].length + data[1].length);
      newData.set(data[0]);
      newData.set(data[1], data[0].length);
      data[0] = newData;
      data.splice(1, 1);
    }
    //retrieve PTS/DTS from first fragment
    frag = data[0];
    pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
    if (pesPrefix === 1) {
      pesLen = (frag[4] << 8) + frag[5];
      // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
      // minus 6 : PES header size
      if (pesLen && pesLen > stream.size - 6) {
        return null;
      }
      pesFlags = frag[7];
      if (pesFlags & 0xC0) {
        /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
            as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
            as Bitwise operators treat their operands as a sequence of 32 bits */
        pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
        (frag[10] & 0xFF) * 4194304 + // 1 << 22
        (frag[11] & 0xFE) * 16384 + // 1 << 14
        (frag[12] & 0xFF) * 128 + // 1 << 7
        (frag[13] & 0xFE) / 2;
        // check if greater than 2^32 -1
        if (pesPts > 4294967295) {
          // decrement 2^33
          pesPts -= 8589934592;
        }
        if (pesFlags & 0x40) {
          pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
          (frag[15] & 0xFF) * 4194304 + // 1 << 22
          (frag[16] & 0xFE) * 16384 + // 1 << 14
          (frag[17] & 0xFF) * 128 + // 1 << 7
          (frag[18] & 0xFE) / 2;
          // check if greater than 2^32 -1
          if (pesDts > 4294967295) {
            // decrement 2^33
            pesDts -= 8589934592;
          }
          if (pesPts - pesDts > 60 * 90000) {
            logger["b" /* logger */].warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
            pesPts = pesDts;
          }
        } else {
          pesDts = pesPts;
        }
      }
      pesHdrLen = frag[8];
      // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
      payloadStartOffset = pesHdrLen + 9;

      stream.size -= payloadStartOffset;
      //reassemble PES packet
      pesData = new Uint8Array(stream.size);
      for (var j = 0, dataLen = data.length; j < dataLen; j++) {
        frag = data[j];
        var len = frag.byteLength;
        if (payloadStartOffset) {
          if (payloadStartOffset > len) {
            // trim full frag if PES header bigger than frag
            payloadStartOffset -= len;
            continue;
          } else {
            // trim partial frag if PES header smaller than frag
            frag = frag.subarray(payloadStartOffset);
            len -= payloadStartOffset;
            payloadStartOffset = 0;
          }
        }
        pesData.set(frag, i);
        i += len;
      }
      if (pesLen) {
        // payload size : remove PES header + PES extension
        pesLen -= pesHdrLen + 3;
      }
      return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
    } else {
      return null;
    }
  };

  TSDemuxer.prototype.pushAccesUnit = function pushAccesUnit(avcSample, avcTrack) {
    if (avcSample.units.length && avcSample.frame) {
      var samples = avcTrack.samples;
      var nbSamples = samples.length;
      // only push AVC sample if starting with a keyframe is not mandatory OR
      //    if keyframe already found in this fragment OR
      //       keyframe found in last fragment (track.sps) AND
      //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
      if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
        avcSample.id = nbSamples;
        samples.push(avcSample);
      } else {
        // dropped samples, track it
        avcTrack.dropped++;
      }
    }
    if (avcSample.debug.length) {
      logger["b" /* logger */].log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
    }
  };

  TSDemuxer.prototype._parseAVCPES = function _parseAVCPES(pes, last) {
    var _this = this;

    //logger.log('parse new PES');
    var track = this._avcTrack,
        units = this._parseAVCNALu(pes.data),
        debug = false,
        expGolombDecoder,
        avcSample = this.avcSample,
        push,
        spsfound = false,
        i,
        pushAccesUnit = this.pushAccesUnit.bind(this),
        createAVCSample = function createAVCSample(key, pts, dts, debug) {
      return { key: key, pts: pts, dts: dts, units: [], debug: debug };
    };
    //free pes.data to save up some memory
    pes.data = null;

    // if new NAL units found and last sample still there, let's push ...
    // this helps parsing streams with missing AUD (only do this if AUD never found)
    if (avcSample && units.length && !track.audFound) {
      pushAccesUnit(avcSample, track);
      avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, '');
    }

    units.forEach(function (unit) {
      switch (unit.type) {
        //NDR
        case 1:
          push = true;
          if (!avcSample) {
            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
          }
          if (debug) {
            avcSample.debug += 'NDR ';
          }
          avcSample.frame = true;
          var data = unit.data;
          // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)
          if (spsfound && data.length > 4) {
            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
            var sliceType = new exp_golomb(data).readSliceType();
            // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
            // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
            // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
            // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
            //if (sliceType === 2 || sliceType === 7) {
            if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
              avcSample.key = true;
            }
          }
          break;
        //IDR
        case 5:
          push = true;
          // handle PES not starting with AUD
          if (!avcSample) {
            avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, '');
          }
          if (debug) {
            avcSample.debug += 'IDR ';
          }
          avcSample.key = true;
          avcSample.frame = true;
          break;
        //SEI
        case 6:
          push = true;
          if (debug && avcSample) {
            avcSample.debug += 'SEI ';
          }
          expGolombDecoder = new exp_golomb(_this.discardEPB(unit.data));

          // skip frameType
          expGolombDecoder.readUByte();

          var payloadType = 0;
          var payloadSize = 0;
          var endOfCaptions = false;
          var b = 0;

          while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
            payloadType = 0;
            do {
              b = expGolombDecoder.readUByte();
              payloadType += b;
            } while (b === 0xFF);

            // Parse payload size.
            payloadSize = 0;
            do {
              b = expGolombDecoder.readUByte();
              payloadSize += b;
            } while (b === 0xFF);

            // TODO: there can be more than one payload in an SEI packet...
            // TODO: need to read type and size in a while loop to get them all
            if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {

              endOfCaptions = true;

              var countryCode = expGolombDecoder.readUByte();

              if (countryCode === 181) {
                var providerCode = expGolombDecoder.readUShort();

                if (providerCode === 49) {
                  var userStructure = expGolombDecoder.readUInt();

                  if (userStructure === 0x47413934) {
                    var userDataType = expGolombDecoder.readUByte();

                    // Raw CEA-608 bytes wrapped in CEA-708 packet
                    if (userDataType === 3) {
                      var firstByte = expGolombDecoder.readUByte();
                      var secondByte = expGolombDecoder.readUByte();

                      var totalCCs = 31 & firstByte;
                      var byteArray = [firstByte, secondByte];

                      for (i = 0; i < totalCCs; i++) {
                        // 3 bytes per CC
                        byteArray.push(expGolombDecoder.readUByte());
                        byteArray.push(expGolombDecoder.readUByte());
                        byteArray.push(expGolombDecoder.readUByte());
                      }

                      _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                    }
                  }
                }
              }
            } else if (payloadSize < expGolombDecoder.bytesAvailable) {
              for (i = 0; i < payloadSize; i++) {
                expGolombDecoder.readUByte();
              }
            }
          }
          break;
        //SPS
        case 7:
          push = true;
          spsfound = true;
          if (debug && avcSample) {
            avcSample.debug += 'SPS ';
          }
          if (!track.sps) {
            expGolombDecoder = new exp_golomb(unit.data);
            var config = expGolombDecoder.readSPS();
            track.width = config.width;
            track.height = config.height;
            track.pixelRatio = config.pixelRatio;
            track.sps = [unit.data];
            track.duration = _this._duration;
            var codecarray = unit.data.subarray(1, 4);
            var codecstring = 'avc1.';
            for (i = 0; i < 3; i++) {
              var h = codecarray[i].toString(16);
              if (h.length < 2) {
                h = '0' + h;
              }
              codecstring += h;
            }
            track.codec = codecstring;
          }
          break;
        //PPS
        case 8:
          push = true;
          if (debug && avcSample) {
            avcSample.debug += 'PPS ';
          }
          if (!track.pps) {
            track.pps = [unit.data];
          }
          break;
        // AUD
        case 9:
          push = false;
          track.audFound = true;
          if (avcSample) {
            pushAccesUnit(avcSample, track);
          }
          avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
          break;
        // Filler Data
        case 12:
          push = false;
          break;
        default:
          push = false;
          if (avcSample) {
            avcSample.debug += 'unknown NAL ' + unit.type + ' ';
          }
          break;
      }
      if (avcSample && push) {
        var _units = avcSample.units;
        _units.push(unit);
      }
    });
    // if last PES packet, push samples
    if (last && avcSample) {
      pushAccesUnit(avcSample, track);
      this.avcSample = null;
    }
  };

  TSDemuxer.prototype._insertSampleInOrder = function _insertSampleInOrder(arr, data) {
    var len = arr.length;
    if (len > 0) {
      if (data.pts >= arr[len - 1].pts) {
        arr.push(data);
      } else {
        for (var pos = len - 1; pos >= 0; pos--) {
          if (data.pts < arr[pos].pts) {
            arr.splice(pos, 0, data);
            break;
          }
        }
      }
    } else {
      arr.push(data);
    }
  };

  TSDemuxer.prototype._getLastNalUnit = function _getLastNalUnit() {
    var avcSample = this.avcSample,
        lastUnit = void 0;
    // try to fallback to previous sample if current one is empty
    if (!avcSample || avcSample.units.length === 0) {
      var track = this._avcTrack,
          samples = track.samples;
      avcSample = samples[samples.length - 1];
    }
    if (avcSample) {
      var units = avcSample.units;
      lastUnit = units[units.length - 1];
    }
    return lastUnit;
  };

  TSDemuxer.prototype._parseAVCNALu = function _parseAVCNALu(array) {
    var i = 0,
        len = array.byteLength,
        value,
        overflow,
        track = this._avcTrack,
        state = track.naluState || 0,
        lastState = state;
    var units = [],
        unit,
        unitType,
        lastUnitStart = -1,
        lastUnitType;
    //logger.log('PES:' + Hex.hexDump(array));

    if (state === -1) {
      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
      lastUnitStart = 0;
      // NALu type is value read from offset 0
      lastUnitType = array[0] & 0x1f;
      state = 0;
      i = 1;
    }

    while (i < len) {
      value = array[i++];
      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
      if (!state) {
        state = value ? 0 : 1;
        continue;
      }
      if (state === 1) {
        state = value ? 0 : 2;
        continue;
      }
      // here we have state either equal to 2 or 3
      if (!value) {
        state = 3;
      } else if (value === 1) {
        if (lastUnitStart >= 0) {
          unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
          //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
          units.push(unit);
        } else {
          // lastUnitStart is undefined => this is the first start code found in this PES packet
          // first check if start code delimiter is overlapping between 2 PES packets,
          // ie it started in last packet (lastState not zero)
          // and ended at the beginning of this PES packet (i <= 4 - lastState)
          var lastUnit = this._getLastNalUnit();
          if (lastUnit) {
            if (lastState && i <= 4 - lastState) {
              // start delimiter overlapping between PES packets
              // strip start delimiter bytes from the end of last NAL unit
              // check if lastUnit had a state different from zero
              if (lastUnit.state) {
                // strip last bytes
                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
              }
            }
            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
            overflow = i - state - 1;
            if (overflow > 0) {
              //logger.log('first NALU found with overflow:' + overflow);
              var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
              tmp.set(lastUnit.data, 0);
              tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
              lastUnit.data = tmp;
            }
          }
        }
        // check if we can read unit type
        if (i < len) {
          unitType = array[i] & 0x1f;
          //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
          lastUnitStart = i;
          lastUnitType = unitType;
          state = 0;
        } else {
          // not enough byte to read unit type. let's read it on next PES parsing
          state = -1;
        }
      } else {
        state = 0;
      }
    }
    if (lastUnitStart >= 0 && state >= 0) {
      unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
      units.push(unit);
      //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
    }
    // no NALu found
    if (units.length === 0) {
      // append pes.data to previous NAL unit
      var _lastUnit = this._getLastNalUnit();
      if (_lastUnit) {
        var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
        _tmp.set(_lastUnit.data, 0);
        _tmp.set(array, _lastUnit.data.byteLength);
        _lastUnit.data = _tmp;
      }
    }
    track.naluState = state;
    return units;
  };

  /**
   * remove Emulation Prevention bytes from a RBSP
   */


  TSDemuxer.prototype.discardEPB = function discardEPB(data) {
    var length = data.byteLength,
        EPBPositions = [],
        i = 1,
        newLength,
        newData;

    // Find all `Emulation Prevention Bytes`
    while (i < length - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
        EPBPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }

    // If no Emulation Prevention Bytes were found just return the original
    // array
    if (EPBPositions.length === 0) {
      return data;
    }

    // Create a new array to hold the NAL unit data
    newLength = length - EPBPositions.length;
    newData = new Uint8Array(newLength);
    var sourceIndex = 0;

    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === EPBPositions[0]) {
        // Skip this byte
        sourceIndex++;
        // Remove this position index
        EPBPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  };

  TSDemuxer.prototype._parseAACPES = function _parseAACPES(pes) {
    var track = this._audioTrack,
        data = pes.data,
        pts = pes.pts,
        startOffset = 0,
        aacOverFlow = this.aacOverFlow,
        aacLastPTS = this.aacLastPTS,
        frameDuration,
        frameIndex,
        offset,
        stamp,
        len;
    if (aacOverFlow) {
      var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
      tmp.set(aacOverFlow, 0);
      tmp.set(data, aacOverFlow.byteLength);
      //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
      data = tmp;
    }
    // look for ADTS header (0xFFFx)
    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
      if (isHeader(data, offset)) {
        break;
      }
    }
    // if ADTS header does not start straight from the beginning of the PES payload, raise an error
    if (offset) {
      var reason, fatal;
      if (offset < len - 1) {
        reason = 'AAC PES did not start with ADTS header,offset:' + offset;
        fatal = false;
      } else {
        reason = 'no ADTS header found in AAC PES';
        fatal = true;
      }
      logger["b" /* logger */].warn('parsing error:' + reason);
      this.observer.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
      if (fatal) {
        return;
      }
    }

    initTrackConfig(track, this.observer, data, offset, this.audioCodec);
    frameIndex = 0;
    frameDuration = getFrameDuration(track.samplerate);

    // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
    // first sample PTS should be equal to last sample PTS + frameDuration
    if (aacOverFlow && aacLastPTS) {
      var newPTS = aacLastPTS + frameDuration;
      if (Math.abs(newPTS - pts) > 1) {
        logger["b" /* logger */].log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
        pts = newPTS;
      }
    }

    //scan for aac samples
    while (offset < len) {
      if (isHeader(data, offset) && offset + 5 < len) {
        var frame = appendFrame(track, data, offset, pts, frameIndex);
        if (frame) {
          //logger.log(`${Math.round(frame.sample.pts)} : AAC`);
          offset += frame.length;
          stamp = frame.sample.pts;
          frameIndex++;
        } else {
          //logger.log('Unable to parse AAC frame');
          break;
        }
      } else {
        //nothing found, keep looking
        offset++;
      }
    }

    if (offset < len) {
      aacOverFlow = data.subarray(offset, len);
      //logger.log(`AAC: overflow detected:${len-offset}`);
    } else {
      aacOverFlow = null;
    }
    this.aacOverFlow = aacOverFlow;
    this.aacLastPTS = stamp;
  };

  TSDemuxer.prototype._parseMPEGPES = function _parseMPEGPES(pes) {
    var data = pes.data;
    var length = data.length;
    var frameIndex = 0;
    var offset = 0;
    var pts = pes.pts;

    while (offset < length) {
      if (mpegaudio.isHeader(data, offset)) {
        var frame = mpegaudio.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
        if (frame) {
          offset += frame.length;
          frameIndex++;
        } else {
          //logger.log('Unable to parse Mpeg audio frame');
          break;
        }
      } else {
        //nothing found, keep looking
        offset++;
      }
    }
  };

  TSDemuxer.prototype._parseID3PES = function _parseID3PES(pes) {
    this._id3Track.samples.push(pes);
  };

  return TSDemuxer;
}();

/* harmony default export */ var tsdemuxer = (tsdemuxer_TSDemuxer);
// CONCATENATED MODULE: ./src/demux/mp3demuxer.js
function mp3demuxer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * MP3 demuxer
 */




var mp3demuxer_MP3Demuxer = function () {
  function MP3Demuxer(observer, remuxer, config) {
    mp3demuxer__classCallCheck(this, MP3Demuxer);

    this.observer = observer;
    this.config = config;
    this.remuxer = remuxer;
  }

  MP3Demuxer.prototype.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
    this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: false, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
  };

  MP3Demuxer.prototype.resetTimeStamp = function resetTimeStamp() {};

  MP3Demuxer.probe = function probe(data) {
    // check if data contains ID3 timestamp and MPEG sync word
    var offset, length;
    var id3Data = id3["a" /* default */].getID3Data(data, 0);
    if (id3Data && id3["a" /* default */].getTimeStamp(id3Data) !== undefined) {
      // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1
      // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)
      // More info http://www.mp3-tech.org/programmer/frame_header.html
      for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
        if (mpegaudio.probe(data, offset)) {
          logger["b" /* logger */].log('MPEG Audio sync word found !');
          return true;
        }
      }
    }
    return false;
  };

  // feed incoming data to the front of the parsing pipeline


  MP3Demuxer.prototype.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
    var id3Data = id3["a" /* default */].getID3Data(data, 0);
    var timestamp = id3["a" /* default */].getTimeStamp(id3Data);
    var pts = timestamp ? 90 * timestamp : timeOffset * 90000;
    var offset = id3Data.length;
    var length = data.length;
    var frameIndex = 0,
        stamp = 0;
    var track = this._audioTrack;

    var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];

    while (offset < length) {
      if (mpegaudio.isHeader(data, offset)) {
        var frame = mpegaudio.appendFrame(track, data, offset, pts, frameIndex);
        if (frame) {
          offset += frame.length;
          stamp = frame.sample.pts;
          frameIndex++;
        } else {
          //logger.log('Unable to parse Mpeg audio frame');
          break;
        }
      } else if (id3["a" /* default */].isHeader(data, offset)) {
        id3Data = id3["a" /* default */].getID3Data(data, offset);
        id3Samples.push({ pts: stamp, dts: stamp, data: id3Data });
        offset += id3Data.length;
      } else {
        //nothing found, keep looking
        offset++;
      }
    }

    this.remuxer.remux(track, { samples: [] }, { samples: id3Samples, inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
  };

  MP3Demuxer.prototype.destroy = function destroy() {};

  return MP3Demuxer;
}();

/* harmony default export */ var mp3demuxer = (mp3demuxer_MP3Demuxer);
// CONCATENATED MODULE: ./src/helper/aac.js
function aac__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  AAC helper
 */

var AAC = function () {
  function AAC() {
    aac__classCallCheck(this, AAC);
  }

  AAC.getSilentFrame = function getSilentFrame(codec, channelCount) {
    switch (codec) {
      case 'mp4a.40.2':
        if (channelCount === 1) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
        } else if (channelCount === 2) {
          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
        } else if (channelCount === 3) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
        } else if (channelCount === 4) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
        } else if (channelCount === 5) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
        } else if (channelCount === 6) {
          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
        }
        break;
      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
      default:
        if (channelCount === 1) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        } else if (channelCount === 2) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        } else if (channelCount === 3) {
          // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
        }
        break;
    }
    return null;
  };

  return AAC;
}();

/* harmony default export */ var aac = (AAC);
// CONCATENATED MODULE: ./src/remux/mp4-generator.js
function mp4_generator__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generate MP4 Box
*/

//import Hex from '../utils/hex';

var mp4_generator_UINT32_MAX = Math.pow(2, 32) - 1;

var MP4 = function () {
  function MP4() {
    mp4_generator__classCallCheck(this, MP4);
  }

  MP4.init = function init() {
    MP4.types = {
      avc1: [], // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      '.mp3': [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };

    var i;
    for (i in MP4.types) {
      if (MP4.types.hasOwnProperty(i)) {
        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }

    var videoHdlr = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // pre_defined
    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
    ]);

    var audioHdlr = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // pre_defined
    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
    ]);

    MP4.HDLR_TYPES = {
      'video': videoHdlr,
      'audio': audioHdlr
    };

    var dref = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x01, // entry_count
    0x00, 0x00, 0x00, 0x0c, // entry_size
    0x75, 0x72, 0x6c, 0x20, // 'url' type
    0x00, // version 0
    0x00, 0x00, 0x01 // entry_flags
    ]);

    var stco = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00 // entry_count
    ]);

    MP4.STTS = MP4.STSC = MP4.STCO = stco;

    MP4.STSZ = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, // sample_size
    0x00, 0x00, 0x00, 0x00]);
    MP4.VMHD = new Uint8Array([0x00, // version
    0x00, 0x00, 0x01, // flags
    0x00, 0x00, // graphicsmode
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
    ]);
    MP4.SMHD = new Uint8Array([0x00, // version
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, // balance
    0x00, 0x00 // reserved
    ]);

    MP4.STSD = new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x01]); // entry_count

    var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
    var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
    var minorVersion = new Uint8Array([0, 0, 0, 1]);

    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
  };

  MP4.box = function box(type) {
    var payload = Array.prototype.slice.call(arguments, 1),
        size = 8,
        i = payload.length,
        len = i,
        result;
    // calculate the total size we need to allocate
    while (i--) {
      size += payload[i].byteLength;
    }
    result = new Uint8Array(size);
    result[0] = size >> 24 & 0xff;
    result[1] = size >> 16 & 0xff;
    result[2] = size >> 8 & 0xff;
    result[3] = size & 0xff;
    result.set(type, 4);
    // copy the payload into the result
    for (i = 0, size = 8; i < len; i++) {
      // copy payload[i] array @ offset size
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  };

  MP4.hdlr = function hdlr(type) {
    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
  };

  MP4.mdat = function mdat(data) {
    return MP4.box(MP4.types.mdat, data);
  };

  MP4.mdhd = function mdhd(timescale, duration) {
    duration *= timescale;
    var upperWordDuration = Math.floor(duration / (mp4_generator_UINT32_MAX + 1));
    var lowerWordDuration = Math.floor(duration % (mp4_generator_UINT32_MAX + 1));
    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
    0x00, 0x00]));
  };

  MP4.mdia = function mdia(track) {
    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
  };

  MP4.mfhd = function mfhd(sequenceNumber) {
    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
    sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]) // sequence_number
    );
  };

  MP4.minf = function minf(track) {
    if (track.type === 'audio') {
      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
    } else {
      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
    }
  };

  MP4.moof = function moof(sn, baseMediaDecodeTime, track) {
    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
  };
  /**
   * @param tracks... (optional) {array} the tracks associated with this movie
   */


  MP4.moov = function moov(tracks) {
    var i = tracks.length,
        boxes = [];

    while (i--) {
      boxes[i] = MP4.trak(tracks[i]);
    }

    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
  };

  MP4.mvex = function mvex(tracks) {
    var i = tracks.length,
        boxes = [];

    while (i--) {
      boxes[i] = MP4.trex(tracks[i]);
    }
    return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
  };

  MP4.mvhd = function mvhd(timescale, duration) {
    duration *= timescale;
    var upperWordDuration = Math.floor(duration / (mp4_generator_UINT32_MAX + 1));
    var lowerWordDuration = Math.floor(duration % (mp4_generator_UINT32_MAX + 1));
    var bytes = new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
    0x01, 0x00, // 1.0 volume
    0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
    0xff, 0xff, 0xff, 0xff // next_track_ID
    ]);
    return MP4.box(MP4.types.mvhd, bytes);
  };

  MP4.sdtp = function sdtp(track) {
    var samples = track.samples || [],
        bytes = new Uint8Array(4 + samples.length),
        flags,
        i;
    // leave the full box header (4 bytes) all zero
    // write the sample table
    for (i = 0; i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }

    return MP4.box(MP4.types.sdtp, bytes);
  };

  MP4.stbl = function stbl(track) {
    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
  };

  MP4.avc1 = function avc1(track) {
    var sps = [],
        pps = [],
        i,
        data,
        len;
    // assemble the SPSs

    for (i = 0; i < track.sps.length; i++) {
      data = track.sps[i];
      len = data.byteLength;
      sps.push(len >>> 8 & 0xFF);
      sps.push(len & 0xFF);
      sps = sps.concat(Array.prototype.slice.call(data)); // SPS
    }

    // assemble the PPSs
    for (i = 0; i < track.pps.length; i++) {
      data = track.pps[i];
      len = data.byteLength;
      pps.push(len >>> 8 & 0xFF);
      pps.push(len & 0xFF);
      pps = pps.concat(Array.prototype.slice.call(data));
    }

    var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
    sps[3], // profile
    sps[4], // profile compat
    sps[5], // level
    0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
    0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
    ]).concat(pps))),
        // "PPS"
    width = track.width,
        height = track.height,
        hSpacing = track.pixelRatio[0],
        vSpacing = track.pixelRatio[1];
    //console.log('avcc:' + Hex.hexDump(avcc));
    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, // pre_defined
    0x00, 0x00, // reserved
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
    width >> 8 & 0xFF, width & 0xff, // width
    height >> 8 & 0xFF, height & 0xff, // height
    0x00, 0x48, 0x00, 0x00, // horizresolution
    0x00, 0x48, 0x00, 0x00, // vertresolution
    0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // frame_count
    0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
    0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
    0x00, 0x18, // depth = 24
    0x11, 0x11]), // pre_defined = -1
    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
    0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
    0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
    hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
    vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
  };

  MP4.esds = function esds(track) {
    var configlen = track.config.length;
    return new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags

    0x03, // descriptor_type
    0x17 + configlen, // length
    0x00, 0x01, //es_id
    0x00, // stream_priority

    0x04, // descriptor_type
    0x0f + configlen, // length
    0x40, //codec : mpeg4_audio
    0x15, // stream_type
    0x00, 0x00, 0x00, // buffer_size
    0x00, 0x00, 0x00, 0x00, // maxBitrate
    0x00, 0x00, 0x00, 0x00, // avgBitrate

    0x05 // descriptor_type
    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
  };

  MP4.mp4a = function mp4a(track) {
    var samplerate = track.samplerate;
    return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, track.channelCount, // channelcount
    0x00, 0x10, // sampleSize:16bits
    0x00, 0x00, 0x00, 0x00, // reserved2
    samplerate >> 8 & 0xFF, samplerate & 0xff, //
    0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
  };

  MP4.mp3 = function mp3(track) {
    var samplerate = track.samplerate;
    return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
    0x00, 0x00, 0x00, // reserved
    0x00, 0x01, // data_reference_index
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, track.channelCount, // channelcount
    0x00, 0x10, // sampleSize:16bits
    0x00, 0x00, 0x00, 0x00, // reserved2
    samplerate >> 8 & 0xFF, samplerate & 0xff, //
    0x00, 0x00]));
  };

  MP4.stsd = function stsd(track) {
    if (track.type === 'audio') {
      if (!track.isAAC && track.codec === 'mp3') {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
      }
      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
    } else {
      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
    }
  };

  MP4.tkhd = function tkhd(track) {
    var id = track.id,
        duration = track.duration * track.timescale,
        width = track.width,
        height = track.height,
        upperWordDuration = Math.floor(duration / (mp4_generator_UINT32_MAX + 1)),
        lowerWordDuration = Math.floor(duration % (mp4_generator_UINT32_MAX + 1));
    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x07, // flags
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
    id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
    0x00, 0x00, 0x00, 0x00, // reserved
    upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
    0x00, 0x00, // layer
    0x00, 0x00, // alternate_group
    0x00, 0x00, // non-audio track volume
    0x00, 0x00, // reserved
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
    width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
    height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
    ]));
  };

  MP4.traf = function traf(track, baseMediaDecodeTime) {
    var sampleDependencyTable = MP4.sdtp(track),
        id = track.id,
        upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (mp4_generator_UINT32_MAX + 1)),
        lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (mp4_generator_UINT32_MAX + 1));
    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF]) // track_ID
    ), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
    0x00, 0x00, 0x00, // flags
    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
    20 + // tfdt
    8 + // traf header
    16 + // mfhd
    8 + // moof header
    8), // mdat header
    sampleDependencyTable);
  };

  /**
   * Generate a track box.
   * @param track {object} a track definition
   * @return {Uint8Array} the track box
   */


  MP4.trak = function trak(track) {
    track.duration = track.duration || 0xffffffff;
    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
  };

  MP4.trex = function trex(track) {
    var id = track.id;
    return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
    0x00, 0x00, 0x00, // flags
    id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
    0x00, 0x00, 0x00, 0x01, // default_sample_description_index
    0x00, 0x00, 0x00, 0x00, // default_sample_duration
    0x00, 0x00, 0x00, 0x00, // default_sample_size
    0x00, 0x01, 0x00, 0x01 // default_sample_flags
    ]));
  };

  MP4.trun = function trun(track, offset) {
    var samples = track.samples || [],
        len = samples.length,
        arraylen = 12 + 16 * len,
        array = new Uint8Array(arraylen),
        i,
        sample,
        duration,
        size,
        flags,
        cts;
    offset += 8 + arraylen;
    array.set([0x00, // version 0
    0x00, 0x0f, 0x01, // flags
    len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
    offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
    ], 0);
    for (i = 0; i < len; i++) {
      sample = samples[i];
      duration = sample.duration;
      size = sample.size;
      flags = sample.flags;
      cts = sample.cts;
      array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
      size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
      cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
      ], 12 + 16 * i);
    }
    return MP4.box(MP4.types.trun, array);
  };

  MP4.initSegment = function initSegment(tracks) {
    if (!MP4.types) {
      MP4.init();
    }
    var movie = MP4.moov(tracks),
        result;
    result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
    result.set(MP4.FTYP);
    result.set(movie, MP4.FTYP.byteLength);
    return result;
  };

  return MP4;
}();

/* harmony default export */ var mp4_generator = (MP4);
// CONCATENATED MODULE: ./src/remux/mp4-remuxer.js
function mp4_remuxer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
* fMP4 remuxer
*/







// 10 seconds
var MAX_SILENT_FRAME_DURATION = 10 * 1000;

var mp4_remuxer_MP4Remuxer = function () {
  function MP4Remuxer(observer, config, typeSupported, vendor) {
    mp4_remuxer__classCallCheck(this, MP4Remuxer);

    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    var userAgent = navigator.userAgent;
    this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
    this.ISGenerated = false;
  }

  MP4Remuxer.prototype.destroy = function destroy() {};

  MP4Remuxer.prototype.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
    this._initPTS = this._initDTS = defaultTimeStamp;
  };

  MP4Remuxer.prototype.resetInitSegment = function resetInitSegment() {
    this.ISGenerated = false;
  };

  MP4Remuxer.prototype.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
    // generate Init Segment if needed
    if (!this.ISGenerated) {
      this.generateIS(audioTrack, videoTrack, timeOffset);
    }

    if (this.ISGenerated) {
      var nbAudioSamples = audioTrack.samples.length;
      var nbVideoSamples = videoTrack.samples.length;
      var audioTimeOffset = timeOffset;
      var videoTimeOffset = timeOffset;
      if (nbAudioSamples && nbVideoSamples) {
        // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)
        // if first audio DTS is not aligned with first video DTS then we need to take that into account
        // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small
        // drift between audio and video streams
        var audiovideoDeltaDts = (audioTrack.samples[0].dts - videoTrack.samples[0].dts) / videoTrack.inputTimeScale;
        audioTimeOffset += Math.max(0, audiovideoDeltaDts);
        videoTimeOffset += Math.max(0, -audiovideoDeltaDts);
      }
      // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
      // calculated in remuxAudio.
      //logger.log('nb AAC samples:' + audioTrack.samples.length);
      if (nbAudioSamples) {
        // if initSegment was generated without video samples, regenerate it again
        if (!audioTrack.timescale) {
          logger["b" /* logger */].warn('regenerate InitSegment as audio detected');
          this.generateIS(audioTrack, videoTrack, timeOffset);
        }
        var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
        //logger.log('nb AVC samples:' + videoTrack.samples.length);
        if (nbVideoSamples) {
          var audioTrackLength = void 0;
          if (audioData) {
            audioTrackLength = audioData.endPTS - audioData.startPTS;
          }
          // if initSegment was generated without video samples, regenerate it again
          if (!videoTrack.timescale) {
            logger["b" /* logger */].warn('regenerate InitSegment as video detected');
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
          this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength, accurateTimeOffset);
        }
      } else {
        var videoData = void 0;
        //logger.log('nb AVC samples:' + videoTrack.samples.length);
        if (nbVideoSamples) {
          videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, accurateTimeOffset);
        }
        if (videoData && audioTrack.codec) {
          this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
        }
      }
    }
    //logger.log('nb ID3 samples:' + audioTrack.samples.length);
    if (id3Track.samples.length) {
      this.remuxID3(id3Track, timeOffset);
    }
    //logger.log('nb ID3 samples:' + audioTrack.samples.length);
    if (textTrack.samples.length) {
      this.remuxText(textTrack, timeOffset);
    }
    //notify end of parsing
    this.observer.trigger(events["a" /* default */].FRAG_PARSED);
  };

  MP4Remuxer.prototype.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {
    var observer = this.observer,
        audioSamples = audioTrack.samples,
        videoSamples = videoTrack.samples,
        typeSupported = this.typeSupported,
        container = 'audio/mp4',
        tracks = {},
        data = { tracks: tracks },
        computePTSDTS = this._initPTS === undefined,
        initPTS,
        initDTS;

    if (computePTSDTS) {
      initPTS = initDTS = Infinity;
    }
    if (audioTrack.config && audioSamples.length) {
      // let's use audio sampling rate as MP4 time scale.
      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
      // using audio sampling rate here helps having an integer MP4 frame duration
      // this avoids potential rounding issue and AV sync issue
      audioTrack.timescale = audioTrack.samplerate;
      logger["b" /* logger */].log('audio sampling rate : ' + audioTrack.samplerate);
      if (!audioTrack.isAAC) {
        if (typeSupported.mpeg) {
          // Chrome and Safari
          container = 'audio/mpeg';
          audioTrack.codec = '';
        } else if (typeSupported.mp3) {
          // Firefox
          audioTrack.codec = 'mp3';
        }
      }
      tracks.audio = {
        container: container,
        codec: audioTrack.codec,
        initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : mp4_generator.initSegment([audioTrack]),
        metadata: {
          channelCount: audioTrack.channelCount
        }
      };
      if (computePTSDTS) {
        // remember first PTS of this demuxing context. for audio, PTS = DTS
        initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
      }
    }

    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
      // let's use input time scale as MP4 video timescale
      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
      var inputTimeScale = videoTrack.inputTimeScale;
      videoTrack.timescale = inputTimeScale;
      tracks.video = {
        container: 'video/mp4',
        codec: videoTrack.codec,
        initSegment: mp4_generator.initSegment([videoTrack]),
        metadata: {
          width: videoTrack.width,
          height: videoTrack.height
        }
      };
      if (computePTSDTS) {
        initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
        initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
        this.observer.trigger(events["a" /* default */].INIT_PTS_FOUND, { initPTS: initPTS });
      }
    }

    if (Object.keys(tracks).length) {
      observer.trigger(events["a" /* default */].FRAG_PARSING_INIT_SEGMENT, data);
      this.ISGenerated = true;
      if (computePTSDTS) {
        this._initPTS = initPTS;
        this._initDTS = initDTS;
      }
    } else {
      observer.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
    }
  };

  MP4Remuxer.prototype.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength, accurateTimeOffset) {
    var offset = 8,
        timeScale = track.timescale,
        mp4SampleDuration,
        mdat,
        moof,
        firstPTS,
        firstDTS,
        nextDTS,
        lastPTS,
        lastDTS,
        inputSamples = track.samples,
        outputSamples = [],
        nbSamples = inputSamples.length,
        ptsNormalize = this._PTSNormalize,
        initDTS = this._initDTS;

    // for (let i = 0; i < track.samples.length; i++) {
    //   let avcSample = track.samples[i];
    //   let units = avcSample.units;
    //   let unitsString = '';
    //   for (let j = 0; j < units.length ; j++) {
    //     unitsString += units[j].type + ',';
    //     if (units[j].data.length < 500) {
    //       unitsString += Hex.hexDump(units[j].data);
    //     }
    //   }
    //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
    // }

    // if parsed fragment is contiguous with last one, let's use last DTS value as reference
    var nextAvcDts = this.nextAvcDts;

    var isSafari = this.isSafari;

    // Safari does not like overlapping DTS on consecutive fragments. let's use nextAvcDts to overcome this if fragments are consecutive
    if (isSafari) {
      // also consider consecutive fragments as being contiguous (even if a level switch occurs),
      // for sake of clarity:
      // consecutive fragments are frags with
      //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
      //  - less than 200 ms PTS gaps (timeScale/5)
      contiguous |= inputSamples.length && nextAvcDts && (accurateTimeOffset && Math.abs(timeOffset - nextAvcDts / timeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAvcDts - initDTS) < timeScale / 5);
    }

    if (!contiguous) {
      // if not contiguous, let's use target timeOffset
      nextAvcDts = timeOffset * timeScale;
    }

    // PTS is coded on 33bits, and can loop from -2^32 to 2^32
    // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
    inputSamples.forEach(function (sample) {
      sample.pts = ptsNormalize(sample.pts - initDTS, nextAvcDts);
      sample.dts = ptsNormalize(sample.dts - initDTS, nextAvcDts);
    });

    // sort video samples by DTS then PTS then demux id order
    inputSamples.sort(function (a, b) {
      var deltadts = a.dts - b.dts;
      var deltapts = a.pts - b.pts;
      return deltadts ? deltadts : deltapts ? deltapts : a.id - b.id;
    });

    // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
    var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
      return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
    }, 0);
    if (PTSDTSshift < 0) {
      logger["b" /* logger */].warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
      for (var i = 0; i < inputSamples.length; i++) {
        inputSamples[i].dts += PTSDTSshift;
      }
    }

    // compute first DTS and last DTS, normalize them against reference value
    var sample = inputSamples[0];
    firstDTS = Math.max(sample.dts, 0);
    firstPTS = Math.max(sample.pts, 0);

    // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
    var delta = Math.round((firstDTS - nextAvcDts) / 90);
    // if fragment are contiguous, detect hole/overlapping between fragments
    if (contiguous) {
      if (delta) {
        if (delta > 1) {
          logger["b" /* logger */].log('AVC:' + delta + ' ms hole between fragments detected,filling it');
        } else if (delta < -1) {
          logger["b" /* logger */].log('AVC:' + -delta + ' ms overlapping between fragments detected');
        }
        // remove hole/gap : set DTS to next expected DTS
        firstDTS = nextAvcDts;
        inputSamples[0].dts = firstDTS;
        // offset PTS as well, ensure that PTS is smaller or equal than new DTS
        firstPTS = Math.max(firstPTS - delta, nextAvcDts);
        inputSamples[0].pts = firstPTS;
        logger["b" /* logger */].log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
      }
    }
    nextDTS = firstDTS;

    // compute lastPTS/lastDTS
    sample = inputSamples[inputSamples.length - 1];
    lastDTS = Math.max(sample.dts, 0);
    lastPTS = Math.max(sample.pts, 0, lastDTS);

    // on Safari let's signal the same sample duration for all samples
    // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
    // set this constant duration as being the avg delta between consecutive DTS.
    if (isSafari) {
      mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
    }

    var nbNalu = 0,
        naluLen = 0;
    for (var _i = 0; _i < nbSamples; _i++) {
      // compute total/avc sample length and nb of NAL units
      var _sample = inputSamples[_i],
          units = _sample.units,
          nbUnits = units.length,
          sampleLen = 0;
      for (var j = 0; j < nbUnits; j++) {
        sampleLen += units[j].data.length;
      }
      naluLen += sampleLen;
      nbNalu += nbUnits;
      _sample.length = sampleLen;

      // normalize PTS/DTS
      if (isSafari) {
        // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
        _sample.dts = firstDTS + _i * mp4SampleDuration;
      } else {
        // ensure sample monotonic DTS
        _sample.dts = Math.max(_sample.dts, firstDTS);
      }
      // ensure that computed value is greater or equal than sample DTS
      _sample.pts = Math.max(_sample.pts, _sample.dts);
    }

    /* concatenate the video data and construct the mdat in place
      (need 8 more bytes to fill length and mpdat type) */
    var mdatSize = naluLen + 4 * nbNalu + 8;
    try {
      mdat = new Uint8Array(mdatSize);
    } catch (err) {
      this.observer.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MUX_ERROR, details: errors["a" /* ErrorDetails */].REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
      return;
    }
    var view = new DataView(mdat.buffer);
    view.setUint32(0, mdatSize);
    mdat.set(mp4_generator.types.mdat, 4);

    for (var _i2 = 0; _i2 < nbSamples; _i2++) {
      var avcSample = inputSamples[_i2],
          avcSampleUnits = avcSample.units,
          mp4SampleLength = 0,
          compositionTimeOffset = void 0;
      // convert NALU bitstream to MP4 format (prepend NALU with size field)
      for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
        var unit = avcSampleUnits[_j],
            unitData = unit.data,
            unitDataLen = unit.data.byteLength;
        view.setUint32(offset, unitDataLen);
        offset += 4;
        mdat.set(unitData, offset);
        offset += unitDataLen;
        mp4SampleLength += 4 + unitDataLen;
      }

      if (!isSafari) {
        // expected sample duration is the Decoding Timestamp diff of consecutive samples
        if (_i2 < nbSamples - 1) {
          mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
        } else {
          var config = this.config,
              lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
          if (config.stretchShortVideoTrack) {
            // In some cases, a segment's audio track duration may exceed the video track duration.
            // Since we've already remuxed audio, and we know how long the audio track is, we look to
            // see if the delta to the next segment is longer than the minimum of maxBufferHole and
            // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
            // the duration of the last frame to minimize any potential gap between segments.
            var maxBufferHole = config.maxBufferHole,
                maxSeekHole = config.maxSeekHole,
                gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * timeScale),
                deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
            if (deltaToFrameEnd > gapTolerance) {
              // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
              // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
              mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
              if (mp4SampleDuration < 0) {
                mp4SampleDuration = lastFrameDuration;
              }
              logger["b" /* logger */].log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          } else {
            mp4SampleDuration = lastFrameDuration;
          }
        }
        compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
      } else {
        compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
      }

      //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
      outputSamples.push({
        size: mp4SampleLength,
        // constant duration
        duration: mp4SampleDuration,
        cts: compositionTimeOffset,
        flags: {
          isLeading: 0,
          isDependedOn: 0,
          hasRedundancy: 0,
          degradPrio: 0,
          dependsOn: avcSample.key ? 2 : 1,
          isNonSync: avcSample.key ? 0 : 1
        }
      });
    }
    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
    this.nextAvcDts = lastDTS + mp4SampleDuration;
    var dropped = track.dropped;
    track.len = 0;
    track.nbNalu = 0;
    track.dropped = 0;
    if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
      var flags = outputSamples[0].flags;
      // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
      // https://code.google.com/p/chromium/issues/detail?id=229412
      flags.dependsOn = 2;
      flags.isNonSync = 0;
    }
    track.samples = outputSamples;
    moof = mp4_generator.moof(track.sequenceNumber++, firstDTS, track);
    track.samples = [];

    var data = {
      data1: moof,
      data2: mdat,
      startPTS: firstPTS / timeScale,
      endPTS: (lastPTS + mp4SampleDuration) / timeScale,
      startDTS: firstDTS / timeScale,
      endDTS: this.nextAvcDts / timeScale,
      type: 'video',
      nb: outputSamples.length,
      dropped: dropped
    };
    this.observer.trigger(events["a" /* default */].FRAG_PARSING_DATA, data);
    return data;
  };

  MP4Remuxer.prototype.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
    var inputTimeScale = track.inputTimeScale,
        mp4timeScale = track.timescale,
        scaleFactor = inputTimeScale / mp4timeScale,
        mp4SampleDuration = track.isAAC ? 1024 : 1152,
        inputSampleDuration = mp4SampleDuration * scaleFactor,
        ptsNormalize = this._PTSNormalize,
        initDTS = this._initDTS,
        rawMPEG = !track.isAAC && this.typeSupported.mpeg;

    var offset,
        mp4Sample,
        fillFrame,
        mdat,
        moof,
        firstPTS,
        lastPTS,
        inputSamples = track.samples,
        outputSamples = [],
        nextAudioPts = this.nextAudioPts;

    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
    // for sake of clarity:
    // consecutive fragments are frags with
    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
    //  - less than 20 audio frames distance
    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
    // this helps ensuring audio continuity
    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
    contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initDTS) < 20 * inputSampleDuration);

    // compute normalized PTS
    inputSamples.forEach(function (sample) {
      sample.pts = sample.dts = ptsNormalize(sample.pts - initDTS, timeOffset * inputTimeScale);
    });

    // filter out sample with negative PTS that are not playable anyway
    // if we don't remove these negative samples, they will shift all audio samples forward.
    // leading to audio overlap between current / next fragment
    inputSamples = inputSamples.filter(function (sample) {
      return sample.pts >= 0;
    });

    // in case all samples have negative PTS, and have been filtered out, return now
    if (inputSamples.length === 0) {
      return;
    }

    if (!contiguous) {
      if (!accurateTimeOffset) {
        // if frag are mot contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS
        nextAudioPts = inputSamples[0].pts;
      } else {
        // if timeOffset is accurate, let's use it as predicted next audio PTS
        nextAudioPts = timeOffset * inputTimeScale;
      }
    }

    // If the audio track is missing samples, the frames seem to get "left-shifted" within the
    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
    // In an effort to prevent this from happening, we inject frames here where there are gaps.
    // When possible, we inject a silent frame; when that's not possible, we duplicate the last
    // frame.

    if (track.isAAC) {
      var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
      for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length;) {
        // First, let's see how far off this frame is from where we expect it to be
        var sample = inputSamples[i],
            delta;
        var pts = sample.pts;
        delta = pts - nextPts;

        //console.log(Math.round(pts) + '/' + Math.round(nextPts) + '/' + Math.round(delta));
        var duration = Math.abs(1000 * delta / inputTimeScale);

        // If we're overlapping by more than a duration, drop this sample
        if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
          logger["b" /* logger */].warn('Dropping 1 audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(duration) + ' ms overlap.');
          inputSamples.splice(i, 1);
          track.len -= sample.unit.length;
          // Don't touch nextPtsNorm or i
        }

        // Insert missing frames if:
        // 1: We're more than maxAudioFramesDrift frame away
        // 2: Not more than MAX_SILENT_FRAME_DURATION away
        // 3: currentTime (aka nextPtsNorm) is not 0
        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && nextPts) {
            var missing = Math.round(delta / inputSampleDuration);
            logger["b" /* logger */].warn('Injecting ' + missing + ' audio frame @ ' + (nextPts / inputTimeScale).toFixed(3) + 's due to ' + Math.round(1000 * delta / inputTimeScale) + ' ms gap.');
            for (var j = 0; j < missing; j++) {
              var newStamp = Math.max(nextPts, 0);
              fillFrame = aac.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
              if (!fillFrame) {
                logger["b" /* logger */].log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                fillFrame = sample.unit.subarray();
              }
              inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
              track.len += fillFrame.length;
              nextPts += inputSampleDuration;
              i++;
            }

            // Adjust sample to next expected pts
            sample.pts = sample.dts = nextPts;
            nextPts += inputSampleDuration;
            i++;
          } else {
            // Otherwise, just adjust pts
            if (Math.abs(delta) > 0.1 * inputSampleDuration) {
              //logger.log(`Invalid frame delta ${Math.round(delta + inputSampleDuration)} at PTS ${Math.round(pts / 90)} (should be ${Math.round(inputSampleDuration)}).`);
            }
            sample.pts = sample.dts = nextPts;
            nextPts += inputSampleDuration;
            i++;
          }
      }
    }

    for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
      var audioSample = inputSamples[_j2];
      var unit = audioSample.unit;
      var _pts = audioSample.pts;
      //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
      // if not first sample
      if (lastPTS !== undefined) {
        mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);
      } else {
        var _delta = Math.round(1000 * (_pts - nextAudioPts) / inputTimeScale),
            numMissingFrames = 0;
        // if fragment are contiguous, detect hole/overlapping between fragments
        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
        if (contiguous && track.isAAC) {
          // log delta
          if (_delta) {
            if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION) {
              numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
              logger["b" /* logger */].log(_delta + ' ms hole between AAC samples detected,filling it');
              if (numMissingFrames > 0) {
                fillFrame = aac.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  fillFrame = unit.subarray();
                }
                track.len += numMissingFrames * fillFrame.length;
              }
              // if we have frame overlap, overlapping for more than half a frame duraion
            } else if (_delta < -12) {
              // drop overlapping audio frames... browser will deal with it
              logger["b" /* logger */].log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (_pts / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
              track.len -= unit.byteLength;
              continue;
            }
            // set PTS/DTS to expected PTS/DTS
            _pts = nextAudioPts;
          }
        }
        // remember first PTS of our audioSamples
        firstPTS = _pts;
        if (track.len > 0) {
          /* concatenate the audio data and construct the mdat in place
            (need 8 more bytes to fill length and mdat type) */
          var mdatSize = rawMPEG ? track.len : track.len + 8;
          offset = rawMPEG ? 0 : 8;
          try {
            mdat = new Uint8Array(mdatSize);
          } catch (err) {
            this.observer.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MUX_ERROR, details: errors["a" /* ErrorDetails */].REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
            return;
          }
          if (!rawMPEG) {
            var view = new DataView(mdat.buffer);
            view.setUint32(0, mdatSize);
            mdat.set(mp4_generator.types.mdat, 4);
          }
        } else {
          // no audio samples
          return;
        }
        for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
          fillFrame = aac.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
          if (!fillFrame) {
            logger["b" /* logger */].log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
            fillFrame = unit.subarray();
          }
          mdat.set(fillFrame, offset);
          offset += fillFrame.byteLength;
          mp4Sample = {
            size: fillFrame.byteLength,
            cts: 0,
            duration: 1024,
            flags: {
              isLeading: 0,
              isDependedOn: 0,
              hasRedundancy: 0,
              degradPrio: 0,
              dependsOn: 1
            }
          };
          outputSamples.push(mp4Sample);
        }
      }
      mdat.set(unit, offset);
      var unitLen = unit.byteLength;
      offset += unitLen;
      //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
      mp4Sample = {
        size: unitLen,
        cts: 0,
        duration: 0,
        flags: {
          isLeading: 0,
          isDependedOn: 0,
          hasRedundancy: 0,
          degradPrio: 0,
          dependsOn: 1
        }
      };
      outputSamples.push(mp4Sample);
      lastPTS = _pts;
    }
    var lastSampleDuration = 0;
    var nbSamples = outputSamples.length;
    //set last sample duration as being identical to previous sample
    if (nbSamples >= 2) {
      lastSampleDuration = outputSamples[nbSamples - 2].duration;
      mp4Sample.duration = lastSampleDuration;
    }
    if (nbSamples) {
      // next audio sample PTS should be equal to last sample PTS + duration
      this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
      //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
      track.len = 0;
      track.samples = outputSamples;
      if (rawMPEG) {
        moof = new Uint8Array();
      } else {
        moof = mp4_generator.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
      }
      track.samples = [];
      var start = firstPTS / inputTimeScale;
      var end = nextAudioPts / inputTimeScale;
      var audioData = {
        data1: moof,
        data2: mdat,
        startPTS: start,
        endPTS: end,
        startDTS: start,
        endDTS: end,
        type: 'audio',
        nb: nbSamples
      };
      this.observer.trigger(events["a" /* default */].FRAG_PARSING_DATA, audioData);
      return audioData;
    }
    return null;
  };

  MP4Remuxer.prototype.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
    var inputTimeScale = track.inputTimeScale,
        mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
        scaleFactor = inputTimeScale / mp4timeScale,
        nextAudioPts = this.nextAudioPts,


    // sync with video's timestamp
    startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
        endDTS = videoData.endDTS * inputTimeScale + this._initDTS,

    // one sample's duration value
    sampleDuration = 1024,
        frameDuration = scaleFactor * sampleDuration,


    // samples count of this segment's duration
    nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),


    // silent frame
    silentFrame = aac.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);

    logger["b" /* logger */].warn('remux empty Audio');
    // Can't remux if we can't generate a silent frame...
    if (!silentFrame) {
      logger["b" /* logger */].trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
      return;
    }

    var samples = [];
    for (var i = 0; i < nbSamples; i++) {
      var stamp = startDTS + i * frameDuration;
      samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
      track.len += silentFrame.length;
    }
    track.samples = samples;

    this.remuxAudio(track, timeOffset, contiguous);
  };

  MP4Remuxer.prototype.remuxID3 = function remuxID3(track, timeOffset) {
    var length = track.samples.length,
        sample;
    var inputTimeScale = track.inputTimeScale;
    var initPTS = this._initPTS;
    var initDTS = this._initDTS;
    // consume samples
    if (length) {
      for (var index = 0; index < length; index++) {
        sample = track.samples[index];
        // setting id3 pts, dts to relative time
        // using this._initPTS and this._initDTS to calculate relative time
        sample.pts = (sample.pts - initPTS) / inputTimeScale;
        sample.dts = (sample.dts - initDTS) / inputTimeScale;
      }
      this.observer.trigger(events["a" /* default */].FRAG_PARSING_METADATA, {
        samples: track.samples
      });
    }

    track.samples = [];
    timeOffset = timeOffset;
  };

  MP4Remuxer.prototype.remuxText = function remuxText(track, timeOffset) {
    track.samples.sort(function (a, b) {
      return a.pts - b.pts;
    });

    var length = track.samples.length,
        sample;
    var inputTimeScale = track.inputTimeScale;
    var initPTS = this._initPTS;
    // consume samples
    if (length) {
      for (var index = 0; index < length; index++) {
        sample = track.samples[index];
        // setting text pts, dts to relative time
        // using this._initPTS and this._initDTS to calculate relative time
        sample.pts = (sample.pts - initPTS) / inputTimeScale;
      }
      this.observer.trigger(events["a" /* default */].FRAG_PARSING_USERDATA, {
        samples: track.samples
      });
    }

    track.samples = [];
    timeOffset = timeOffset;
  };

  MP4Remuxer.prototype._PTSNormalize = function _PTSNormalize(value, reference) {
    var offset;
    if (reference === undefined) {
      return value;
    }
    if (reference < value) {
      // - 2^33
      offset = -8589934592;
    } else {
      // + 2^33
      offset = 8589934592;
    }
    /* PTS is 33bit (from 0 to 2^33 -1)
      if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
      PTS looping occured. fill the gap */
    while (Math.abs(value - reference) > 4294967296) {
      value += offset;
    }
    return value;
  };

  return MP4Remuxer;
}();

/* harmony default export */ var mp4_remuxer = (mp4_remuxer_MP4Remuxer);
// CONCATENATED MODULE: ./src/remux/passthrough-remuxer.js
function passthrough_remuxer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * passthrough remuxer
*/


var passthrough_remuxer_PassThroughRemuxer = function () {
  function PassThroughRemuxer(observer) {
    passthrough_remuxer__classCallCheck(this, PassThroughRemuxer);

    this.observer = observer;
  }

  PassThroughRemuxer.prototype.destroy = function destroy() {};

  PassThroughRemuxer.prototype.resetTimeStamp = function resetTimeStamp() {};

  PassThroughRemuxer.prototype.resetInitSegment = function resetInitSegment() {};

  PassThroughRemuxer.prototype.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
    var observer = this.observer;
    var streamType = '';
    if (audioTrack) {
      streamType += 'audio';
    }
    if (videoTrack) {
      streamType += 'video';
    }
    observer.trigger(events["a" /* default */].FRAG_PARSING_DATA, {
      data1: rawData,
      startPTS: timeOffset,
      startDTS: timeOffset,
      type: streamType,
      nb: 1,
      dropped: 0
    });
    //notify end of parsing
    observer.trigger(events["a" /* default */].FRAG_PARSED);
  };

  return PassThroughRemuxer;
}();

/* harmony default export */ var passthrough_remuxer = (passthrough_remuxer_PassThroughRemuxer);
// CONCATENATED MODULE: ./src/demux/demuxer-inline.js
function demuxer_inline__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*  inline demuxer.
 *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
 */











var demuxer_inline_DemuxerInline = function () {
  function DemuxerInline(observer, typeSupported, config, vendor) {
    demuxer_inline__classCallCheck(this, DemuxerInline);

    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
  }

  DemuxerInline.prototype.destroy = function destroy() {
    var demuxer = this.demuxer;
    if (demuxer) {
      demuxer.destroy();
    }
  };

  DemuxerInline.prototype.push = function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
    if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
      var decrypter = this.decrypter;
      if (decrypter == null) {
        decrypter = this.decrypter = new crypt_decrypter["a" /* default */](this.observer, this.config);
      }
      var localthis = this;
      // performance.now() not available on WebWorker, at least on Safari Desktop
      var startTime;
      try {
        startTime = performance.now();
      } catch (error) {
        startTime = Date.now();
      }
      decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
        var endTime;
        try {
          endTime = performance.now();
        } catch (error) {
          endTime = Date.now();
        }
        localthis.observer.trigger(events["a" /* default */].FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
        localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      });
    } else {
      this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
    }
  };

  DemuxerInline.prototype.pushDecrypted = function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
    var demuxer = this.demuxer;
    if (!demuxer ||
    // in case of continuity change, we might switch from content type (AAC container to TS container for example)
    // so let's check that current demuxer is still valid
    discontinuity && !this.probe(data)) {
      var observer = this.observer;
      var typeSupported = this.typeSupported;
      var config = this.config;
      // probing order is TS/AAC/MP3/MP4
      var muxConfig = [{ demux: tsdemuxer, remux: mp4_remuxer }, { demux: mp4demuxer, remux: passthrough_remuxer }, { demux: aacdemuxer, remux: mp4_remuxer }, { demux: mp3demuxer, remux: mp4_remuxer }];

      // probe for content type
      for (var i = 0, len = muxConfig.length; i < len; i++) {
        var mux = muxConfig[i];
        var probe = mux.demux.probe;
        if (probe(data)) {
          var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
          demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
          this.probe = probe;
          break;
        }
      }
      if (!demuxer) {
        observer.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
        return;
      }
      this.demuxer = demuxer;
    }
    var remuxer = this.remuxer;

    if (discontinuity || trackSwitch) {
      demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
      remuxer.resetInitSegment();
    }
    if (discontinuity) {
      demuxer.resetTimeStamp(defaultInitPTS);
      remuxer.resetTimeStamp(defaultInitPTS);
    }
    if (typeof demuxer.setDecryptData === 'function') {
      demuxer.setDecryptData(decryptdata);
    }
    demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
  };

  return DemuxerInline;
}();

/* harmony default export */ var demuxer_inline = __webpack_exports__["a"] = (demuxer_inline_DemuxerInline);

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var cues_namespaceObject = {};
__webpack_require__.d(cues_namespaceObject, "newCue", function() { return newCue; });

// EXTERNAL MODULE: ./node_modules/url-toolkit/src/url-toolkit.js
var url_toolkit = __webpack_require__(6);
var url_toolkit_default = /*#__PURE__*/__webpack_require__.n(url_toolkit);

// EXTERNAL MODULE: ./src/events.js
var events = __webpack_require__(1);

// EXTERNAL MODULE: ./src/errors.js
var errors = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/logger.js
var logger = __webpack_require__(0);

// CONCATENATED MODULE: ./src/event-handler.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
*
* All objects in the event handling chain should inherit from this class
*
*/





var event_handler_EventHandler = function () {
  function EventHandler(hls) {
    _classCallCheck(this, EventHandler);

    this.hls = hls;
    this.onEvent = this.onEvent.bind(this);

    for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      events[_key - 1] = arguments[_key];
    }

    this.handledEvents = events;
    this.useGenericHandler = true;

    this.registerListeners();
  }

  EventHandler.prototype.destroy = function destroy() {
    this.unregisterListeners();
  };

  EventHandler.prototype.isEventHandler = function isEventHandler() {
    return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
  };

  EventHandler.prototype.registerListeners = function registerListeners() {
    if (this.isEventHandler()) {
      this.handledEvents.forEach(function (event) {
        if (event === 'hlsEventGeneric') {
          throw new Error('Forbidden event name: ' + event);
        }
        this.hls.on(event, this.onEvent);
      }, this);
    }
  };

  EventHandler.prototype.unregisterListeners = function unregisterListeners() {
    if (this.isEventHandler()) {
      this.handledEvents.forEach(function (event) {
        this.hls.off(event, this.onEvent);
      }, this);
    }
  };

  /**
   * arguments: event (string), data (any)
   */


  EventHandler.prototype.onEvent = function onEvent(event, data) {
    this.onEventGeneric(event, data);
  };

  EventHandler.prototype.onEventGeneric = function onEventGeneric(event, data) {
    var eventToFunction = function eventToFunction(event, data) {
      var funcName = 'on' + event.replace('hls', '');
      if (typeof this[funcName] !== 'function') {
        throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
      }
      return this[funcName].bind(this, data);
    };
    try {
      eventToFunction.call(this, event, data).call();
    } catch (err) {
      logger["b" /* logger */].error('internal error happened while processing ' + event + ':' + err.message);
      this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].OTHER_ERROR, details: errors["a" /* ErrorDetails */].INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
    }
  };

  return EventHandler;
}();

/* harmony default export */ var event_handler = (event_handler_EventHandler);
// CONCATENATED MODULE: ./src/utils/attr-list.js
function attr_list__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;

// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js

var AttrList = function () {
  function AttrList(attrs) {
    attr_list__classCallCheck(this, AttrList);

    if (typeof attrs === 'string') {
      attrs = AttrList.parseAttrList(attrs);
    }
    for (var attr in attrs) {
      if (attrs.hasOwnProperty(attr)) {
        this[attr] = attrs[attr];
      }
    }
  }

  AttrList.prototype.decimalInteger = function decimalInteger(attrName) {
    var intValue = parseInt(this[attrName], 10);
    if (intValue > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }
    return intValue;
  };

  AttrList.prototype.hexadecimalInteger = function hexadecimalInteger(attrName) {
    if (this[attrName]) {
      var stringValue = (this[attrName] || '0x').slice(2);
      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;

      var value = new Uint8Array(stringValue.length / 2);
      for (var i = 0; i < stringValue.length / 2; i++) {
        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
      }
      return value;
    } else {
      return null;
    }
  };

  AttrList.prototype.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
    var intValue = parseInt(this[attrName], 16);
    if (intValue > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }
    return intValue;
  };

  AttrList.prototype.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
    return parseFloat(this[attrName]);
  };

  AttrList.prototype.enumeratedString = function enumeratedString(attrName) {
    return this[attrName];
  };

  AttrList.prototype.decimalResolution = function decimalResolution(attrName) {
    var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
    if (res === null) {
      return undefined;
    }
    return {
      width: parseInt(res[1], 10),
      height: parseInt(res[2], 10)
    };
  };

  AttrList.parseAttrList = function parseAttrList(input) {
    var match,
        attrs = {};
    ATTR_LIST_REGEX.lastIndex = 0;
    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
      var value = match[2],
          quote = '"';

      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
        value = value.slice(1, -1);
      }
      attrs[match[1]] = value;
    }
    return attrs;
  };

  return AttrList;
}();

/* harmony default export */ var attr_list = (AttrList);
// CONCATENATED MODULE: ./src/utils/codecs.js
// from http://mp4ra.org/codecs.html
var sampleEntryCodesISO = {
    audio: {
        'a3ds': true,
        'ac-3': true,
        'ac-4': true,
        'alac': true,
        'alaw': true,
        'dra1': true,
        'dts+': true,
        'dts-': true,
        'dtsc': true,
        'dtse': true,
        'dtsh': true,
        'ec-3': true,
        'enca': true,
        'g719': true,
        'g726': true,
        'm4ae': true,
        'mha1': true,
        'mha2': true,
        'mhm1': true,
        'mhm2': true,
        'mlpa': true,
        'mp4a': true,
        'raw ': true,
        'Opus': true,
        'samr': true,
        'sawb': true,
        'sawp': true,
        'sevc': true,
        'sqcp': true,
        'ssmv': true,
        'twos': true,
        'ulaw': true
    },
    video: {
        'avc1': true,
        'avc2': true,
        'avc3': true,
        'avc4': true,
        'avcp': true,
        'drac': true,
        'dvav': true,
        'dvhe': true,
        'encv': true,
        'hev1': true,
        'hvc1': true,
        'mjp2': true,
        'mp4v': true,
        'mvc1': true,
        'mvc2': true,
        'mvc3': true,
        'mvc4': true,
        'resv': true,
        'rv60': true,
        's263': true,
        'svc1': true,
        'svc2': true,
        'vc-1': true,
        'vp08': true,
        'vp09': true
    }
};

function isCodecType(codec, type) {
    var typeCodes = sampleEntryCodesISO[type];
    return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
}

function isCodecSupportedInMp4(codec, type) {
    return MediaSource.isTypeSupported((type || 'video') + '/mp4;codecs="' + codec + '"');
}


// CONCATENATED MODULE: ./src/loader/playlist-loader.js
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function playlist_loader__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Playlist Loader
*/









// https://regex101.com is your friend
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;

var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
/|(?!#)(\S+)/.source, // segment URI, group 3 => the URI (note newline is not eaten)
/|#EXT-X-BYTERANGE:*(.+)/.source, // next segment's byterange, group 4 => range spec (x@y)
/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, // next segment's program date/time group 5 => the datetime spec
/|#.*/.source // All other non-segment oriented tags will match with all groups empty
].join(''), 'g');

var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;

var playlist_loader_LevelKey = function () {
  function LevelKey() {
    playlist_loader__classCallCheck(this, LevelKey);

    this.method = null;
    this.key = null;
    this.iv = null;
    this._uri = null;
  }

  _createClass(LevelKey, [{
    key: 'uri',
    get: function get() {
      if (!this._uri && this.reluri) {
        this._uri = url_toolkit_default.a.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
      }
      return this._uri;
    }
  }]);

  return LevelKey;
}();

var playlist_loader_Fragment = function () {
  function Fragment() {
    playlist_loader__classCallCheck(this, Fragment);

    this._url = null;
    this._byteRange = null;
    this._decryptdata = null;
    this.tagList = [];
  }

  /**
   * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
   * @returns {Uint8Array}
   */
  Fragment.prototype.createInitializationVector = function createInitializationVector(segmentNumber) {
    var uint8View = new Uint8Array(16);

    for (var i = 12; i < 16; i++) {
      uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
    }

    return uint8View;
  };

  /**
   * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
   * @param levelkey - a playlist's encryption info
   * @param segmentNumber - the fragment's segment number
   * @returns {*} - an object to be applied as a fragment's decryptdata
   */


  Fragment.prototype.fragmentDecryptdataFromLevelkey = function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
    var decryptdata = levelkey;

    if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
      decryptdata = new playlist_loader_LevelKey();
      decryptdata.method = levelkey.method;
      decryptdata.baseuri = levelkey.baseuri;
      decryptdata.reluri = levelkey.reluri;
      decryptdata.iv = this.createInitializationVector(segmentNumber);
    }

    return decryptdata;
  };

  Fragment.prototype.cloneObj = function cloneObj(obj) {
    return JSON.parse(JSON.stringify(obj));
  };

  _createClass(Fragment, [{
    key: 'url',
    get: function get() {
      if (!this._url && this.relurl) {
        this._url = url_toolkit_default.a.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
      }
      return this._url;
    },
    set: function set(value) {
      this._url = value;
    }
  }, {
    key: 'programDateTime',
    get: function get() {
      if (!this._programDateTime && this.rawProgramDateTime) {
        this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));
      }
      return this._programDateTime;
    }
  }, {
    key: 'byteRange',
    get: function get() {
      if (!this._byteRange) {
        var byteRange = this._byteRange = [];
        if (this.rawByteRange) {
          var params = this.rawByteRange.split('@', 2);
          if (params.length === 1) {
            var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
            byteRange[0] = lastByteRangeEndOffset ? lastByteRangeEndOffset : 0;
          } else {
            byteRange[0] = parseInt(params[1]);
          }
          byteRange[1] = parseInt(params[0]) + byteRange[0];
        }
      }
      return this._byteRange;
    }
  }, {
    key: 'byteRangeStartOffset',
    get: function get() {
      return this.byteRange[0];
    }
  }, {
    key: 'byteRangeEndOffset',
    get: function get() {
      return this.byteRange[1];
    }
  }, {
    key: 'decryptdata',
    get: function get() {
      if (!this._decryptdata) {
        this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
      }
      return this._decryptdata;
    }
  }]);

  return Fragment;
}();

function findGroup(groups, mediaGroupId) {
  if (!groups) {
    return null;
  }

  var matchingGroup = null;

  for (var i = 0; i < groups.length; i++) {
    var group = groups[i];
    if (group.id === mediaGroupId) {
      matchingGroup = group;
    }
  }

  return matchingGroup;
}

var playlist_loader_PlaylistLoader = function (_EventHandler) {
  _inherits(PlaylistLoader, _EventHandler);

  function PlaylistLoader(hls) {
    playlist_loader__classCallCheck(this, PlaylistLoader);

    var _this = _possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MANIFEST_LOADING, events["a" /* default */].LEVEL_LOADING, events["a" /* default */].AUDIO_TRACK_LOADING, events["a" /* default */].SUBTITLE_TRACK_LOADING));

    _this.loaders = {};
    return _this;
  }

  PlaylistLoader.prototype.destroy = function destroy() {
    for (var loaderName in this.loaders) {
      var loader = this.loaders[loaderName];
      if (loader) {
        loader.destroy();
      }
    }
    this.loaders = {};
    event_handler.prototype.destroy.call(this);
  };

  PlaylistLoader.prototype.onManifestLoading = function onManifestLoading(data) {
    this.load(data.url, { type: 'manifest' });
  };

  PlaylistLoader.prototype.onLevelLoading = function onLevelLoading(data) {
    this.load(data.url, { type: 'level', level: data.level, id: data.id });
  };

  PlaylistLoader.prototype.onAudioTrackLoading = function onAudioTrackLoading(data) {
    this.load(data.url, { type: 'audioTrack', id: data.id });
  };

  PlaylistLoader.prototype.onSubtitleTrackLoading = function onSubtitleTrackLoading(data) {
    this.load(data.url, { type: 'subtitleTrack', id: data.id });
  };

  PlaylistLoader.prototype.load = function load(url, context) {
    var loader = this.loaders[context.type];
    if (loader !== undefined) {
      var loaderContext = loader.context;
      if (loaderContext && loaderContext.url === url) {
        logger["b" /* logger */].trace('playlist request ongoing');
        return;
      } else {
        logger["b" /* logger */].warn('abort previous loader for type:' + context.type);
        loader.abort();
      }
    }
    var config = this.hls.config,
        maxRetry = void 0,
        timeout = void 0,
        retryDelay = void 0,
        maxRetryDelay = void 0;
    if (context.type === 'manifest') {
      maxRetry = config.manifestLoadingMaxRetry;
      timeout = config.manifestLoadingTimeOut;
      retryDelay = config.manifestLoadingRetryDelay;
      maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
    } else if (context.type === 'level') {
      // Disable internal loader retry logic, since we are managing retries in Level Controller
      maxRetry = 0;
      timeout = config.levelLoadingTimeOut;
    } else {
      // TODO Introduce retry settings for audio-track and subtitle-track, it should not use level retry config
      maxRetry = config.levelLoadingMaxRetry;
      timeout = config.levelLoadingTimeOut;
      retryDelay = config.levelLoadingRetryDelay;
      maxRetryDelay = config.levelLoadingMaxRetryTimeout;
      logger["b" /* logger */].log('loading playlist for ' + context.type + ' ' + (context.level || context.id));
    }
    loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
    context.url = url;
    context.responseType = '';

    var loaderConfig = void 0,
        loaderCallbacks = void 0;
    loaderConfig = { timeout: timeout, maxRetry: maxRetry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
    loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
    loader.load(context, loaderConfig, loaderCallbacks);
  };

  PlaylistLoader.prototype.resolve = function resolve(url, baseUrl) {
    return url_toolkit_default.a.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
  };

  PlaylistLoader.prototype.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
    var levels = [],
        result = void 0;
    MASTER_PLAYLIST_REGEX.lastIndex = 0;

    function setCodecs(codecs, level) {
      ['video', 'audio'].forEach(function (type) {
        var filtered = codecs.filter(function (codec) {
          return isCodecType(codec, type);
        });
        if (filtered.length) {
          var preferred = filtered.filter(function (codec) {
            return codec.lastIndexOf('avc1', 0) === 0 || codec.lastIndexOf('mp4a', 0) === 0;
          });
          level[type + 'Codec'] = preferred.length > 0 ? preferred[0] : filtered[0];

          // remove from list
          codecs = codecs.filter(function (codec) {
            return filtered.indexOf(codec) === -1;
          });
        }
      });

      level.unknownCodecs = codecs;
    }

    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
      var level = {};

      var attrs = level.attrs = new attr_list(result[1]);
      level.url = this.resolve(result[2], baseurl);

      var resolution = attrs.decimalResolution('RESOLUTION');
      if (resolution) {
        level.width = resolution.width;
        level.height = resolution.height;
      }
      level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
      level.name = attrs.NAME;

      setCodecs([].concat((attrs.CODECS || '').split(/[ ,]+/)), level);

      if (level.videoCodec && level.videoCodec.indexOf('avc1') !== -1) {
        level.videoCodec = this.avc1toavcoti(level.videoCodec);
      }

      levels.push(level);
    }
    return levels;
  };

  PlaylistLoader.prototype.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type) {
    var audioGroups = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    var result = void 0;
    var medias = [];
    var id = 0;
    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
      var media = {};
      var attrs = new attr_list(result[1]);
      if (attrs.TYPE === type) {
        media.groupId = attrs['GROUP-ID'];
        media.name = attrs.NAME;
        media.type = type;
        media.default = attrs.DEFAULT === 'YES';
        media.autoselect = attrs.AUTOSELECT === 'YES';
        media.forced = attrs.FORCED === 'YES';
        if (attrs.URI) {
          media.url = this.resolve(attrs.URI, baseurl);
        }
        media.lang = attrs.LANGUAGE;
        if (!media.name) {
          media.name = media.lang;
        }
        if (audioGroups.length) {
          var groupCodec = findGroup(audioGroups, media.groupId);
          media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
        }
        media.id = id++;
        medias.push(media);
      }
    }
    return medias;
  };

  PlaylistLoader.prototype.avc1toavcoti = function avc1toavcoti(codec) {
    var result,
        avcdata = codec.split('.');
    if (avcdata.length > 2) {
      result = avcdata.shift() + '.';
      result += parseInt(avcdata.shift()).toString(16);
      result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
    } else {
      result = codec;
    }
    return result;
  };

  PlaylistLoader.prototype.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type) {
    var currentSN = 0,
        totalduration = 0,
        level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
        levelkey = new playlist_loader_LevelKey(),
        cc = 0,
        prevFrag = null,
        frag = new playlist_loader_Fragment(),
        result,
        i;

    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;

    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
      var duration = result[1];
      if (duration) {
        // INF
        frag.duration = parseFloat(duration);
        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
        var title = (' ' + result[2]).slice(1);
        frag.title = title ? title : null;
        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
      } else if (result[3]) {
        // url
        if (!isNaN(frag.duration)) {
          var sn = currentSN++;
          frag.type = type;
          frag.start = totalduration;
          frag.levelkey = levelkey;
          frag.sn = sn;
          frag.level = id;
          frag.cc = cc;
          frag.baseurl = baseurl;
          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
          frag.relurl = (' ' + result[3]).slice(1);

          level.fragments.push(frag);
          prevFrag = frag;
          totalduration += frag.duration;

          frag = new playlist_loader_Fragment();
        }
      } else if (result[4]) {
        // X-BYTERANGE
        frag.rawByteRange = (' ' + result[4]).slice(1);
        if (prevFrag) {
          var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
          if (lastByteRangeEndOffset) {
            frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
          }
        }
      } else if (result[5]) {
        // PROGRAM-DATE-TIME
        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
        frag.rawProgramDateTime = (' ' + result[5]).slice(1);
        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
        if (level.programDateTime === undefined) {
          level.programDateTime = new Date(new Date(Date.parse(result[5])) - 1000 * totalduration);
        }
      } else {
        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
        for (i = 1; i < result.length; i++) {
          if (result[i] !== undefined) {
            break;
          }
        }

        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
        var value1 = (' ' + result[i + 1]).slice(1);
        var value2 = (' ' + result[i + 2]).slice(1);

        switch (result[i]) {
          case '#':
            frag.tagList.push(value2 ? [value1, value2] : [value1]);
            break;
          case 'PLAYLIST-TYPE':
            level.type = value1.toUpperCase();
            break;
          case 'MEDIA-SEQUENCE':
            currentSN = level.startSN = parseInt(value1);
            break;
          case 'TARGETDURATION':
            level.targetduration = parseFloat(value1);
            break;
          case 'VERSION':
            level.version = parseInt(value1);
            break;
          case 'EXTM3U':
            break;
          case 'ENDLIST':
            level.live = false;
            break;
          case 'DIS':
            cc++;
            frag.tagList.push(['DIS']);
            break;
          case 'DISCONTINUITY-SEQ':
            cc = parseInt(value1);
            break;
          case 'KEY':
            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
            var decryptparams = value1;
            var keyAttrs = new attr_list(decryptparams);
            var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                decrypturi = keyAttrs.URI,
                decryptiv = keyAttrs.hexadecimalInteger('IV');
            if (decryptmethod) {
              levelkey = new playlist_loader_LevelKey();
              if (decrypturi && ['AES-128', 'SAMPLE-AES'].indexOf(decryptmethod) >= 0) {
                levelkey.method = decryptmethod;
                // URI to get the key
                levelkey.baseuri = baseurl;
                levelkey.reluri = decrypturi;
                levelkey.key = null;
                // Initialization Vector (IV)
                levelkey.iv = decryptiv;
              }
            }
            break;
          case 'START':
            var startParams = value1;
            var startAttrs = new attr_list(startParams);
            var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
            //TIME-OFFSET can be 0
            if (!isNaN(startTimeOffset)) {
              level.startTimeOffset = startTimeOffset;
            }
            break;
          case 'MAP':
            var mapAttrs = new attr_list(value1);
            frag.relurl = mapAttrs.URI;
            frag.rawByteRange = mapAttrs.BYTERANGE;
            frag.baseurl = baseurl;
            frag.level = id;
            frag.type = type;
            frag.sn = 'initSegment';
            level.initSegment = frag;
            frag = new playlist_loader_Fragment();
            break;
          default:
            logger["b" /* logger */].warn('line parsed but not handled: ' + result);
            break;
        }
      }
    }
    frag = prevFrag;
    //logger.log('found ' + level.fragments.length + ' fragments');
    if (frag && !frag.relurl) {
      level.fragments.pop();
      totalduration -= frag.duration;
    }
    level.totalduration = totalduration;
    level.averagetargetduration = totalduration / level.fragments.length;
    level.endSN = currentSN - 1;
    level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
    level.endCC = cc;
    return level;
  };

  PlaylistLoader.prototype.loadsuccess = function loadsuccess(response, stats, context) {
    var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    var string = response.data,
        url = response.url,
        type = context.type,
        id = context.id,
        level = context.level,
        hls = this.hls;

    this.loaders[type] = undefined;
    // responseURL not supported on some browsers (it is used to detect URL redirection)
    // data-uri mode also not supported (but no need to detect redirection)
    if (url === undefined || url.indexOf('data:') === 0) {
      // fallback to initial URL
      url = context.url;
    }
    stats.tload = performance.now();
    //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
    if (string.indexOf('#EXTM3U') === 0) {
      if (string.indexOf('#EXTINF:') > 0) {
        var isLevel = type !== 'audioTrack' && type !== 'subtitleTrack',
            levelId = !isNaN(level) ? level : !isNaN(id) ? id : 0,
            levelDetails = this.parseLevelPlaylist(string, url, levelId, type === 'audioTrack' ? 'audio' : type === 'subtitleTrack' ? 'subtitle' : 'main');
        levelDetails.tload = stats.tload;
        if (type === 'manifest') {
          // first request, stream manifest (no master playlist), fire manifest loaded event with level details
          hls.trigger(events["a" /* default */].MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats, networkDetails: networkDetails });
        }
        stats.tparsed = performance.now();
        if (levelDetails.targetduration) {
          if (isLevel) {
            hls.trigger(events["a" /* default */].LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats, networkDetails: networkDetails });
          } else {
            if (type === 'audioTrack') {
              hls.trigger(events["a" /* default */].AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats, networkDetails: networkDetails });
            } else if (type === 'subtitleTrack') {
              hls.trigger(events["a" /* default */].SUBTITLE_TRACK_LOADED, { details: levelDetails, id: id, stats: stats, networkDetails: networkDetails });
            }
          }
        } else {
          hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: errors["a" /* ErrorDetails */].MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration', networkDetails: networkDetails });
        }
      } else {
        var levels = this.parseMasterPlaylist(string, url);
        // multi level playlist, parse level info
        if (levels.length) {
          var audioGroups = levels.map(function (l) {
            return { id: l.attrs.AUDIO, codec: l.audioCodec };
          });
          var audioTracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO', audioGroups);
          var subtitles = this.parseMasterPlaylistMedia(string, url, 'SUBTITLES');
          if (audioTracks.length) {
            // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
            var embeddedAudioFound = false;
            audioTracks.forEach(function (audioTrack) {
              if (!audioTrack.url) {
                embeddedAudioFound = true;
              }
            });
            // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
            // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
            if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
              logger["b" /* logger */].log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
              audioTracks.unshift({ type: 'main', name: 'main' });
            }
          }
          hls.trigger(events["a" /* default */].MANIFEST_LOADED, { levels: levels, audioTracks: audioTracks, subtitles: subtitles, url: url, stats: stats, networkDetails: networkDetails });
        } else {
          hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: errors["a" /* ErrorDetails */].MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest', networkDetails: networkDetails });
        }
      }
    } else {
      hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: errors["a" /* ErrorDetails */].MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter', networkDetails: networkDetails });
    }
  };

  PlaylistLoader.prototype.loaderror = function loaderror(response, context) {
    var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var details,
        fatal,
        loader = context.loader;
    switch (context.type) {
      case 'manifest':
        details = errors["a" /* ErrorDetails */].MANIFEST_LOAD_ERROR;
        fatal = true;
        break;
      case 'level':
        details = errors["a" /* ErrorDetails */].LEVEL_LOAD_ERROR;
        fatal = false;
        break;
      case 'audioTrack':
        details = errors["a" /* ErrorDetails */].AUDIO_TRACK_LOAD_ERROR;
        fatal = false;
        break;
    }
    if (loader) {
      loader.abort();
      this.loaders[context.type] = undefined;
    }
    this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context, networkDetails: networkDetails });
  };

  PlaylistLoader.prototype.loadtimeout = function loadtimeout(stats, context) {
    var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var details,
        fatal,
        loader = context.loader;
    switch (context.type) {
      case 'manifest':
        details = errors["a" /* ErrorDetails */].MANIFEST_LOAD_TIMEOUT;
        fatal = true;
        break;
      case 'level':
        details = errors["a" /* ErrorDetails */].LEVEL_LOAD_TIMEOUT;
        fatal = false;
        break;
      case 'audioTrack':
        details = errors["a" /* ErrorDetails */].AUDIO_TRACK_LOAD_TIMEOUT;
        fatal = false;
        break;
    }
    if (loader) {
      loader.abort();
      this.loaders[context.type] = undefined;
    }
    this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context, networkDetails: networkDetails });
  };

  return PlaylistLoader;
}(event_handler);

/* harmony default export */ var playlist_loader = (playlist_loader_PlaylistLoader);
// CONCATENATED MODULE: ./src/loader/fragment-loader.js
function fragment_loader__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function fragment_loader__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function fragment_loader__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Fragment Loader
*/






var fragment_loader_FragmentLoader = function (_EventHandler) {
  fragment_loader__inherits(FragmentLoader, _EventHandler);

  function FragmentLoader(hls) {
    fragment_loader__classCallCheck(this, FragmentLoader);

    var _this = fragment_loader__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].FRAG_LOADING));

    _this.loaders = {};
    return _this;
  }

  FragmentLoader.prototype.destroy = function destroy() {
    var loaders = this.loaders;
    for (var loaderName in loaders) {
      var loader = loaders[loaderName];
      if (loader) {
        loader.destroy();
      }
    }
    this.loaders = {};
    event_handler.prototype.destroy.call(this);
  };

  FragmentLoader.prototype.onFragLoading = function onFragLoading(data) {
    var frag = data.frag,
        type = frag.type,
        loader = this.loaders[type],
        config = this.hls.config;

    frag.loaded = 0;
    if (loader) {
      logger["b" /* logger */].warn('abort previous fragment loader for type:' + type);
      loader.abort();
    }
    loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);

    var loaderContext = void 0,
        loaderConfig = void 0,
        loaderCallbacks = void 0;
    loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
    var start = frag.byteRangeStartOffset,
        end = frag.byteRangeEndOffset;
    if (!isNaN(start) && !isNaN(end)) {
      loaderContext.rangeStart = start;
      loaderContext.rangeEnd = end;
    }
    loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
    loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
    loader.load(loaderContext, loaderConfig, loaderCallbacks);
  };

  FragmentLoader.prototype.loadsuccess = function loadsuccess(response, stats, context) {
    var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    var payload = response.data,
        frag = context.frag;
    // detach fragment loader on load success
    frag.loader = undefined;
    this.loaders[frag.type] = undefined;
    this.hls.trigger(events["a" /* default */].FRAG_LOADED, { payload: payload, frag: frag, stats: stats, networkDetails: networkDetails });
  };

  FragmentLoader.prototype.loaderror = function loaderror(response, context) {
    var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var loader = context.loader;
    if (loader) {
      loader.abort();
    }
    this.loaders[context.type] = undefined;
    this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: errors["a" /* ErrorDetails */].FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response, networkDetails: networkDetails });
  };

  FragmentLoader.prototype.loadtimeout = function loadtimeout(stats, context) {
    var networkDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    var loader = context.loader;
    if (loader) {
      loader.abort();
    }
    this.loaders[context.type] = undefined;
    this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: errors["a" /* ErrorDetails */].FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag, networkDetails: networkDetails });
  };

  // data will be used for progressive parsing


  FragmentLoader.prototype.loadprogress = function loadprogress(stats, context, data) {
    var networkDetails = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    // jshint ignore:line
    var frag = context.frag;
    frag.loaded = stats.loaded;
    this.hls.trigger(events["a" /* default */].FRAG_LOAD_PROGRESS, { frag: frag, stats: stats, networkDetails: networkDetails });
  };

  return FragmentLoader;
}(event_handler);

/* harmony default export */ var fragment_loader = (fragment_loader_FragmentLoader);
// CONCATENATED MODULE: ./src/loader/key-loader.js
function key_loader__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function key_loader__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function key_loader__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Decrypt key Loader
*/






var key_loader_KeyLoader = function (_EventHandler) {
  key_loader__inherits(KeyLoader, _EventHandler);

  function KeyLoader(hls) {
    key_loader__classCallCheck(this, KeyLoader);

    var _this = key_loader__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].KEY_LOADING));

    _this.loaders = {};
    _this.decryptkey = null;
    _this.decrypturl = null;
    return _this;
  }

  KeyLoader.prototype.destroy = function destroy() {
    for (var loaderName in this.loaders) {
      var loader = this.loaders[loaderName];
      if (loader) {
        loader.destroy();
      }
    }
    this.loaders = {};
    event_handler.prototype.destroy.call(this);
  };

  KeyLoader.prototype.onKeyLoading = function onKeyLoading(data) {
    var frag = data.frag,
        type = frag.type,
        loader = this.loaders[type],
        decryptdata = frag.decryptdata,
        uri = decryptdata.uri;
    // if uri is different from previous one or if decrypt key not retrieved yet
    if (uri !== this.decrypturl || this.decryptkey === null) {
      var config = this.hls.config;

      if (loader) {
        logger["b" /* logger */].warn('abort previous key loader for type:' + type);
        loader.abort();
      }
      frag.loader = this.loaders[type] = new config.loader(config);
      this.decrypturl = uri;
      this.decryptkey = null;

      var loaderContext = void 0,
          loaderConfig = void 0,
          loaderCallbacks = void 0;
      loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
      loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
      loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
      frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
    } else if (this.decryptkey) {
      // we already loaded this key, return it
      decryptdata.key = this.decryptkey;
      this.hls.trigger(events["a" /* default */].KEY_LOADED, { frag: frag });
    }
  };

  KeyLoader.prototype.loadsuccess = function loadsuccess(response, stats, context) {
    var frag = context.frag;
    this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
    // detach fragment loader on load success
    frag.loader = undefined;
    this.loaders[frag.type] = undefined;
    this.hls.trigger(events["a" /* default */].KEY_LOADED, { frag: frag });
  };

  KeyLoader.prototype.loaderror = function loaderror(response, context) {
    var frag = context.frag,
        loader = frag.loader;
    if (loader) {
      loader.abort();
    }
    this.loaders[context.type] = undefined;
    this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: errors["a" /* ErrorDetails */].KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
  };

  KeyLoader.prototype.loadtimeout = function loadtimeout(stats, context) {
    var frag = context.frag,
        loader = frag.loader;
    if (loader) {
      loader.abort();
    }
    this.loaders[context.type] = undefined;
    this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].NETWORK_ERROR, details: errors["a" /* ErrorDetails */].KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
  };

  return KeyLoader;
}(event_handler);

/* harmony default export */ var key_loader = (key_loader_KeyLoader);
// CONCATENATED MODULE: ./src/utils/binary-search.js
var BinarySearch = {
    /**
     * Searches for an item in an array which matches a certain condition.
     * This requires the condition to only match one item in the array,
     * and for the array to be ordered.
     *
     * @param {Array} list The array to search.
     * @param {Function} comparisonFunction
     *      Called and provided a candidate item as the first argument.
     *      Should return:
     *          > -1 if the item should be located at a lower index than the provided item.
     *          > 1 if the item should be located at a higher index than the provided item.
     *          > 0 if the item is the item you're looking for.
     *
     * @return {*} The object if it is found or null otherwise.
     */
    search: function search(list, comparisonFunction) {
        var minIndex = 0;
        var maxIndex = list.length - 1;
        var currentIndex = null;
        var currentElement = null;

        while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];

            var comparisonResult = comparisonFunction(currentElement);
            if (comparisonResult > 0) {
                minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
                maxIndex = currentIndex - 1;
            } else {
                return currentElement;
            }
        }

        return null;
    }
};

/* harmony default export */ var binary_search = (BinarySearch);
// CONCATENATED MODULE: ./src/helper/buffer-helper.js
/**
 * Buffer Helper utils, providing methods dealing buffer length retrieval
*/

var BufferHelper = {
  isBuffered: function isBuffered(media, position) {
    try {
      if (media) {
        var buffered = media.buffered;
        for (var i = 0; i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
    } catch (error) {
      // this is to catch
      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
      // This SourceBuffer has been removed from the parent media source
    }
    return false;
  },

  bufferInfo: function bufferInfo(media, pos, maxHoleDuration) {
    try {
      if (media) {
        var vbuffered = media.buffered,
            buffered = [],
            i;
        for (i = 0; i < vbuffered.length; i++) {
          buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
        }
        return this.bufferedInfo(buffered, pos, maxHoleDuration);
      }
    } catch (error) {
      // this is to catch
      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':
      // This SourceBuffer has been removed from the parent media source
    }
    return { len: 0, start: pos, end: pos, nextStart: undefined };
  },

  bufferedInfo: function bufferedInfo(buffered, pos, maxHoleDuration) {
    var buffered2 = [],

    // bufferStart and bufferEnd are buffer boundaries around current video position
    bufferLen,
        bufferStart,
        bufferEnd,
        bufferStartNext,
        i;
    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
    buffered.sort(function (a, b) {
      var diff = a.start - b.start;
      if (diff) {
        return diff;
      } else {
        return b.end - a.end;
      }
    });
    // there might be some small holes between buffer time range
    // consider that holes smaller than maxHoleDuration are irrelevant and build another
    // buffer time range representations that discards those holes
    for (i = 0; i < buffered.length; i++) {
      var buf2len = buffered2.length;
      if (buf2len) {
        var buf2end = buffered2[buf2len - 1].end;
        // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
        if (buffered[i].start - buf2end < maxHoleDuration) {
          // merge overlapping time ranges
          // update lastRange.end only if smaller than item.end
          // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
          // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
          if (buffered[i].end > buf2end) {
            buffered2[buf2len - 1].end = buffered[i].end;
          }
        } else {
          // big hole
          buffered2.push(buffered[i]);
        }
      } else {
        // first value
        buffered2.push(buffered[i]);
      }
    }
    for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
      var start = buffered2[i].start,
          end = buffered2[i].end;
      //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
      if (pos + maxHoleDuration >= start && pos < end) {
        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
        bufferStart = start;
        bufferEnd = end;
        bufferLen = bufferEnd - pos;
      } else if (pos + maxHoleDuration < start) {
        bufferStartNext = start;
        break;
      }
    }
    return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
  }
};

/* harmony default export */ var buffer_helper = (BufferHelper);
// EXTERNAL MODULE: ./src/demux/demuxer-inline.js + 12 modules
var demuxer_inline = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/events/events.js
var events_events = __webpack_require__(5);
var events_default = /*#__PURE__*/__webpack_require__.n(events_events);

// EXTERNAL MODULE: ./node_modules/webworkify-webpack/index.js
var webworkify_webpack = __webpack_require__(9);
var webworkify_webpack_default = /*#__PURE__*/__webpack_require__.n(webworkify_webpack);

// CONCATENATED MODULE: ./src/helper/mediasource-helper.js
/**
 * MediaSource helper
 */

function getMediaSource() {
  if (typeof window !== 'undefined') {
    return window.MediaSource || window.WebKitMediaSource;
  }
}
// CONCATENATED MODULE: ./src/demux/demuxer.js
function demuxer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }









var demuxer_MediaSource = getMediaSource();

var demuxer_Demuxer = function () {
  function Demuxer(hls, id) {
    demuxer__classCallCheck(this, Demuxer);

    this.hls = hls;
    this.id = id;
    // observer setup
    var observer = this.observer = new events_default.a();
    var config = hls.config;
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };

    var forwardMessage = function (ev, data) {
      data = data || {};
      data.frag = this.frag;
      data.id = this.id;
      hls.trigger(ev, data);
    }.bind(this);

    // forward events to main thread
    observer.on(events["a" /* default */].FRAG_DECRYPTED, forwardMessage);
    observer.on(events["a" /* default */].FRAG_PARSING_INIT_SEGMENT, forwardMessage);
    observer.on(events["a" /* default */].FRAG_PARSING_DATA, forwardMessage);
    observer.on(events["a" /* default */].FRAG_PARSED, forwardMessage);
    observer.on(events["a" /* default */].ERROR, forwardMessage);
    observer.on(events["a" /* default */].FRAG_PARSING_METADATA, forwardMessage);
    observer.on(events["a" /* default */].FRAG_PARSING_USERDATA, forwardMessage);
    observer.on(events["a" /* default */].INIT_PTS_FOUND, forwardMessage);

    var typeSupported = {
      mp4: demuxer_MediaSource.isTypeSupported('video/mp4'),
      mpeg: demuxer_MediaSource.isTypeSupported('audio/mpeg'),
      mp3: demuxer_MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
    };
    // navigator.vendor is not always available in Web Worker
    // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
    var vendor = navigator.vendor;
    if (config.enableWorker && typeof Worker !== 'undefined') {
      logger["b" /* logger */].log('demuxing in webworker');
      var w = void 0;
      try {
        w = this.w = webworkify_webpack_default()(/*require.resolve*/(10));
        this.onwmsg = this.onWorkerMessage.bind(this);
        w.addEventListener('message', this.onwmsg);
        w.onerror = function (event) {
          hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].OTHER_ERROR, details: errors["a" /* ErrorDetails */].INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
        };
        w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
      } catch (err) {
        logger["b" /* logger */].error('error while initializing DemuxerWorker, fallback on DemuxerInline');
        if (w) {
          // revoke the Object URL that was used to create demuxer worker, so as not to leak it
          URL.revokeObjectURL(w.objectURL);
        }
        this.demuxer = new demuxer_inline["a" /* default */](observer, typeSupported, config, vendor);
        this.w = undefined;
      }
    } else {
      this.demuxer = new demuxer_inline["a" /* default */](observer, typeSupported, config, vendor);
    }
  }

  Demuxer.prototype.destroy = function destroy() {
    var w = this.w;
    if (w) {
      w.removeEventListener('message', this.onwmsg);
      w.terminate();
      this.w = null;
    } else {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.destroy();
        this.demuxer = null;
      }
    }
    var observer = this.observer;
    if (observer) {
      observer.removeAllListeners();
      this.observer = null;
    }
  };

  Demuxer.prototype.push = function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
    var w = this.w;
    var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;
    var decryptdata = frag.decryptdata;
    var lastFrag = this.frag;
    var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
    var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
    var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
    var contiguous = !trackSwitch && nextSN;
    if (discontinuity) {
      logger["b" /* logger */].log(this.id + ':discontinuity detected');
    }
    if (trackSwitch) {
      logger["b" /* logger */].log(this.id + ':switch detected');
    }
    this.frag = frag;
    if (w) {
      // post fragment payload as transferable objects for ArrayBuffer (no copy)
      w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, data instanceof ArrayBuffer ? [data] : []);
    } else {
      var demuxer = this.demuxer;
      if (demuxer) {
        demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
      }
    }
  };

  Demuxer.prototype.onWorkerMessage = function onWorkerMessage(ev) {
    var data = ev.data,
        hls = this.hls;
    //console.log('onWorkerMessage:' + data.event);
    switch (data.event) {
      case 'init':
        // revoke the Object URL that was used to create demuxer worker, so as not to leak it
        URL.revokeObjectURL(this.w.objectURL);
        break;
      // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
      case events["a" /* default */].FRAG_PARSING_DATA:
        data.data.data1 = new Uint8Array(data.data1);
        if (data.data2) {
          data.data.data2 = new Uint8Array(data.data2);
        }
      /* falls through */
      default:
        data.data = data.data || {};
        data.data.frag = this.frag;
        data.data.id = this.id;
        hls.trigger(data.event, data.data);
        break;
    }
  };

  return Demuxer;
}();

/* harmony default export */ var demux_demuxer = (demuxer_Demuxer);
// CONCATENATED MODULE: ./src/helper/level-helper.js
/**
 * Level Helper class, providing methods dealing with playlist sliding and drift
*/



function updatePTS(fragments, fromIdx, toIdx) {
  var fragFrom = fragments[fromIdx],
      fragTo = fragments[toIdx],
      fragToPTS = fragTo.startPTS;
  // if we know startPTS[toIdx]
  if (!isNaN(fragToPTS)) {
    // update fragment duration.
    // it helps to fix drifts between playlist reported duration and fragment real duration
    if (toIdx > fromIdx) {
      fragFrom.duration = fragToPTS - fragFrom.start;
      if (fragFrom.duration < 0) {
        logger["b" /* logger */].warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
      }
    } else {
      fragTo.duration = fragFrom.start - fragToPTS;
      if (fragTo.duration < 0) {
        logger["b" /* logger */].warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
      }
    }
  } else {
    // we dont know startPTS[toIdx]
    if (toIdx > fromIdx) {
      fragTo.start = fragFrom.start + fragFrom.duration;
    } else {
      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
    }
  }
}

function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  // update frag PTS/DTS
  var maxStartPTS = startPTS;
  if (!isNaN(frag.startPTS)) {
    // delta PTS between audio and video
    var deltaPTS = Math.abs(frag.startPTS - startPTS);
    if (isNaN(frag.deltaPTS)) {
      frag.deltaPTS = deltaPTS;
    } else {
      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
    }
    maxStartPTS = Math.max(startPTS, frag.startPTS);
    startPTS = Math.min(startPTS, frag.startPTS);
    endPTS = Math.max(endPTS, frag.endPTS);
    startDTS = Math.min(startDTS, frag.startDTS);
    endDTS = Math.max(endDTS, frag.endDTS);
  }

  var drift = startPTS - frag.start;
  frag.start = frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.endPTS = endPTS;
  frag.startDTS = startDTS;
  frag.endDTS = endDTS;
  frag.duration = endPTS - startPTS;

  var sn = frag.sn;
  // exit if sn out of range
  if (!details || sn < details.startSN || sn > details.endSN) {
    return 0;
  }
  var fragIdx, fragments, i;
  fragIdx = sn - details.startSN;
  fragments = details.fragments;
  // update frag reference in fragments array
  // rationale is that fragments array might not contain this frag object.
  // this will happpen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()
  // if we don't update frag, we won't be able to propagate PTS info on the playlist
  // resulting in invalid sliding computation
  fragments[fragIdx] = frag;
  // adjust fragment PTS/duration from seqnum-1 to frag 0
  for (i = fragIdx; i > 0; i--) {
    updatePTS(fragments, i, i - 1);
  }

  // adjust fragment PTS/duration from seqnum to last frag
  for (i = fragIdx; i < fragments.length - 1; i++) {
    updatePTS(fragments, i, i + 1);
  }
  details.PTSKnown = true;
  //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);

  return drift;
}

function mergeDetails(oldDetails, newDetails) {
  var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
      end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
      delta = newDetails.startSN - oldDetails.startSN,
      oldfragments = oldDetails.fragments,
      newfragments = newDetails.fragments,
      ccOffset = 0,
      PTSFrag;

  // check if old/new playlists have fragments in common
  if (end < start) {
    newDetails.PTSKnown = false;
    return;
  }
  // loop through overlapping SN and update startPTS , cc, and duration if any found
  for (var i = start; i <= end; i++) {
    var oldFrag = oldfragments[delta + i],
        newFrag = newfragments[i];
    if (newFrag && oldFrag) {
      ccOffset = oldFrag.cc - newFrag.cc;
      if (!isNaN(oldFrag.startPTS)) {
        newFrag.start = newFrag.startPTS = oldFrag.startPTS;
        newFrag.endPTS = oldFrag.endPTS;
        newFrag.duration = oldFrag.duration;
        newFrag.backtracked = oldFrag.backtracked;
        newFrag.dropped = oldFrag.dropped;
        PTSFrag = newFrag;
      }
    }
  }

  if (ccOffset) {
    logger["b" /* logger */].log('discontinuity sliding from playlist, take drift into account');
    for (i = 0; i < newfragments.length; i++) {
      newfragments[i].cc += ccOffset;
    }
  }

  // if at least one fragment contains PTS info, recompute PTS information for all fragments
  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    // ensure that delta is within oldfragments range
    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
    // in that case we also need to adjust start offset of all fragments
    if (delta >= 0 && delta < oldfragments.length) {
      // adjust start by sliding offset
      var sliding = oldfragments[delta].start;
      for (i = 0; i < newfragments.length; i++) {
        newfragments[i].start += sliding;
      }
    }
  }
  // if we are here, it means we have fragments overlapping between
  // old and new level. reliable PTS info is thus relying on old level
  newDetails.PTSKnown = oldDetails.PTSKnown;
}
// CONCATENATED MODULE: ./src/utils/timeRanges.js
/**
 *  TimeRanges to string helper
 */

var TimeRanges = {
  toString: function toString(r) {
    var log = '',
        len = r.length;
    for (var i = 0; i < len; i++) {
      log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
    }
    return log;
  }
};

/* harmony default export */ var timeRanges = (TimeRanges);
// CONCATENATED MODULE: ./src/utils/discontinuities.js



function findFirstFragWithCC(fragments, cc) {
  var firstFrag = null;

  for (var i = 0; i < fragments.length; i += 1) {
    var currentFrag = fragments[i];
    if (currentFrag && currentFrag.cc === cc) {
      firstFrag = currentFrag;
      break;
    }
  }

  return firstFrag;
}

function findFragWithCC(fragments, CC) {
  return binary_search.search(fragments, function (candidate) {
    if (candidate.cc < CC) {
      return 1;
    } else if (candidate.cc > CC) {
      return -1;
    } else {
      return 0;
    }
  });
}

function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
  var shouldAlign = false;
  if (lastLevel && lastLevel.details && details) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      shouldAlign = true;
    }
  }
  return shouldAlign;
}

// Find the first frag in the previous level which matches the CC of the first frag of the new level
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  var prevFrags = prevDetails.fragments;
  var curFrags = curDetails.fragments;

  if (!curFrags.length || !prevFrags.length) {
    logger["b" /* logger */].log('No fragments to align');
    return;
  }

  var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);

  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    logger["b" /* logger */].log('No frag in previous level to align on');
    return;
  }

  return prevStartFrag;
}

function adjustPts(sliding, details) {
  details.fragments.forEach(function (frag) {
    if (frag) {
      var start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  });
  details.PTSKnown = true;
}

// If a change in CC is detected, the PTS can no longer be relied upon
// Attempt to align the level by using the last level - find the last frag matching the current CC and use it's PTS
// as a reference
function alignDiscontinuities(lastFrag, lastLevel, details) {
  if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
    var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
    if (referenceFrag) {
      logger["b" /* logger */].log('Adjusting PTS using last level due to CC increase within current level');
      adjustPts(referenceFrag.start, details);
    }
  }
  // try to align using programDateTime attribute (if available)
  if (details.PTSKnown === false && lastLevel && lastLevel.details) {
    // if last level sliding is 1000 and its first frag PROGRAM-DATE-TIME is 2017-08-20 1:10:00 AM
    // and if new details first frag PROGRAM DATE-TIME is 2017-08-20 1:10:08 AM
    // then we can deduce that playlist B sliding is 1000+8 = 1008s
    var lastPDT = lastLevel.details.programDateTime;
    var newPDT = details.programDateTime;
    // date diff is in ms. frag.start is in seconds
    var sliding = (newPDT - lastPDT) / 1000 + lastLevel.details.fragments[0].start;
    if (!isNaN(sliding)) {
      logger["b" /* logger */].log('adjusting PTS using programDateTime delta, sliding:' + sliding.toFixed(3));
      adjustPts(sliding, details);
    }
  }
}
// CONCATENATED MODULE: ./src/controller/stream-controller.js
var stream_controller__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function stream_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function stream_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function stream_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Stream Controller
*/












var State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_LEVEL: 'WAITING_LEVEL',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR'
};

var stream_controller_StreamController = function (_EventHandler) {
  stream_controller__inherits(StreamController, _EventHandler);

  function StreamController(hls) {
    stream_controller__classCallCheck(this, StreamController);

    var _this = stream_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MEDIA_ATTACHED, events["a" /* default */].MEDIA_DETACHING, events["a" /* default */].MANIFEST_LOADING, events["a" /* default */].MANIFEST_PARSED, events["a" /* default */].LEVEL_LOADED, events["a" /* default */].KEY_LOADED, events["a" /* default */].FRAG_LOADED, events["a" /* default */].FRAG_LOAD_EMERGENCY_ABORTED, events["a" /* default */].FRAG_PARSING_INIT_SEGMENT, events["a" /* default */].FRAG_PARSING_DATA, events["a" /* default */].FRAG_PARSED, events["a" /* default */].ERROR, events["a" /* default */].AUDIO_TRACK_SWITCHING, events["a" /* default */].AUDIO_TRACK_SWITCHED, events["a" /* default */].BUFFER_CREATED, events["a" /* default */].BUFFER_APPENDED, events["a" /* default */].BUFFER_FLUSHED));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this._state = State.STOPPED;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  StreamController.prototype.destroy = function destroy() {
    this.stopLoad();
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
    event_handler.prototype.destroy.call(this);
    this.state = State.STOPPED;
  };

  StreamController.prototype.startLoad = function startLoad(startPosition) {
    if (this.levels) {
      var lastCurrentTime = this.lastCurrentTime,
          hls = this.hls;
      this.stopLoad();
      if (!this.timer) {
        this.timer = setInterval(this.ontick, 100);
      }
      this.level = -1;
      this.fragLoadError = 0;
      if (!this.startFragRequested) {
        // determine load level
        var startLevel = hls.startLevel;
        if (startLevel === -1) {
          // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
          startLevel = 0;
          this.bitrateTest = true;
        }
        // set new level to playlist loader : this will trigger start level load
        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
        this.level = hls.nextLoadLevel = startLevel;
        this.loadedmetadata = false;
      }
      // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
      if (lastCurrentTime > 0 && startPosition === -1) {
        logger["b" /* logger */].log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
        startPosition = lastCurrentTime;
      }
      this.state = State.IDLE;
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
      this.tick();
    } else {
      this.forceStartLoad = true;
      this.state = State.STOPPED;
    }
  };

  StreamController.prototype.stopLoad = function stopLoad() {
    var frag = this.fragCurrent;
    if (frag) {
      if (frag.loader) {
        frag.loader.abort();
      }
      this.fragCurrent = null;
    }
    this.fragPrevious = null;
    if (this.demuxer) {
      this.demuxer.destroy();
      this.demuxer = null;
    }
    this.state = State.STOPPED;
    this.forceStartLoad = false;
  };

  StreamController.prototype.tick = function tick() {
    this.ticks++;
    if (this.ticks === 1) {
      this.doTick();
      if (this.ticks > 1) {
        setTimeout(this.tick, 1);
      }
      this.ticks = 0;
    }
  };

  StreamController.prototype.doTick = function doTick() {
    switch (this.state) {
      case State.ERROR:
        //don't do anything in error state to avoid breaking further ...
        break;
      case State.BUFFER_FLUSHING:
        // in buffer flushing state, reset fragLoadError counter
        this.fragLoadError = 0;
        break;
      case State.IDLE:
        this._doTickIdle();
        break;
      case State.WAITING_LEVEL:
        var level = this.levels[this.level];
        // check if playlist is already loaded
        if (level && level.details) {
          this.state = State.IDLE;
        }
        break;
      case State.FRAG_LOADING_WAITING_RETRY:
        var now = performance.now();
        var retryDate = this.retryDate;
        // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
        if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
          logger["b" /* logger */].log('mediaController: retryDate reached, switch back to IDLE state');
          this.state = State.IDLE;
        }
        break;
      case State.ERROR:
      case State.STOPPED:
      case State.FRAG_LOADING:
      case State.PARSING:
      case State.PARSED:
      case State.ENDED:
        break;
      default:
        break;
    }
    // check buffer
    this._checkBuffer();
    // check/update current fragment
    this._checkFragmentChanged();
  };

  // Ironically the "idle" state is the on we do the most logic in it seems ....
  // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
  //       played segment, or on pause/play/seek instead of naively checking every 100ms?


  StreamController.prototype._doTickIdle = function _doTickIdle() {
    var hls = this.hls,
        config = hls.config,
        media = this.media;

    // if start level not parsed yet OR
    // if video not attached AND start fragment already requested OR start frag prefetch disable
    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment
    if (this.levelLastLoaded === undefined || !media && (this.startFragRequested || !config.startFragPrefetch)) {
      return;
    }

    // if we have not yet loaded any fragment, start loading from start position
    var pos = void 0;
    if (this.loadedmetadata) {
      pos = media.currentTime;
    } else {
      pos = this.nextLoadPosition;
    }
    // determine next load level
    var level = hls.nextLoadLevel,
        levelInfo = this.levels[level];

    if (!levelInfo) {
      return;
    }

    var levelBitrate = levelInfo.bitrate,
        maxBufLen = void 0;

    // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
    if (levelBitrate) {
      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
    } else {
      maxBufLen = config.maxBufferLength;
    }
    maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);

    // determine next candidate fragment to be loaded, based on current position and end of buffer position
    // ensure up to `config.maxMaxBufferLength` of buffer upfront

    var bufferInfo = buffer_helper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
        bufferLen = bufferInfo.len;
    // Stay idle if we are still with buffer margins
    if (bufferLen >= maxBufLen) {
      return;
    }

    // if buffer length is less than maxBufLen try to load a new fragment ...
    logger["b" /* logger */].trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');

    // set next load level : this will trigger a playlist load if needed
    this.level = hls.nextLoadLevel = level;

    var levelDetails = levelInfo.details;
    // if level info not retrieved yet, switch state and wait for level retrieval
    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
    if (levelDetails === undefined || levelDetails.live === true && this.levelLastLoaded !== level) {
      this.state = State.WAITING_LEVEL;
      return;
    }

    // we just got done loading the final fragment and there is no other buffered range after ...
    // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
    // so we should not switch to ENDED in that case, to be able to buffer them
    // dont switch to ENDED if we need to backtrack last fragment
    var fragPrevious = this.fragPrevious;
    if (!levelDetails.live && fragPrevious && !fragPrevious.backtracked && fragPrevious.sn === levelDetails.endSN && !bufferInfo.nextStart) {
      // fragPrevious is last fragment. retrieve level duration using last frag start offset + duration
      // real duration might be lower than initial duration if there are drifts between real frag duration and playlist signaling
      var duration = Math.min(media.duration, fragPrevious.start + fragPrevious.duration);
      // if everything (almost) til the end is buffered, let's signal eos
      // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference (audio/video offsets...)
      // tolerate up to one frag duration to cope with these cases.
      // also cope with almost zero last frag duration (max last frag duration with 200ms) refer to https://github.com/video-dev/hls.js/pull/657
      if (duration - Math.max(bufferInfo.end, fragPrevious.start) <= Math.max(0.2, fragPrevious.duration)) {
        // Finalize the media stream
        var data = {};
        if (this.altAudio) {
          data.type = 'video';
        }
        this.hls.trigger(events["a" /* default */].BUFFER_EOS, data);
        this.state = State.ENDED;
        return;
      }
    }

    // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
    this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
  };

  StreamController.prototype._fetchPayloadOrEos = function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
    var fragPrevious = this.fragPrevious,
        level = this.level,
        fragments = levelDetails.fragments,
        fragLen = fragments.length;

    // empty playlist
    if (fragLen === 0) {
      return;
    }

    // find fragment index, contiguous with end of buffer position
    var start = fragments[0].start,
        end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
        bufferEnd = bufferInfo.end,
        frag = void 0;

    if (levelDetails.initSegment && !levelDetails.initSegment.data) {
      frag = levelDetails.initSegment;
    } else {
      // in case of live playlist we need to ensure that requested position is not located before playlist start
      if (levelDetails.live) {
        var initialLiveManifestSize = this.config.initialLiveManifestSize;
        if (fragLen < initialLiveManifestSize) {
          logger["b" /* logger */].warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
          return;
        }

        frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
        // if it explicitely returns null don't load any fragment and exit function now
        if (frag === null) {
          return;
        }
      } else {
        // VoD playlist: if bufferEnd before start of playlist, load first fragment
        if (bufferEnd < start) {
          frag = fragments[0];
        }
      }
    }
    if (!frag) {
      frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
    }
    if (frag) {
      this._loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd);
    }
    return;
  };

  StreamController.prototype._ensureFragmentAtLivePoint = function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
    var config = this.hls.config,
        media = this.media;

    var frag = void 0;

    // check if requested position is within seekable boundaries :
    //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
    var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;

    if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
      var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
      logger["b" /* logger */].log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
      bufferEnd = liveSyncPosition;
      if (media && media.readyState && media.duration > liveSyncPosition) {
        media.currentTime = liveSyncPosition;
      }
      this.nextLoadPosition = liveSyncPosition;
    }

    // if end of buffer greater than live edge, don't load any fragment
    // this could happen if live playlist intermittently slides in the past.
    // level 1 loaded [182580161,182580167]
    // level 1 loaded [182580162,182580169]
    // Loading 182580168 of [182580162 ,182580169],level 1 ..
    // Loading 182580169 of [182580162 ,182580169],level 1 ..
    // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
    // level 1 loaded [182580164,182580171]
    //
    // don't return null in case media not loaded yet (readystate === 0)
    if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
      return null;
    }

    if (this.startFragRequested && !levelDetails.PTSKnown) {
      /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
         try to load frag matching with next SN.
         even if SN are not synchronized between playlists, loading this frag will help us
         compute playlist sliding and find the right one after in case it was not the right consecutive one */
      if (fragPrevious) {
        var targetSN = fragPrevious.sn + 1;
        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
          var fragNext = fragments[targetSN - levelDetails.startSN];
          if (fragPrevious.cc === fragNext.cc) {
            frag = fragNext;
            logger["b" /* logger */].log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
          }
        }
        // next frag SN not available (or not with same continuity counter)
        // look for a frag sharing the same CC
        if (!frag) {
          frag = binary_search.search(fragments, function (frag) {
            return fragPrevious.cc - frag.cc;
          });
          if (frag) {
            logger["b" /* logger */].log('live playlist, switching playlist, load frag with same CC: ' + frag.sn);
          }
        }
      }
      if (!frag) {
        /* we have no idea about which fragment should be loaded.
           so let's load mid fragment. it will help computing playlist sliding and find the right one
        */
        frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
        logger["b" /* logger */].log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
      }
    }
    return frag;
  };

  StreamController.prototype._findFragment = function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
    var config = this.hls.config;
    var frag = void 0;
    var foundFrag = void 0;
    var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
    var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
    var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
      // offset should be within fragment boundary - config.maxFragLookUpTolerance
      // this is to cope with situations like
      // bufferEnd = 9.991
      // frag[Ø] : [0,10]
      // frag[1] : [10,20]
      // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
      //              frag start               frag start+duration
      //                  |-----------------------------|
      //              <--->                         <--->
      //  ...--------><-----------------------------><---------....
      // previous frag         matching fragment         next frag
      //  return -1             return 0                 return 1
      //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
      // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
      if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
        return 1;
      } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
      else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
          return -1;
        }
      return 0;
    };

    if (bufferEnd < end) {
      if (bufferEnd > end - maxFragLookUpTolerance) {
        maxFragLookUpTolerance = 0;
      }
      // Prefer the next fragment if it's within tolerance
      if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
        foundFrag = fragNext;
      } else {
        foundFrag = binary_search.search(fragments, fragmentWithinToleranceTest);
      }
    } else {
      // reach end of playlist
      foundFrag = fragments[fragLen - 1];
    }
    if (foundFrag) {
      frag = foundFrag;
      var curSNIdx = frag.sn - levelDetails.startSN;
      var sameLevel = fragPrevious && frag.level === fragPrevious.level;
      var prevFrag = fragments[curSNIdx - 1];
      var nextFrag = fragments[curSNIdx + 1];
      //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
      if (fragPrevious && frag.sn === fragPrevious.sn) {
        if (sameLevel && !frag.backtracked) {
          if (frag.sn < levelDetails.endSN) {
            var deltaPTS = fragPrevious.deltaPTS;
            // if there is a significant delta between audio and video, larger than max allowed hole,
            // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
            // let's try to load previous fragment again to get last keyframe
            // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
            if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
              frag = prevFrag;
              logger["b" /* logger */].warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
              // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
              fragPrevious.loadCounter--;
            } else {
              frag = nextFrag;
              logger["b" /* logger */].log('SN just loaded, load next one: ' + frag.sn);
            }
          } else {
            frag = null;
          }
        } else if (frag.backtracked) {
          // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
          if (nextFrag && nextFrag.backtracked) {
            logger["b" /* logger */].warn('Already backtracked from fragment ' + nextFrag.sn + ', will not backtrack to fragment ' + frag.sn + '. Loading fragment ' + nextFrag.sn);
            frag = nextFrag;
          } else {
            // If a fragment has dropped frames and it's in a same level/sequence, load the previous fragment to try and find the keyframe
            // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
            logger["b" /* logger */].warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
            frag.dropped = 0;
            if (prevFrag) {
              if (prevFrag.loadCounter) {
                prevFrag.loadCounter--;
              }
              frag = prevFrag;
              frag.backtracked = true;
            } else if (curSNIdx) {
              // can't backtrack on very first fragment
              frag = null;
            }
          }
        }
      }
    }
    return frag;
  };

  StreamController.prototype._loadFragmentOrKey = function _loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd) {
    var hls = this.hls,
        config = hls.config;

    //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
    if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
      logger["b" /* logger */].log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
      this.state = State.KEY_LOADING;
      hls.trigger(events["a" /* default */].KEY_LOADING, { frag: frag });
    } else {
      logger["b" /* logger */].log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
      // ensure that we are not reloading the same fragments in loop ...
      if (this.fragLoadIdx !== undefined) {
        this.fragLoadIdx++;
      } else {
        this.fragLoadIdx = 0;
      }
      if (frag.loadCounter) {
        frag.loadCounter++;
        var maxThreshold = config.fragLoadingLoopThreshold;
        // if this frag has already been loaded 3 times, and if it has been reloaded recently
        if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
          hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
          return;
        }
      } else {
        frag.loadCounter = 1;
      }
      frag.loadIdx = this.fragLoadIdx;
      frag.autoLevel = hls.autoLevelEnabled;
      frag.bitrateTest = this.bitrateTest;

      this.fragCurrent = frag;
      this.startFragRequested = true;
      // Don't update nextLoadPosition for fragments which are not buffered
      if (!isNaN(frag.sn) && !frag.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }
      hls.trigger(events["a" /* default */].FRAG_LOADING, { frag: frag });
      // lazy demuxer init, as this could take some time ... do it during frag loading
      if (!this.demuxer) {
        this.demuxer = new demux_demuxer(hls, 'main');
      }
      this.state = State.FRAG_LOADING;
      return;
    }
  };

  StreamController.prototype.getBufferedFrag = function getBufferedFrag(position) {
    return binary_search.search(this._bufferedFrags, function (frag) {
      if (position < frag.startPTS) {
        return -1;
      } else if (position > frag.endPTS) {
        return 1;
      }
      return 0;
    });
  };

  StreamController.prototype.followingBufferedFrag = function followingBufferedFrag(frag) {
    if (frag) {
      // try to get range of next fragment (500ms after this range)
      return this.getBufferedFrag(frag.endPTS + 0.5);
    }
    return null;
  };

  StreamController.prototype._checkFragmentChanged = function _checkFragmentChanged() {
    var fragPlayingCurrent,
        currentTime,
        video = this.media;
    if (video && video.readyState && video.seeking === false) {
      currentTime = video.currentTime;
      /* if video element is in seeked state, currentTime can only increase.
        (assuming that playback rate is positive ...)
        As sometimes currentTime jumps back to zero after a
        media decode error, check this, to avoid seeking back to
        wrong position after a media decode error
      */
      if (currentTime > video.playbackRate * this.lastCurrentTime) {
        this.lastCurrentTime = currentTime;
      }
      if (buffer_helper.isBuffered(video, currentTime)) {
        fragPlayingCurrent = this.getBufferedFrag(currentTime);
      } else if (buffer_helper.isBuffered(video, currentTime + 0.1)) {
        /* ensure that FRAG_CHANGED event is triggered at startup,
          when first video frame is displayed and playback is paused.
          add a tolerance of 100ms, in case current position is not buffered,
          check if current pos+100ms is buffered and use that buffer range
          for FRAG_CHANGED event reporting */
        fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
      }
      if (fragPlayingCurrent) {
        var fragPlaying = fragPlayingCurrent;
        if (fragPlaying !== this.fragPlaying) {
          this.hls.trigger(events["a" /* default */].FRAG_CHANGED, { frag: fragPlaying });
          var fragPlayingLevel = fragPlaying.level;
          if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
            this.hls.trigger(events["a" /* default */].LEVEL_SWITCHED, { level: fragPlayingLevel });
          }
          this.fragPlaying = fragPlaying;
        }
      }
    }
  };

  /*
    on immediate level switch :
     - pause playback if playing
     - cancel any pending load request
     - and trigger a buffer flush
  */


  StreamController.prototype.immediateLevelSwitch = function immediateLevelSwitch() {
    logger["b" /* logger */].log('immediateLevelSwitch');
    if (!this.immediateSwitch) {
      this.immediateSwitch = true;
      var media = this.media,
          previouslyPaused = void 0;
      if (media) {
        previouslyPaused = media.paused;
        media.pause();
      } else {
        // don't restart playback after instant level switch in case media not attached
        previouslyPaused = true;
      }
      this.previouslyPaused = previouslyPaused;
    }
    var fragCurrent = this.fragCurrent;
    if (fragCurrent && fragCurrent.loader) {
      fragCurrent.loader.abort();
    }
    this.fragCurrent = null;
    // increase fragment load Index to avoid frag loop loading error after buffer flush
    if (this.fragLoadIdx !== undefined) {
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
    }
    // flush everything
    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  };

  /*
     on immediate level switch end, after new fragment has been buffered :
      - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
      - resume the playback if needed
  */


  StreamController.prototype.immediateLevelSwitchEnd = function immediateLevelSwitchEnd() {
    var media = this.media;
    if (media && media.buffered.length) {
      this.immediateSwitch = false;
      if (buffer_helper.isBuffered(media, media.currentTime)) {
        // only nudge if currentTime is buffered
        media.currentTime -= 0.0001;
      }
      if (!this.previouslyPaused) {
        media.play();
      }
    }
  };

  StreamController.prototype.nextLevelSwitch = function nextLevelSwitch() {
    /* try to switch ASAP without breaking video playback :
       in order to ensure smooth but quick level switching,
      we need to find the next flushable buffer range
      we should take into account new segment fetch time
    */
    var media = this.media;
    // ensure that media is defined and that metadata are available (to retrieve currentTime)
    if (media && media.readyState) {
      var fetchdelay = void 0,
          fragPlayingCurrent = void 0,
          nextBufferedFrag = void 0;
      if (this.fragLoadIdx !== undefined) {
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
      fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
      if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
        // flush buffer preceding current fragment (flush until current fragment start offset)
        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
        this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
      }
      if (!media.paused) {
        // add a safety delay of 1s
        var nextLevelId = this.hls.nextLoadLevel,
            nextLevel = this.levels[nextLevelId],
            fragLastKbps = this.fragLastKbps;
        if (fragLastKbps && this.fragCurrent) {
          fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
        } else {
          fetchdelay = 0;
        }
      } else {
        fetchdelay = 0;
      }
      //logger.log('fetchdelay:'+fetchdelay);
      // find buffer range that will be reached once new fragment will be fetched
      nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
      if (nextBufferedFrag) {
        // we can flush buffer range following this one without stalling playback
        nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
        if (nextBufferedFrag) {
          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
          var fragCurrent = this.fragCurrent;
          if (fragCurrent && fragCurrent.loader) {
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          // start flush position is the start PTS of next buffered frag.
          // we use frag.naxStartPTS which is max(audio startPTS, video startPTS).
          // in case there is a small PTS Delta between audio and video, using maxStartPTS avoids flushing last samples from current fragment
          this.flushMainBuffer(nextBufferedFrag.maxStartPTS, Number.POSITIVE_INFINITY);
        }
      }
    }
  };

  StreamController.prototype.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {
    this.state = State.BUFFER_FLUSHING;
    var flushScope = { startOffset: startOffset, endOffset: endOffset };
    // if alternate audio tracks are used, only flush video, otherwise flush everything
    if (this.altAudio) {
      flushScope.type = 'video';
    }
    this.hls.trigger(events["a" /* default */].BUFFER_FLUSHING, flushScope);
  };

  StreamController.prototype.onMediaAttached = function onMediaAttached(data) {
    var media = this.media = this.mediaBuffer = data.media;
    this.onvseeking = this.onMediaSeeking.bind(this);
    this.onvseeked = this.onMediaSeeked.bind(this);
    this.onvended = this.onMediaEnded.bind(this);
    media.addEventListener('seeking', this.onvseeking);
    media.addEventListener('seeked', this.onvseeked);
    media.addEventListener('ended', this.onvended);
    var config = this.config;
    if (this.levels && config.autoStartLoad) {
      this.hls.startLoad(config.startPosition);
    }
  };

  StreamController.prototype.onMediaDetaching = function onMediaDetaching() {
    var media = this.media;
    if (media && media.ended) {
      logger["b" /* logger */].log('MSE detaching and video ended, reset startPosition');
      this.startPosition = this.lastCurrentTime = 0;
    }

    // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
    var levels = this.levels;
    if (levels) {
      // reset fragment load counter
      levels.forEach(function (level) {
        if (level.details) {
          level.details.fragments.forEach(function (fragment) {
            fragment.loadCounter = undefined;
            fragment.backtracked = undefined;
          });
        }
      });
    }
    // remove video listeners
    if (media) {
      media.removeEventListener('seeking', this.onvseeking);
      media.removeEventListener('seeked', this.onvseeked);
      media.removeEventListener('ended', this.onvended);
      this.onvseeking = this.onvseeked = this.onvended = null;
    }
    this.media = this.mediaBuffer = null;
    this.loadedmetadata = false;
    this.stopLoad();
  };

  StreamController.prototype.onMediaSeeking = function onMediaSeeking() {
    var media = this.media,
        currentTime = media ? media.currentTime : undefined,
        config = this.config;
    if (!isNaN(currentTime)) {
      logger["b" /* logger */].log('media seeking to ' + currentTime.toFixed(3));
    }
    var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
    var bufferInfo = buffer_helper.bufferInfo(mediaBuffer, currentTime, this.config.maxBufferHole);
    if (this.state === State.FRAG_LOADING) {
      var fragCurrent = this.fragCurrent;
      // check if we are seeking to a unbuffered area AND if frag loading is in progress
      if (bufferInfo.len === 0 && fragCurrent) {
        var tolerance = config.maxFragLookUpTolerance,
            fragStartOffset = fragCurrent.start - tolerance,
            fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
        // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
        if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
          if (fragCurrent.loader) {
            logger["b" /* logger */].log('seeking outside of buffer while fragment load in progress, cancel fragment load');
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          this.fragPrevious = null;
          // switch to IDLE state to load new fragment
          this.state = State.IDLE;
        } else {
          logger["b" /* logger */].log('seeking outside of buffer but within currently loaded fragment range');
        }
      }
    } else if (this.state === State.ENDED) {
      // if seeking to unbuffered area, clean up fragPrevious
      if (bufferInfo.len === 0) {
        this.fragPrevious = 0;
      }
      // switch to IDLE state to check for potential new fragment
      this.state = State.IDLE;
    }
    if (media) {
      this.lastCurrentTime = currentTime;
    }
    // avoid reporting fragment loop loading error in case user is seeking several times on same position
    if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
      this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
    }
    // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
    if (!this.loadedmetadata) {
      this.nextLoadPosition = this.startPosition = currentTime;
    }
    // tick to speed up processing
    this.tick();
  };

  StreamController.prototype.onMediaSeeked = function onMediaSeeked() {
    var media = this.media,
        currentTime = media ? media.currentTime : undefined;
    if (!isNaN(currentTime)) {
      logger["b" /* logger */].log('media seeked to ' + currentTime.toFixed(3));
    }
    // tick to speed up FRAGMENT_PLAYING triggering
    this.tick();
  };

  StreamController.prototype.onMediaEnded = function onMediaEnded() {
    logger["b" /* logger */].log('media ended');
    // reset startPosition and lastCurrentTime to restart playback @ stream beginning
    this.startPosition = this.lastCurrentTime = 0;
  };

  StreamController.prototype.onManifestLoading = function onManifestLoading() {
    // reset buffer on manifest loading
    logger["b" /* logger */].log('trigger BUFFER_RESET');
    this.hls.trigger(events["a" /* default */].BUFFER_RESET);
    this._bufferedFrags = [];
    this.stalled = false;
    this.startPosition = this.lastCurrentTime = 0;
  };

  StreamController.prototype.onManifestParsed = function onManifestParsed(data) {
    var aac = false,
        heaac = false,
        codec;
    data.levels.forEach(function (level) {
      // detect if we have different kind of audio codecs used amongst playlists
      codec = level.audioCodec;
      if (codec) {
        if (codec.indexOf('mp4a.40.2') !== -1) {
          aac = true;
        }
        if (codec.indexOf('mp4a.40.5') !== -1) {
          heaac = true;
        }
      }
    });
    this.audioCodecSwitch = aac && heaac;
    if (this.audioCodecSwitch) {
      logger["b" /* logger */].log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
    }
    this.levels = data.levels;
    this.startFragRequested = false;
    var config = this.config;
    if (config.autoStartLoad || this.forceStartLoad) {
      this.hls.startLoad(config.startPosition);
    }
  };

  StreamController.prototype.onLevelLoaded = function onLevelLoaded(data) {
    var newDetails = data.details;
    var newLevelId = data.level;
    var lastLevel = this.levels[this.levelLastLoaded];
    var curLevel = this.levels[newLevelId];
    var duration = newDetails.totalduration;
    var sliding = 0;

    logger["b" /* logger */].log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

    if (newDetails.live) {
      var curDetails = curLevel.details;
      if (curDetails && newDetails.fragments.length > 0) {
        // we already have details for that level, merge them
        mergeDetails(curDetails, newDetails);
        sliding = newDetails.fragments[0].start;
        this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
        if (newDetails.PTSKnown && !isNaN(sliding)) {
          logger["b" /* logger */].log('live playlist sliding:' + sliding.toFixed(3));
        } else {
          logger["b" /* logger */].log('live playlist - outdated PTS, unknown sliding');
          alignDiscontinuities(this.fragPrevious, lastLevel, newDetails);
        }
      } else {
        logger["b" /* logger */].log('live playlist - first load, unknown sliding');
        newDetails.PTSKnown = false;
        alignDiscontinuities(this.fragPrevious, lastLevel, newDetails);
      }
    } else {
      newDetails.PTSKnown = false;
    }
    // override level info
    curLevel.details = newDetails;
    this.levelLastLoaded = newLevelId;
    this.hls.trigger(events["a" /* default */].LEVEL_UPDATED, { details: newDetails, level: newLevelId });

    if (this.startFragRequested === false) {
      // compute start position if set to -1. use it straight away if value is defined
      if (this.startPosition === -1 || this.lastCurrentTime === -1) {
        // first, check if start time offset has been set in playlist, if yes, use this value
        var startTimeOffset = newDetails.startTimeOffset;
        if (!isNaN(startTimeOffset)) {
          if (startTimeOffset < 0) {
            logger["b" /* logger */].log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
            startTimeOffset = sliding + duration + startTimeOffset;
          }
          logger["b" /* logger */].log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
          this.startPosition = startTimeOffset;
        } else {
          // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
          if (newDetails.live) {
            this.startPosition = this.computeLivePosition(sliding, newDetails);
            logger["b" /* logger */].log('configure startPosition to ' + this.startPosition);
          } else {
            this.startPosition = 0;
          }
        }
        this.lastCurrentTime = this.startPosition;
      }
      this.nextLoadPosition = this.startPosition;
    }
    // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
    if (this.state === State.WAITING_LEVEL) {
      this.state = State.IDLE;
    }
    //trigger handler right now
    this.tick();
  };

  StreamController.prototype.onKeyLoaded = function onKeyLoaded() {
    if (this.state === State.KEY_LOADING) {
      this.state = State.IDLE;
      this.tick();
    }
  };

  StreamController.prototype.onFragLoaded = function onFragLoaded(data) {
    var fragCurrent = this.fragCurrent,
        fragLoaded = data.frag;
    if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
      var stats = data.stats,
          currentLevel = this.levels[fragCurrent.level],
          details = currentLevel.details;
      logger["b" /* logger */].log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
      // reset frag bitrate test in any case after frag loaded event
      this.bitrateTest = false;
      this.stats = stats;
      // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
      // then this means that we should be able to load a fragment at a higher quality level
      if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {
        // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
        this.state = State.IDLE;
        this.startFragRequested = false;
        stats.tparsed = stats.tbuffered = performance.now();
        this.hls.trigger(events["a" /* default */].FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
        this.tick();
      } else if (fragLoaded.sn === 'initSegment') {
        this.state = State.IDLE;
        stats.tparsed = stats.tbuffered = performance.now();
        details.initSegment.data = data.payload;
        this.hls.trigger(events["a" /* default */].FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
        this.tick();
      } else {
        this.state = State.PARSING;
        // transmux the MPEG-TS data to ISO-BMFF segments
        var duration = details.totalduration,
            level = fragCurrent.level,
            sn = fragCurrent.sn,
            audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
        if (this.audioCodecSwap) {
          logger["b" /* logger */].log('swapping playlist audio codec');
          if (audioCodec === undefined) {
            audioCodec = this.lastAudioCodec;
          }
          if (audioCodec) {
            if (audioCodec.indexOf('mp4a.40.5') !== -1) {
              audioCodec = 'mp4a.40.2';
            } else {
              audioCodec = 'mp4a.40.5';
            }
          }
        }
        this.pendingBuffering = true;
        this.appended = false;
        logger["b" /* logger */].log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
        var demuxer = this.demuxer;
        if (!demuxer) {
          demuxer = this.demuxer = new demux_demuxer(this.hls, 'main');
        }
        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
        var media = this.media;
        var mediaSeeking = media && media.seeking;
        var accurateTimeOffset = !mediaSeeking && (details.PTSKnown || !details.live);
        var initSegmentData = details.initSegment ? details.initSegment.data : [];
        demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, duration, accurateTimeOffset, undefined);
      }
    }
    this.fragLoadError = 0;
  };

  StreamController.prototype.onFragParsingInitSegment = function onFragParsingInitSegment(data) {
    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
      var tracks = data.tracks,
          trackName,
          track;

      // if audio track is expected to come from audio stream controller, discard any coming from main
      if (tracks.audio && this.altAudio) {
        delete tracks.audio;
      }
      // include levelCodec in audio and video tracks
      track = tracks.audio;
      if (track) {
        var audioCodec = this.levels[this.level].audioCodec,
            ua = navigator.userAgent.toLowerCase();
        if (audioCodec && this.audioCodecSwap) {
          logger["b" /* logger */].log('swapping playlist audio codec');
          if (audioCodec.indexOf('mp4a.40.5') !== -1) {
            audioCodec = 'mp4a.40.2';
          } else {
            audioCodec = 'mp4a.40.5';
          }
        }
        // in case AAC and HE-AAC audio codecs are signalled in manifest
        // force HE-AAC , as it seems that most browsers prefers that way,
        // except for mono streams OR on FF
        // these conditions might need to be reviewed ...
        if (this.audioCodecSwitch) {
          // don't force HE-AAC if mono stream
          if (track.metadata.channelCount !== 1 &&
          // don't force HE-AAC if firefox
          ua.indexOf('firefox') === -1) {
            audioCodec = 'mp4a.40.5';
          }
        }
        // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
        if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
          // Exclude mpeg audio
          audioCodec = 'mp4a.40.2';
          logger["b" /* logger */].log('Android: force audio codec to ' + audioCodec);
        }
        track.levelCodec = audioCodec;
        track.id = data.id;
      }
      track = tracks.video;
      if (track) {
        track.levelCodec = this.levels[this.level].videoCodec;
        track.id = data.id;
      }
      this.hls.trigger(events["a" /* default */].BUFFER_CODECS, tracks);
      // loop through tracks that are going to be provided to bufferController
      for (trackName in tracks) {
        track = tracks[trackName];
        logger["b" /* logger */].log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
        var initSegment = track.initSegment;
        if (initSegment) {
          this.appended = true;
          // arm pending Buffering flag before appending a segment
          this.pendingBuffering = true;
          this.hls.trigger(events["a" /* default */].BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
        }
      }
      //trigger handler right now
      this.tick();
    }
  };

  StreamController.prototype.onFragParsingData = function onFragParsingData(data) {
    var _this2 = this;

    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
    this.state === State.PARSING) {
      var level = this.levels[this.level],
          frag = fragCurrent;
      if (isNaN(data.endPTS)) {
        data.endPTS = data.startPTS + fragCurrent.duration;
        data.endDTS = data.startDTS + fragCurrent.duration;
      }

      logger["b" /* logger */].log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));

      // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
      if (data.type === 'video') {
        frag.dropped = data.dropped;
        if (frag.dropped) {
          if (!frag.backtracked) {
            var levelDetails = level.details;
            if (levelDetails && frag.sn === levelDetails.startSN) {
              logger["b" /* logger */].warn('missing video frame(s) on first frag, appending with gap');
            } else {
              logger["b" /* logger */].warn('missing video frame(s), backtracking fragment');
              // Return back to the IDLE state without appending to buffer
              // Causes findFragments to backtrack a segment and find the keyframe
              // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
              frag.backtracked = true;
              this.nextLoadPosition = data.startPTS;
              this.state = State.IDLE;
              this.fragPrevious = frag;
              this.tick();
              return;
            }
          } else {
            logger["b" /* logger */].warn('Already backtracked on this fragment, appending with the gap');
          }
        } else {
          // Only reset the backtracked flag if we've loaded the frag without any dropped frames
          frag.backtracked = false;
        }
      }

      var drift = updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
          hls = this.hls;
      hls.trigger(events["a" /* default */].LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });

      // has remuxer dropped video frames located before first keyframe ?
      [data.data1, data.data2].forEach(function (buffer) {
        // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
        // in that case it is useless to append following segments
        if (buffer && buffer.length && _this2.state === State.PARSING) {
          _this2.appended = true;
          // arm pending Buffering flag before appending a segment
          _this2.pendingBuffering = true;
          hls.trigger(events["a" /* default */].BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
        }
      });
      //trigger handler right now
      this.tick();
    }
  };

  StreamController.prototype.onFragParsed = function onFragParsed(data) {
    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
      this.stats.tparsed = performance.now();
      this.state = State.PARSED;
      this._checkAppendedParsed();
    }
  };

  StreamController.prototype.onAudioTrackSwitching = function onAudioTrackSwitching(data) {
    // if any URL found on new audio track, it is an alternate audio track
    var altAudio = !!data.url,
        trackId = data.id;
    // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
    // don't do anything if we switch to alt audio: audio stream controller is handling it.
    // we will just have to change buffer scheduling on audioTrackSwitched
    if (!altAudio) {
      if (this.mediaBuffer !== this.media) {
        logger["b" /* logger */].log('switching on main audio, use media.buffered to schedule main fragment loading');
        this.mediaBuffer = this.media;
        var fragCurrent = this.fragCurrent;
        // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
        if (fragCurrent.loader) {
          logger["b" /* logger */].log('switching to main audio track, cancel main fragment load');
          fragCurrent.loader.abort();
        }
        this.fragCurrent = null;
        this.fragPrevious = null;
        // destroy demuxer to force init segment generation (following audio switch)
        if (this.demuxer) {
          this.demuxer.destroy();
          this.demuxer = null;
        }
        // switch to IDLE state to load new fragment
        this.state = State.IDLE;
      }
      var hls = this.hls;
      // switching to main audio, flush all audio and trigger track switched
      hls.trigger(events["a" /* default */].BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
      hls.trigger(events["a" /* default */].AUDIO_TRACK_SWITCHED, { id: trackId });
      this.altAudio = false;
    }
  };

  StreamController.prototype.onAudioTrackSwitched = function onAudioTrackSwitched(data) {
    var trackId = data.id,
        altAudio = !!this.hls.audioTracks[trackId].url;
    if (altAudio) {
      var videoBuffer = this.videoBuffer;
      // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
      if (videoBuffer && this.mediaBuffer !== videoBuffer) {
        logger["b" /* logger */].log('switching on alternate audio, use video.buffered to schedule main fragment loading');
        this.mediaBuffer = videoBuffer;
      }
    }
    this.altAudio = altAudio;
    this.tick();
  };

  StreamController.prototype.onBufferCreated = function onBufferCreated(data) {
    var tracks = data.tracks,
        mediaTrack = void 0,
        name = void 0,
        alternate = false;
    for (var type in tracks) {
      var track = tracks[type];
      if (track.id === 'main') {
        name = type;
        mediaTrack = track;
        // keep video source buffer reference
        if (type === 'video') {
          this.videoBuffer = tracks[type].buffer;
        }
      } else {
        alternate = true;
      }
    }
    if (alternate && mediaTrack) {
      logger["b" /* logger */].log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
      this.mediaBuffer = mediaTrack.buffer;
    } else {
      this.mediaBuffer = this.media;
    }
  };

  StreamController.prototype.onBufferAppended = function onBufferAppended(data) {
    if (data.parent === 'main') {
      var state = this.state;
      if (state === State.PARSING || state === State.PARSED) {
        // check if all buffers have been appended
        this.pendingBuffering = data.pending > 0;
        this._checkAppendedParsed();
      }
    }
  };

  StreamController.prototype._checkAppendedParsed = function _checkAppendedParsed() {
    //trigger handler right now
    if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
      var frag = this.fragCurrent;
      if (frag) {
        var media = this.mediaBuffer ? this.mediaBuffer : this.media;
        logger["b" /* logger */].log('main buffered : ' + timeRanges.toString(media.buffered));
        // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
        var bufferedFrags = this._bufferedFrags.filter(function (frag) {
          return buffer_helper.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
        });
        // push new range
        bufferedFrags.push(frag);
        // sort frags, as we use BinarySearch for lookup in getBufferedFrag ...
        this._bufferedFrags = bufferedFrags.sort(function (a, b) {
          return a.startPTS - b.startPTS;
        });
        this.fragPrevious = frag;
        var stats = this.stats;
        stats.tbuffered = performance.now();
        // we should get rid of this.fragLastKbps
        this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
        this.hls.trigger(events["a" /* default */].FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
        this.state = State.IDLE;
      }
      this.tick();
    }
  };

  StreamController.prototype.onError = function onError(data) {
    var frag = data.frag || this.fragCurrent;
    // don't handle frag error not related to main fragment
    if (frag && frag.type !== 'main') {
      return;
    }
    // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
    var mediaBuffered = !!this.media && buffer_helper.isBuffered(this.media, this.media.currentTime) && buffer_helper.isBuffered(this.media, this.media.currentTime + 0.5);

    switch (data.details) {
      case errors["a" /* ErrorDetails */].FRAG_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].FRAG_LOAD_TIMEOUT:
      case errors["a" /* ErrorDetails */].KEY_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].KEY_LOAD_TIMEOUT:
        if (!data.fatal) {
          // keep retrying until the limit will be reached
          if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
            // exponential backoff capped to config.fragLoadingMaxRetryTimeout
            var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
            // reset load counter to avoid frag loop loading error
            frag.loadCounter = 0;
            logger["b" /* logger */].warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
            this.retryDate = performance.now() + delay;
            // retry loading state
            // if loadedmetadata is not set, it means that we are emergency switch down on first frag
            // in that case, reset startFragRequested flag
            if (!this.loadedmetadata) {
              this.startFragRequested = false;
              this.nextLoadPosition = this.startPosition;
            }
            this.fragLoadError++;
            this.state = State.FRAG_LOADING_WAITING_RETRY;
          } else {
            logger["b" /* logger */].error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
            // switch error to fatal
            data.fatal = true;
            this.state = State.ERROR;
          }
        }
        break;
      case errors["a" /* ErrorDetails */].FRAG_LOOP_LOADING_ERROR:
        if (!data.fatal) {
          // if buffer is not empty
          if (mediaBuffered) {
            // try to reduce max buffer length : rationale is that we could get
            // frag loop loading error because of buffer eviction
            this._reduceMaxBufferLength(frag.duration);
            this.state = State.IDLE;
          } else {
            // buffer empty. report as fatal if in manual mode or if lowest level.
            // level controller takes care of emergency switch down logic
            if (!frag.autoLevel || frag.level === 0) {
              // switch error to fatal
              data.fatal = true;
              this.state = State.ERROR;
            }
          }
        }
        break;
      case errors["a" /* ErrorDetails */].LEVEL_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].LEVEL_LOAD_TIMEOUT:
        if (this.state !== State.ERROR) {
          if (data.fatal) {
            // if fatal error, stop processing
            this.state = State.ERROR;
            logger["b" /* logger */].warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
          } else {
            // in case of non fatal error while loading level, if level controller is not retrying to load level , switch back to IDLE
            if (!data.levelRetry && this.state === State.WAITING_LEVEL) {
              this.state = State.IDLE;
            }
          }
        }
        break;
      case errors["a" /* ErrorDetails */].BUFFER_FULL_ERROR:
        // if in appending state
        if (data.parent === 'main' && (this.state === State.PARSING || this.state === State.PARSED)) {
          // reduce max buf len if current position is buffered
          if (mediaBuffered) {
            this._reduceMaxBufferLength(this.config.maxBufferLength);
            this.state = State.IDLE;
          } else {
            // current position is not buffered, but browser is still complaining about buffer full error
            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
            // in that case flush the whole buffer to recover
            logger["b" /* logger */].warn('buffer full error also media.currentTime is not buffered, flush everything');
            this.fragCurrent = null;
            // flush everything
            this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
          }
        }
        break;
      default:
        break;
    }
  };

  StreamController.prototype._reduceMaxBufferLength = function _reduceMaxBufferLength(minLength) {
    var config = this.config;
    if (config.maxMaxBufferLength >= minLength) {
      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
      config.maxMaxBufferLength /= 2;
      logger["b" /* logger */].warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
      if (this.fragLoadIdx !== undefined) {
        // increase fragment load Index to avoid frag loop loading error after buffer flush
        this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
      }
    }
  };

  StreamController.prototype._checkBuffer = function _checkBuffer() {
    var media = this.media,
        config = this.config;
    // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
    if (media && media.readyState) {
      var currentTime = media.currentTime,
          mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media,
          buffered = mediaBuffer.buffered;
      // adjust currentTime to start position on loaded metadata
      if (!this.loadedmetadata && buffered.length) {
        this.loadedmetadata = true;
        // only adjust currentTime if different from startPosition or if startPosition not buffered
        // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
        var startPosition = media.seeking ? currentTime : this.startPosition,
            startPositionBuffered = buffer_helper.isBuffered(mediaBuffer, startPosition),
            firstbufferedPosition = buffered.start(0),
            startNotBufferedButClose = !startPositionBuffered && Math.abs(startPosition - firstbufferedPosition) < config.maxSeekHole;
        // if currentTime not matching with expected startPosition or startPosition not buffered but close to first buffered
        if (currentTime !== startPosition || startNotBufferedButClose) {
          logger["b" /* logger */].log('target start position:' + startPosition);
          // if startPosition not buffered, let's seek to buffered.start(0)
          if (startNotBufferedButClose) {
            startPosition = firstbufferedPosition;
            logger["b" /* logger */].log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
          }
          logger["b" /* logger */].log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
          media.currentTime = startPosition;
        }
      } else if (this.immediateSwitch) {
        this.immediateLevelSwitchEnd();
      } else {
        var bufferInfo = buffer_helper.bufferInfo(media, currentTime, 0),
            expectedPlaying = !(media.paused || // not playing when media is paused
        media.ended || // not playing when media is ended
        media.buffered.length === 0),
            // not playing if nothing buffered
        jumpThreshold = 0.5,
            // tolerance needed as some browsers stalls playback before reaching buffered range end
        playheadMoving = currentTime !== this.lastCurrentTime;

        if (playheadMoving) {
          // played moving, but was previously stalled => now not stuck anymore
          if (this.stallReported) {
            logger["b" /* logger */].warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(performance.now() - this.stalled) + 'ms');
            this.stallReported = false;
          }
          this.stalled = undefined;
          this.nudgeRetry = 0;
        } else {
          // playhead not moving
          if (expectedPlaying) {
            // playhead not moving BUT media expected to play
            var tnow = performance.now();
            var hls = this.hls;
            if (!this.stalled) {
              // stall just detected, store current time
              this.stalled = tnow;
              this.stallReported = false;
            } else {
              // playback already stalled, check stalling duration
              // if stalling for more than a given threshold, let's try to recover
              var stalledDuration = tnow - this.stalled;
              var bufferLen = bufferInfo.len;
              var nudgeRetry = this.nudgeRetry || 0;
              // have we reached stall deadline ?
              if (bufferLen <= jumpThreshold && stalledDuration > config.lowBufferWatchdogPeriod * 1000) {
                // report stalled error once
                if (!this.stallReported) {
                  this.stallReported = true;
                  logger["b" /* logger */].warn('playback stalling in low buffer @' + currentTime);
                  hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                }
                // if buffer len is below threshold, try to jump to start of next buffer range if close
                // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
                var nextBufferStart = bufferInfo.nextStart,
                    delta = nextBufferStart - currentTime;
                if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {
                  this.nudgeRetry = ++nudgeRetry;
                  var nudgeOffset = nudgeRetry * config.nudgeOffset;
                  // next buffer is close ! adjust currentTime to nextBufferStart
                  // this will ensure effective video decoding
                  logger["b" /* logger */].log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + nudgeOffset);
                  media.currentTime = nextBufferStart + nudgeOffset;
                  // reset stalled so to rearm watchdog timer
                  this.stalled = undefined;
                  hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].BUFFER_SEEK_OVER_HOLE, fatal: false, hole: nextBufferStart + nudgeOffset - currentTime });
                }
              } else if (bufferLen > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
                // report stalled error once
                if (!this.stallReported) {
                  this.stallReported = true;
                  logger["b" /* logger */].warn('playback stalling in high buffer @' + currentTime);
                  hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                }
                // reset stalled so to rearm watchdog timer
                this.stalled = undefined;
                this.nudgeRetry = ++nudgeRetry;
                if (nudgeRetry < config.nudgeMaxRetry) {
                  var _currentTime = media.currentTime;
                  var targetTime = _currentTime + nudgeRetry * config.nudgeOffset;
                  logger["b" /* logger */].log('adjust currentTime from ' + _currentTime + ' to ' + targetTime);
                  // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
                  media.currentTime = targetTime;
                  hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].BUFFER_NUDGE_ON_STALL, fatal: false });
                } else {
                  logger["b" /* logger */].error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
                  hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].BUFFER_STALLED_ERROR, fatal: true });
                }
              }
            }
          }
        }
      }
    }
  };

  StreamController.prototype.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
    this.state = State.IDLE;
    // if loadedmetadata is not set, it means that we are emergency switch down on first frag
    // in that case, reset startFragRequested flag
    if (!this.loadedmetadata) {
      this.startFragRequested = false;
      this.nextLoadPosition = this.startPosition;
    }
    this.tick();
  };

  StreamController.prototype.onBufferFlushed = function onBufferFlushed() {
    /* after successful buffer flushing, filter flushed fragments from bufferedFrags
      use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
    */
    var media = this.mediaBuffer ? this.mediaBuffer : this.media;
    this._bufferedFrags = this._bufferedFrags.filter(function (frag) {
      return buffer_helper.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
    });

    if (this.fragLoadIdx !== undefined) {
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
    }
    // move to IDLE once flush complete. this should trigger new fragment loading
    this.state = State.IDLE;
    // reset reference to frag
    this.fragPrevious = null;
  };

  StreamController.prototype.swapAudioCodec = function swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  };

  StreamController.prototype.computeLivePosition = function computeLivePosition(sliding, levelDetails) {
    var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
    return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
  };

  stream_controller__createClass(StreamController, [{
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        logger["b" /* logger */].log('main stream:' + previousState + '->' + nextState);
        this.hls.trigger(events["a" /* default */].STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
      }
    },
    get: function get() {
      return this._state;
    }
  }, {
    key: 'currentLevel',
    get: function get() {
      var media = this.media;
      if (media) {
        var frag = this.getBufferedFrag(media.currentTime);
        if (frag) {
          return frag.level;
        }
      }
      return -1;
    }
  }, {
    key: 'nextBufferedFrag',
    get: function get() {
      var media = this.media;
      if (media) {
        // first get end range of current fragment
        return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
      } else {
        return null;
      }
    }
  }, {
    key: 'nextLevel',
    get: function get() {
      var frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      } else {
        return -1;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this._liveSyncPosition;
    },
    set: function set(value) {
      this._liveSyncPosition = value;
    }
  }]);

  return StreamController;
}(event_handler);

/* harmony default export */ var stream_controller = (stream_controller_StreamController);
// CONCATENATED MODULE: ./src/controller/level-controller.js
var level_controller__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function level_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function level_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function level_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Level Controller
*/







var level_controller_LevelController = function (_EventHandler) {
  level_controller__inherits(LevelController, _EventHandler);

  function LevelController(hls) {
    level_controller__classCallCheck(this, LevelController);

    var _this = level_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MANIFEST_LOADED, events["a" /* default */].LEVEL_LOADED, events["a" /* default */].FRAG_LOADED, events["a" /* default */].ERROR));

    _this.canload = false;
    _this.currentLevelIndex = null;
    _this.manualLevelIndex = -1;
    _this.timer = null;
    return _this;
  }

  LevelController.prototype.destroy = function destroy() {
    this.cleanTimer();
    this.manualLevelIndex = -1;
  };

  LevelController.prototype.cleanTimer = function cleanTimer() {
    if (this.timer !== null) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  };

  LevelController.prototype.startLoad = function startLoad() {
    var levels = this._levels;

    this.canload = true;
    this.levelRetryCount = 0;

    // clean up live level details to force reload them, and reset load errors
    if (levels) {
      levels.forEach(function (level) {
        level.loadError = 0;
        var levelDetails = level.details;
        if (levelDetails && levelDetails.live) {
          level.details = undefined;
        }
      });
    }
    // speed up live playlist refresh if timer exists
    if (this.timer !== null) {
      this.loadLevel();
    }
  };

  LevelController.prototype.stopLoad = function stopLoad() {
    this.canload = false;
  };

  LevelController.prototype.onManifestLoaded = function onManifestLoaded(data) {
    var levels = [];
    var bitrateStart = void 0;
    var levelSet = {};
    var levelFromSet = null;
    var videoCodecFound = false;
    var audioCodecFound = false;
    var chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
    var audioTracks = [];

    // regroup redundant levels together
    data.levels.forEach(function (level) {
      level.loadError = 0;
      level.fragmentError = false;

      videoCodecFound = videoCodecFound || !!level.videoCodec;
      audioCodecFound = audioCodecFound || !!level.audioCodec || !!(level.attrs && level.attrs.AUDIO);

      // erase audio codec info if browser does not support mp4a.40.34.
      // demuxer will autodetect codec and fallback to mpeg/audio
      if (chromeOrFirefox === true && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
        level.audioCodec = undefined;
      }

      levelFromSet = levelSet[level.bitrate];

      if (levelFromSet === undefined) {
        level.url = [level.url];
        level.urlId = 0;
        levelSet[level.bitrate] = level;
        levels.push(level);
      } else {
        levelFromSet.url.push(level.url);
      }
    });

    // remove audio-only level if we also have levels with audio+video codecs signalled
    if (videoCodecFound === true && audioCodecFound === true) {
      levels = levels.filter(function (_ref) {
        var videoCodec = _ref.videoCodec;
        return !!videoCodec;
      });
    }

    // only keep levels with supported audio/video codecs
    levels = levels.filter(function (_ref2) {
      var audioCodec = _ref2.audioCodec,
          videoCodec = _ref2.videoCodec;

      return (!audioCodec || isCodecSupportedInMp4(audioCodec)) && (!videoCodec || isCodecSupportedInMp4(videoCodec));
    });

    if (data.audioTracks) {
      audioTracks = data.audioTracks.filter(function (track) {
        return !track.audioCodec || isCodecSupportedInMp4(track.audioCodec, 'audio');
      });
    }

    if (levels.length > 0) {
      // start bitrate is the first bitrate of the manifest
      bitrateStart = levels[0].bitrate;
      // sort level on bitrate
      levels.sort(function (a, b) {
        return a.bitrate - b.bitrate;
      });
      this._levels = levels;
      // find index of first level in sorted levels
      for (var i = 0; i < levels.length; i++) {
        if (levels[i].bitrate === bitrateStart) {
          this._firstLevel = i;
          logger["b" /* logger */].log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
          break;
        }
      }
      this.hls.trigger(events["a" /* default */].MANIFEST_PARSED, {
        levels: levels,
        audioTracks: audioTracks,
        firstLevel: this._firstLevel,
        stats: data.stats,
        audio: audioCodecFound,
        video: videoCodecFound,
        altAudio: audioTracks.length > 0
      });
    } else {
      this.hls.trigger(events["a" /* default */].ERROR, {
        type: errors["b" /* ErrorTypes */].MEDIA_ERROR,
        details: errors["a" /* ErrorDetails */].MANIFEST_INCOMPATIBLE_CODECS_ERROR,
        fatal: true,
        url: this.hls.url,
        reason: 'no level with compatible codecs found in manifest'
      });
    }
  };

  LevelController.prototype.setLevelInternal = function setLevelInternal(newLevel) {
    var levels = this._levels;
    var hls = this.hls;
    // check if level idx is valid
    if (newLevel >= 0 && newLevel < levels.length) {
      // stopping live reloading timer if any
      this.cleanTimer();
      if (this.currentLevelIndex !== newLevel) {
        logger["b" /* logger */].log('switching to level ' + newLevel);
        this.currentLevelIndex = newLevel;
        var levelProperties = levels[newLevel];
        levelProperties.level = newLevel;
        // LEVEL_SWITCH to be deprecated in next major release
        hls.trigger(events["a" /* default */].LEVEL_SWITCH, levelProperties);
        hls.trigger(events["a" /* default */].LEVEL_SWITCHING, levelProperties);
      }
      var level = levels[newLevel],
          levelDetails = level.details;
      // check if we need to load playlist for this level
      if (!levelDetails || levelDetails.live === true) {
        // level not retrieved yet, or live playlist we need to (re)load it
        var urlId = level.urlId;
        hls.trigger(events["a" /* default */].LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
      }
    } else {
      // invalid level id given, trigger error
      hls.trigger(events["a" /* default */].ERROR, {
        type: errors["b" /* ErrorTypes */].OTHER_ERROR,
        details: errors["a" /* ErrorDetails */].LEVEL_SWITCH_ERROR,
        level: newLevel,
        fatal: false,
        reason: 'invalid level idx'
      });
    }
  };

  LevelController.prototype.onError = function onError(data) {
    if (data.fatal === true) {
      if (data.type === errors["b" /* ErrorTypes */].NETWORK_ERROR) {
        this.cleanTimer();
      }
      return;
    }

    var levelError = false,
        fragmentError = false;
    var levelIndex = void 0;

    // try to recover not fatal errors
    switch (data.details) {
      case errors["a" /* ErrorDetails */].FRAG_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].FRAG_LOAD_TIMEOUT:
      case errors["a" /* ErrorDetails */].FRAG_LOOP_LOADING_ERROR:
      case errors["a" /* ErrorDetails */].KEY_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].KEY_LOAD_TIMEOUT:
        levelIndex = data.frag.level;
        fragmentError = true;
        break;
      case errors["a" /* ErrorDetails */].LEVEL_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].LEVEL_LOAD_TIMEOUT:
        levelIndex = data.context.level;
        levelError = true;
        break;
      case errors["a" /* ErrorDetails */].REMUX_ALLOC_ERROR:
        levelIndex = data.level;
        levelError = true;
        break;
    }

    if (levelIndex !== undefined) {
      this.recoverLevel(data, levelIndex, levelError, fragmentError);
    }
  };

  /**
   * Switch to a redundant stream if any available.
   * If redundant stream is not available, emergency switch down if ABR mode is enabled.
   *
   * @param {Object} errorEvent
   * @param {Number} levelIndex current level index
   * @param {Boolean} levelError
   * @param {Boolean} fragmentError
   */
  // FIXME Find a better abstraction where fragment/level retry management is well decoupled


  LevelController.prototype.recoverLevel = function recoverLevel(errorEvent, levelIndex, levelError, fragmentError) {
    var _this2 = this;

    var config = this.hls.config;
    var errorDetails = errorEvent.details;

    var level = this._levels[levelIndex];
    var redundantLevels = void 0,
        delay = void 0,
        nextLevel = void 0;

    level.loadError++;
    level.fragmentError = fragmentError;

    if (levelError === true) {
      if (this.levelRetryCount + 1 <= config.levelLoadingMaxRetry) {
        // exponential backoff capped to max retry timeout
        delay = Math.min(Math.pow(2, this.levelRetryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
        // Schedule level reload
        this.timer = setTimeout(function () {
          return _this2.loadLevel();
        }, delay);
        // boolean used to inform stream controller not to switch back to IDLE on non fatal error
        errorEvent.levelRetry = true;
        this.levelRetryCount++;
        logger["b" /* logger */].warn('level controller, ' + errorDetails + ', retry in ' + delay + ' ms, current retry count is ' + this.levelRetryCount);
      } else {
        logger["b" /* logger */].error('level controller, cannot recover from ' + errorDetails + ' error');
        this.currentLevelIndex = null;
        // stopping live reloading timer if any
        this.cleanTimer();
        // switch error to fatal
        errorEvent.fatal = true;
        return;
      }
    }

    // Try any redundant streams if available for both errors: level and fragment
    // If level.loadError reaches redundantLevels it means that we tried them all, no hope  => let's switch down
    if (levelError === true || fragmentError === true) {
      redundantLevels = level.url.length;

      if (redundantLevels > 1 && level.loadError < redundantLevels) {
        logger["b" /* logger */].warn('level controller, ' + errorDetails + ' for level ' + levelIndex + ': switching to redundant stream id ' + level.urlId);
        level.urlId = (level.urlId + 1) % redundantLevels;
        level.details = undefined;
      } else {
        // Search for available level
        if (this.manualLevelIndex === -1) {
          // When lowest level has been reached, let's start hunt from the top
          nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;
          logger["b" /* logger */].warn('level controller, ' + errorDetails + ': switch to ' + nextLevel);
          this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
        } else if (fragmentError === true) {
          // Allow fragment retry as long as configuration allows.
          // reset this._level so that another call to set level() will trigger again a frag load
          logger["b" /* logger */].warn('level controller, ' + errorDetails + ': reload a fragment');
          this.currentLevelIndex = null;
        }
      }
    }
  };

  // reset errors on the successful load of a fragment


  LevelController.prototype.onFragLoaded = function onFragLoaded(_ref3) {
    var frag = _ref3.frag;

    if (frag !== undefined && frag.type === 'main') {
      var level = this._levels[frag.level];
      if (level !== undefined) {
        level.fragmentError = false;
        level.loadError = 0;
        this.levelRetryCount = 0;
      }
    }
  };

  LevelController.prototype.onLevelLoaded = function onLevelLoaded(data) {
    var _this3 = this;

    var levelId = data.level;
    // only process level loaded events matching with expected level
    if (levelId === this.currentLevelIndex) {
      var curLevel = this._levels[levelId];
      // reset level load error counter on successful level loaded only if there is no issues with fragments
      if (curLevel.fragmentError === false) {
        curLevel.loadError = 0;
        this.levelRetryCount = 0;
      }
      var newDetails = data.details;
      // if current playlist is a live playlist, arm a timer to reload it
      if (newDetails.live) {
        var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
            curDetails = curLevel.details;
        if (curDetails && newDetails.endSN === curDetails.endSN) {
          // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
          // changed then it MUST wait for a period of one-half the target
          // duration before retrying.
          reloadInterval /= 2;
          logger["b" /* logger */].log('same live playlist, reload twice faster');
        }
        // decrement reloadInterval with level loading delay
        reloadInterval -= performance.now() - data.stats.trequest;
        // in any case, don't reload more than every second
        reloadInterval = Math.max(1000, Math.round(reloadInterval));
        logger["b" /* logger */].log('live playlist, reload in ' + reloadInterval + ' ms');
        this.timer = setTimeout(function () {
          return _this3.loadLevel();
        }, reloadInterval);
      } else {
        this.cleanTimer();
      }
    }
  };

  LevelController.prototype.loadLevel = function loadLevel() {
    var level = void 0,
        urlIndex = void 0;

    if (this.currentLevelIndex !== null && this.canload === true) {
      level = this._levels[this.currentLevelIndex];
      if (level !== undefined && level.url.length > 0) {
        urlIndex = level.urlId;
        this.hls.trigger(events["a" /* default */].LEVEL_LOADING, { url: level.url[urlIndex], level: this.currentLevelIndex, id: urlIndex });
      }
    }
  };

  level_controller__createClass(LevelController, [{
    key: 'levels',
    get: function get() {
      return this._levels;
    }
  }, {
    key: 'level',
    get: function get() {
      return this.currentLevelIndex;
    },
    set: function set(newLevel) {
      var levels = this._levels;
      if (levels) {
        newLevel = Math.min(newLevel, levels.length - 1);
        if (this.currentLevelIndex !== newLevel || levels[newLevel].details === undefined) {
          this.setLevelInternal(newLevel);
        }
      }
    }
  }, {
    key: 'manualLevel',
    get: function get() {
      return this.manualLevelIndex;
    },
    set: function set(newLevel) {
      this.manualLevelIndex = newLevel;
      if (this._startLevel === undefined) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
  }, {
    key: 'firstLevel',
    get: function get() {
      return this._firstLevel;
    },
    set: function set(newLevel) {
      this._firstLevel = newLevel;
    }
  }, {
    key: 'startLevel',
    get: function get() {
      // hls.startLevel takes precedence over config.startLevel
      // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
      if (this._startLevel === undefined) {
        var configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== undefined) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    },
    set: function set(newLevel) {
      this._startLevel = newLevel;
    }
  }, {
    key: 'nextLoadLevel',
    get: function get() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    },
    set: function set(nextLevel) {
      this.level = nextLevel;
      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
  }]);

  return LevelController;
}(event_handler);

/* harmony default export */ var level_controller = (level_controller_LevelController);
// EXTERNAL MODULE: ./src/demux/id3.js
var id3 = __webpack_require__(3);

// CONCATENATED MODULE: ./src/controller/id3-track-controller.js
function id3_track_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function id3_track_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function id3_track_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * id3 metadata track controller
*/





var id3_track_controller_ID3TrackController = function (_EventHandler) {
  id3_track_controller__inherits(ID3TrackController, _EventHandler);

  function ID3TrackController(hls) {
    id3_track_controller__classCallCheck(this, ID3TrackController);

    var _this = id3_track_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MEDIA_ATTACHED, events["a" /* default */].MEDIA_DETACHING, events["a" /* default */].FRAG_PARSING_METADATA));

    _this.id3Track = undefined;
    _this.media = undefined;
    return _this;
  }

  ID3TrackController.prototype.destroy = function destroy() {
    event_handler.prototype.destroy.call(this);
  };

  // Add ID3 metatadata text track.


  ID3TrackController.prototype.onMediaAttached = function onMediaAttached(data) {
    this.media = data.media;
    if (!this.media) {
      return;
    }
  };

  ID3TrackController.prototype.onMediaDetaching = function onMediaDetaching() {
    this.media = undefined;
  };

  ID3TrackController.prototype.onFragParsingMetadata = function onFragParsingMetadata(data) {
    var fragment = data.frag;
    var samples = data.samples;

    // create track dynamically
    if (!this.id3Track) {
      this.id3Track = this.media.addTextTrack('metadata', 'id3');
      this.id3Track.mode = 'hidden';
    }

    // Attempt to recreate Safari functionality by creating
    // WebKitDataCue objects when available and store the decoded
    // ID3 data in the value property of the cue
    var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;

    for (var i = 0; i < samples.length; i++) {
      var frames = id3["a" /* default */].getID3Frames(samples[i].data);
      if (frames) {
        var startTime = samples[i].pts;
        var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;

        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
        if (startTime === endTime) {
          endTime += 0.0001;
        }

        for (var j = 0; j < frames.length; j++) {
          var frame = frames[j];
          // Safari doesn't put the timestamp frame in the TextTrack
          if (!id3["a" /* default */].isTimeStampFrame(frame)) {
            var cue = new Cue(startTime, endTime, '');
            cue.value = frame;
            this.id3Track.addCue(cue);
          }
        }
      }
    }
  };

  return ID3TrackController;
}(event_handler);

/* harmony default export */ var id3_track_controller = (id3_track_controller_ID3TrackController);
// CONCATENATED MODULE: ./src/helper/is-supported.js


function is_supported_isSupported() {
  var mediaSource = getMediaSource();
  var sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
  var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');

  // if SourceBuffer is exposed ensure its API is valid
  // safari and old version of Chrome doe not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible
  var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
  return !!isTypeSupported && !!sourceBufferValidAPI;
}
// CONCATENATED MODULE: ./src/utils/ewma.js
function ewma__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * compute an Exponential Weighted moving average
 * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
 *  - heavily inspired from shaka-player
 */

var EWMA = function () {

  //  About half of the estimated value will be from the last |halfLife| samples by weight.
  function EWMA(halfLife) {
    ewma__classCallCheck(this, EWMA);

    // Larger values of alpha expire historical data more slowly.
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = 0;
    this.totalWeight_ = 0;
  }

  EWMA.prototype.sample = function sample(weight, value) {
    var adjAlpha = Math.pow(this.alpha_, weight);
    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
    this.totalWeight_ += weight;
  };

  EWMA.prototype.getTotalWeight = function getTotalWeight() {
    return this.totalWeight_;
  };

  EWMA.prototype.getEstimate = function getEstimate() {
    if (this.alpha_) {
      var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
      return this.estimate_ / zeroFactor;
    } else {
      return this.estimate_;
    }
  };

  return EWMA;
}();

/* harmony default export */ var ewma = (EWMA);
// CONCATENATED MODULE: ./src/utils/ewma-bandwidth-estimator.js
function ewma_bandwidth_estimator__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*
 * EWMA Bandwidth Estimator
 *  - heavily inspired from shaka-player
 * Tracks bandwidth samples and estimates available bandwidth.
 * Based on the minimum of two exponentially-weighted moving averages with
 * different half-lives.
 */



var ewma_bandwidth_estimator_EwmaBandWidthEstimator = function () {
  function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
    ewma_bandwidth_estimator__classCallCheck(this, EwmaBandWidthEstimator);

    this.hls = hls;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new ewma(slow);
    this.fast_ = new ewma(fast);
  }

  EwmaBandWidthEstimator.prototype.sample = function sample(durationMs, numBytes) {
    durationMs = Math.max(durationMs, this.minDelayMs_);
    var bandwidth = 8000 * numBytes / durationMs,

    //console.log('instant bw:'+ Math.round(bandwidth));
    // we weight sample using loading duration....
    weight = durationMs / 1000;
    this.fast_.sample(weight, bandwidth);
    this.slow_.sample(weight, bandwidth);
  };

  EwmaBandWidthEstimator.prototype.canEstimate = function canEstimate() {
    var fast = this.fast_;
    return fast && fast.getTotalWeight() >= this.minWeight_;
  };

  EwmaBandWidthEstimator.prototype.getEstimate = function getEstimate() {
    if (this.canEstimate()) {
      //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
      //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
      // Take the minimum of these two estimates.  This should have the effect of
      // adapting down quickly, but up more slowly.
      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
    } else {
      return this.defaultEstimate_;
    }
  };

  EwmaBandWidthEstimator.prototype.destroy = function destroy() {};

  return EwmaBandWidthEstimator;
}();

/* harmony default export */ var ewma_bandwidth_estimator = (ewma_bandwidth_estimator_EwmaBandWidthEstimator);
// CONCATENATED MODULE: ./src/controller/abr-controller.js
var abr_controller__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function abr_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function abr_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function abr_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * simple ABR Controller
 *  - compute next level based on last fragment bw heuristics
 *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
 */








var abr_controller_AbrController = function (_EventHandler) {
  abr_controller__inherits(AbrController, _EventHandler);

  function AbrController(hls) {
    abr_controller__classCallCheck(this, AbrController);

    var _this = abr_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].FRAG_LOADING, events["a" /* default */].FRAG_LOADED, events["a" /* default */].FRAG_BUFFERED, events["a" /* default */].ERROR));

    _this.lastLoadedFragLevel = 0;
    _this._nextAutoLevel = -1;
    _this.hls = hls;
    _this.timer = null;
    _this._bwEstimator = null;
    _this.onCheck = _this._abandonRulesCheck.bind(_this);
    return _this;
  }

  AbrController.prototype.destroy = function destroy() {
    this.clearTimer();
    event_handler.prototype.destroy.call(this);
  };

  AbrController.prototype.onFragLoading = function onFragLoading(data) {
    var frag = data.frag;
    if (frag.type === 'main') {
      if (!this.timer) {
        this.timer = setInterval(this.onCheck, 100);
      }
      // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
      // so we need to wait for stream manifest / playlist type to instantiate it.
      if (!this._bwEstimator) {
        var hls = this.hls,
            level = data.frag.level,
            isLive = hls.levels[level].details.live,
            config = hls.config,
            ewmaFast = void 0,
            ewmaSlow = void 0;

        if (isLive) {
          ewmaFast = config.abrEwmaFastLive;
          ewmaSlow = config.abrEwmaSlowLive;
        } else {
          ewmaFast = config.abrEwmaFastVoD;
          ewmaSlow = config.abrEwmaSlowVoD;
        }
        this._bwEstimator = new ewma_bandwidth_estimator(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
      }
      this.fragCurrent = frag;
    }
  };

  AbrController.prototype._abandonRulesCheck = function _abandonRulesCheck() {
    /*
      monitor fragment retrieval time...
      we compute expected time of arrival of the complete fragment.
      we compare it to expected time of buffer starvation
    */
    var hls = this.hls,
        v = hls.media,
        frag = this.fragCurrent,
        loader = frag.loader,
        minAutoLevel = hls.minAutoLevel;

    // if loader has been destroyed or loading has been aborted, stop timer and return
    if (!loader || loader.stats && loader.stats.aborted) {
      logger["b" /* logger */].warn('frag loader destroy or aborted, disarm abandonRules');
      this.clearTimer();
      // reset forced auto level value so that next level will be selected
      this._nextAutoLevel = -1;
      return;
    }
    var stats = loader.stats;
    /* only monitor frag retrieval time if
    (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
    if (v && stats && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
      var requestDelay = performance.now() - stats.trequest,
          playbackRate = Math.abs(v.playbackRate);
      // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
      if (requestDelay > 500 * frag.duration / playbackRate) {
        var levels = hls.levels,
            loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
            // byte/s; at least 1 byte/s to avoid division by zero
        // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
        level = levels[frag.level],
            levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
            expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
            pos = v.currentTime,
            fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
            bufferStarvationDelay = (buffer_helper.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
        // consider emergency switch down only if we have less than 2 frag buffered AND
        // time to finish loading current fragment is bigger than buffer starvation delay
        // ie if we risk buffer starvation if bw does not increase quickly
        if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
          var fragLevelNextLoadedDelay = void 0,
              nextLoadLevel = void 0;
          // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
          // we start from current level - 1 and we step down , until we find a matching level
          for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
            // compute time to load next fragment at lower level
            // 0.8 : consider only 80% of current bw to be conservative
            // 8 = bits per byte (bps/Bps)
            var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
            fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
            if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
              // we found a lower level that be rebuffering free with current estimated bw !
              break;
            }
          }
          // only emergency switch down if it takes less time to load new fragment at lowest level instead
          // of finishing loading current one ...
          if (fragLevelNextLoadedDelay < fragLoadedDelay) {
            logger["b" /* logger */].warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
            // force next load level in auto mode
            hls.nextLoadLevel = nextLoadLevel;
            // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
            this._bwEstimator.sample(requestDelay, stats.loaded);
            //abort fragment loading
            loader.abort();
            // stop abandon rules timer
            this.clearTimer();
            hls.trigger(events["a" /* default */].FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
          }
        }
      }
    }
  };

  AbrController.prototype.onFragLoaded = function onFragLoaded(data) {
    var frag = data.frag;
    if (frag.type === 'main' && !isNaN(frag.sn)) {
      // stop monitoring bw once frag loaded
      this.clearTimer();
      // store level id after successful fragment load
      this.lastLoadedFragLevel = frag.level;
      // reset forced auto level value so that next level will be selected
      this._nextAutoLevel = -1;

      // compute level average bitrate
      if (this.hls.config.abrMaxWithRealBitrate) {
        var level = this.hls.levels[frag.level];
        var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
        var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
        level.loaded = { bytes: loadedBytes, duration: loadedDuration };
        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
      }
      // if fragment has been loaded to perform a bitrate test,
      if (data.frag.bitrateTest) {
        var stats = data.stats;
        stats.tparsed = stats.tbuffered = stats.tload;
        this.onFragBuffered(data);
      }
    }
  };

  AbrController.prototype.onFragBuffered = function onFragBuffered(data) {
    var stats = data.stats,
        frag = data.frag;
    // only update stats on first frag buffering
    // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
    // and leading to wrong bw estimation
    // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
    if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && !isNaN(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
      // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
      // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
      // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
      var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
      logger["b" /* logger */].log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
      this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
      stats.bwEstimate = this._bwEstimator.getEstimate();
      // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
      if (frag.bitrateTest) {
        this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
      } else {
        this.bitrateTestDelay = 0;
      }
    }
  };

  AbrController.prototype.onError = function onError(data) {
    // stop timer in case of frag loading error
    switch (data.details) {
      case errors["a" /* ErrorDetails */].FRAG_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].FRAG_LOAD_TIMEOUT:
        this.clearTimer();
        break;
      default:
        break;
    }
  };

  AbrController.prototype.clearTimer = function clearTimer() {
    clearInterval(this.timer);
    this.timer = null;
  };

  // return next auto level


  AbrController.prototype._findBestLevel = function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
    for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
      var levelInfo = levels[i],
          levelDetails = levelInfo.details,
          avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
          live = levelDetails ? levelDetails.live : false,
          adjustedbw = void 0;
      // follow algorithm captured from stagefright :
      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
      // Pick the highest bandwidth stream below or equal to estimated bandwidth.
      // consider only 80% of the available bandwidth, but if we are switching up,
      // be even more conservative (70%) to avoid overestimating and immediately
      // switching back.
      if (i <= currentLevel) {
        adjustedbw = bwFactor * currentBw;
      } else {
        adjustedbw = bwUpFactor * currentBw;
      }
      var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
          fetchDuration = bitrate * avgDuration / adjustedbw;

      logger["b" /* logger */].trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
      // if adjusted bw is greater than level bitrate AND
      if (adjustedbw > bitrate && (
      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
      !fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
        // as we are looping from highest to lowest, this will return the best achievable quality level
        return i;
      }
    }
    // not enough time budget even with quality level 0 ... rebuffering might happen
    return -1;
  };

  abr_controller__createClass(AbrController, [{
    key: 'nextAutoLevel',
    get: function get() {
      var forcedAutoLevel = this._nextAutoLevel;
      var bwEstimator = this._bwEstimator;
      // in case next auto level has been forced, and bw not available or not reliable, return forced value
      if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
        return forcedAutoLevel;
      }
      // compute next level using ABR logic
      var nextABRAutoLevel = this._nextABRAutoLevel;
      // if forced auto level has been defined, use it to cap ABR computed quality level
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }
      return nextABRAutoLevel;
    },
    set: function set(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  }, {
    key: '_nextABRAutoLevel',
    get: function get() {
      var hls = this.hls,
          maxAutoLevel = hls.maxAutoLevel,
          levels = hls.levels,
          config = hls.config,
          minAutoLevel = hls.minAutoLevel;
      var v = hls.media,
          currentLevel = this.lastLoadedFragLevel,
          currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
          pos = v ? v.currentTime : 0,

      // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
      // if we're playing back at the normal rate.
      playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
          avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,

      // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
      bufferStarvationDelay = (buffer_helper.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;

      // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
      var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
      if (bestLevel >= 0) {
        return bestLevel;
      } else {
        logger["b" /* logger */].trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
        // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
        // if no matching level found, logic will return 0
        var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
            bwFactor = config.abrBandWidthFactor,
            bwUpFactor = config.abrBandWidthUpFactor;
        if (bufferStarvationDelay === 0) {
          // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
          var bitrateTestDelay = this.bitrateTestDelay;
          if (bitrateTestDelay) {
            // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
            // max video loading delay used in  automatic start level selection :
            // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
            // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
            // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
            var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
            maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
            logger["b" /* logger */].trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
            // don't use conservative factor on bitrate test
            bwFactor = bwUpFactor = 1;
          }
        }
        bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
        return Math.max(bestLevel, 0);
      }
    }
  }]);

  return AbrController;
}(event_handler);

/* harmony default export */ var abr_controller = (abr_controller_AbrController);
// CONCATENATED MODULE: ./src/controller/buffer-controller.js
function buffer_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function buffer_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function buffer_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Buffer Controller
*/







var buffer_controller_MediaSource = getMediaSource();

var buffer_controller_BufferController = function (_EventHandler) {
  buffer_controller__inherits(BufferController, _EventHandler);

  function BufferController(hls) {
    buffer_controller__classCallCheck(this, BufferController);

    // the value that we have set mediasource.duration to
    // (the actual duration may be tweaked slighly by the browser)
    var _this = buffer_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MEDIA_ATTACHING, events["a" /* default */].MEDIA_DETACHING, events["a" /* default */].MANIFEST_PARSED, events["a" /* default */].BUFFER_RESET, events["a" /* default */].BUFFER_APPENDING, events["a" /* default */].BUFFER_CODECS, events["a" /* default */].BUFFER_EOS, events["a" /* default */].BUFFER_FLUSHING, events["a" /* default */].LEVEL_PTS_UPDATED, events["a" /* default */].LEVEL_UPDATED));

    _this._msDuration = null;
    // the value that we want to set mediaSource.duration to
    _this._levelDuration = null;
    // current stream state: true - for live broadcast, false - for VoD content
    _this._live = null;
    // cache the self generated object url to detect hijack of video tag
    _this._objectUrl = null;

    // Source Buffer listeners
    _this.onsbue = _this.onSBUpdateEnd.bind(_this);
    _this.onsbe = _this.onSBUpdateError.bind(_this);
    _this.pendingTracks = {};
    _this.tracks = {};
    return _this;
  }

  BufferController.prototype.destroy = function destroy() {
    event_handler.prototype.destroy.call(this);
  };

  BufferController.prototype.onLevelPtsUpdated = function onLevelPtsUpdated(data) {
    var type = data.type;
    var audioTrack = this.tracks.audio;

    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
    // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
    // event if SB is in updating state.
    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486

    if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
      // Chrome audio mp3 track
      var audioBuffer = this.sourceBuffer.audio;
      var delta = Math.abs(audioBuffer.timestampOffset - data.start);

      // adjust timestamp offset if time delta is greater than 100ms
      if (delta > 0.1) {
        var updating = audioBuffer.updating;

        try {
          audioBuffer.abort();
        } catch (err) {
          updating = true;
          logger["b" /* logger */].warn('can not abort audio buffer: ' + err);
        }

        if (!updating) {
          logger["b" /* logger */].warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
          audioBuffer.timestampOffset = data.start;
        } else {
          this.audioTimestampOffset = data.start;
        }
      }
    }
  };

  BufferController.prototype.onManifestParsed = function onManifestParsed(data) {
    var audioExpected = data.audio,
        videoExpected = data.video || data.levels.length && data.audio,
        sourceBufferNb = 0;
    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
    // sourcebuffers will be created all at once when the expected nb of tracks will be reached
    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
    // it will contain the expected nb of source buffers, no need to compute it
    if (data.altAudio && (audioExpected || videoExpected)) {
      sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
      logger["b" /* logger */].log(sourceBufferNb + ' sourceBuffer(s) expected');
    }
    this.sourceBufferNb = sourceBufferNb;
  };

  BufferController.prototype.onMediaAttaching = function onMediaAttaching(data) {
    var media = this.media = data.media;
    if (media) {
      // setup the media source
      var ms = this.mediaSource = new buffer_controller_MediaSource();
      //Media Source listeners
      this.onmso = this.onMediaSourceOpen.bind(this);
      this.onmse = this.onMediaSourceEnded.bind(this);
      this.onmsc = this.onMediaSourceClose.bind(this);
      ms.addEventListener('sourceopen', this.onmso);
      ms.addEventListener('sourceended', this.onmse);
      ms.addEventListener('sourceclose', this.onmsc);
      // link video and media Source
      media.src = URL.createObjectURL(ms);
      // cache the locally generated object url
      this._objectUrl = media.src;
    }
  };

  BufferController.prototype.onMediaDetaching = function onMediaDetaching() {
    logger["b" /* logger */].log('media source detaching');
    var ms = this.mediaSource;
    if (ms) {
      if (ms.readyState === 'open') {
        try {
          // endOfStream could trigger exception if any sourcebuffer is in updating state
          // we don't really care about checking sourcebuffer state here,
          // as we are anyway detaching the MediaSource
          // let's just avoid this exception to propagate
          ms.endOfStream();
        } catch (err) {
          logger["b" /* logger */].warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
        }
      }
      ms.removeEventListener('sourceopen', this.onmso);
      ms.removeEventListener('sourceended', this.onmse);
      ms.removeEventListener('sourceclose', this.onmsc);

      // Detach properly the MediaSource from the HTMLMediaElement as
      // suggested in https://github.com/w3c/media-source/issues/53.
      if (this.media) {
        URL.revokeObjectURL(this._objectUrl);

        // clean up video tag src only if it's our own url. some external libraries might
        // hijack the video tag and change its 'src' without destroying the Hls instance first
        if (this.media.src === this._objectUrl) {
          this.media.removeAttribute('src');
          this.media.load();
        } else {
          logger["b" /* logger */].warn('media.src was changed by a third party - skip cleanup');
        }
      }

      this.mediaSource = null;
      this.media = null;
      this._objectUrl = null;
      this.pendingTracks = {};
      this.tracks = {};
      this.sourceBuffer = {};
      this.flushRange = [];
      this.segments = [];
      this.appended = 0;
    }
    this.onmso = this.onmse = this.onmsc = null;
    this.hls.trigger(events["a" /* default */].MEDIA_DETACHED);
  };

  BufferController.prototype.onMediaSourceOpen = function onMediaSourceOpen() {
    logger["b" /* logger */].log('media source opened');
    this.hls.trigger(events["a" /* default */].MEDIA_ATTACHED, { media: this.media });
    var mediaSource = this.mediaSource;
    if (mediaSource) {
      // once received, don't listen anymore to sourceopen event
      mediaSource.removeEventListener('sourceopen', this.onmso);
    }
    this.checkPendingTracks();
  };

  BufferController.prototype.checkPendingTracks = function checkPendingTracks() {
    // if any buffer codecs pending, check if we have enough to create sourceBuffers
    var pendingTracks = this.pendingTracks,
        pendingTracksNb = Object.keys(pendingTracks).length;
    // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
    if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {
      // ok, let's create them now !
      this.createSourceBuffers(pendingTracks);
      this.pendingTracks = {};
      // append any pending segments now !
      this.doAppending();
    }
  };

  BufferController.prototype.onMediaSourceClose = function onMediaSourceClose() {
    logger["b" /* logger */].log('media source closed');
  };

  BufferController.prototype.onMediaSourceEnded = function onMediaSourceEnded() {
    logger["b" /* logger */].log('media source ended');
  };

  BufferController.prototype.onSBUpdateEnd = function onSBUpdateEnd() {
    // update timestampOffset
    if (this.audioTimestampOffset) {
      var audioBuffer = this.sourceBuffer.audio;
      logger["b" /* logger */].warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
      audioBuffer.timestampOffset = this.audioTimestampOffset;
      delete this.audioTimestampOffset;
    }

    if (this._needsFlush) {
      this.doFlush();
    }

    if (this._needsEos) {
      this.checkEos();
    }
    this.appending = false;
    var parent = this.parent;
    // count nb of pending segments waiting for appending on this sourcebuffer
    var pending = this.segments.reduce(function (counter, segment) {
      return segment.parent === parent ? counter + 1 : counter;
    }, 0);
    this.hls.trigger(events["a" /* default */].BUFFER_APPENDED, { parent: parent, pending: pending });

    // don't append in flushing mode
    if (!this._needsFlush) {
      this.doAppending();
    }

    this.updateMediaElementDuration();
  };

  BufferController.prototype.onSBUpdateError = function onSBUpdateError(event) {
    logger["b" /* logger */].error('sourceBuffer error:', event);
    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
    // this error might not always be fatal (it is fatal if decode error is set, in that case
    // it will be followed by a mediaElement error ...)
    this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].BUFFER_APPENDING_ERROR, fatal: false });
    // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
  };

  BufferController.prototype.onBufferReset = function onBufferReset() {
    var sourceBuffer = this.sourceBuffer;
    for (var type in sourceBuffer) {
      var sb = sourceBuffer[type];
      try {
        this.mediaSource.removeSourceBuffer(sb);
        sb.removeEventListener('updateend', this.onsbue);
        sb.removeEventListener('error', this.onsbe);
      } catch (err) {}
    }
    this.sourceBuffer = {};
    this.flushRange = [];
    this.segments = [];
    this.appended = 0;
  };

  BufferController.prototype.onBufferCodecs = function onBufferCodecs(tracks) {
    // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
    // if sourcebuffers already created, do nothing ...
    if (Object.keys(this.sourceBuffer).length === 0) {
      for (var trackName in tracks) {
        this.pendingTracks[trackName] = tracks[trackName];
      }
      var mediaSource = this.mediaSource;
      if (mediaSource && mediaSource.readyState === 'open') {
        // try to create sourcebuffers if mediasource opened
        this.checkPendingTracks();
      }
    }
  };

  BufferController.prototype.createSourceBuffers = function createSourceBuffers(tracks) {
    var sourceBuffer = this.sourceBuffer,
        mediaSource = this.mediaSource;

    for (var trackName in tracks) {
      if (!sourceBuffer[trackName]) {
        var track = tracks[trackName];
        // use levelCodec as first priority
        var codec = track.levelCodec || track.codec;
        var mimeType = track.container + ';codecs=' + codec;
        logger["b" /* logger */].log('creating sourceBuffer(' + mimeType + ')');
        try {
          var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
          sb.addEventListener('updateend', this.onsbue);
          sb.addEventListener('error', this.onsbe);
          this.tracks[trackName] = { codec: codec, container: track.container };
          track.buffer = sb;
        } catch (err) {
          logger["b" /* logger */].error('error while trying to add sourceBuffer:' + err.message);
          this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
        }
      }
    }
    this.hls.trigger(events["a" /* default */].BUFFER_CREATED, { tracks: tracks });
  };

  BufferController.prototype.onBufferAppending = function onBufferAppending(data) {
    if (!this._needsFlush) {
      if (!this.segments) {
        this.segments = [data];
      } else {
        this.segments.push(data);
      }
      this.doAppending();
    }
  };

  BufferController.prototype.onBufferAppendFail = function onBufferAppendFail(data) {
    logger["b" /* logger */].error('sourceBuffer error:', data.event);
    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
    // this error might not always be fatal (it is fatal if decode error is set, in that case
    // it will be followed by a mediaElement error ...)
    this.hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].BUFFER_APPENDING_ERROR, fatal: false });
  };

  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()


  BufferController.prototype.onBufferEos = function onBufferEos(data) {
    var sb = this.sourceBuffer;
    var dataType = data.type;
    for (var type in sb) {
      if (!dataType || type === dataType) {
        if (!sb[type].ended) {
          sb[type].ended = true;
          logger["b" /* logger */].log(type + ' sourceBuffer now EOS');
        }
      }
    }
    this.checkEos();
  };

  // if all source buffers are marked as ended, signal endOfStream() to MediaSource.


  BufferController.prototype.checkEos = function checkEos() {
    var sb = this.sourceBuffer,
        mediaSource = this.mediaSource;
    if (!mediaSource || mediaSource.readyState !== 'open') {
      this._needsEos = false;
      return;
    }
    for (var type in sb) {
      var sbobj = sb[type];
      if (!sbobj.ended) {
        return;
      }
      if (sbobj.updating) {
        this._needsEos = true;
        return;
      }
    }
    logger["b" /* logger */].log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
    //Notify the media element that it now has all of the media data
    try {
      mediaSource.endOfStream();
    } catch (e) {
      logger["b" /* logger */].warn('exception while calling mediaSource.endOfStream()');
    }
    this._needsEos = false;
  };

  BufferController.prototype.onBufferFlushing = function onBufferFlushing(data) {
    this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
    // attempt flush immediately
    this.flushBufferCounter = 0;
    this.doFlush();
  };

  BufferController.prototype.onLevelUpdated = function onLevelUpdated(_ref) {
    var details = _ref.details;

    if (details.fragments.length > 0) {
      this._levelDuration = details.totalduration + details.fragments[0].start;
      this._live = details.live;
      this.updateMediaElementDuration();
    }
  };

  /**
   * Update Media Source duration to current level duration or override to Infinity if configuration parameter
   * 'liveDurationInfinity` is set to `true`
   * More details: https://github.com/video-dev/hls.js/issues/355
   */


  BufferController.prototype.updateMediaElementDuration = function updateMediaElementDuration() {
    var config = this.hls.config;

    var duration = void 0;

    if (this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== 'open') {
      return;
    }

    for (var type in this.sourceBuffer) {
      if (this.sourceBuffer[type].updating === true) {
        // can't set duration whilst a buffer is updating
        return;
      }
    }

    duration = this.media.duration;
    // initialise to the value that the media source is reporting
    if (this._msDuration === null) {
      this._msDuration = this.mediaSource.duration;
    }

    if (this._live === true && config.liveDurationInfinity === true) {
      // Override duration to Infinity
      logger["b" /* logger */].log('Media Source duration is set to Infinity');
      this._msDuration = this.mediaSource.duration = Infinity;
    } else if (this._levelDuration > this._msDuration && this._levelDuration > duration || duration === Infinity || isNaN(duration)) {
      // levelDuration was the last value we set.
      // not using mediaSource.duration as the browser may tweak this value
      // only update Media Source duration if its value increase, this is to avoid
      // flushing already buffered portion when switching between quality level
      logger["b" /* logger */].log('Updating Media Source duration to ' + this._levelDuration.toFixed(3));
      this._msDuration = this.mediaSource.duration = this._levelDuration;
    }
  };

  BufferController.prototype.doFlush = function doFlush() {
    // loop through all buffer ranges to flush
    while (this.flushRange.length) {
      var range = this.flushRange[0];
      // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
      if (this.flushBuffer(range.start, range.end, range.type)) {
        // range flushed, remove from flush array
        this.flushRange.shift();
        this.flushBufferCounter = 0;
      } else {
        this._needsFlush = true;
        // avoid looping, wait for SB update end to retrigger a flush
        return;
      }
    }
    if (this.flushRange.length === 0) {
      // everything flushed
      this._needsFlush = false;

      // let's recompute this.appended, which is used to avoid flush looping
      var appended = 0;
      var sourceBuffer = this.sourceBuffer;
      try {
        for (var type in sourceBuffer) {
          appended += sourceBuffer[type].buffered.length;
        }
      } catch (error) {
        // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
        // this is harmess at this stage, catch this to avoid reporting an internal exception
        logger["b" /* logger */].error('error while accessing sourceBuffer.buffered');
      }
      this.appended = appended;
      this.hls.trigger(events["a" /* default */].BUFFER_FLUSHED);
    }
  };

  BufferController.prototype.doAppending = function doAppending() {
    var hls = this.hls,
        sourceBuffer = this.sourceBuffer,
        segments = this.segments;
    if (Object.keys(sourceBuffer).length) {
      if (this.media.error) {
        this.segments = [];
        logger["b" /* logger */].error('trying to append although a media error occured, flush segment and abort');
        return;
      }
      if (this.appending) {
        //logger.log(`sb appending in progress`);
        return;
      }
      if (segments && segments.length) {
        var segment = segments.shift();
        try {
          var type = segment.type,
              sb = sourceBuffer[type];
          if (sb) {
            if (!sb.updating) {
              // reset sourceBuffer ended flag before appending segment
              sb.ended = false;
              //logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
              this.parent = segment.parent;
              sb.appendBuffer(segment.data);
              this.appendError = 0;
              this.appended++;
              this.appending = true;
            } else {
              segments.unshift(segment);
            }
          } else {
            // in case we don't have any source buffer matching with this segment type,
            // it means that Mediasource fails to create sourcebuffer
            // discard this segment, and trigger update end
            this.onSBUpdateEnd();
          }
        } catch (err) {
          // in case any error occured while appending, put back segment in segments table
          logger["b" /* logger */].error('error while trying to append buffer:' + err.message);
          segments.unshift(segment);
          var event = { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, parent: segment.parent };
          if (err.code !== 22) {
            if (this.appendError) {
              this.appendError++;
            } else {
              this.appendError = 1;
            }
            event.details = errors["a" /* ErrorDetails */].BUFFER_APPEND_ERROR;
            /* with UHD content, we could get loop of quota exceeded error until
              browser is able to evict some data from sourcebuffer. retrying help recovering this
            */
            if (this.appendError > hls.config.appendErrorMaxRetry) {
              logger["b" /* logger */].log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
              segments = [];
              event.fatal = true;
              hls.trigger(events["a" /* default */].ERROR, event);
              return;
            } else {
              event.fatal = false;
              hls.trigger(events["a" /* default */].ERROR, event);
            }
          } else {
            // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
            // let's stop appending any segments, and report BUFFER_FULL_ERROR error
            this.segments = [];
            event.details = errors["a" /* ErrorDetails */].BUFFER_FULL_ERROR;
            event.fatal = false;
            hls.trigger(events["a" /* default */].ERROR, event);
            return;
          }
        }
      }
    }
  };

  /*
    flush specified buffered range,
    return true once range has been flushed.
    as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
  */


  BufferController.prototype.flushBuffer = function flushBuffer(startOffset, endOffset, typeIn) {
    var sb,
        i,
        bufStart,
        bufEnd,
        flushStart,
        flushEnd,
        sourceBuffer = this.sourceBuffer;
    if (Object.keys(sourceBuffer).length) {
      logger["b" /* logger */].log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
      // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
      if (this.flushBufferCounter < this.appended) {
        for (var type in sourceBuffer) {
          // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
          // if no, let's flush all sourcebuffers
          if (typeIn && type !== typeIn) {
            continue;
          }
          sb = sourceBuffer[type];
          // we are going to flush buffer, mark source buffer as 'not ended'
          sb.ended = false;
          if (!sb.updating) {
            try {
              for (i = 0; i < sb.buffered.length; i++) {
                bufStart = sb.buffered.start(i);
                bufEnd = sb.buffered.end(i);
                // workaround firefox not able to properly flush multiple buffered range.
                if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                  flushStart = startOffset;
                  flushEnd = endOffset;
                } else {
                  flushStart = Math.max(bufStart, startOffset);
                  flushEnd = Math.min(bufEnd, endOffset);
                }
                /* sometimes sourcebuffer.remove() does not flush
                   the exact expected time range.
                   to avoid rounding issues/infinite loop,
                   only flush buffer range of length greater than 500ms.
                */
                if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                  this.flushBufferCounter++;
                  logger["b" /* logger */].log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                  sb.remove(flushStart, flushEnd);
                  return false;
                }
              }
            } catch (e) {
              logger["b" /* logger */].warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');
            }
          } else {
            //logger.log('abort ' + type + ' append in progress');
            // this will abort any appending in progress
            //sb.abort();
            logger["b" /* logger */].warn('cannot flush, sb updating in progress');
            return false;
          }
        }
      } else {
        logger["b" /* logger */].warn('abort flushing too many retries');
      }
      logger["b" /* logger */].log('buffer flushed');
    }
    // everything flushed !
    return true;
  };

  return BufferController;
}(event_handler);

/* harmony default export */ var buffer_controller = (buffer_controller_BufferController);
// CONCATENATED MODULE: ./src/controller/cap-level-controller.js
var cap_level_controller__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function cap_level_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function cap_level_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function cap_level_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * cap stream level to media size dimension controller
*/




var cap_level_controller_CapLevelController = function (_EventHandler) {
  cap_level_controller__inherits(CapLevelController, _EventHandler);

  function CapLevelController(hls) {
    cap_level_controller__classCallCheck(this, CapLevelController);

    return cap_level_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].FPS_DROP_LEVEL_CAPPING, events["a" /* default */].MEDIA_ATTACHING, events["a" /* default */].MANIFEST_PARSED));
  }

  CapLevelController.prototype.destroy = function destroy() {
    if (this.hls.config.capLevelToPlayerSize) {
      this.media = this.restrictedLevels = null;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) {
        this.timer = clearInterval(this.timer);
      }
    }
  };

  CapLevelController.prototype.onFpsDropLevelCapping = function onFpsDropLevelCapping(data) {
    // Don't add a restricted level more than once
    if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
      this.restrictedLevels.push(data.droppedLevel);
    }
  };

  CapLevelController.prototype.onMediaAttaching = function onMediaAttaching(data) {
    this.media = data.media instanceof HTMLVideoElement ? data.media : null;
  };

  CapLevelController.prototype.onManifestParsed = function onManifestParsed(data) {
    var hls = this.hls;
    this.restrictedLevels = [];
    if (hls.config.capLevelToPlayerSize) {
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.levels = data.levels;
      hls.firstLevel = this.getMaxLevel(data.firstLevel);
      clearInterval(this.timer);
      this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
      this.detectPlayerSize();
    }
  };

  CapLevelController.prototype.detectPlayerSize = function detectPlayerSize() {
    if (this.media) {
      var levelsLength = this.levels ? this.levels.length : 0;
      if (levelsLength) {
        var hls = this.hls;
        hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
        if (hls.autoLevelCapping > this.autoLevelCapping) {
          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
          // usually happen when the user go to the fullscreen mode.
          hls.streamController.nextLevelSwitch();
        }
        this.autoLevelCapping = hls.autoLevelCapping;
      }
    }
  };

  /*
  * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
  */


  CapLevelController.prototype.getMaxLevel = function getMaxLevel(capLevelIndex) {
    var _this2 = this;

    if (!this.levels) {
      return -1;
    }

    var validLevels = this.levels.filter(function (level, index) {
      return CapLevelController.isLevelAllowed(index, _this2.restrictedLevels) && index <= capLevelIndex;
    });

    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
  };

  CapLevelController.isLevelAllowed = function isLevelAllowed(level) {
    var restrictedLevels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    return restrictedLevels.indexOf(level) === -1;
  };

  CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
    if (!levels || levels && !levels.length) {
      return -1;
    }

    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next
    // to determine whether we've chosen the greatest bandwidth for the media's dimensions
    var atGreatestBandiwdth = function atGreatestBandiwdth(curLevel, nextLevel) {
      if (!nextLevel) {
        return true;
      }
      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
    };

    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to
    // the max level
    var maxLevelIndex = levels.length - 1;

    for (var i = 0; i < levels.length; i += 1) {
      var level = levels[i];
      if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
        maxLevelIndex = i;
        break;
      }
    }

    return maxLevelIndex;
  };

  cap_level_controller__createClass(CapLevelController, [{
    key: 'mediaWidth',
    get: function get() {
      var width = void 0;
      var media = this.media;
      if (media) {
        width = media.width || media.clientWidth || media.offsetWidth;
        width *= CapLevelController.contentScaleFactor;
      }
      return width;
    }
  }, {
    key: 'mediaHeight',
    get: function get() {
      var height = void 0;
      var media = this.media;
      if (media) {
        height = media.height || media.clientHeight || media.offsetHeight;
        height *= CapLevelController.contentScaleFactor;
      }
      return height;
    }
  }], [{
    key: 'contentScaleFactor',
    get: function get() {
      var pixelRatio = 1;
      try {
        pixelRatio = window.devicePixelRatio;
      } catch (e) {}
      return pixelRatio;
    }
  }]);

  return CapLevelController;
}(event_handler);

/* harmony default export */ var cap_level_controller = (cap_level_controller_CapLevelController);
// CONCATENATED MODULE: ./src/controller/fps-controller.js
function fps_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function fps_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function fps_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * FPS Controller
*/





var fps_controller_FPSController = function (_EventHandler) {
  fps_controller__inherits(FPSController, _EventHandler);

  function FPSController(hls) {
    fps_controller__classCallCheck(this, FPSController);

    return fps_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MEDIA_ATTACHING));
  }

  FPSController.prototype.destroy = function destroy() {
    if (this.timer) {
      clearInterval(this.timer);
    }
    this.isVideoPlaybackQualityAvailable = false;
  };

  FPSController.prototype.onMediaAttaching = function onMediaAttaching(data) {
    var config = this.hls.config;
    if (config.capLevelOnFPSDrop) {
      var video = this.video = data.media instanceof HTMLVideoElement ? data.media : null;
      if (typeof video.getVideoPlaybackQuality === 'function') {
        this.isVideoPlaybackQualityAvailable = true;
      }
      clearInterval(this.timer);
      this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
    }
  };

  FPSController.prototype.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
    var currentTime = performance.now();
    if (decodedFrames) {
      if (this.lastTime) {
        var currentPeriod = currentTime - this.lastTime,
            currentDropped = droppedFrames - this.lastDroppedFrames,
            currentDecoded = decodedFrames - this.lastDecodedFrames,
            droppedFPS = 1000 * currentDropped / currentPeriod,
            hls = this.hls;
        hls.trigger(events["a" /* default */].FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
        if (droppedFPS > 0) {
          //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
            var currentLevel = hls.currentLevel;
            logger["b" /* logger */].warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
              currentLevel = currentLevel - 1;
              hls.trigger(events["a" /* default */].FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
              hls.autoLevelCapping = currentLevel;
              hls.streamController.nextLevelSwitch();
            }
          }
        }
      }
      this.lastTime = currentTime;
      this.lastDroppedFrames = droppedFrames;
      this.lastDecodedFrames = decodedFrames;
    }
  };

  FPSController.prototype.checkFPSInterval = function checkFPSInterval() {
    var video = this.video;
    if (video) {
      if (this.isVideoPlaybackQualityAvailable) {
        var videoPlaybackQuality = video.getVideoPlaybackQuality();
        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
      } else {
        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
      }
    }
  };

  return FPSController;
}(event_handler);

/* harmony default export */ var fps_controller = (fps_controller_FPSController);
// CONCATENATED MODULE: ./src/utils/xhr-loader.js
function xhr_loader__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * XHR based logger
*/



var xhr_loader_XhrLoader = function () {
  function XhrLoader(config) {
    xhr_loader__classCallCheck(this, XhrLoader);

    if (config && config.xhrSetup) {
      this.xhrSetup = config.xhrSetup;
    }
  }

  XhrLoader.prototype.destroy = function destroy() {
    this.abort();
    this.loader = null;
  };

  XhrLoader.prototype.abort = function abort() {
    var loader = this.loader;
    if (loader && loader.readyState !== 4) {
      this.stats.aborted = true;
      loader.abort();
    }

    window.clearTimeout(this.requestTimeout);
    this.requestTimeout = null;
    window.clearTimeout(this.retryTimeout);
    this.retryTimeout = null;
  };

  XhrLoader.prototype.load = function load(context, config, callbacks) {
    this.context = context;
    this.config = config;
    this.callbacks = callbacks;
    this.stats = { trequest: performance.now(), retry: 0 };
    this.retryDelay = config.retryDelay;
    this.loadInternal();
  };

  XhrLoader.prototype.loadInternal = function loadInternal() {
    var xhr,
        context = this.context;
    xhr = this.loader = new XMLHttpRequest();

    var stats = this.stats;
    stats.tfirst = 0;
    stats.loaded = 0;
    var xhrSetup = this.xhrSetup;

    try {
      if (xhrSetup) {
        try {
          xhrSetup(xhr, context.url);
        } catch (e) {
          // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
          // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
          xhr.open('GET', context.url, true);
          xhrSetup(xhr, context.url);
        }
      }
      if (!xhr.readyState) {
        xhr.open('GET', context.url, true);
      }
    } catch (e) {
      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS
      this.callbacks.onError({ code: xhr.status, text: e.message }, context, xhr);
      return;
    }

    if (context.rangeEnd) {
      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
    }
    xhr.onreadystatechange = this.readystatechange.bind(this);
    xhr.onprogress = this.loadprogress.bind(this);
    xhr.responseType = context.responseType;

    // setup timeout before we perform request
    this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
    xhr.send();
  };

  XhrLoader.prototype.readystatechange = function readystatechange(event) {
    var xhr = event.currentTarget,
        readyState = xhr.readyState,
        stats = this.stats,
        context = this.context,
        config = this.config;

    // don't proceed if xhr has been aborted
    if (stats.aborted) {
      return;
    }

    // >= HEADERS_RECEIVED
    if (readyState >= 2) {
      // clear xhr timeout and rearm it if readyState less than 4
      window.clearTimeout(this.requestTimeout);
      if (stats.tfirst === 0) {
        stats.tfirst = Math.max(performance.now(), stats.trequest);
      }
      if (readyState === 4) {
        var status = xhr.status;
        // http status between 200 to 299 are all successful
        if (status >= 200 && status < 300) {
          stats.tload = Math.max(stats.tfirst, performance.now());
          var data = void 0,
              len = void 0;
          if (context.responseType === 'arraybuffer') {
            data = xhr.response;
            len = data.byteLength;
          } else {
            data = xhr.responseText;
            len = data.length;
          }
          stats.loaded = stats.total = len;
          var response = { url: xhr.responseURL, data: data };
          this.callbacks.onSuccess(response, stats, context, xhr);
        } else {
          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
          if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
            logger["b" /* logger */].error(status + ' while loading ' + context.url);
            this.callbacks.onError({ code: status, text: xhr.statusText }, context, xhr);
          } else {
            // retry
            logger["b" /* logger */].warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
            // aborts and resets internal state
            this.destroy();
            // schedule retry
            this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
            // set exponential backoff
            this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
            stats.retry++;
          }
        }
      } else {
        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
        this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
      }
    }
  };

  XhrLoader.prototype.loadtimeout = function loadtimeout() {
    logger["b" /* logger */].warn('timeout while loading ' + this.context.url);
    this.callbacks.onTimeout(this.stats, this.context, null);
  };

  XhrLoader.prototype.loadprogress = function loadprogress(event) {
    var xhr = event.currentTarget,
        stats = this.stats;

    stats.loaded = event.loaded;
    if (event.lengthComputable) {
      stats.total = event.total;
    }
    var onProgress = this.callbacks.onProgress;
    if (onProgress) {
      // third arg is to provide on progress data
      onProgress(stats, this.context, null, xhr);
    }
  };

  return XhrLoader;
}();

/* harmony default export */ var xhr_loader = (xhr_loader_XhrLoader);
// CONCATENATED MODULE: ./src/controller/audio-track-controller.js
var audio_track_controller__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function audio_track_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function audio_track_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function audio_track_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * audio track controller
*/






var audio_track_controller_AudioTrackController = function (_EventHandler) {
  audio_track_controller__inherits(AudioTrackController, _EventHandler);

  function AudioTrackController(hls) {
    audio_track_controller__classCallCheck(this, AudioTrackController);

    var _this = audio_track_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MANIFEST_LOADING, events["a" /* default */].MANIFEST_PARSED, events["a" /* default */].AUDIO_TRACK_LOADED, events["a" /* default */].ERROR));

    _this.ticks = 0;
    _this.ontick = _this.tick.bind(_this);
    return _this;
  }

  AudioTrackController.prototype.destroy = function destroy() {
    this.cleanTimer();
    event_handler.prototype.destroy.call(this);
  };

  AudioTrackController.prototype.cleanTimer = function cleanTimer() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  };

  AudioTrackController.prototype.tick = function tick() {
    this.ticks++;
    if (this.ticks === 1) {
      this.doTick();
      if (this.ticks > 1) {
        setTimeout(this.tick, 1);
      }
      this.ticks = 0;
    }
  };

  AudioTrackController.prototype.doTick = function doTick() {
    this.updateTrack(this.trackId);
  };

  AudioTrackController.prototype.onError = function onError(data) {
    if (data.fatal && data.type === errors["b" /* ErrorTypes */].NETWORK_ERROR) {
      this.cleanTimer();
    }
  };

  AudioTrackController.prototype.onManifestLoading = function onManifestLoading() {
    // reset audio tracks on manifest loading
    this.tracks = [];
    this.trackId = -1;
  };

  AudioTrackController.prototype.onManifestParsed = function onManifestParsed(data) {
    var _this2 = this;

    var tracks = data.audioTracks || [];
    var defaultFound = false;
    this.tracks = tracks;
    this.hls.trigger(events["a" /* default */].AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
    // loop through available audio tracks and autoselect default if needed
    var id = 0;
    tracks.forEach(function (track) {
      if (track.default && !defaultFound) {
        _this2.audioTrack = id;
        defaultFound = true;
        return;
      }
      id++;
    });
    if (defaultFound === false && tracks.length) {
      logger["b" /* logger */].log('no default audio track defined, use first audio track as default');
      this.audioTrack = 0;
    }
  };

  AudioTrackController.prototype.onAudioTrackLoaded = function onAudioTrackLoaded(data) {
    if (data.id < this.tracks.length) {
      logger["b" /* logger */].log('audioTrack ' + data.id + ' loaded');
      this.tracks[data.id].details = data.details;
      // check if current playlist is a live playlist
      if (data.details.live && !this.timer) {
        // if live playlist we will have to reload it periodically
        // set reload period to playlist target duration
        this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
      }
      if (!data.details.live && this.timer) {
        // playlist is not live and timer is armed : stopping it
        this.cleanTimer();
      }
    }
  };

  /** get alternate audio tracks list from playlist **/


  AudioTrackController.prototype.setAudioTrackInternal = function setAudioTrackInternal(newId) {
    // check if level idx is valid
    if (newId >= 0 && newId < this.tracks.length) {
      // stopping live reloading timer if any
      this.cleanTimer();
      this.trackId = newId;
      logger["b" /* logger */].log('switching to audioTrack ' + newId);
      var audioTrack = this.tracks[newId],
          hls = this.hls,
          type = audioTrack.type,
          url = audioTrack.url,
          eventObj = { id: newId, type: type, url: url };
      // keep AUDIO_TRACK_SWITCH for legacy reason
      hls.trigger(events["a" /* default */].AUDIO_TRACK_SWITCH, eventObj);
      hls.trigger(events["a" /* default */].AUDIO_TRACK_SWITCHING, eventObj);
      // check if we need to load playlist for this audio Track
      var details = audioTrack.details;
      if (url && (details === undefined || details.live === true)) {
        // track not retrieved yet, or live playlist we need to (re)load it
        logger["b" /* logger */].log('(re)loading playlist for audioTrack ' + newId);
        hls.trigger(events["a" /* default */].AUDIO_TRACK_LOADING, { url: url, id: newId });
      }
    }
  };

  AudioTrackController.prototype.updateTrack = function updateTrack(newId) {
    // check if level idx is valid
    if (newId >= 0 && newId < this.tracks.length) {
      // stopping live reloading timer if any
      this.cleanTimer();
      this.trackId = newId;
      logger["b" /* logger */].log('updating audioTrack ' + newId);
      var audioTrack = this.tracks[newId],
          url = audioTrack.url;
      // check if we need to load playlist for this audio Track
      var details = audioTrack.details;
      if (url && (details === undefined || details.live === true)) {
        // track not retrieved yet, or live playlist we need to (re)load it
        logger["b" /* logger */].log('(re)loading playlist for audioTrack ' + newId);
        this.hls.trigger(events["a" /* default */].AUDIO_TRACK_LOADING, { url: url, id: newId });
      }
    }
  };

  audio_track_controller__createClass(AudioTrackController, [{
    key: 'audioTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      return this.trackId;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
        this.setAudioTrackInternal(audioTrackId);
      }
    }
  }]);

  return AudioTrackController;
}(event_handler);

/* harmony default export */ var audio_track_controller = (audio_track_controller_AudioTrackController);
// CONCATENATED MODULE: ./src/controller/audio-stream-controller.js
var audio_stream_controller__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function audio_stream_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function audio_stream_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function audio_stream_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Audio Stream Controller
*/











var audio_stream_controller_State = {
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  IDLE: 'IDLE',
  PAUSED: 'PAUSED',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING',
  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
  WAITING_TRACK: 'WAITING_TRACK',
  PARSING: 'PARSING',
  PARSED: 'PARSED',
  BUFFER_FLUSHING: 'BUFFER_FLUSHING',
  ENDED: 'ENDED',
  ERROR: 'ERROR',
  WAITING_INIT_PTS: 'WAITING_INIT_PTS'
};

var audio_stream_controller_AudioStreamController = function (_EventHandler) {
  audio_stream_controller__inherits(AudioStreamController, _EventHandler);

  function AudioStreamController(hls) {
    audio_stream_controller__classCallCheck(this, AudioStreamController);

    var _this = audio_stream_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MEDIA_ATTACHED, events["a" /* default */].MEDIA_DETACHING, events["a" /* default */].AUDIO_TRACKS_UPDATED, events["a" /* default */].AUDIO_TRACK_SWITCHING, events["a" /* default */].AUDIO_TRACK_LOADED, events["a" /* default */].KEY_LOADED, events["a" /* default */].FRAG_LOADED, events["a" /* default */].FRAG_PARSING_INIT_SEGMENT, events["a" /* default */].FRAG_PARSING_DATA, events["a" /* default */].FRAG_PARSED, events["a" /* default */].ERROR, events["a" /* default */].BUFFER_RESET, events["a" /* default */].BUFFER_CREATED, events["a" /* default */].BUFFER_APPENDED, events["a" /* default */].BUFFER_FLUSHED, events["a" /* default */].INIT_PTS_FOUND));

    _this.config = hls.config;
    _this.audioCodecSwap = false;
    _this.ticks = 0;
    _this._state = audio_stream_controller_State.STOPPED;
    _this.ontick = _this.tick.bind(_this);
    _this.initPTS = [];
    _this.waitingFragment = null;
    _this.videoTrackCC = null;
    return _this;
  }

  AudioStreamController.prototype.destroy = function destroy() {
    this.stopLoad();
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
    event_handler.prototype.destroy.call(this);
    this.state = audio_stream_controller_State.STOPPED;
  };

  //Signal that video PTS was found


  AudioStreamController.prototype.onInitPtsFound = function onInitPtsFound(data) {
    var demuxerId = data.id,
        cc = data.frag.cc,
        initPTS = data.initPTS;
    if (demuxerId === 'main') {
      //Always update the new INIT PTS
      //Can change due level switch
      this.initPTS[cc] = initPTS;
      this.videoTrackCC = cc;
      logger["b" /* logger */].log('InitPTS for cc:' + cc + ' found from video track:' + initPTS);

      //If we are waiting we need to demux/remux the waiting frag
      //With the new initPTS
      if (this.state === audio_stream_controller_State.WAITING_INIT_PTS) {
        this.tick();
      }
    }
  };

  AudioStreamController.prototype.startLoad = function startLoad(startPosition) {
    if (this.tracks) {
      var lastCurrentTime = this.lastCurrentTime;
      this.stopLoad();
      if (!this.timer) {
        this.timer = setInterval(this.ontick, 100);
      }
      this.fragLoadError = 0;
      if (lastCurrentTime > 0 && startPosition === -1) {
        logger["b" /* logger */].log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
        this.state = audio_stream_controller_State.IDLE;
      } else {
        this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
        this.state = audio_stream_controller_State.STARTING;
      }
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
      this.tick();
    } else {
      this.startPosition = startPosition;
      this.state = audio_stream_controller_State.STOPPED;
    }
  };

  AudioStreamController.prototype.stopLoad = function stopLoad() {
    var frag = this.fragCurrent;
    if (frag) {
      if (frag.loader) {
        frag.loader.abort();
      }
      this.fragCurrent = null;
    }
    this.fragPrevious = null;
    if (this.demuxer) {
      this.demuxer.destroy();
      this.demuxer = null;
    }
    this.state = audio_stream_controller_State.STOPPED;
  };

  AudioStreamController.prototype.tick = function tick() {
    this.ticks++;
    if (this.ticks === 1) {
      this.doTick();
      if (this.ticks > 1) {
        setTimeout(this.tick, 1);
      }
      this.ticks = 0;
    }
  };

  AudioStreamController.prototype.doTick = function doTick() {
    var pos,
        track,
        trackDetails,
        hls = this.hls,
        config = hls.config;
    //logger.log('audioStream:' + this.state);
    switch (this.state) {
      case audio_stream_controller_State.ERROR:
      //don't do anything in error state to avoid breaking further ...
      case audio_stream_controller_State.PAUSED:
      //don't do anything in paused state either ...
      case audio_stream_controller_State.BUFFER_FLUSHING:
        break;
      case audio_stream_controller_State.STARTING:
        this.state = audio_stream_controller_State.WAITING_TRACK;
        this.loadedmetadata = false;
        break;
      case audio_stream_controller_State.IDLE:
        var tracks = this.tracks;
        // audio tracks not received => exit loop
        if (!tracks) {
          break;
        }
        // if video not attached AND
        // start fragment already requested OR start frag prefetch disable
        // exit loop
        // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
        if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
          break;
        }
        // determine next candidate fragment to be loaded, based on current position and
        //  end of buffer position
        // if we have not yet loaded any fragment, start loading from start position
        if (this.loadedmetadata) {
          pos = this.media.currentTime;
        } else {
          pos = this.nextLoadPosition;
          if (pos === undefined) {
            break;
          }
        }
        var media = this.mediaBuffer ? this.mediaBuffer : this.media,
            videoBuffer = this.videoBuffer ? this.videoBuffer : this.media,
            bufferInfo = buffer_helper.bufferInfo(media, pos, config.maxBufferHole),
            mainBufferInfo = buffer_helper.bufferInfo(videoBuffer, pos, config.maxBufferHole),
            bufferLen = bufferInfo.len,
            bufferEnd = bufferInfo.end,
            fragPrevious = this.fragPrevious,

        // ensure we buffer at least config.maxBufferLength (default 30s)
        // once we reach that threshold, don't buffer more than video (mainBufferInfo.len)
        maxBufLen = Math.max(config.maxBufferLength, mainBufferInfo.len),
            audioSwitch = this.audioSwitch,
            trackId = this.trackId;

        // if buffer length is less than maxBufLen try to load a new fragment
        if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
          trackDetails = tracks[trackId].details;
          // if track info not retrieved yet, switch state and wait for track retrieval
          if (typeof trackDetails === 'undefined') {
            this.state = audio_stream_controller_State.WAITING_TRACK;
            break;
          }

          // check if we need to finalize media stream
          // we just got done loading the final fragment and there is no other buffered range after ...
          // rationale is that in case there are any buffered ranges after, it means that there are unbuffered portion in between
          // so we should not switch to ENDED in that case, to be able to buffer them
          if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN && !bufferInfo.nextStart) {
            // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
            // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
            // between different renditions. using half frag duration should help cope with these cases.
            if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
              // Finalize the media stream
              this.hls.trigger(events["a" /* default */].BUFFER_EOS, { type: 'audio' });
              this.state = audio_stream_controller_State.ENDED;
              break;
            }
          }

          // find fragment index, contiguous with end of buffer position
          var fragments = trackDetails.fragments,
              fragLen = fragments.length,
              start = fragments[0].start,
              end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
              frag = void 0;

          // When switching audio track, reload audio as close as possible to currentTime
          if (audioSwitch) {
            if (trackDetails.live && !trackDetails.PTSKnown) {
              logger["b" /* logger */].log('switching audiotrack, live stream, unknown PTS,load first fragment');
              bufferEnd = 0;
            } else {
              bufferEnd = pos;
              // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
              if (trackDetails.PTSKnown && pos < start) {
                // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                if (bufferInfo.end > start || bufferInfo.nextStart) {
                  logger["b" /* logger */].log('alt audio track ahead of main track, seek to start of alt audio track');
                  this.media.currentTime = start + 0.05;
                } else {
                  return;
                }
              }
            }
          }
          if (trackDetails.initSegment && !trackDetails.initSegment.data) {
            frag = trackDetails.initSegment;
          }
          // if bufferEnd before start of playlist, load first fragment
          else if (bufferEnd <= start) {
              frag = fragments[0];
              if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                // Ensure we find a fragment which matches the continuity of the video track
                frag = findFragWithCC(fragments, this.videoTrackCC);
              }
              if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                // let's force seek to start
                var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                logger["b" /* logger */].log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                this.media.currentTime = nextBuffered + 0.05;
                return;
              }
            } else {
              var foundFrag = void 0;
              var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
              var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
              var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                // offset should be within fragment boundary - config.maxFragLookUpTolerance
                // this is to cope with situations like
                // bufferEnd = 9.991
                // frag[Ø] : [0,10]
                // frag[1] : [10,20]
                // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                //              frag start               frag start+duration
                //                  |-----------------------------|
                //              <--->                         <--->
                //  ...--------><-----------------------------><---------....
                // previous frag         matching fragment         next frag
                //  return -1             return 0                 return 1
                //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                  return 1;
                } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                    return -1;
                  }
                return 0;
              };

              if (bufferEnd < end) {
                if (bufferEnd > end - maxFragLookUpTolerance) {
                  maxFragLookUpTolerance = 0;
                }
                // Prefer the next fragment if it's within tolerance
                if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                  foundFrag = fragNext;
                } else {
                  foundFrag = binary_search.search(fragments, fragmentWithinToleranceTest);
                }
              } else {
                // reach end of playlist
                foundFrag = fragments[fragLen - 1];
              }
              if (foundFrag) {
                frag = foundFrag;
                start = foundFrag.start;
                //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                  if (frag.sn < trackDetails.endSN) {
                    frag = fragments[frag.sn + 1 - trackDetails.startSN];
                    logger["b" /* logger */].log('SN just loaded, load next one: ' + frag.sn);
                  } else {
                    frag = null;
                  }
                }
              }
            }
          if (frag) {
            //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
            if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
              logger["b" /* logger */].log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
              this.state = audio_stream_controller_State.KEY_LOADING;
              hls.trigger(events["a" /* default */].KEY_LOADING, { frag: frag });
            } else {
              logger["b" /* logger */].log('Loading ' + frag.sn + ', cc: ' + frag.cc + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
              // ensure that we are not reloading the same fragments in loop ...
              if (this.fragLoadIdx !== undefined) {
                this.fragLoadIdx++;
              } else {
                this.fragLoadIdx = 0;
              }
              if (frag.loadCounter) {
                frag.loadCounter++;
                var maxThreshold = config.fragLoadingLoopThreshold;
                // if this frag has already been loaded 3 times, and if it has been reloaded recently
                if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                  hls.trigger(events["a" /* default */].ERROR, { type: errors["b" /* ErrorTypes */].MEDIA_ERROR, details: errors["a" /* ErrorDetails */].FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                  return;
                }
              } else {
                frag.loadCounter = 1;
              }
              frag.loadIdx = this.fragLoadIdx;
              this.fragCurrent = frag;
              this.startFragRequested = true;
              if (!isNaN(frag.sn)) {
                this.nextLoadPosition = frag.start + frag.duration;
              }
              hls.trigger(events["a" /* default */].FRAG_LOADING, { frag: frag });
              this.state = audio_stream_controller_State.FRAG_LOADING;
            }
          }
        }
        break;
      case audio_stream_controller_State.WAITING_TRACK:
        track = this.tracks[this.trackId];
        // check if playlist is already loaded
        if (track && track.details) {
          this.state = audio_stream_controller_State.IDLE;
        }
        break;
      case audio_stream_controller_State.FRAG_LOADING_WAITING_RETRY:
        var now = performance.now();
        var retryDate = this.retryDate;
        media = this.media;
        var isSeeking = media && media.seeking;
        // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
        if (!retryDate || now >= retryDate || isSeeking) {
          logger["b" /* logger */].log('audioStreamController: retryDate reached, switch back to IDLE state');
          this.state = audio_stream_controller_State.IDLE;
        }
        break;
      case audio_stream_controller_State.WAITING_INIT_PTS:
        var videoTrackCC = this.videoTrackCC;
        if (this.initPTS[videoTrackCC] === undefined) {
          break;
        }

        // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS
        var waitingFrag = this.waitingFragment;
        if (waitingFrag) {
          var waitingFragCC = waitingFrag.frag.cc;
          if (videoTrackCC !== waitingFragCC) {
            track = this.tracks[this.trackId];
            if (track.details && track.details.live) {
              logger["b" /* logger */].warn('Waiting fragment CC (' + waitingFragCC + ') does not match video track CC (' + videoTrackCC + ')');
              this.waitingFragment = null;
              this.state = audio_stream_controller_State.IDLE;
            }
          } else {
            this.state = audio_stream_controller_State.FRAG_LOADING;
            this.onFragLoaded(this.waitingFragment);
            this.waitingFragment = null;
          }
        } else {
          this.state = audio_stream_controller_State.IDLE;
        }

        break;
      case audio_stream_controller_State.STOPPED:
      case audio_stream_controller_State.FRAG_LOADING:
      case audio_stream_controller_State.PARSING:
      case audio_stream_controller_State.PARSED:
      case audio_stream_controller_State.ENDED:
        break;
      default:
        break;
    }
  };

  AudioStreamController.prototype.onMediaAttached = function onMediaAttached(data) {
    var media = this.media = this.mediaBuffer = data.media;
    this.onvseeking = this.onMediaSeeking.bind(this);
    this.onvended = this.onMediaEnded.bind(this);
    media.addEventListener('seeking', this.onvseeking);
    media.addEventListener('ended', this.onvended);
    var config = this.config;
    if (this.tracks && config.autoStartLoad) {
      this.startLoad(config.startPosition);
    }
  };

  AudioStreamController.prototype.onMediaDetaching = function onMediaDetaching() {
    var media = this.media;
    if (media && media.ended) {
      logger["b" /* logger */].log('MSE detaching and video ended, reset startPosition');
      this.startPosition = this.lastCurrentTime = 0;
    }

    // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
    var tracks = this.tracks;
    if (tracks) {
      // reset fragment load counter
      tracks.forEach(function (track) {
        if (track.details) {
          track.details.fragments.forEach(function (fragment) {
            fragment.loadCounter = undefined;
          });
        }
      });
    }
    // remove video listeners
    if (media) {
      media.removeEventListener('seeking', this.onvseeking);
      media.removeEventListener('ended', this.onvended);
      this.onvseeking = this.onvseeked = this.onvended = null;
    }
    this.media = this.mediaBuffer = this.videoBuffer = null;
    this.loadedmetadata = false;
    this.stopLoad();
  };

  AudioStreamController.prototype.onMediaSeeking = function onMediaSeeking() {
    if (this.state === audio_stream_controller_State.ENDED) {
      // switch to IDLE state to check for potential new fragment
      this.state = audio_stream_controller_State.IDLE;
    }
    if (this.media) {
      this.lastCurrentTime = this.media.currentTime;
    }
    // avoid reporting fragment loop loading error in case user is seeking several times on same position
    if (this.fragLoadIdx !== undefined) {
      this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
    }
    // tick to speed up processing
    this.tick();
  };

  AudioStreamController.prototype.onMediaEnded = function onMediaEnded() {
    // reset startPosition and lastCurrentTime to restart playback @ stream beginning
    this.startPosition = this.lastCurrentTime = 0;
  };

  AudioStreamController.prototype.onAudioTracksUpdated = function onAudioTracksUpdated(data) {
    logger["b" /* logger */].log('audio tracks updated');
    this.tracks = data.audioTracks;
  };

  AudioStreamController.prototype.onAudioTrackSwitching = function onAudioTrackSwitching(data) {
    // if any URL found on new audio track, it is an alternate audio track
    var altAudio = !!data.url;
    this.trackId = data.id;

    this.fragCurrent = null;
    this.state = audio_stream_controller_State.PAUSED;
    this.waitingFragment = null;
    // destroy useless demuxer when switching audio to main
    if (!altAudio) {
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = null;
      }
    } else {
      // switching to audio track, start timer if not already started
      if (!this.timer) {
        this.timer = setInterval(this.ontick, 100);
      }
    }

    //should we switch tracks ?
    if (altAudio) {
      this.audioSwitch = true;
      //main audio track are handled by stream-controller, just do something if switching to alt audio track
      this.state = audio_stream_controller_State.IDLE;
      // increase fragment load Index to avoid frag loop loading error after buffer flush
      if (this.fragLoadIdx !== undefined) {
        this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
      }
    }
    this.tick();
  };

  AudioStreamController.prototype.onAudioTrackLoaded = function onAudioTrackLoaded(data) {
    var newDetails = data.details,
        trackId = data.id,
        track = this.tracks[trackId],
        duration = newDetails.totalduration,
        sliding = 0;

    logger["b" /* logger */].log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);

    if (newDetails.live) {
      var curDetails = track.details;
      if (curDetails && newDetails.fragments.length > 0) {
        // we already have details for that level, merge them
        mergeDetails(curDetails, newDetails);
        sliding = newDetails.fragments[0].start;
        // TODO
        //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
        if (newDetails.PTSKnown) {
          logger["b" /* logger */].log('live audio playlist sliding:' + sliding.toFixed(3));
        } else {
          logger["b" /* logger */].log('live audio playlist - outdated PTS, unknown sliding');
        }
      } else {
        newDetails.PTSKnown = false;
        logger["b" /* logger */].log('live audio playlist - first load, unknown sliding');
      }
    } else {
      newDetails.PTSKnown = false;
    }
    track.details = newDetails;

    // compute start position
    if (!this.startFragRequested) {
      // compute start position if set to -1. use it straight away if value is defined
      if (this.startPosition === -1) {
        // first, check if start time offset has been set in playlist, if yes, use this value
        var startTimeOffset = newDetails.startTimeOffset;
        if (!isNaN(startTimeOffset)) {
          logger["b" /* logger */].log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
          this.startPosition = startTimeOffset;
        } else {
          this.startPosition = 0;
        }
      }
      this.nextLoadPosition = this.startPosition;
    }
    // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
    if (this.state === audio_stream_controller_State.WAITING_TRACK) {
      this.state = audio_stream_controller_State.IDLE;
    }
    //trigger handler right now
    this.tick();
  };

  AudioStreamController.prototype.onKeyLoaded = function onKeyLoaded() {
    if (this.state === audio_stream_controller_State.KEY_LOADING) {
      this.state = audio_stream_controller_State.IDLE;
      this.tick();
    }
  };

  AudioStreamController.prototype.onFragLoaded = function onFragLoaded(data) {
    var fragCurrent = this.fragCurrent,
        fragLoaded = data.frag;
    if (this.state === audio_stream_controller_State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
      var track = this.tracks[this.trackId],
          details = track.details,
          duration = details.totalduration,
          trackId = fragCurrent.level,
          sn = fragCurrent.sn,
          cc = fragCurrent.cc,
          audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
          stats = this.stats = data.stats;
      if (sn === 'initSegment') {
        this.state = audio_stream_controller_State.IDLE;

        stats.tparsed = stats.tbuffered = performance.now();
        details.initSegment.data = data.payload;
        this.hls.trigger(events["a" /* default */].FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
        this.tick();
      } else {
        this.state = audio_stream_controller_State.PARSING;
        // transmux the MPEG-TS data to ISO-BMFF segments
        this.appended = false;
        if (!this.demuxer) {
          this.demuxer = new demux_demuxer(this.hls, 'audio');
        }
        //Check if we have video initPTS
        // If not we need to wait for it
        var initPTS = this.initPTS[cc];
        var initSegmentData = details.initSegment ? details.initSegment.data : [];
        if (details.initSegment || initPTS !== undefined) {
          this.pendingBuffering = true;
          logger["b" /* logger */].log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
          // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
          var accurateTimeOffset = false; //details.PTSKnown || !details.live;
          this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
        } else {
          logger["b" /* logger */].log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
          this.waitingFragment = data;
          this.state = audio_stream_controller_State.WAITING_INIT_PTS;
        }
      }
    }
    this.fragLoadError = 0;
  };

  AudioStreamController.prototype.onFragParsingInitSegment = function onFragParsingInitSegment(data) {
    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === audio_stream_controller_State.PARSING) {
      var tracks = data.tracks,
          track = void 0;

      // delete any video track found on audio demuxer
      if (tracks.video) {
        delete tracks.video;
      }

      // include levelCodec in audio and video tracks
      track = tracks.audio;
      if (track) {
        track.levelCodec = track.codec;
        track.id = data.id;
        this.hls.trigger(events["a" /* default */].BUFFER_CODECS, tracks);
        logger["b" /* logger */].log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
        var initSegment = track.initSegment;
        if (initSegment) {
          var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
          if (this.audioSwitch) {
            this.pendingData = [appendObj];
          } else {
            this.appended = true;
            // arm pending Buffering flag before appending a segment
            this.pendingBuffering = true;
            this.hls.trigger(events["a" /* default */].BUFFER_APPENDING, appendObj);
          }
        }
        //trigger handler right now
        this.tick();
      }
    }
  };

  AudioStreamController.prototype.onFragParsingData = function onFragParsingData(data) {
    var _this2 = this;

    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === audio_stream_controller_State.PARSING) {
      var trackId = this.trackId,
          track = this.tracks[trackId],
          hls = this.hls;

      if (isNaN(data.endPTS)) {
        data.endPTS = data.startPTS + fragCurrent.duration;
        data.endDTS = data.startDTS + fragCurrent.duration;
      }

      logger["b" /* logger */].log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
      updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);

      var audioSwitch = this.audioSwitch,
          media = this.media,
          appendOnBufferFlush = false;
      //Only flush audio from old audio tracks when PTS is known on new audio track
      if (audioSwitch && media) {
        if (media.readyState) {
          var currentTime = media.currentTime;
          logger["b" /* logger */].log('switching audio track : currentTime:' + currentTime);
          if (currentTime >= data.startPTS) {
            logger["b" /* logger */].log('switching audio track : flushing all audio');
            this.state = audio_stream_controller_State.BUFFER_FLUSHING;
            hls.trigger(events["a" /* default */].BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            appendOnBufferFlush = true;
            //Lets announce that the initial audio track switch flush occur
            this.audioSwitch = false;
            hls.trigger(events["a" /* default */].AUDIO_TRACK_SWITCHED, { id: trackId });
          }
        } else {
          //Lets announce that the initial audio track switch flush occur
          this.audioSwitch = false;
          hls.trigger(events["a" /* default */].AUDIO_TRACK_SWITCHED, { id: trackId });
        }
      }

      var pendingData = this.pendingData;
      if (!this.audioSwitch) {
        [data.data1, data.data2].forEach(function (buffer) {
          if (buffer && buffer.length) {
            pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
          }
        });
        if (!appendOnBufferFlush && pendingData.length) {
          pendingData.forEach(function (appendObj) {
            // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
            // in that case it is useless to append following segments
            if (_this2.state === audio_stream_controller_State.PARSING) {
              // arm pending Buffering flag before appending a segment
              _this2.pendingBuffering = true;
              _this2.hls.trigger(events["a" /* default */].BUFFER_APPENDING, appendObj);
            }
          });
          this.pendingData = [];
          this.appended = true;
        }
      }
      //trigger handler right now
      this.tick();
    }
  };

  AudioStreamController.prototype.onFragParsed = function onFragParsed(data) {
    var fragCurrent = this.fragCurrent;
    var fragNew = data.frag;
    if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === audio_stream_controller_State.PARSING) {
      this.stats.tparsed = performance.now();
      this.state = audio_stream_controller_State.PARSED;
      this._checkAppendedParsed();
    }
  };

  AudioStreamController.prototype.onBufferReset = function onBufferReset() {
    // reset reference to sourcebuffers
    this.mediaBuffer = this.videoBuffer = null;
    this.loadedmetadata = false;
  };

  AudioStreamController.prototype.onBufferCreated = function onBufferCreated(data) {
    var audioTrack = data.tracks.audio;
    if (audioTrack) {
      this.mediaBuffer = audioTrack.buffer;
      this.loadedmetadata = true;
    }
    if (data.tracks.video) {
      this.videoBuffer = data.tracks.video.buffer;
    }
  };

  AudioStreamController.prototype.onBufferAppended = function onBufferAppended(data) {
    if (data.parent === 'audio') {
      var state = this.state;
      if (state === audio_stream_controller_State.PARSING || state === audio_stream_controller_State.PARSED) {
        // check if all buffers have been appended
        this.pendingBuffering = data.pending > 0;
        this._checkAppendedParsed();
      }
    }
  };

  AudioStreamController.prototype._checkAppendedParsed = function _checkAppendedParsed() {
    //trigger handler right now
    if (this.state === audio_stream_controller_State.PARSED && (!this.appended || !this.pendingBuffering)) {
      var frag = this.fragCurrent,
          stats = this.stats,
          hls = this.hls;
      if (frag) {
        this.fragPrevious = frag;
        stats.tbuffered = performance.now();
        hls.trigger(events["a" /* default */].FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
        var media = this.mediaBuffer ? this.mediaBuffer : this.media;
        logger["b" /* logger */].log('audio buffered : ' + timeRanges.toString(media.buffered));
        if (this.audioSwitch && this.appended) {
          this.audioSwitch = false;
          hls.trigger(events["a" /* default */].AUDIO_TRACK_SWITCHED, { id: this.trackId });
        }
        this.state = audio_stream_controller_State.IDLE;
      }
      this.tick();
    }
  };

  AudioStreamController.prototype.onError = function onError(data) {
    var frag = data.frag;
    // don't handle frag error not related to audio fragment
    if (frag && frag.type !== 'audio') {
      return;
    }
    switch (data.details) {
      case errors["a" /* ErrorDetails */].FRAG_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].FRAG_LOAD_TIMEOUT:
        if (!data.fatal) {
          var loadError = this.fragLoadError;
          if (loadError) {
            loadError++;
          } else {
            loadError = 1;
          }
          var config = this.config;
          if (loadError <= config.fragLoadingMaxRetry) {
            this.fragLoadError = loadError;
            // reset load counter to avoid frag loop loading error
            frag.loadCounter = 0;
            // exponential backoff capped to config.fragLoadingMaxRetryTimeout
            var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
            logger["b" /* logger */].warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
            this.retryDate = performance.now() + delay;
            // retry loading state
            this.state = audio_stream_controller_State.FRAG_LOADING_WAITING_RETRY;
          } else {
            logger["b" /* logger */].error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
            // switch error to fatal
            data.fatal = true;
            this.state = audio_stream_controller_State.ERROR;
          }
        }
        break;
      case errors["a" /* ErrorDetails */].FRAG_LOOP_LOADING_ERROR:
      case errors["a" /* ErrorDetails */].AUDIO_TRACK_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].AUDIO_TRACK_LOAD_TIMEOUT:
      case errors["a" /* ErrorDetails */].KEY_LOAD_ERROR:
      case errors["a" /* ErrorDetails */].KEY_LOAD_TIMEOUT:
        //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
        if (this.state !== audio_stream_controller_State.ERROR) {
          // if fatal error, stop processing, otherwise move to IDLE to retry loading
          this.state = data.fatal ? audio_stream_controller_State.ERROR : audio_stream_controller_State.IDLE;
          logger["b" /* logger */].warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
        }
        break;
      case errors["a" /* ErrorDetails */].BUFFER_FULL_ERROR:
        // if in appending state
        if (data.parent === 'audio' && (this.state === audio_stream_controller_State.PARSING || this.state === audio_stream_controller_State.PARSED)) {
          var media = this.mediaBuffer,
              currentTime = this.media.currentTime,
              mediaBuffered = media && buffer_helper.isBuffered(media, currentTime) && buffer_helper.isBuffered(media, currentTime + 0.5);
          // reduce max buf len if current position is buffered
          if (mediaBuffered) {
            var _config = this.config;
            if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
              // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
              _config.maxMaxBufferLength /= 2;
              logger["b" /* logger */].warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
              // increase fragment load Index to avoid frag loop loading error after buffer flush
              this.fragLoadIdx += 2 * _config.fragLoadingLoopThreshold;
            }
            this.state = audio_stream_controller_State.IDLE;
          } else {
            // current position is not buffered, but browser is still complaining about buffer full error
            // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
            // in that case flush the whole audio buffer to recover
            logger["b" /* logger */].warn('buffer full error also media.currentTime is not buffered, flush audio buffer');
            this.fragCurrent = null;
            // flush everything
            this.state = audio_stream_controller_State.BUFFER_FLUSHING;
            this.hls.trigger(events["a" /* default */].BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
          }
        }
        break;
      default:
        break;
    }
  };

  AudioStreamController.prototype.onBufferFlushed = function onBufferFlushed() {
    var _this3 = this;

    var pendingData = this.pendingData;
    if (pendingData && pendingData.length) {
      logger["b" /* logger */].log('appending pending audio data on Buffer Flushed');
      pendingData.forEach(function (appendObj) {
        _this3.hls.trigger(events["a" /* default */].BUFFER_APPENDING, appendObj);
      });
      this.appended = true;
      this.pendingData = [];
      this.state = audio_stream_controller_State.PARSED;
    } else {
      // move to IDLE once flush complete. this should trigger new fragment loading
      this.state = audio_stream_controller_State.IDLE;
      // reset reference to frag
      this.fragPrevious = null;
      this.tick();
    }
  };

  audio_stream_controller__createClass(AudioStreamController, [{
    key: 'state',
    set: function set(nextState) {
      if (this.state !== nextState) {
        var previousState = this.state;
        this._state = nextState;
        logger["b" /* logger */].log('audio stream:' + previousState + '->' + nextState);
      }
    },
    get: function get() {
      return this._state;
    }
  }]);

  return AudioStreamController;
}(event_handler);

/* harmony default export */ var audio_stream_controller = (audio_stream_controller_AudioStreamController);
// CONCATENATED MODULE: ./src/utils/vttcue.js
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var vttcue = ((function () {
  if (typeof window !== 'undefined' && window.VTTCue) {
    return window.VTTCue;
  }

  var autoKeyword = 'auto';
  var directionSetting = {
    '': true,
    lr: true,
    rl: true
  };
  var alignSetting = {
    start: true,
    middle: true,
    end: true,
    left: true,
    right: true
  };

  function findDirectionSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var dir = directionSetting[value.toLowerCase()];
    return dir ? value.toLowerCase() : false;
  }

  function findAlignSetting(value) {
    if (typeof value !== 'string') {
      return false;
    }
    var align = alignSetting[value.toLowerCase()];
    return align ? value.toLowerCase() : false;
  }

  function extend(obj) {
    var i = 1;
    for (; i < arguments.length; i++) {
      var cobj = arguments[i];
      for (var p in cobj) {
        obj[p] = cobj[p];
      }
    }

    return obj;
  }

  function VTTCue(startTime, endTime, text) {
    var cue = this;
    var isIE8 = function () {
      if (typeof navigator === 'undefined') {
        return;
      }
      return (/MSIE\s8\.0/.test(navigator.userAgent)
      );
    }();
    var baseObj = {};

    if (isIE8) {
      cue = document.createElement('custom');
    } else {
      baseObj.enumerable = true;
    }

    /**
     * Shim implementation specific properties. These properties are not in
     * the spec.
     */

    // Lets us know when the VTTCue's data has changed in such a way that we need
    // to recompute its display state. This lets us compute its display state
    // lazily.
    cue.hasBeenReset = false;

    /**
     * VTTCue and TextTrackCue properties
     * http://dev.w3.org/html5/webvtt/#vttcue-interface
     */

    var _id = '';
    var _pauseOnExit = false;
    var _startTime = startTime;
    var _endTime = endTime;
    var _text = text;
    var _region = null;
    var _vertical = '';
    var _snapToLines = true;
    var _line = 'auto';
    var _lineAlign = 'start';
    var _position = 50;
    var _positionAlign = 'middle';
    var _size = 50;
    var _align = 'middle';

    Object.defineProperty(cue, 'id', extend({}, baseObj, {
      get: function get() {
        return _id;
      },
      set: function set(value) {
        _id = '' + value;
      }
    }));

    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
      get: function get() {
        return _pauseOnExit;
      },
      set: function set(value) {
        _pauseOnExit = !!value;
      }
    }));

    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
      get: function get() {
        return _startTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('Start time must be set to a number.');
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
      get: function get() {
        return _endTime;
      },
      set: function set(value) {
        if (typeof value !== 'number') {
          throw new TypeError('End time must be set to a number.');
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'text', extend({}, baseObj, {
      get: function get() {
        return _text;
      },
      set: function set(value) {
        _text = '' + value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'region', extend({}, baseObj, {
      get: function get() {
        return _region;
      },
      set: function set(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
      get: function get() {
        return _vertical;
      },
      set: function set(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
      get: function get() {
        return _snapToLines;
      },
      set: function set(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'line', extend({}, baseObj, {
      get: function get() {
        return _line;
      },
      set: function set(value) {
        if (typeof value !== 'number' && value !== autoKeyword) {
          throw new SyntaxError('An invalid number or illegal string was specified.');
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
      get: function get() {
        return _lineAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'position', extend({}, baseObj, {
      get: function get() {
        return _position;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Position must be between 0 and 100.');
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
      get: function get() {
        return _positionAlign;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'size', extend({}, baseObj, {
      get: function get() {
        return _size;
      },
      set: function set(value) {
        if (value < 0 || value > 100) {
          throw new Error('Size must be between 0 and 100.');
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

    Object.defineProperty(cue, 'align', extend({}, baseObj, {
      get: function get() {
        return _align;
      },
      set: function set(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError('An invalid or illegal string was specified.');
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

    /**
     * Other <track> spec defined properties
     */

    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
    cue.displayState = undefined;

    if (isIE8) {
      return cue;
    }
  }

  /**
   * VTTCue methods
   */

  VTTCue.prototype.getCueAsHTML = function () {
    // Assume WebVTT.convertCueToDOMTree is on the global.
    var WebVTT = window.WebVTT;
    return WebVTT.convertCueToDOMTree(window, this.text);
  };

  return VTTCue;
})());
// CONCATENATED MODULE: ./src/utils/vttparser.js
/*
 * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
 */



var StringDecoder = function StringDecoder() {
  return {
    decode: function decode(data) {
      if (!data) {
        return '';
      }
      if (typeof data !== 'string') {
        throw new Error('Error - expected string data.');
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};

function VTTParser() {
  this.window = window;
  this.state = 'INITIAL';
  this.buffer = '';
  this.decoder = new StringDecoder();
  this.regionList = [];
}

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0, m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = Object.create(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function set(k, v) {
    if (!this.get(k) && v !== '') {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function has(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function alt(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function integer(k, v) {
    if (/^-?\d+$/.test(v)) {
      // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function percent(k, v) {
    var m;
    if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== 'string') {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

var defaults = new vttcue(0, 0, 0);
// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
//  Safari doesn't yet support this change, but FF and Chrome do.
var center = defaults.align === 'middle' ? 'middle' : 'center';

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error('Malformed timestamp: ' + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, '');
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
        case 'region':
          // Find the last region we parsed with the same region id.
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case 'vertical':
          settings.alt(k, v, ['rl', 'lr']);
          break;
        case 'line':
          var vals = v.split(','),
              vals0 = vals[0];
          settings.integer(k, vals0);
          if (settings.percent(k, vals0)) {
            settings.set('snapToLines', false);
          }
          settings.alt(k, vals0, ['auto']);
          if (vals.length === 2) {
            settings.alt('lineAlign', vals[1], ['start', center, 'end']);
          }
          break;
        case 'position':
          vals = v.split(',');
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
          }
          break;
        case 'size':
          settings.percent(k, v);
          break;
        case 'align':
          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
          break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get('region', null);
    cue.vertical = settings.get('vertical', '');
    var line = settings.get('line', 'auto');
    if (line === 'auto' && defaults.line === -1) {
      // set numeric line number for Safari
      line = -1;
    }
    cue.line = line;
    cue.lineAlign = settings.get('lineAlign', 'start');
    cue.snapToLines = settings.get('snapToLines', true);
    cue.size = settings.get('size', 100);
    cue.align = settings.get('align', center);
    var position = settings.get('position', 'auto');
    if (position === 'auto' && defaults.position === 50) {
      // set numeric position for Safari
      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
    }
    cue.position = position;
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, '');
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp(); // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== '-->') {
    // (3) next characters must match '-->'
    throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp(); // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, '\n');
}

VTTParser.prototype = {
  parse: function parse(data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, { stream: true });
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;

      buffer = fixLineBreaks(buffer);

      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      parseOptions(input, function (k, v) {
        switch (k) {
          case 'Region':
            // 3.3 WebVTT region metadata header syntax
            console.log('parse region', v);
            //parseRegion(v);
            break;
        }
      }, /:/);
    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === 'INITIAL') {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();
        // strip of UTF-8 BOM if any
        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8
        var m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new Error('Malformed WebVTT signature.');
        }

        self.state = 'HEADER';
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
          case 'HEADER':
            // 13-18 - Allow a header (metadata) under the WEBVTT line.
            if (/:/.test(line)) {
              parseHeader(line);
            } else if (!line) {
              // An empty line terminates the header and starts the body (cues).
              self.state = 'ID';
            }
            continue;
          case 'NOTE':
            // Ignore NOTE blocks.
            if (!line) {
              self.state = 'ID';
            }
            continue;
          case 'ID':
            // Check for the start of NOTE blocks.
            if (/^NOTE($|[ \t])/.test(line)) {
              self.state = 'NOTE';
              break;
            }
            // 19-29 - Allow any number of line terminators, then initialize new cue values.
            if (!line) {
              continue;
            }
            self.cue = new vttcue(0, 0, '');
            self.state = 'CUE';
            // 30-39 - Check if self line contains an optional identifier or timing data.
            if (line.indexOf('-->') === -1) {
              self.cue.id = line;
              continue;
            }
          // Process line as start of a cue.
          /*falls through*/
          case 'CUE':
            // 40 - Collect cue timings and settings.
            try {
              parseCue(line, self.cue, self.regionList);
            } catch (e) {
              // In case of an error ignore rest of the cue.
              self.cue = null;
              self.state = 'BADCUE';
              continue;
            }
            self.state = 'CUETEXT';
            continue;
          case 'CUETEXT':
            var hasSubstring = line.indexOf('-->') !== -1;
            // 34 - If we have an empty line then report the cue.
            // 35 - If we have the special substring '-->' then report the cue,
            // but do not collect the line as we need to process the current
            // one as a new cue.
            if (!line || hasSubstring && (alreadyCollectedLine = true)) {
              // We are done parsing self cue.
              if (self.oncue) {
                self.oncue(self.cue);
              }
              self.cue = null;
              self.state = 'ID';
              continue;
            }
            if (self.cue.text) {
              self.cue.text += '\n';
            }
            self.cue.text += line;
            continue;
          case 'BADCUE':
            // BADCUE
            // 54-62 - Collect and discard the remaining cue.
            if (!line) {
              self.state = 'ID';
            }
            continue;
        }
      }
    } catch (e) {

      // If we are currently parsing a cue, report what we have.
      if (self.state === 'CUETEXT' && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
    }
    return this;
  },
  flush: function flush() {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === 'HEADER') {
        self.buffer += '\n\n';
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === 'INITIAL') {
        throw new Error('Malformed WebVTT signature.');
      }
    } catch (e) {
      throw e;
    }
    if (self.onflush) {
      self.onflush();
    }
    return this;
  }
};



/* harmony default export */ var vttparser = (VTTParser);
// CONCATENATED MODULE: ./src/utils/cues.js


function newCue(track, startTime, endTime, captionScreen) {
  var row;
  var cue;
  var indenting;
  var indent;
  var text;
  var VTTCue = window.VTTCue || window.TextTrackCue;

  for (var r = 0; r < captionScreen.rows.length; r++) {
    row = captionScreen.rows[r];
    indenting = true;
    indent = 0;
    text = '';

    if (!row.isEmpty()) {
      for (var c = 0; c < row.chars.length; c++) {
        if (row.chars[c].uchar.match(/\s/) && indenting) {
          indent++;
        } else {
          text += row.chars[c].uchar;
          indenting = false;
        }
      }
      //To be used for cleaning-up orphaned roll-up captions
      row.cueStartTime = startTime;

      // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
      if (startTime === endTime) {
        endTime += 0.0001;
      }

      cue = new VTTCue(startTime, endTime, fixLineBreaks(text.trim()));

      if (indent >= 16) {
        indent--;
      } else {
        indent++;
      }

      // VTTCue.line get's flakey when using controls, so let's now include line 13&14
      // also, drop line 1 since it's to close to the top
      if (navigator.userAgent.match(/Firefox\//)) {
        cue.line = r + 1;
      } else {
        cue.line = r > 7 ? r - 2 : r + 1;
      }
      cue.align = 'left';
      // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
      cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
      track.addCue(cue);
    }
  }
}
// CONCATENATED MODULE: ./src/utils/cea-608-parser.js
function cea_608_parser__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *
 * This code was ported from the dash.js project at:
 *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
 *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
 *
 * The original copyright appears below:
 *
 * The copyright in this software is being made available under the BSD License,
 * included below. This software may be subject to other third party and contributor
 * rights, including patent rights, and no such rights are granted under this license.
 *
 * Copyright (c) 2015-2016, DASH Industry Forum.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *  1. Redistributions of source code must retain the above copyright notice, this
 *  list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *  this list of conditions and the following disclaimer in the documentation and/or
 *  other materials provided with the distribution.
 *  2. Neither the name of Dash Industry Forum nor the names of its
 *  contributors may be used to endorse or promote products derived from this software
 *  without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
 *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */
/**
 *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
 */

var specialCea608CharsCodes = {
    0x2a: 0xe1, // lowercase a, acute accent
    0x5c: 0xe9, // lowercase e, acute accent
    0x5e: 0xed, // lowercase i, acute accent
    0x5f: 0xf3, // lowercase o, acute accent
    0x60: 0xfa, // lowercase u, acute accent
    0x7b: 0xe7, // lowercase c with cedilla
    0x7c: 0xf7, // division symbol
    0x7d: 0xd1, // uppercase N tilde
    0x7e: 0xf1, // lowercase n tilde
    0x7f: 0x2588, // Full block
    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
    // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
    0x80: 0xae, // Registered symbol (R)
    0x81: 0xb0, // degree sign
    0x82: 0xbd, // 1/2 symbol
    0x83: 0xbf, // Inverted (open) question mark
    0x84: 0x2122, // Trademark symbol (TM)
    0x85: 0xa2, // Cents symbol
    0x86: 0xa3, // Pounds sterling
    0x87: 0x266a, // Music 8'th note
    0x88: 0xe0, // lowercase a, grave accent
    0x89: 0x20, // transparent space (regular)
    0x8a: 0xe8, // lowercase e, grave accent
    0x8b: 0xe2, // lowercase a, circumflex accent
    0x8c: 0xea, // lowercase e, circumflex accent
    0x8d: 0xee, // lowercase i, circumflex accent
    0x8e: 0xf4, // lowercase o, circumflex accent
    0x8f: 0xfb, // lowercase u, circumflex accent
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
    0x90: 0xc1, // capital letter A with acute
    0x91: 0xc9, // capital letter E with acute
    0x92: 0xd3, // capital letter O with acute
    0x93: 0xda, // capital letter U with acute
    0x94: 0xdc, // capital letter U with diaresis
    0x95: 0xfc, // lowercase letter U with diaeresis
    0x96: 0x2018, // opening single quote
    0x97: 0xa1, // inverted exclamation mark
    0x98: 0x2a, // asterisk
    0x99: 0x2019, // closing single quote
    0x9a: 0x2501, // box drawings heavy horizontal
    0x9b: 0xa9, // copyright sign
    0x9c: 0x2120, // Service mark
    0x9d: 0x2022, // (round) bullet
    0x9e: 0x201c, // Left double quotation mark
    0x9f: 0x201d, // Right double quotation mark
    0xa0: 0xc0, // uppercase A, grave accent
    0xa1: 0xc2, // uppercase A, circumflex
    0xa2: 0xc7, // uppercase C with cedilla
    0xa3: 0xc8, // uppercase E, grave accent
    0xa4: 0xca, // uppercase E, circumflex
    0xa5: 0xcb, // capital letter E with diaresis
    0xa6: 0xeb, // lowercase letter e with diaresis
    0xa7: 0xce, // uppercase I, circumflex
    0xa8: 0xcf, // uppercase I, with diaresis
    0xa9: 0xef, // lowercase i, with diaresis
    0xaa: 0xd4, // uppercase O, circumflex
    0xab: 0xd9, // uppercase U, grave accent
    0xac: 0xf9, // lowercase u, grave accent
    0xad: 0xdb, // uppercase U, circumflex
    0xae: 0xab, // left-pointing double angle quotation mark
    0xaf: 0xbb, // right-pointing double angle quotation mark
    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
    0xb0: 0xc3, // Uppercase A, tilde
    0xb1: 0xe3, // Lowercase a, tilde
    0xb2: 0xcd, // Uppercase I, acute accent
    0xb3: 0xcc, // Uppercase I, grave accent
    0xb4: 0xec, // Lowercase i, grave accent
    0xb5: 0xd2, // Uppercase O, grave accent
    0xb6: 0xf2, // Lowercase o, grave accent
    0xb7: 0xd5, // Uppercase O, tilde
    0xb8: 0xf5, // Lowercase o, tilde
    0xb9: 0x7b, // Open curly brace
    0xba: 0x7d, // Closing curly brace
    0xbb: 0x5c, // Backslash
    0xbc: 0x5e, // Caret
    0xbd: 0x5f, // Underscore
    0xbe: 0x7c, // Pipe (vertical line)
    0xbf: 0x223c, // Tilde operator
    0xc0: 0xc4, // Uppercase A, umlaut
    0xc1: 0xe4, // Lowercase A, umlaut
    0xc2: 0xd6, // Uppercase O, umlaut
    0xc3: 0xf6, // Lowercase o, umlaut
    0xc4: 0xdf, // Esszett (sharp S)
    0xc5: 0xa5, // Yen symbol
    0xc6: 0xa4, // Generic currency sign
    0xc7: 0x2503, // Box drawings heavy vertical
    0xc8: 0xc5, // Uppercase A, ring
    0xc9: 0xe5, // Lowercase A, ring
    0xca: 0xd8, // Uppercase O, stroke
    0xcb: 0xf8, // Lowercase o, strok
    0xcc: 0x250f, // Box drawings heavy down and right
    0xcd: 0x2513, // Box drawings heavy down and left
    0xce: 0x2517, // Box drawings heavy up and right
    0xcf: 0x251b // Box drawings heavy up and left
};

/**
 * Utils
 */
var getCharForByte = function getCharForByte(byte) {
    var charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
        charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
};

var NR_ROWS = 15,
    NR_COLS = 100;
// Tables to look up row from PAC data
var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };

var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];

/**
 * Simple logger class to be able to write with time-stamps and filter on level.
 */
var cea_608_parser_logger = {
    verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
    time: null,
    verboseLevel: 0, // Only write errors
    setTime: function setTime(newTime) {
        this.time = newTime;
    },
    log: function log(severity, msg) {
        var minLevel = this.verboseFilter[severity];
        if (this.verboseLevel >= minLevel) {
            console.log(this.time + ' [' + severity + '] ' + msg);
        }
    }
};

var numArrayToHexArray = function numArrayToHexArray(numArray) {
    var hexArray = [];
    for (var j = 0; j < numArray.length; j++) {
        hexArray.push(numArray[j].toString(16));
    }
    return hexArray;
};

var PenState = function () {
    function PenState(foreground, underline, italics, background, flash) {
        cea_608_parser__classCallCheck(this, PenState);

        this.foreground = foreground || 'white';
        this.underline = underline || false;
        this.italics = italics || false;
        this.background = background || 'black';
        this.flash = flash || false;
    }

    PenState.prototype.reset = function reset() {
        this.foreground = 'white';
        this.underline = false;
        this.italics = false;
        this.background = 'black';
        this.flash = false;
    };

    PenState.prototype.setStyles = function setStyles(styles) {
        var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
        for (var i = 0; i < attribs.length; i++) {
            var style = attribs[i];
            if (styles.hasOwnProperty(style)) {
                this[style] = styles[style];
            }
        }
    };

    PenState.prototype.isDefault = function isDefault() {
        return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
    };

    PenState.prototype.equals = function equals(other) {
        return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
    };

    PenState.prototype.copy = function copy(newPenState) {
        this.foreground = newPenState.foreground;
        this.underline = newPenState.underline;
        this.italics = newPenState.italics;
        this.background = newPenState.background;
        this.flash = newPenState.flash;
    };

    PenState.prototype.toString = function toString() {
        return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
    };

    return PenState;
}();

/**
 * Unicode character with styling and background.
 * @constructor
 */


var StyledUnicodeChar = function () {
    function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
        cea_608_parser__classCallCheck(this, StyledUnicodeChar);

        this.uchar = uchar || ' '; // unicode character
        this.penState = new PenState(foreground, underline, italics, background, flash);
    }

    StyledUnicodeChar.prototype.reset = function reset() {
        this.uchar = ' ';
        this.penState.reset();
    };

    StyledUnicodeChar.prototype.setChar = function setChar(uchar, newPenState) {
        this.uchar = uchar;
        this.penState.copy(newPenState);
    };

    StyledUnicodeChar.prototype.setPenState = function setPenState(newPenState) {
        this.penState.copy(newPenState);
    };

    StyledUnicodeChar.prototype.equals = function equals(other) {
        return this.uchar === other.uchar && this.penState.equals(other.penState);
    };

    StyledUnicodeChar.prototype.copy = function copy(newChar) {
        this.uchar = newChar.uchar;
        this.penState.copy(newChar.penState);
    };

    StyledUnicodeChar.prototype.isEmpty = function isEmpty() {
        return this.uchar === ' ' && this.penState.isDefault();
    };

    return StyledUnicodeChar;
}();

/**
 * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
 * @constructor
 */


var Row = function () {
    function Row() {
        cea_608_parser__classCallCheck(this, Row);

        this.chars = [];
        for (var i = 0; i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar());
        }
        this.pos = 0;
        this.currPenState = new PenState();
    }

    Row.prototype.equals = function equals(other) {
        var equal = true;
        for (var i = 0; i < NR_COLS; i++) {
            if (!this.chars[i].equals(other.chars[i])) {
                equal = false;
                break;
            }
        }
        return equal;
    };

    Row.prototype.copy = function copy(other) {
        for (var i = 0; i < NR_COLS; i++) {
            this.chars[i].copy(other.chars[i]);
        }
    };

    Row.prototype.isEmpty = function isEmpty() {
        var empty = true;
        for (var i = 0; i < NR_COLS; i++) {
            if (!this.chars[i].isEmpty()) {
                empty = false;
                break;
            }
        }
        return empty;
    };

    /**
     *  Set the cursor to a valid column.
     */


    Row.prototype.setCursor = function setCursor(absPos) {
        if (this.pos !== absPos) {
            this.pos = absPos;
        }
        if (this.pos < 0) {
            cea_608_parser_logger.log('ERROR', 'Negative cursor position ' + this.pos);
            this.pos = 0;
        } else if (this.pos > NR_COLS) {
            cea_608_parser_logger.log('ERROR', 'Too large cursor position ' + this.pos);
            this.pos = NR_COLS;
        }
    };

    /**
     * Move the cursor relative to current position.
     */


    Row.prototype.moveCursor = function moveCursor(relPos) {
        var newPos = this.pos + relPos;
        if (relPos > 1) {
            for (var i = this.pos + 1; i < newPos + 1; i++) {
                this.chars[i].setPenState(this.currPenState);
            }
        }
        this.setCursor(newPos);
    };

    /**
     * Backspace, move one step back and clear character.
     */


    Row.prototype.backSpace = function backSpace() {
        this.moveCursor(-1);
        this.chars[this.pos].setChar(' ', this.currPenState);
    };

    Row.prototype.insertChar = function insertChar(byte) {
        if (byte >= 0x90) {
            //Extended char
            this.backSpace();
        }
        var char = getCharForByte(byte);
        if (this.pos >= NR_COLS) {
            cea_608_parser_logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
            return;
        }
        this.chars[this.pos].setChar(char, this.currPenState);
        this.moveCursor(1);
    };

    Row.prototype.clearFromPos = function clearFromPos(startPos) {
        var i;
        for (i = startPos; i < NR_COLS; i++) {
            this.chars[i].reset();
        }
    };

    Row.prototype.clear = function clear() {
        this.clearFromPos(0);
        this.pos = 0;
        this.currPenState.reset();
    };

    Row.prototype.clearToEndOfRow = function clearToEndOfRow() {
        this.clearFromPos(this.pos);
    };

    Row.prototype.getTextString = function getTextString() {
        var chars = [];
        var empty = true;
        for (var i = 0; i < NR_COLS; i++) {
            var char = this.chars[i].uchar;
            if (char !== ' ') {
                empty = false;
            }
            chars.push(char);
        }
        if (empty) {
            return '';
        } else {
            return chars.join('');
        }
    };

    Row.prototype.setPenStyles = function setPenStyles(styles) {
        this.currPenState.setStyles(styles);
        var currChar = this.chars[this.pos];
        currChar.setPenState(this.currPenState);
    };

    return Row;
}();

/**
 * Keep a CEA-608 screen of 32x15 styled characters
 * @constructor
*/


var CaptionScreen = function () {
    function CaptionScreen() {
        cea_608_parser__classCallCheck(this, CaptionScreen);

        this.rows = [];
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
        }
        this.currRow = NR_ROWS - 1;
        this.nrRollUpRows = null;
        this.reset();
    }

    CaptionScreen.prototype.reset = function reset() {
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows[i].clear();
        }
        this.currRow = NR_ROWS - 1;
    };

    CaptionScreen.prototype.equals = function equals(other) {
        var equal = true;
        for (var i = 0; i < NR_ROWS; i++) {
            if (!this.rows[i].equals(other.rows[i])) {
                equal = false;
                break;
            }
        }
        return equal;
    };

    CaptionScreen.prototype.copy = function copy(other) {
        for (var i = 0; i < NR_ROWS; i++) {
            this.rows[i].copy(other.rows[i]);
        }
    };

    CaptionScreen.prototype.isEmpty = function isEmpty() {
        var empty = true;
        for (var i = 0; i < NR_ROWS; i++) {
            if (!this.rows[i].isEmpty()) {
                empty = false;
                break;
            }
        }
        return empty;
    };

    CaptionScreen.prototype.backSpace = function backSpace() {
        var row = this.rows[this.currRow];
        row.backSpace();
    };

    CaptionScreen.prototype.clearToEndOfRow = function clearToEndOfRow() {
        var row = this.rows[this.currRow];
        row.clearToEndOfRow();
    };

    /**
     * Insert a character (without styling) in the current row.
     */


    CaptionScreen.prototype.insertChar = function insertChar(char) {
        var row = this.rows[this.currRow];
        row.insertChar(char);
    };

    CaptionScreen.prototype.setPen = function setPen(styles) {
        var row = this.rows[this.currRow];
        row.setPenStyles(styles);
    };

    CaptionScreen.prototype.moveCursor = function moveCursor(relPos) {
        var row = this.rows[this.currRow];
        row.moveCursor(relPos);
    };

    CaptionScreen.prototype.setCursor = function setCursor(absPos) {
        cea_608_parser_logger.log('INFO', 'setCursor: ' + absPos);
        var row = this.rows[this.currRow];
        row.setCursor(absPos);
    };

    CaptionScreen.prototype.setPAC = function setPAC(pacData) {
        cea_608_parser_logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
        var newRow = pacData.row - 1;
        if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
            newRow = this.nrRollUpRows - 1;
        }

        //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
        if (this.nrRollUpRows && this.currRow !== newRow) {
            //clear all rows first
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows[i].clear();
            }

            //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
            //topRowIndex - the start of rows to copy (inclusive index)
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            //We only copy if the last position was already shown.
            //We use the cueStartTime value to check this.
            var lastOutputScreen = this.lastOutputScreen;
            if (lastOutputScreen) {
                var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                if (prevLineTime && prevLineTime < cea_608_parser_logger.time) {
                    for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                        this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                    }
                }
            }
        }

        this.currRow = newRow;
        var row = this.rows[this.currRow];
        if (pacData.indent !== null) {
            var indent = pacData.indent;
            var prevPos = Math.max(indent - 1, 0);
            row.setCursor(pacData.indent);
            pacData.color = row.chars[prevPos].penState.foreground;
        }
        var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
        this.setPen(styles);
    };

    /**
     * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
     */


    CaptionScreen.prototype.setBkgData = function setBkgData(bkgData) {

        cea_608_parser_logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
        this.backSpace();
        this.setPen(bkgData);
        this.insertChar(0x20); //Space
    };

    CaptionScreen.prototype.setRollUpRows = function setRollUpRows(nrRows) {
        this.nrRollUpRows = nrRows;
    };

    CaptionScreen.prototype.rollUp = function rollUp() {
        if (this.nrRollUpRows === null) {
            cea_608_parser_logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
            return; //Not properly setup
        }
        cea_608_parser_logger.log('TEXT', this.getDisplayText());
        var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        var topRow = this.rows.splice(topRowIndex, 1)[0];
        topRow.clear();
        this.rows.splice(this.currRow, 0, topRow);
        cea_608_parser_logger.log('INFO', 'Rolling up');
        //logger.log('TEXT', this.get_display_text())
    };

    /**
     * Get all non-empty rows with as unicode text.
     */


    CaptionScreen.prototype.getDisplayText = function getDisplayText(asOneRow) {
        asOneRow = asOneRow || false;
        var displayText = [];
        var text = '';
        var rowNr = -1;
        for (var i = 0; i < NR_ROWS; i++) {
            var rowText = this.rows[i].getTextString();
            if (rowText) {
                rowNr = i + 1;
                if (asOneRow) {
                    displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                } else {
                    displayText.push(rowText.trim());
                }
            }
        }
        if (displayText.length > 0) {
            if (asOneRow) {
                text = '[' + displayText.join(' | ') + ']';
            } else {
                text = displayText.join('\n');
            }
        }
        return text;
    };

    CaptionScreen.prototype.getTextAndFormat = function getTextAndFormat() {
        return this.rows;
    };

    return CaptionScreen;
}();

//var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];

var Cea608Channel = function () {
    function Cea608Channel(channelNumber, outputFilter) {
        cea_608_parser__classCallCheck(this, Cea608Channel);

        this.chNr = channelNumber;
        this.outputFilter = outputFilter;
        this.mode = null;
        this.verbose = 0;
        this.displayedMemory = new CaptionScreen();
        this.nonDisplayedMemory = new CaptionScreen();
        this.lastOutputScreen = new CaptionScreen();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null; // Keeps track of where a cue started.
    }

    Cea608Channel.prototype.reset = function reset() {
        this.mode = null;
        this.displayedMemory.reset();
        this.nonDisplayedMemory.reset();
        this.lastOutputScreen.reset();
        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
        this.writeScreen = this.displayedMemory;
        this.mode = null;
        this.cueStartTime = null;
        this.lastCueEndTime = null;
    };

    Cea608Channel.prototype.getHandler = function getHandler() {
        return this.outputFilter;
    };

    Cea608Channel.prototype.setHandler = function setHandler(newHandler) {
        this.outputFilter = newHandler;
    };

    Cea608Channel.prototype.setPAC = function setPAC(pacData) {
        this.writeScreen.setPAC(pacData);
    };

    Cea608Channel.prototype.setBkgData = function setBkgData(bkgData) {
        this.writeScreen.setBkgData(bkgData);
    };

    Cea608Channel.prototype.setMode = function setMode(newMode) {
        if (newMode === this.mode) {
            return;
        }
        this.mode = newMode;
        cea_608_parser_logger.log('INFO', 'MODE=' + newMode);
        if (this.mode === 'MODE_POP-ON') {
            this.writeScreen = this.nonDisplayedMemory;
        } else {
            this.writeScreen = this.displayedMemory;
            this.writeScreen.reset();
        }
        if (this.mode !== 'MODE_ROLL-UP') {
            this.displayedMemory.nrRollUpRows = null;
            this.nonDisplayedMemory.nrRollUpRows = null;
        }
        this.mode = newMode;
    };

    Cea608Channel.prototype.insertChars = function insertChars(chars) {
        for (var i = 0; i < chars.length; i++) {
            this.writeScreen.insertChar(chars[i]);
        }
        var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
        cea_608_parser_logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
        if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
            cea_608_parser_logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
            this.outputDataUpdate();
        }
    };

    Cea608Channel.prototype.ccRCL = function ccRCL() {
        // Resume Caption Loading (switch mode to Pop On)
        cea_608_parser_logger.log('INFO', 'RCL - Resume Caption Loading');
        this.setMode('MODE_POP-ON');
    };

    Cea608Channel.prototype.ccBS = function ccBS() {
        // BackSpace
        cea_608_parser_logger.log('INFO', 'BS - BackSpace');
        if (this.mode === 'MODE_TEXT') {
            return;
        }
        this.writeScreen.backSpace();
        if (this.writeScreen === this.displayedMemory) {
            this.outputDataUpdate();
        }
    };

    Cea608Channel.prototype.ccAOF = function ccAOF() {
        // Reserved (formerly Alarm Off)
        return;
    };

    Cea608Channel.prototype.ccAON = function ccAON() {
        // Reserved (formerly Alarm On)
        return;
    };

    Cea608Channel.prototype.ccDER = function ccDER() {
        // Delete to End of Row
        cea_608_parser_logger.log('INFO', 'DER- Delete to End of Row');
        this.writeScreen.clearToEndOfRow();
        this.outputDataUpdate();
    };

    Cea608Channel.prototype.ccRU = function ccRU(nrRows) {
        //Roll-Up Captions-2,3,or 4 Rows
        cea_608_parser_logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
        this.writeScreen = this.displayedMemory;
        this.setMode('MODE_ROLL-UP');
        this.writeScreen.setRollUpRows(nrRows);
    };

    Cea608Channel.prototype.ccFON = function ccFON() {
        //Flash On
        cea_608_parser_logger.log('INFO', 'FON - Flash On');
        this.writeScreen.setPen({ flash: true });
    };

    Cea608Channel.prototype.ccRDC = function ccRDC() {
        // Resume Direct Captioning (switch mode to PaintOn)
        cea_608_parser_logger.log('INFO', 'RDC - Resume Direct Captioning');
        this.setMode('MODE_PAINT-ON');
    };

    Cea608Channel.prototype.ccTR = function ccTR() {
        // Text Restart in text mode (not supported, however)
        cea_608_parser_logger.log('INFO', 'TR');
        this.setMode('MODE_TEXT');
    };

    Cea608Channel.prototype.ccRTD = function ccRTD() {
        // Resume Text Display in Text mode (not supported, however)
        cea_608_parser_logger.log('INFO', 'RTD');
        this.setMode('MODE_TEXT');
    };

    Cea608Channel.prototype.ccEDM = function ccEDM() {
        // Erase Displayed Memory
        cea_608_parser_logger.log('INFO', 'EDM - Erase Displayed Memory');
        this.displayedMemory.reset();
        this.outputDataUpdate(true);
    };

    Cea608Channel.prototype.ccCR = function ccCR() {
        // Carriage Return
        cea_608_parser_logger.log('CR - Carriage Return');
        this.writeScreen.rollUp();
        this.outputDataUpdate(true);
    };

    Cea608Channel.prototype.ccENM = function ccENM() {
        //Erase Non-Displayed Memory
        cea_608_parser_logger.log('INFO', 'ENM - Erase Non-displayed Memory');
        this.nonDisplayedMemory.reset();
    };

    Cea608Channel.prototype.ccEOC = function ccEOC() {
        //End of Caption (Flip Memories)
        cea_608_parser_logger.log('INFO', 'EOC - End Of Caption');
        if (this.mode === 'MODE_POP-ON') {
            var tmp = this.displayedMemory;
            this.displayedMemory = this.nonDisplayedMemory;
            this.nonDisplayedMemory = tmp;
            this.writeScreen = this.nonDisplayedMemory;
            cea_608_parser_logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
        }
        this.outputDataUpdate(true);
    };

    Cea608Channel.prototype.ccTO = function ccTO(nrCols) {
        // Tab Offset 1,2, or 3 columns
        cea_608_parser_logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
        this.writeScreen.moveCursor(nrCols);
    };

    Cea608Channel.prototype.ccMIDROW = function ccMIDROW(secondByte) {
        // Parse MIDROW command
        var styles = { flash: false };
        styles.underline = secondByte % 2 === 1;
        styles.italics = secondByte >= 0x2e;
        if (!styles.italics) {
            var colorIndex = Math.floor(secondByte / 2) - 0x10;
            var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
            styles.foreground = colors[colorIndex];
        } else {
            styles.foreground = 'white';
        }
        cea_608_parser_logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
        this.writeScreen.setPen(styles);
    };

    Cea608Channel.prototype.outputDataUpdate = function outputDataUpdate() {
        var dispatch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        var t = cea_608_parser_logger.time;
        if (t === null) {
            return;
        }
        if (this.outputFilter) {
            if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                // Start of a new cue
                this.cueStartTime = t;
            } else {
                if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                    if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                        if (dispatch === true && this.outputFilter.dispatchCue) {
                            this.outputFilter.dispatchCue();
                        }
                    }
                    this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                }
            }
            this.lastOutputScreen.copy(this.displayedMemory);
        }
    };

    Cea608Channel.prototype.cueSplitAtTime = function cueSplitAtTime(t) {
        if (this.outputFilter) {
            if (!this.displayedMemory.isEmpty()) {
                if (this.outputFilter.newCue) {
                    this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                }
                this.cueStartTime = t;
            }
        }
    };

    return Cea608Channel;
}();

var Cea608Parser = function () {
    function Cea608Parser(field, out1, out2) {
        cea_608_parser__classCallCheck(this, Cea608Parser);

        this.field = field || 1;
        this.outputs = [out1, out2];
        this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
        this.currChNr = -1; // Will be 1 or 2
        this.lastCmdA = null; // First byte of last command
        this.lastCmdB = null; // Second byte of last command
        this.bufferedData = [];
        this.startTime = null;
        this.lastTime = null;
        this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
    }

    Cea608Parser.prototype.getHandler = function getHandler(index) {
        return this.channels[index].getHandler();
    };

    Cea608Parser.prototype.setHandler = function setHandler(index, newHandler) {
        this.channels[index].setHandler(newHandler);
    };

    /**
     * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
     */


    Cea608Parser.prototype.addData = function addData(t, byteList) {
        var cmdFound,
            a,
            b,
            charsFound = false;

        this.lastTime = t;
        cea_608_parser_logger.setTime(t);

        for (var i = 0; i < byteList.length; i += 2) {
            a = byteList[i] & 0x7f;
            b = byteList[i + 1] & 0x7f;
            if (a === 0 && b === 0) {
                this.dataCounters.padding += 2;
                continue;
            } else {
                cea_608_parser_logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
            }
            cmdFound = this.parseCmd(a, b);
            if (!cmdFound) {
                cmdFound = this.parseMidrow(a, b);
            }
            if (!cmdFound) {
                cmdFound = this.parsePAC(a, b);
            }
            if (!cmdFound) {
                cmdFound = this.parseBackgroundAttributes(a, b);
            }
            if (!cmdFound) {
                charsFound = this.parseChars(a, b);
                if (charsFound) {
                    if (this.currChNr && this.currChNr >= 0) {
                        var channel = this.channels[this.currChNr - 1];
                        channel.insertChars(charsFound);
                    } else {
                        cea_608_parser_logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                    }
                }
            }
            if (cmdFound) {
                this.dataCounters.cmd += 2;
            } else if (charsFound) {
                this.dataCounters.char += 2;
            } else {
                this.dataCounters.other += 2;
                cea_608_parser_logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
            }
        }
    };

    /**
     * Parse Command.
     * @returns {Boolean} Tells if a command was found
     */


    Cea608Parser.prototype.parseCmd = function parseCmd(a, b) {
        var chNr = null;

        var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
        var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
        if (!(cond1 || cond2)) {
            return false;
        }

        if (a === this.lastCmdA && b === this.lastCmdB) {
            this.lastCmdA = null;
            this.lastCmdB = null; // Repeated commands are dropped (once)
            cea_608_parser_logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
            return true;
        }

        if (a === 0x14 || a === 0x17) {
            chNr = 1;
        } else {
            chNr = 2; // (a === 0x1C || a=== 0x1f)
        }

        var channel = this.channels[chNr - 1];

        if (a === 0x14 || a === 0x1C) {
            if (b === 0x20) {
                channel.ccRCL();
            } else if (b === 0x21) {
                channel.ccBS();
            } else if (b === 0x22) {
                channel.ccAOF();
            } else if (b === 0x23) {
                channel.ccAON();
            } else if (b === 0x24) {
                channel.ccDER();
            } else if (b === 0x25) {
                channel.ccRU(2);
            } else if (b === 0x26) {
                channel.ccRU(3);
            } else if (b === 0x27) {
                channel.ccRU(4);
            } else if (b === 0x28) {
                channel.ccFON();
            } else if (b === 0x29) {
                channel.ccRDC();
            } else if (b === 0x2A) {
                channel.ccTR();
            } else if (b === 0x2B) {
                channel.ccRTD();
            } else if (b === 0x2C) {
                channel.ccEDM();
            } else if (b === 0x2D) {
                channel.ccCR();
            } else if (b === 0x2E) {
                channel.ccENM();
            } else if (b === 0x2F) {
                channel.ccEOC();
            }
        } else {
            //a == 0x17 || a == 0x1F
            channel.ccTO(b - 0x20);
        }
        this.lastCmdA = a;
        this.lastCmdB = b;
        this.currChNr = chNr;
        return true;
    };

    /**
     * Parse midrow styling command
     * @returns {Boolean}
     */


    Cea608Parser.prototype.parseMidrow = function parseMidrow(a, b) {
        var chNr = null;

        if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
            if (a === 0x11) {
                chNr = 1;
            } else {
                chNr = 2;
            }
            if (chNr !== this.currChNr) {
                cea_608_parser_logger.log('ERROR', 'Mismatch channel in midrow parsing');
                return false;
            }
            var channel = this.channels[chNr - 1];
            channel.ccMIDROW(b);
            cea_608_parser_logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
            return true;
        }
        return false;
    };
    /**
     * Parse Preable Access Codes (Table 53).
     * @returns {Boolean} Tells if PAC found
     */


    Cea608Parser.prototype.parsePAC = function parsePAC(a, b) {

        var chNr = null;
        var row = null;

        var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
        var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
        if (!(case1 || case2)) {
            return false;
        }

        if (a === this.lastCmdA && b === this.lastCmdB) {
            this.lastCmdA = null;
            this.lastCmdB = null;
            return true; // Repeated commands are dropped (once)
        }

        chNr = a <= 0x17 ? 1 : 2;

        if (0x40 <= b && b <= 0x5F) {
            row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
        } else {
            // 0x60 <= b <= 0x7F
            row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
        }
        var pacData = this.interpretPAC(row, b);
        var channel = this.channels[chNr - 1];
        channel.setPAC(pacData);
        this.lastCmdA = a;
        this.lastCmdB = b;
        this.currChNr = chNr;
        return true;
    };

    /**
     * Interpret the second byte of the pac, and return the information.
     * @returns {Object} pacData with style parameters.
     */


    Cea608Parser.prototype.interpretPAC = function interpretPAC(row, byte) {
        var pacIndex = byte;
        var pacData = { color: null, italics: false, indent: null, underline: false, row: row };

        if (byte > 0x5F) {
            pacIndex = byte - 0x60;
        } else {
            pacIndex = byte - 0x40;
        }
        pacData.underline = (pacIndex & 1) === 1;
        if (pacIndex <= 0xd) {
            pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
        } else if (pacIndex <= 0xf) {
            pacData.italics = true;
            pacData.color = 'white';
        } else {
            pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
        }
        return pacData; // Note that row has zero offset. The spec uses 1.
    };

    /**
     * Parse characters.
     * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
     */


    Cea608Parser.prototype.parseChars = function parseChars(a, b) {

        var channelNr = null,
            charCodes = null,
            charCode1 = null;

        if (a >= 0x19) {
            channelNr = 2;
            charCode1 = a - 8;
        } else {
            channelNr = 1;
            charCode1 = a;
        }
        if (0x11 <= charCode1 && charCode1 <= 0x13) {
            // Special character
            var oneCode = b;
            if (charCode1 === 0x11) {
                oneCode = b + 0x50;
            } else if (charCode1 === 0x12) {
                oneCode = b + 0x70;
            } else {
                oneCode = b + 0x90;
            }
            cea_608_parser_logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
            charCodes = [oneCode];
        } else if (0x20 <= a && a <= 0x7f) {
            charCodes = b === 0 ? [a] : [a, b];
        }
        if (charCodes) {
            var hexCodes = numArrayToHexArray(charCodes);
            cea_608_parser_logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
            this.lastCmdA = null;
            this.lastCmdB = null;
        }
        return charCodes;
    };

    /**
    * Parse extended background attributes as well as new foreground color black.
    * @returns{Boolean} Tells if background attributes are found
    */


    Cea608Parser.prototype.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {
        var bkgData, index, chNr, channel;

        var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
        var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
        if (!(case1 || case2)) {
            return false;
        }
        bkgData = {};
        if (a === 0x10 || a === 0x18) {
            index = Math.floor((b - 0x20) / 2);
            bkgData.background = backgroundColors[index];
            if (b % 2 === 1) {
                bkgData.background = bkgData.background + '_semi';
            }
        } else if (b === 0x2d) {
            bkgData.background = 'transparent';
        } else {
            bkgData.foreground = 'black';
            if (b === 0x2f) {
                bkgData.underline = true;
            }
        }
        chNr = a < 0x18 ? 1 : 2;
        channel = this.channels[chNr - 1];
        channel.setBkgData(bkgData);
        this.lastCmdA = null;
        this.lastCmdB = null;
        return true;
    };

    /**
     * Reset state of parser and its channels.
     */


    Cea608Parser.prototype.reset = function reset() {
        for (var i = 0; i < this.channels.length; i++) {
            if (this.channels[i]) {
                this.channels[i].reset();
            }
        }
        this.lastCmdA = null;
        this.lastCmdB = null;
    };

    /**
     * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
     */


    Cea608Parser.prototype.cueSplitAtTime = function cueSplitAtTime(t) {
        for (var i = 0; i < this.channels.length; i++) {
            if (this.channels[i]) {
                this.channels[i].cueSplitAtTime(t);
            }
        }
    };

    return Cea608Parser;
}();

/* harmony default export */ var cea_608_parser = (Cea608Parser);
// CONCATENATED MODULE: ./src/utils/output-filter.js
function output_filter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OutputFilter = function () {
  function OutputFilter(timelineController, track) {
    output_filter__classCallCheck(this, OutputFilter);

    this.timelineController = timelineController;
    this.track = track;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
  }

  OutputFilter.prototype.dispatchCue = function dispatchCue() {
    if (this.startTime === null) {
      return;
    }
    this.timelineController.addCues('textTrack' + this.track, this.startTime, this.endTime, this.screen);
    this.startTime = null;
  };

  OutputFilter.prototype.newCue = function newCue(startTime, endTime, screen) {
    if (this.startTime === null || this.startTime > startTime) {
      this.startTime = startTime;
    }
    this.endTime = endTime;
    this.screen = screen;
    this.timelineController.createCaptionsTrack(this.track);
  };

  return OutputFilter;
}();

/* harmony default export */ var output_filter = (OutputFilter);
// CONCATENATED MODULE: ./src/utils/webvtt-parser.js



// String.prototype.startsWith is not supported in IE11
var startsWith = function startsWith(inputString, searchString, position) {
    return inputString.substr(position || 0, searchString.length) === searchString;
};

var cueString2millis = function cueString2millis(timeString) {
    var ts = parseInt(timeString.substr(-3));
    var secs = parseInt(timeString.substr(-6, 2));
    var mins = parseInt(timeString.substr(-9, 2));
    var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;

    if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) {
        return -1;
    }

    ts += 1000 * secs;
    ts += 60 * 1000 * mins;
    ts += 60 * 60 * 1000 * hours;

    return ts;
};

// From https://github.com/darkskyapp/string-hash
var hash = function hash(text) {
    var hash = 5381;
    var i = text.length;
    while (i) {
        hash = hash * 33 ^ text.charCodeAt(--i);
    }
    return (hash >>> 0).toString();
};

var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
    var currCC = vttCCs[cc];
    var prevCC = vttCCs[currCC.prevCC];

    // This is the first discontinuity or cues have been processed since the last discontinuity
    // Offset = current discontinuity time
    if (!prevCC || !prevCC.new && currCC.new) {
        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
        currCC.new = false;
        return;
    }

    // There have been discontinuities since cues were last parsed.
    // Offset = time elapsed
    while (prevCC && prevCC.new) {
        vttCCs.ccOffset += currCC.start - prevCC.start;
        currCC.new = false;
        currCC = prevCC;
        prevCC = vttCCs[currCC.prevCC];
    }

    vttCCs.presentationOffset = presentationTime;
};

var WebVTTParser = {
    parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
        // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
        var re = /\r\n|\n\r|\n|\r/g;
        // Uint8Array.prototype.reduce is not implemented in IE11
        var vttLines = Object(id3["b" /* utf8ArrayToStr */])(new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');

        var cueTime = '00:00.000';
        var mpegTs = 0;
        var localTime = 0;
        var presentationTime = 0;
        var cues = [];
        var parsingError = void 0;
        var inHeader = true;
        // let VTTCue = VTTCue || window.TextTrackCue;

        // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
        var parser = new vttparser();

        parser.oncue = function (cue) {
            // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
            var currCC = vttCCs[cc];
            var cueOffset = vttCCs.ccOffset;

            // Update offsets for new discontinuities
            if (currCC && currCC.new) {
                if (localTime !== undefined) {
                    // When local time is provided, offset = discontinuity start time - local time
                    cueOffset = vttCCs.ccOffset = currCC.start;
                } else {
                    calculateOffset(vttCCs, cc, presentationTime);
                }
            }

            if (presentationTime) {
                // If we have MPEGTS, offset = presentation time + discontinuity offset
                cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;
            }

            cue.startTime += cueOffset - localTime;
            cue.endTime += cueOffset - localTime;

            // Create a unique hash id for a cue based on start/end times and text.
            // This helps timeline-controller to avoid showing repeated captions.
            cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);

            // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
            cue.text = decodeURIComponent(encodeURIComponent(cue.text));
            if (cue.endTime > 0) {
                cues.push(cue);
            }
        };

        parser.onparsingerror = function (e) {
            parsingError = e;
        };

        parser.onflush = function () {
            if (parsingError && errorCallBack) {
                errorCallBack(parsingError);
                return;
            }
            callBack(cues);
        };

        // Go through contents line by line.
        vttLines.forEach(function (line) {
            if (inHeader) {
                // Look for X-TIMESTAMP-MAP in header.
                if (startsWith(line, 'X-TIMESTAMP-MAP=')) {
                    // Once found, no more are allowed anyway, so stop searching.
                    inHeader = false;
                    // Extract LOCAL and MPEGTS.
                    line.substr(16).split(',').forEach(function (timestamp) {
                        if (startsWith(timestamp, 'LOCAL:')) {
                            cueTime = timestamp.substr(6);
                        } else if (startsWith(timestamp, 'MPEGTS:')) {
                            mpegTs = parseInt(timestamp.substr(7));
                        }
                    });
                    try {
                        // Calculate subtitle offset in milliseconds.
                        // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.
                        syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;
                        // Adjust MPEGTS by sync PTS.
                        mpegTs -= syncPTS;
                        // Convert cue time to seconds
                        localTime = cueString2millis(cueTime) / 1000;
                        // Convert MPEGTS to seconds from 90kHz.
                        presentationTime = mpegTs / 90000;

                        if (localTime === -1) {
                            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                        }
                    } catch (e) {
                        parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                    }
                    // Return without parsing X-TIMESTAMP-MAP line.
                    return;
                } else if (line === '') {
                    inHeader = false;
                }
            }
            // Parse line by default.
            parser.parse(line + '\n');
        });

        parser.flush();
    }
};

/* harmony default export */ var webvtt_parser = (WebVTTParser);
// CONCATENATED MODULE: ./src/controller/timeline-controller.js
function timeline_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function timeline_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function timeline_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Timeline Controller
*/








function clearCurrentCues(track) {
  if (track && track.cues) {
    while (track.cues.length > 0) {
      track.removeCue(track.cues[0]);
    }
  }
}

function reuseVttTextTrack(inUseTrack, manifestTrack) {
  return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
}

function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}

var timeline_controller_TimelineController = function (_EventHandler) {
  timeline_controller__inherits(TimelineController, _EventHandler);

  function TimelineController(hls) {
    timeline_controller__classCallCheck(this, TimelineController);

    var _this = timeline_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MEDIA_ATTACHING, events["a" /* default */].MEDIA_DETACHING, events["a" /* default */].FRAG_PARSING_USERDATA, events["a" /* default */].FRAG_DECRYPTED, events["a" /* default */].MANIFEST_LOADING, events["a" /* default */].MANIFEST_LOADED, events["a" /* default */].FRAG_LOADED, events["a" /* default */].LEVEL_SWITCHING, events["a" /* default */].INIT_PTS_FOUND));

    _this.hls = hls;
    _this.config = hls.config;
    _this.enabled = true;
    _this.Cues = hls.config.cueHandler;
    _this.textTracks = [];
    _this.tracks = [];
    _this.unparsedVttFrags = [];
    _this.initPTS = undefined;
    _this.cueRanges = [];

    if (_this.config.enableCEA708Captions) {
      var channel1 = new output_filter(_this, 1);
      var channel2 = new output_filter(_this, 2);

      _this.cea608Parser = new cea_608_parser(0, channel1, channel2);
    }
    return _this;
  }

  TimelineController.prototype.addCues = function addCues(channel, startTime, endTime, screen) {
    // skip cues which overlap more than 50% with previously parsed time ranges
    var ranges = this.cueRanges;
    var merged = false;
    for (var i = ranges.length; i--;) {
      var cueRange = ranges[i];
      var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
      if (overlap >= 0) {
        cueRange[0] = Math.min(cueRange[0], startTime);
        cueRange[1] = Math.max(cueRange[1], endTime);
        merged = true;
        if (overlap / (endTime - startTime) > 0.5) {
          return;
        }
      }
    }
    if (!merged) {
      ranges.push([startTime, endTime]);
    }
    this.Cues.newCue(this[channel], startTime, endTime, screen);
  };

  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.


  TimelineController.prototype.onInitPtsFound = function onInitPtsFound(data) {
    var _this2 = this;

    if (typeof this.initPTS === 'undefined') {
      this.initPTS = data.initPTS;
    }

    // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.
    // Parse any unparsed fragments upon receiving the initial PTS.
    if (this.unparsedVttFrags.length) {
      this.unparsedVttFrags.forEach(function (frag) {
        _this2.onFragLoaded(frag);
      });
      this.unparsedVttFrags = [];
    }
  };

  TimelineController.prototype.getExistingTrack = function getExistingTrack(channelNumber) {
    var media = this.media;
    if (media) {
      for (var i = 0; i < media.textTracks.length; i++) {
        var textTrack = media.textTracks[i];
        var propName = 'textTrack' + channelNumber;
        if (textTrack[propName] === true) {
          return textTrack;
        }
      }
    }
    return null;
  };

  TimelineController.prototype.sendAddTrackEvent = function sendAddTrackEvent(track, media) {
    var e = null;
    try {
      e = new window.Event('addtrack');
    } catch (err) {
      //for IE11
      e = document.createEvent('Event');
      e.initEvent('addtrack', false, false);
    }
    e.track = track;
    media.dispatchEvent(e);
  };

  TimelineController.prototype.createCaptionsTrack = function createCaptionsTrack(track) {
    var trackVar = 'textTrack' + track;
    if (!this[trackVar]) {
      //Enable reuse of existing text track.
      var existingTrack = this.getExistingTrack(track);
      if (!existingTrack) {
        var textTrack = this.createTextTrack('captions', this.config['captionsTextTrack' + track + 'Label'], this.config.captionsTextTrack1LanguageCode);
        if (textTrack) {
          textTrack[trackVar] = true;
          this[trackVar] = textTrack;
        }
      } else {
        this[trackVar] = existingTrack;
        clearCurrentCues(this[trackVar]);

        this.sendAddTrackEvent(this[trackVar], this.media);
      }
    }
  };

  TimelineController.prototype.createTextTrack = function createTextTrack(kind, label, lang) {
    var media = this.media;
    if (media) {
      return media.addTextTrack(kind, label, lang);
    }
  };

  TimelineController.prototype.destroy = function destroy() {
    event_handler.prototype.destroy.call(this);
  };

  TimelineController.prototype.onMediaAttaching = function onMediaAttaching(data) {
    this.media = data.media;
    this._cleanTracks();
  };

  TimelineController.prototype.onMediaDetaching = function onMediaDetaching() {
    clearCurrentCues(this.textTrack1);
    clearCurrentCues(this.textTrack2);
  };

  TimelineController.prototype.onManifestLoading = function onManifestLoading() {
    this.lastSn = -1; // Detect discontiguity in fragment parsing
    this.prevCC = -1;
    this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests
    this._cleanTracks();
  };

  TimelineController.prototype._cleanTracks = function _cleanTracks() {
    // clear outdated subtitles
    var media = this.media;
    if (media) {
      var textTracks = media.textTracks;
      if (textTracks) {
        for (var i = 0; i < textTracks.length; i++) {
          clearCurrentCues(textTracks[i]);
        }
      }
    }
  };

  TimelineController.prototype.onManifestLoaded = function onManifestLoaded(data) {
    var _this3 = this;

    this.textTracks = [];
    this.unparsedVttFrags = this.unparsedVttFrags || [];
    this.initPTS = undefined;
    this.cueRanges = [];

    if (this.config.enableWebVTT) {
      this.tracks = data.subtitles || [];
      var inUseTracks = this.media ? this.media.textTracks : [];

      this.tracks.forEach(function (track, index) {
        var textTrack = void 0;
        if (index < inUseTracks.length) {
          var inUseTrack = inUseTracks[index];
          // Reuse tracks with the same label, but do not reuse 608/708 tracks
          if (reuseVttTextTrack(inUseTrack, track)) {
            textTrack = inUseTrack;
          }
        }
        if (!textTrack) {
          textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
        }
        textTrack.mode = track.default ? 'showing' : 'hidden';
        _this3.textTracks.push(textTrack);
      });
    }
  };

  TimelineController.prototype.onLevelSwitching = function onLevelSwitching() {
    this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
  };

  TimelineController.prototype.onFragLoaded = function onFragLoaded(data) {
    var frag = data.frag,
        payload = data.payload;
    if (frag.type === 'main') {
      var sn = frag.sn;
      // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
      if (sn !== this.lastSn + 1) {
        var cea608Parser = this.cea608Parser;
        if (cea608Parser) {
          cea608Parser.reset();
        }
      }
      this.lastSn = sn;
    }
    // If fragment is subtitle type, parse as WebVTT.
    else if (frag.type === 'subtitle') {
        if (payload.byteLength) {
          // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
          if (typeof this.initPTS === 'undefined') {
            this.unparsedVttFrags.push(data);
            return;
          }

          var decryptData = frag.decryptdata;
          // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.
          if (decryptData == null || decryptData.key == null || decryptData.method !== 'AES-128') {
            this._parseVTTs(frag, payload);
          }
        } else {
          // In case there is no payload, finish unsuccessfully.
          this.hls.trigger(events["a" /* default */].SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
        }
      }
  };

  TimelineController.prototype._parseVTTs = function _parseVTTs(frag, payload) {
    var vttCCs = this.vttCCs;
    if (!vttCCs[frag.cc]) {
      vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
      this.prevCC = frag.cc;
    }
    var textTracks = this.textTracks,
        hls = this.hls;

    // Parse the WebVTT file contents.
    webvtt_parser.parse(payload, this.initPTS, vttCCs, frag.cc, function (cues) {
      var currentTrack = textTracks[frag.trackId];
      // Add cues and trigger event with success true.
      cues.forEach(function (cue) {
        // Sometimes there are cue overlaps on segmented vtts so the same
        // cue can appear more than once in different vtt files.
        // This avoid showing duplicated cues with same timecode and text.
        if (!currentTrack.cues.getCueById(cue.id)) {
          try {
            currentTrack.addCue(cue);
          } catch (err) {
            var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
            textTrackCue.id = cue.id;
            currentTrack.addCue(textTrackCue);
          }
        }
      });
      hls.trigger(events["a" /* default */].SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
    }, function (e) {
      // Something went wrong while parsing. Trigger event with success false.
      logger["b" /* logger */].log('Failed to parse VTT cue: ' + e);
      hls.trigger(events["a" /* default */].SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
    });
  };

  TimelineController.prototype.onFragDecrypted = function onFragDecrypted(data) {
    var decryptedData = data.payload,
        frag = data.frag;

    if (frag.type === 'subtitle') {
      if (typeof this.initPTS === 'undefined') {
        this.unparsedVttFrags.push(data);
        return;
      }

      this._parseVTTs(frag, decryptedData);
    }
  };

  TimelineController.prototype.onFragParsingUserdata = function onFragParsingUserdata(data) {
    // push all of the CEA-708 messages into the interpreter
    // immediately. It will create the proper timestamps based on our PTS value
    if (this.enabled && this.config.enableCEA708Captions) {
      for (var i = 0; i < data.samples.length; i++) {
        var ccdatas = this.extractCea608Data(data.samples[i].bytes);
        this.cea608Parser.addData(data.samples[i].pts, ccdatas);
      }
    }
  };

  TimelineController.prototype.extractCea608Data = function extractCea608Data(byteArray) {
    var count = byteArray[0] & 31;
    var position = 2;
    var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
    var actualCCBytes = [];

    for (var j = 0; j < count; j++) {
      tmpByte = byteArray[position++];
      ccbyte1 = 0x7F & byteArray[position++];
      ccbyte2 = 0x7F & byteArray[position++];
      ccValid = (4 & tmpByte) !== 0;
      ccType = 3 & tmpByte;

      if (ccbyte1 === 0 && ccbyte2 === 0) {
        continue;
      }

      if (ccValid) {
        if (ccType === 0) // || ccType === 1
          {
            actualCCBytes.push(ccbyte1);
            actualCCBytes.push(ccbyte2);
          }
      }
    }
    return actualCCBytes;
  };

  return TimelineController;
}(event_handler);

/* harmony default export */ var timeline_controller = (timeline_controller_TimelineController);
// CONCATENATED MODULE: ./src/controller/subtitle-track-controller.js
var subtitle_track_controller__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function subtitle_track_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function subtitle_track_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function subtitle_track_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * subtitle track controller
*/





function filterSubtitleTracks(textTrackList) {
  var tracks = [];
  for (var i = 0; i < textTrackList.length; i++) {
    if (textTrackList[i].kind === 'subtitles') {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}

var subtitle_track_controller_SubtitleTrackController = function (_EventHandler) {
  subtitle_track_controller__inherits(SubtitleTrackController, _EventHandler);

  function SubtitleTrackController(hls) {
    subtitle_track_controller__classCallCheck(this, SubtitleTrackController);

    var _this = subtitle_track_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MEDIA_ATTACHED, events["a" /* default */].MEDIA_DETACHING, events["a" /* default */].MANIFEST_LOADING, events["a" /* default */].MANIFEST_LOADED, events["a" /* default */].SUBTITLE_TRACK_LOADED));

    _this.tracks = [];
    _this.trackId = -1;
    _this.media = undefined;
    _this.subtitleDisplay = false;
    return _this;
  }

  SubtitleTrackController.prototype._onTextTracksChanged = function _onTextTracksChanged() {
    // Media is undefined when switching streams via loadSource()
    if (!this.media) {
      return;
    }

    var trackId = -1;
    var tracks = filterSubtitleTracks(this.media.textTracks);
    for (var id = 0; id < tracks.length; id++) {
      if (tracks[id].mode === 'showing') {
        trackId = id;
      }
    }

    // Setting current subtitleTrack will invoke code.
    this.subtitleTrack = trackId;
  };

  SubtitleTrackController.prototype.destroy = function destroy() {
    event_handler.prototype.destroy.call(this);
  };

  // Listen for subtitle track change, then extract the current track ID.


  SubtitleTrackController.prototype.onMediaAttached = function onMediaAttached(data) {
    var _this2 = this;

    this.media = data.media;
    if (!this.media) {
      return;
    }

    if (this.queuedDefaultTrack !== undefined) {
      this.subtitleTrack = this.queuedDefaultTrack;
      delete this.queuedDefaultTrack;
    }

    this.trackChangeListener = this._onTextTracksChanged.bind(this);

    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);
    if (this.useTextTrackPolling) {
      this.subtitlePollingInterval = setInterval(function () {
        _this2.trackChangeListener();
      }, 500);
    } else {
      this.media.textTracks.addEventListener('change', this.trackChangeListener);
    }
  };

  SubtitleTrackController.prototype.onMediaDetaching = function onMediaDetaching() {
    if (!this.media) {
      return;
    }
    if (this.useTextTrackPolling) {
      clearInterval(this.subtitlePollingInterval);
    } else {
      this.media.textTracks.removeEventListener('change', this.trackChangeListener);
    }

    this.media = undefined;
  };

  // Reset subtitle tracks on manifest loading


  SubtitleTrackController.prototype.onManifestLoading = function onManifestLoading() {
    this.tracks = [];
    this.trackId = -1;
  };

  // Fired whenever a new manifest is loaded.


  SubtitleTrackController.prototype.onManifestLoaded = function onManifestLoaded(data) {
    var _this3 = this;

    var tracks = data.subtitles || [];
    this.tracks = tracks;
    this.trackId = -1;
    this.hls.trigger(events["a" /* default */].SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });

    // loop through available subtitle tracks and autoselect default if needed
    // TODO: improve selection logic to handle forced, etc
    tracks.forEach(function (track) {
      if (track.default) {
        // setting this.subtitleTrack will trigger internal logic
        // if media has not been attached yet, it will fail
        // we keep a reference to the default track id
        // and we'll set subtitleTrack when onMediaAttached is triggered
        if (_this3.media) {
          _this3.subtitleTrack = track.id;
        } else {
          _this3.queuedDefaultTrack = track.id;
        }
      }
    });
  };

  // Trigger subtitle track playlist reload.


  SubtitleTrackController.prototype.onTick = function onTick() {
    var trackId = this.trackId;
    var subtitleTrack = this.tracks[trackId];
    if (!subtitleTrack) {
      return;
    }

    var details = subtitleTrack.details;
    // check if we need to load playlist for this subtitle Track
    if (details === undefined || details.live === true) {
      // track not retrieved yet, or live playlist we need to (re)load it
      logger["b" /* logger */].log('(re)loading playlist for subtitle track ' + trackId);
      this.hls.trigger(events["a" /* default */].SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });
    }
  };

  SubtitleTrackController.prototype.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(data) {
    var _this4 = this;

    if (data.id < this.tracks.length) {
      logger["b" /* logger */].log('subtitle track ' + data.id + ' loaded');
      this.tracks[data.id].details = data.details;
      // check if current playlist is a live playlist
      if (data.details.live && !this.timer) {
        // if live playlist we will have to reload it periodically
        // set reload period to playlist target duration
        this.timer = setInterval(function () {
          _this4.onTick();
        }, 1000 * data.details.targetduration, this);
      }
      if (!data.details.live && this.timer) {
        // playlist is not live and timer is armed : stopping it
        clearInterval(this.timer);
        this.timer = null;
      }
    }
  };

  /** get alternate subtitle tracks list from playlist **/


  SubtitleTrackController.prototype.setSubtitleTrackInternal = function setSubtitleTrackInternal(newId) {
    // check if level idx is valid
    if (newId < -1 || newId >= this.tracks.length) {
      return;
    }

    // stopping live reloading timer if any
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }

    var textTracks = filterSubtitleTracks(this.media.textTracks);

    // hide currently enabled subtitle track
    if (this.trackId !== -1 && this.subtitleDisplay) {
      textTracks[this.trackId].mode = 'hidden';
    }

    this.trackId = newId;
    logger["b" /* logger */].log('switching to subtitle track ' + newId);
    this.hls.trigger(events["a" /* default */].SUBTITLE_TRACK_SWITCH, { id: newId });

    if (newId === -1) {
      return;
    }

    var subtitleTrack = this.tracks[newId];
    if (this.subtitleDisplay) {
      textTracks[newId].mode = 'showing';
    }

    // check if we need to load playlist for this subtitle Track
    var details = subtitleTrack.details;
    if (details === undefined || details.live === true) {
      // track not retrieved yet, or live playlist we need to (re)load it
      logger["b" /* logger */].log('(re)loading playlist for subtitle track ' + newId);
      this.hls.trigger(events["a" /* default */].SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });
    }
  };

  subtitle_track_controller__createClass(SubtitleTrackController, [{
    key: 'subtitleTracks',
    get: function get() {
      return this.tracks;
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      return this.trackId;
    }

    /** select a subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      if (this.trackId !== subtitleTrackId) {
        // || this.tracks[subtitleTrackId].details === undefined) {
        this.setSubtitleTrackInternal(subtitleTrackId);
      }
    }
  }]);

  return SubtitleTrackController;
}(event_handler);

/* harmony default export */ var subtitle_track_controller = (subtitle_track_controller_SubtitleTrackController);
// EXTERNAL MODULE: ./src/crypt/decrypter.js + 3 modules
var decrypter = __webpack_require__(4);

// CONCATENATED MODULE: ./src/controller/subtitle-stream-controller.js
function subtitle_stream_controller__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function subtitle_stream_controller__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function subtitle_stream_controller__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/*
 * Subtitle Stream Controller
*/






var subtitle_stream_controller_State = {
  STOPPED: 'STOPPED',
  IDLE: 'IDLE',
  KEY_LOADING: 'KEY_LOADING',
  FRAG_LOADING: 'FRAG_LOADING'
};

var subtitle_stream_controller_SubtitleStreamController = function (_EventHandler) {
  subtitle_stream_controller__inherits(SubtitleStreamController, _EventHandler);

  function SubtitleStreamController(hls) {
    subtitle_stream_controller__classCallCheck(this, SubtitleStreamController);

    var _this = subtitle_stream_controller__possibleConstructorReturn(this, _EventHandler.call(this, hls, events["a" /* default */].MEDIA_ATTACHED, events["a" /* default */].ERROR, events["a" /* default */].KEY_LOADED, events["a" /* default */].FRAG_LOADED, events["a" /* default */].SUBTITLE_TRACKS_UPDATED, events["a" /* default */].SUBTITLE_TRACK_SWITCH, events["a" /* default */].SUBTITLE_TRACK_LOADED, events["a" /* default */].SUBTITLE_FRAG_PROCESSED));

    _this.config = hls.config;
    _this.vttFragSNsProcessed = {};
    _this.vttFragQueues = undefined;
    _this.currentlyProcessing = null;
    _this.state = subtitle_stream_controller_State.STOPPED;
    _this.currentTrackId = -1;
    _this.ticks = 0;
    _this.decrypter = new decrypter["a" /* default */](hls.observer, hls.config);
    return _this;
  }

  SubtitleStreamController.prototype.destroy = function destroy() {
    event_handler.prototype.destroy.call(this);
    this.state = subtitle_stream_controller_State.STOPPED;
  };

  // Remove all queued items and create a new, empty queue for each track.


  SubtitleStreamController.prototype.clearVttFragQueues = function clearVttFragQueues() {
    var _this2 = this;

    this.vttFragQueues = {};
    this.tracks.forEach(function (track) {
      _this2.vttFragQueues[track.id] = [];
    });
  };

  // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.


  SubtitleStreamController.prototype.nextFrag = function nextFrag() {
    if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
      var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
      this.fragCurrent = frag;
      this.hls.trigger(events["a" /* default */].FRAG_LOADING, { frag: frag });
      this.state = subtitle_stream_controller_State.FRAG_LOADING;
    }
  };

  // When fragment has finished processing, add sn to list of completed if successful.


  SubtitleStreamController.prototype.onSubtitleFragProcessed = function onSubtitleFragProcessed(data) {
    if (data.success) {
      this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);
    }
    this.currentlyProcessing = null;
    this.state = subtitle_stream_controller_State.IDLE;
    this.nextFrag();
  };

  SubtitleStreamController.prototype.onMediaAttached = function onMediaAttached() {
    this.state = subtitle_stream_controller_State.IDLE;
  };

  // If something goes wrong, procede to next frag, if we were processing one.


  SubtitleStreamController.prototype.onError = function onError(data) {
    var frag = data.frag;
    // don't handle frag error not related to subtitle fragment
    if (frag && frag.type !== 'subtitle') {
      return;
    }
    if (this.currentlyProcessing) {
      this.currentlyProcessing = null;
      this.nextFrag();
    }
  };

  SubtitleStreamController.prototype.tick = function tick() {
    var _this3 = this;

    this.ticks++;
    if (this.ticks === 1) {
      this.doTick();
      if (this.ticks > 1) {
        setTimeout(function () {
          _this3.tick();
        }, 1);
      }
      this.ticks = 0;
    }
  };

  SubtitleStreamController.prototype.doTick = function doTick() {
    var _this4 = this;

    switch (this.state) {
      case subtitle_stream_controller_State.IDLE:
        var tracks = this.tracks;
        var trackId = this.currentTrackId;

        var processedFragSNs = this.vttFragSNsProcessed[trackId],
            fragQueue = this.vttFragQueues[trackId],
            currentFragSN = !!this.currentlyProcessing ? this.currentlyProcessing.sn : -1;

        var alreadyProcessed = function alreadyProcessed(frag) {
          return processedFragSNs.indexOf(frag.sn) > -1;
        };

        var alreadyInQueue = function alreadyInQueue(frag) {
          return fragQueue.some(function (fragInQueue) {
            return fragInQueue.sn === frag.sn;
          });
        };

        // exit if tracks don't exist
        if (!tracks) {
          break;
        }
        var trackDetails;

        if (trackId < tracks.length) {
          trackDetails = tracks[trackId].details;
        }

        if (typeof trackDetails === 'undefined') {
          break;
        }

        // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.
        trackDetails.fragments.forEach(function (frag) {
          if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {
            // Load key if subtitles are encrypted
            if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
              logger["b" /* logger */].log('Loading key for ' + frag.sn);
              _this4.state = subtitle_stream_controller_State.KEY_LOADING;
              _this4.hls.trigger(events["a" /* default */].KEY_LOADING, { frag: frag });
            } else {
              // Frags don't know their subtitle track ID, so let's just add that...
              frag.trackId = trackId;
              fragQueue.push(frag);
              _this4.nextFrag();
            }
          }
        });
    }
  };

  // Got all new subtitle tracks.


  SubtitleStreamController.prototype.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(data) {
    var _this5 = this;

    logger["b" /* logger */].log('subtitle tracks updated');
    this.tracks = data.subtitleTracks;
    this.clearVttFragQueues();
    this.vttFragSNsProcessed = {};
    this.tracks.forEach(function (track) {
      _this5.vttFragSNsProcessed[track.id] = [];
    });
  };

  SubtitleStreamController.prototype.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(data) {
    this.currentTrackId = data.id;
    this.clearVttFragQueues();
  };

  // Got a new set of subtitle fragments.


  SubtitleStreamController.prototype.onSubtitleTrackLoaded = function onSubtitleTrackLoaded() {
    this.tick();
  };

  SubtitleStreamController.prototype.onKeyLoaded = function onKeyLoaded() {
    if (this.state === subtitle_stream_controller_State.KEY_LOADING) {
      this.state = subtitle_stream_controller_State.IDLE;
      this.tick();
    }
  };

  SubtitleStreamController.prototype.onFragLoaded = function onFragLoaded(data) {
    var fragCurrent = this.fragCurrent,
        decryptData = data.frag.decryptdata;
    var fragLoaded = data.frag,
        hls = this.hls;
    if (this.state === subtitle_stream_controller_State.FRAG_LOADING && fragCurrent && data.frag.type === 'subtitle' && fragCurrent.sn === data.frag.sn) {
      // check to see if the payload needs to be decrypted
      if (data.payload.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.method === 'AES-128') {
        var startTime;
        try {
          startTime = performance.now();
        } catch (error) {
          startTime = Date.now();
        }
        // decrypt the subtitles
        this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function (decryptedData) {
          var endTime;
          try {
            endTime = performance.now();
          } catch (error) {
            endTime = Date.now();
          }
          hls.trigger(events["a" /* default */].FRAG_DECRYPTED, { frag: fragLoaded, payload: decryptedData, stats: { tstart: startTime, tdecrypt: endTime } });
        });
      }
    }
  };

  return SubtitleStreamController;
}(event_handler);

/* harmony default export */ var subtitle_stream_controller = (subtitle_stream_controller_SubtitleStreamController);
// CONCATENATED MODULE: ./src/config.js
/**
 * HLS config
 */






//import FetchLoader from './utils/fetch-loader';









var hlsDefaultConfig = {
  autoStartLoad: true, // used by stream-controller
  startPosition: -1, // used by stream-controller
  defaultAudioCodec: undefined, // used by stream-controller
  debug: false, // used by logger
  capLevelOnFPSDrop: false, // used by fps-controller
  capLevelToPlayerSize: false, // used by cap-level-controller
  initialLiveManifestSize: 1, // used by stream-controller
  maxBufferLength: 30, // used by stream-controller
  maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
  maxBufferHole: 0.5, // used by stream-controller
  maxSeekHole: 2, // used by stream-controller
  lowBufferWatchdogPeriod: 0.5, // used by stream-controller
  highBufferWatchdogPeriod: 3, // used by stream-controller
  nudgeOffset: 0.1, // used by stream-controller
  nudgeMaxRetry: 3, // used by stream-controller
  maxFragLookUpTolerance: 0.25, // used by stream-controller
  liveSyncDurationCount: 3, // used by stream-controller
  liveMaxLatencyDurationCount: Infinity, // used by stream-controller
  liveSyncDuration: undefined, // used by stream-controller
  liveMaxLatencyDuration: undefined, // used by stream-controller
  liveDurationInfinity: false, // used by buffer-controller
  maxMaxBufferLength: 600, // used by stream-controller
  enableWorker: true, // used by demuxer
  enableSoftwareAES: true, // used by decrypter
  manifestLoadingTimeOut: 10000, // used by playlist-loader
  manifestLoadingMaxRetry: 1, // used by playlist-loader
  manifestLoadingRetryDelay: 1000, // used by playlist-loader
  manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  startLevel: undefined, // used by level-controller
  levelLoadingTimeOut: 10000, // used by playlist-loader
  levelLoadingMaxRetry: 4, // used by playlist-loader
  levelLoadingRetryDelay: 1000, // used by playlist-loader
  levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
  fragLoadingTimeOut: 20000, // used by fragment-loader
  fragLoadingMaxRetry: 6, // used by fragment-loader
  fragLoadingRetryDelay: 1000, // used by fragment-loader
  fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
  fragLoadingLoopThreshold: 3, // used by stream-controller
  startFragPrefetch: false, // used by stream-controller
  fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
  fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
  appendErrorMaxRetry: 3, // used by buffer-controller
  loader: xhr_loader,
  //loader: FetchLoader,
  fLoader: undefined,
  pLoader: undefined,
  xhrSetup: undefined,
  fetchSetup: undefined,
  abrController: abr_controller,
  bufferController: buffer_controller,
  capLevelController: cap_level_controller,
  fpsController: fps_controller,
  stretchShortVideoTrack: false, // used by mp4-remuxer
  maxAudioFramesDrift: 1, // used by mp4-remuxer
  forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
  abrEwmaFastLive: 3, // used by abr-controller
  abrEwmaSlowLive: 9, // used by abr-controller
  abrEwmaFastVoD: 3, // used by abr-controller
  abrEwmaSlowVoD: 9, // used by abr-controller
  abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
  abrBandWidthFactor: 0.95, // used by abr-controller
  abrBandWidthUpFactor: 0.7, // used by abr-controller
  abrMaxWithRealBitrate: false, // used by abr-controller
  maxStarvationDelay: 4, // used by abr-controller
  maxLoadingDelay: 4, // used by abr-controller
  minAutoBitrate: 0 // used by hls
};

if (true) {
  hlsDefaultConfig.subtitleStreamController = subtitle_stream_controller;
  hlsDefaultConfig.subtitleTrackController = subtitle_track_controller;
  hlsDefaultConfig.timelineController = timeline_controller;
  hlsDefaultConfig.cueHandler = cues_namespaceObject;
  hlsDefaultConfig.enableCEA708Captions = true; // used by timeline-controller
  hlsDefaultConfig.enableWebVTT = true; // used by timeline-controller
  hlsDefaultConfig.captionsTextTrack1Label = 'English'; // used by timeline-controller
  hlsDefaultConfig.captionsTextTrack1LanguageCode = 'en'; // used by timeline-controller
  hlsDefaultConfig.captionsTextTrack2Label = 'Spanish'; // used by timeline-controller
  hlsDefaultConfig.captionsTextTrack2LanguageCode = 'es'; // used by timeline-controller
}

if (true) {
  hlsDefaultConfig.audioStreamController = audio_stream_controller;
  hlsDefaultConfig.audioTrackController = audio_track_controller;
}
// CONCATENATED MODULE: ./src/hls.js
var hls__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function hls__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * HLS interface
 */
















var hls_Hls = function () {
  Hls.isSupported = function isSupported() {
    return is_supported_isSupported();
  };

  hls__createClass(Hls, null, [{
    key: 'version',
    get: function get() {
      return "0.8.9";
    }
  }, {
    key: 'Events',
    get: function get() {
      return events["a" /* default */];
    }
  }, {
    key: 'ErrorTypes',
    get: function get() {
      return errors["b" /* ErrorTypes */];
    }
  }, {
    key: 'ErrorDetails',
    get: function get() {
      return errors["a" /* ErrorDetails */];
    }
  }, {
    key: 'DefaultConfig',
    get: function get() {
      if (!Hls.defaultConfig) {
        return hlsDefaultConfig;
      }
      return Hls.defaultConfig;
    },
    set: function set(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
  }]);

  function Hls() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    hls__classCallCheck(this, Hls);

    var defaultConfig = Hls.DefaultConfig;

    if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
      throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
    }

    for (var prop in defaultConfig) {
      if (prop in config) {
        continue;
      }
      config[prop] = defaultConfig[prop];
    }

    if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
    }

    if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
    }

    Object(logger["a" /* enableLogs */])(config.debug);
    this.config = config;
    this._autoLevelCapping = -1;
    // observer setup
    var observer = this.observer = new events_default.a();
    observer.trigger = function trigger(event) {
      for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }

      observer.emit.apply(observer, [event, event].concat(data));
    };

    observer.off = function off(event) {
      for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      observer.removeListener.apply(observer, [event].concat(data));
    };
    this.on = observer.on.bind(observer);
    this.off = observer.off.bind(observer);
    this.trigger = observer.trigger.bind(observer);

    // core controllers and network loaders
    var abrController = this.abrController = new config.abrController(this);
    var bufferController = new config.bufferController(this);
    var capLevelController = new config.capLevelController(this);
    var fpsController = new config.fpsController(this);
    var playListLoader = new playlist_loader(this);
    var fragmentLoader = new fragment_loader(this);
    var keyLoader = new key_loader(this);
    var id3TrackController = new id3_track_controller(this);

    // network controllers
    var levelController = this.levelController = new level_controller(this);
    var streamController = this.streamController = new stream_controller(this);
    var networkControllers = [levelController, streamController];

    // optional audio stream controller
    var Controller = config.audioStreamController;
    if (Controller) {
      networkControllers.push(new Controller(this));
    }
    this.networkControllers = networkControllers;

    var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController];

    // optional audio track and subtitle controller
    Controller = config.audioTrackController;
    if (Controller) {
      var audioTrackController = new Controller(this);
      this.audioTrackController = audioTrackController;
      coreComponents.push(audioTrackController);
    }

    Controller = config.subtitleTrackController;
    if (Controller) {
      var subtitleTrackController = new Controller(this);
      this.subtitleTrackController = subtitleTrackController;
      coreComponents.push(subtitleTrackController);
    }

    // optional subtitle controller
    [config.subtitleStreamController, config.timelineController].forEach(function (Controller) {
      if (Controller) {
        coreComponents.push(new Controller(_this));
      }
    });
    this.coreComponents = coreComponents;
  }

  Hls.prototype.destroy = function destroy() {
    logger["b" /* logger */].log('destroy');
    this.trigger(events["a" /* default */].DESTROYING);
    this.detachMedia();
    this.coreComponents.concat(this.networkControllers).forEach(function (component) {
      component.destroy();
    });
    this.url = null;
    this.observer.removeAllListeners();
    this._autoLevelCapping = -1;
  };

  Hls.prototype.attachMedia = function attachMedia(media) {
    logger["b" /* logger */].log('attachMedia');
    this.media = media;
    this.trigger(events["a" /* default */].MEDIA_ATTACHING, { media: media });
  };

  Hls.prototype.detachMedia = function detachMedia() {
    logger["b" /* logger */].log('detachMedia');
    this.trigger(events["a" /* default */].MEDIA_DETACHING);
    this.media = null;
  };

  Hls.prototype.loadSource = function loadSource(url) {
    url = url_toolkit_default.a.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
    logger["b" /* logger */].log('loadSource:' + url);
    this.url = url;
    // when attaching to a source URL, trigger a playlist load
    this.trigger(events["a" /* default */].MANIFEST_LOADING, { url: url });
  };

  Hls.prototype.startLoad = function startLoad() {
    var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

    logger["b" /* logger */].log('startLoad(' + startPosition + ')');
    this.networkControllers.forEach(function (controller) {
      controller.startLoad(startPosition);
    });
  };

  Hls.prototype.stopLoad = function stopLoad() {
    logger["b" /* logger */].log('stopLoad');
    this.networkControllers.forEach(function (controller) {
      controller.stopLoad();
    });
  };

  Hls.prototype.swapAudioCodec = function swapAudioCodec() {
    logger["b" /* logger */].log('swapAudioCodec');
    this.streamController.swapAudioCodec();
  };

  Hls.prototype.recoverMediaError = function recoverMediaError() {
    logger["b" /* logger */].log('recoverMediaError');
    var media = this.media;
    this.detachMedia();
    this.attachMedia(media);
  };

  /** Return all quality levels **/


  hls__createClass(Hls, [{
    key: 'levels',
    get: function get() {
      return this.levelController.levels;
    }

    /** Return current playback quality level **/

  }, {
    key: 'currentLevel',
    get: function get() {
      return this.streamController.currentLevel;
    }

    /* set quality level immediately (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      logger["b" /* logger */].log('set currentLevel:' + newLevel);
      this.loadLevel = newLevel;
      this.streamController.immediateLevelSwitch();
    }

    /** Return next playback quality level (quality level of next fragment) **/

  }, {
    key: 'nextLevel',
    get: function get() {
      return this.streamController.nextLevel;
    }

    /* set quality level for next fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      logger["b" /* logger */].log('set nextLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }

    /** Return the quality level of current/last loaded fragment **/

  }, {
    key: 'loadLevel',
    get: function get() {
      return this.levelController.level;
    }

    /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
    ,
    set: function set(newLevel) {
      logger["b" /* logger */].log('set loadLevel:' + newLevel);
      this.levelController.manualLevel = newLevel;
    }

    /** Return the quality level of next loaded fragment **/

  }, {
    key: 'nextLoadLevel',
    get: function get() {
      return this.levelController.nextLoadLevel;
    }

    /** set quality level of next loaded fragment **/
    ,
    set: function set(level) {
      this.levelController.nextLoadLevel = level;
    }

    /** Return first level (index of first level referenced in manifest)
    **/

  }, {
    key: 'firstLevel',
    get: function get() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }

    /** set first level (index of first level referenced in manifest)
    **/
    ,
    set: function set(newLevel) {
      logger["b" /* logger */].log('set firstLevel:' + newLevel);
      this.levelController.firstLevel = newLevel;
    }

    /** Return start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/

  }, {
    key: 'startLevel',
    get: function get() {
      return this.levelController.startLevel;
    }

    /** set  start level (level of first fragment that will be played back)
        if not overrided by user, first level appearing in manifest will be used as start level
        if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
    **/
    ,
    set: function set(newLevel) {
      logger["b" /* logger */].log('set startLevel:' + newLevel);
      var hls = this;
      // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, hls.minAutoLevel);
      }
      hls.levelController.startLevel = newLevel;
    }

    /** Return the capping/max level value that could be used by automatic level selection algorithm **/

  }, {
    key: 'autoLevelCapping',
    get: function get() {
      return this._autoLevelCapping;
    }

    /** set the capping/max level value that could be used by automatic level selection algorithm **/
    ,
    set: function set(newLevel) {
      logger["b" /* logger */].log('set autoLevelCapping:' + newLevel);
      this._autoLevelCapping = newLevel;
    }

    /* check if we are in automatic level selection mode */

  }, {
    key: 'autoLevelEnabled',
    get: function get() {
      return this.levelController.manualLevel === -1;
    }

    /* return manual level */

  }, {
    key: 'manualLevel',
    get: function get() {
      return this.levelController.manualLevel;
    }

    /* return min level selectable in auto mode according to config.minAutoBitrate */

  }, {
    key: 'minAutoLevel',
    get: function get() {
      var hls = this,
          levels = hls.levels,
          minAutoBitrate = hls.config.minAutoBitrate,
          len = levels ? levels.length : 0;
      for (var i = 0; i < len; i++) {
        var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
        if (levelNextBitrate > minAutoBitrate) {
          return i;
        }
      }
      return 0;
    }

    /* return max level selectable in auto mode according to autoLevelCapping */

  }, {
    key: 'maxAutoLevel',
    get: function get() {
      var hls = this;
      var levels = hls.levels;
      var autoLevelCapping = hls.autoLevelCapping;
      var maxAutoLevel = void 0;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      return maxAutoLevel;
    }

    // return next auto level

  }, {
    key: 'nextAutoLevel',
    get: function get() {
      var hls = this;
      // ensure next auto level is between  min and max auto level
      return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
    }

    // this setter is used to force next auto level
    // this is useful to force a switch down in auto mode : in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
    // forced value is valid for one fragment. upon succesful frag loading at forced level, this value will be resetted to -1 by ABR controller
    ,
    set: function set(nextLevel) {
      var hls = this;
      hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
    }

    /** get alternate audio tracks list from playlist **/

  }, {
    key: 'audioTracks',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }

    /** get index of the selected audio track (index in audio track lists) **/

  }, {
    key: 'audioTrack',
    get: function get() {
      var audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }

    /** select an audio track, based on its index in audio track lists**/
    ,
    set: function set(audioTrackId) {
      var audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }
  }, {
    key: 'liveSyncPosition',
    get: function get() {
      return this.streamController.liveSyncPosition;
    }

    /** get alternate subtitle tracks list from playlist **/

  }, {
    key: 'subtitleTracks',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }

    /** get index of the selected subtitle track (index in subtitle track lists) **/

  }, {
    key: 'subtitleTrack',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }

    /** select an subtitle track, based on its index in subtitle track lists**/
    ,
    set: function set(subtitleTrackId) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }
  }, {
    key: 'subtitleDisplay',
    get: function get() {
      var subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    },
    set: function set(value) {
      var subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }
  }]);

  return Hls;
}();

/* harmony default export */ var src_hls = __webpack_exports__["default"] = (hls_Hls);

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

function webpackBootstrapFunc (modules) {
/******/  // The module cache
/******/  var installedModules = {};

/******/  // The require function
/******/  function __webpack_require__(moduleId) {

/******/    // Check if module is in cache
/******/    if(installedModules[moduleId])
/******/      return installedModules[moduleId].exports;

/******/    // Create a new module (and put it into the cache)
/******/    var module = installedModules[moduleId] = {
/******/      i: moduleId,
/******/      l: false,
/******/      exports: {}
/******/    };

/******/    // Execute the module function
/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/    // Flag the module as loaded
/******/    module.l = true;

/******/    // Return the exports of the module
/******/    return module.exports;
/******/  }

/******/  // expose the modules object (__webpack_modules__)
/******/  __webpack_require__.m = modules;

/******/  // expose the module cache
/******/  __webpack_require__.c = installedModules;

/******/  // identity function for calling harmony imports with the correct context
/******/  __webpack_require__.i = function(value) { return value; };

/******/  // define getter function for harmony exports
/******/  __webpack_require__.d = function(exports, name, getter) {
/******/    if(!__webpack_require__.o(exports, name)) {
/******/      Object.defineProperty(exports, name, {
/******/        configurable: false,
/******/        enumerable: true,
/******/        get: getter
/******/      });
/******/    }
/******/  };

/******/  // getDefaultExport function for compatibility with non-harmony modules
/******/  __webpack_require__.n = function(module) {
/******/    var getter = module && module.__esModule ?
/******/      function getDefault() { return module['default']; } :
/******/      function getModuleExports() { return module; };
/******/    __webpack_require__.d(getter, 'a', getter);
/******/    return getter;
/******/  };

/******/  // Object.prototype.hasOwnProperty.call
/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/  // __webpack_public_path__
/******/  __webpack_require__.p = "/";

/******/  // on error function for async loading
/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };

  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)
  return f.default || f // try to call default if defined to also support babel esmodule exports
}

// http://stackoverflow.com/a/2593661/130442
function quoteRegExp (str) {
  return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&')
}

function getModuleDependencies (module) {
  var retval = []
  var fnString = module.toString()
  var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/)
  if (!wrapperSignature) return retval

  var webpackRequireName = wrapperSignature[1]
  var re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + '\\((\/\\*.*?\\*\/)?\s?.*?([\\.|\\-|\\w|\/|@]+).*?\\)', 'g') // additional chars when output.pathinfo is true
  var match
  while ((match = re.exec(fnString))) {
    retval.push(match[3])
  }
  return retval
}

function getRequiredModules (sources, moduleId) {
  var modulesQueue = [moduleId]
  var requiredModules = []
  var seenModules = {}

  while (modulesQueue.length) {
    var moduleToCheck = modulesQueue.pop()
    if (seenModules[moduleToCheck] || !sources[moduleToCheck]) continue
    seenModules[moduleToCheck] = true
    requiredModules.push(moduleToCheck)
    var newModules = getModuleDependencies(sources[moduleToCheck])
    modulesQueue = modulesQueue.concat(newModules)
  }

  return requiredModules
}

module.exports = function (moduleId, options) {
  options = options || {}
  var sources = __webpack_require__.m

  var requiredModules = options.all ? Object.keys(sources) : getRequiredModules(sources, moduleId)
  var src = '(' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[id].toString() }).join(',') + '})(self);'

  var blob = new window.Blob([src], { type: 'text/javascript' })
  if (options.bare) { return blob }

  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL

  var workerUrl = URL.createObjectURL(blob)
  var worker = new window.Worker(workerUrl)
  worker.objectURL = workerUrl

  return worker
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__demux_demuxer_inline__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__events__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_events__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_events__);
/* demuxer web worker.
 *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
 *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
 */






var DemuxerWorker = function DemuxerWorker(self) {
  // observer setup
  var observer = new __WEBPACK_IMPORTED_MODULE_3_events___default.a();
  observer.trigger = function trigger(event) {
    for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }

    observer.emit.apply(observer, [event, event].concat(data));
  };

  observer.off = function off(event) {
    for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      data[_key2 - 1] = arguments[_key2];
    }

    observer.removeListener.apply(observer, [event].concat(data));
  };

  var forwardMessage = function forwardMessage(ev, data) {
    self.postMessage({ event: ev, data: data });
  };

  self.addEventListener('message', function (ev) {
    var data = ev.data;
    //console.log('demuxer cmd:' + data.cmd);
    switch (data.cmd) {
      case 'init':
        var config = JSON.parse(data.config);
        self.demuxer = new __WEBPACK_IMPORTED_MODULE_0__demux_demuxer_inline__["a" /* default */](observer, data.typeSupported, config, data.vendor);
        try {
          Object(__WEBPACK_IMPORTED_MODULE_2__utils_logger__["a" /* enableLogs */])(config.debug === true);
        } catch (err) {
          console.warn('demuxerWorker: unable to enable logs');
        }
        // signal end of worker init
        forwardMessage('init', null);
        break;
      case 'demux':
        self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
        break;
      default:
        break;
    }
  });

  // forward events to main thread
  observer.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* default */].FRAG_DECRYPTED, forwardMessage);
  observer.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* default */].FRAG_PARSING_INIT_SEGMENT, forwardMessage);
  observer.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* default */].FRAG_PARSED, forwardMessage);
  observer.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* default */].ERROR, forwardMessage);
  observer.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* default */].FRAG_PARSING_METADATA, forwardMessage);
  observer.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* default */].FRAG_PARSING_USERDATA, forwardMessage);
  observer.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* default */].INIT_PTS_FOUND, forwardMessage);

  // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
  observer.on(__WEBPACK_IMPORTED_MODULE_1__events__["a" /* default */].FRAG_PARSING_DATA, function (ev, data) {
    var transferable = [];
    var message = { event: ev, data: data };
    if (data.data1) {
      message.data1 = data.data1.buffer;
      transferable.push(data.data1.buffer);
      delete data.data1;
    }
    if (data.data2) {
      message.data2 = data.data2.buffer;
      transferable.push(data.data2.buffer);
      delete data.data2;
    }
    self.postMessage(message, transferable);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (DemuxerWorker);

/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=hls.js.map
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

/*global window, require, define */
(function(_window) {
  'use strict';

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

  function setupBrowser() {
    // Allow for MSIE11 msCrypto
    var _crypto = _window.crypto || _window.msCrypto;

    if (!_rng && _crypto && _crypto.getRandomValues) {
      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
      //
      // Moderately fast, high quality
      try {
        var _rnds8 = new Uint8Array(16);
        _whatwgRNG = _rng = function whatwgRNG() {
          _crypto.getRandomValues(_rnds8);
          return _rnds8;
        };
        _rng();
      } catch(e) {}
    }

    if (!_rng) {
      // Math.random()-based (RNG)
      //
      // If all else fails, use Math.random().  It's fast, but is of unspecified
      // quality.
      var  _rnds = new Array(16);
      _mathRNG = _rng = function() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        }

        return _rnds;
      };
      if ('undefined' !== typeof console && console.warn) {
        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
      }
    }
  }

  function setupNode() {
    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
    //
    // Moderately fast, high quality
    if ('function' === typeof require) {
      try {
        var _rb = require('crypto').randomBytes;
        _nodeRNG = _rng = _rb && function() {return _rb(16);};
        _rng();
      } catch(e) {}
    }
  }

  if (_window) {
    setupBrowser();
  } else {
    setupNode();
  }

  // Buffer class to use
  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) === 'string') {
      buf = (options === 'binary') ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;
  uuid._rng = _rng;
  uuid._mathRNG = _mathRNG;
  uuid._nodeRNG = _nodeRNG;
  uuid._whatwgRNG = _whatwgRNG;

  if (('undefined' !== typeof module) && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});


  } else {
    // Publish as global (in browsers)
    _previousRoot = _window.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _window.uuid = _previousRoot;
      return uuid;
    };

    _window.uuid = uuid;
  }
})('undefined' !== typeof window ? window : null);

/**
 * Detect Element Resize
 *
 * https://github.com/sdecima/javascript-detect-element-resize
 * Sebastian Decima
 *
 * version: 0.5.3
 **/

(function() {
    var attachEvent = document.attachEvent,
        stylesCreated = false;

    if (!attachEvent) {
        var requestFrame = (function() {
            var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||
                    function(fn) {
                        return window.setTimeout(fn, 20);
                };
            return function(fn) {
                return raf(fn);
            };
        })();

        var cancelFrame = (function() {
            var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame ||
                window.clearTimeout;
            return function(id) {
                return cancel(id);
            };
        })();

        function resetTriggers(element) {
            var triggers = element.__resizeTriggers__,
                expand = triggers.firstElementChild,
                contract = triggers.lastElementChild,
                expandChild = expand.firstElementChild;
            contract.scrollLeft = contract.scrollWidth;
            contract.scrollTop = contract.scrollHeight;
            expandChild.style.width = expand.offsetWidth + 1 + 'px';
            expandChild.style.height = expand.offsetHeight + 1 + 'px';
            expand.scrollLeft = expand.scrollWidth;
            expand.scrollTop = expand.scrollHeight;
        };

        function checkTriggers(element) {
            return element.offsetWidth != element.__resizeLast__.width ||
                element.offsetHeight != element.__resizeLast__.height;
        }

        function scrollListener(e) {
            var element = this;
            resetTriggers(this);
            if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
            this.__resizeRAF__ = requestFrame(function() {
                if (checkTriggers(element)) {
                    element.__resizeLast__.width = element.offsetWidth;
                    element.__resizeLast__.height = element.offsetHeight;
                    element.__resizeListeners__.forEach(function(fn) {
                        fn.call(element, e);
                    });
                }
            });
        };

        /* Detect CSS Animations support to detect element display/re-attach */
        var animation = false,
            animationstring = 'animation',
            keyframeprefix = '',
            animationstartevent = 'animationstart',
            domPrefixes = 'Webkit Moz O ms'.split(' '),
            startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
            pfx = ''; {
                var elm = document.createElement('fakeelement');
                if (elm.style.animationName !== undefined) {
                    animation = true;
                }

                if (animation === false) {
                    for (var i = 0; i < domPrefixes.length; i++) {
                        if (elm.style[domPrefixes[i] + 'AnimationName'] !== undefined) {
                            pfx = domPrefixes[i];
                            animationstring = pfx + 'Animation';
                            keyframeprefix = '-' + pfx.toLowerCase() + '-';
                            animationstartevent = startEvents[i];
                            animation = true;
                            break;
                        }
                    }
                }
        }

        var animationName = 'resizeanim';
        var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
        var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';
    }

    function createStyles() {
        if (!stylesCreated) {
            //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
            var css = (animationKeyframes ? animationKeyframes : '') +
                '.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' +
                '.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
                head = document.head || document.getElementsByTagName('head')[0],
                style = document.createElement('style');

            style.type = 'text/css';
            if (style.styleSheet) {
                style.styleSheet.cssText = css;
            } else {
                style.appendChild(document.createTextNode(css));
            }

            head.appendChild(style);
            stylesCreated = true;
        }
    }

    window.addResizeListener = function(element, fn) {
        if (attachEvent) element.attachEvent('onresize', fn);
        else {
            if (!element.__resizeTriggers__) {
                if (getComputedStyle(element).position == 'static') element.style.position = 'relative';
                createStyles();
                element.__resizeLast__ = {};
                element.__resizeListeners__ = [];
                (element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';
                element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' +
                    '<div class="contract-trigger"></div>';
                element.appendChild(element.__resizeTriggers__);
                resetTriggers(element);
                element.addEventListener('scroll', scrollListener, true);

                /* Listen for a css animation to detect element display/re-attach */
                animationstartevent && element.__resizeTriggers__.addEventListener(animationstartevent, function(e) {
                    if (e.animationName == animationName)
                        resetTriggers(element);
                });
            }
            element.__resizeListeners__.push(fn);
        }
    };

    window.removeResizeListener = function(element, fn) {
        if (attachEvent) element.detachEvent('onresize', fn);
        else {
            element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
            if (!element.__resizeListeners__.length) {
                element.removeEventListener('scroll', scrollListener);
                element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
            }
        }
    }
})();
// http://spin.js.org/#v2.3.2
!function(a,b){"object"==typeof module&&module.exports?module.exports=b():"function"==typeof define&&define.amd?define(b):a.Spinner=b()}(this,function(){"use strict";function a(a,b){var c,d=document.createElement(a||"div");for(c in b)d[c]=b[c];return d}function b(a){for(var b=1,c=arguments.length;c>b;b++)a.appendChild(arguments[b]);return a}function c(a,b,c,d){var e=["opacity",b,~~(100*a),c,d].join("-"),f=.01+c/d*100,g=Math.max(1-(1-a)/b*(100-f),a),h=j.substring(0,j.indexOf("Animation")).toLowerCase(),i=h&&"-"+h+"-"||"";return m[e]||(k.insertRule("@"+i+"keyframes "+e+"{0%{opacity:"+g+"}"+f+"%{opacity:"+a+"}"+(f+.01)+"%{opacity:1}"+(f+b)%100+"%{opacity:"+a+"}100%{opacity:"+g+"}}",k.cssRules.length),m[e]=1),e}function d(a,b){var c,d,e=a.style;if(b=b.charAt(0).toUpperCase()+b.slice(1),void 0!==e[b])return b;for(d=0;d<l.length;d++)if(c=l[d]+b,void 0!==e[c])return c}function e(a,b){for(var c in b)a.style[d(a,c)||c]=b[c];return a}function f(a){for(var b=1;b<arguments.length;b++){var c=arguments[b];for(var d in c)void 0===a[d]&&(a[d]=c[d])}return a}function g(a,b){return"string"==typeof a?a:a[b%a.length]}function h(a){this.opts=f(a||{},h.defaults,n)}function i(){function c(b,c){return a("<"+b+' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">',c)}k.addRule(".spin-vml","behavior:url(#default#VML)"),h.prototype.lines=function(a,d){function f(){return e(c("group",{coordsize:k+" "+k,coordorigin:-j+" "+-j}),{width:k,height:k})}function h(a,h,i){b(m,b(e(f(),{rotation:360/d.lines*a+"deg",left:~~h}),b(e(c("roundrect",{arcsize:d.corners}),{width:j,height:d.scale*d.width,left:d.scale*d.radius,top:-d.scale*d.width>>1,filter:i}),c("fill",{color:g(d.color,a),opacity:d.opacity}),c("stroke",{opacity:0}))))}var i,j=d.scale*(d.length+d.width),k=2*d.scale*j,l=-(d.width+d.length)*d.scale*2+"px",m=e(f(),{position:"absolute",top:l,left:l});if(d.shadow)for(i=1;i<=d.lines;i++)h(i,-2,"progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)");for(i=1;i<=d.lines;i++)h(i);return b(a,m)},h.prototype.opacity=function(a,b,c,d){var e=a.firstChild;d=d.shadow&&d.lines||0,e&&b+d<e.childNodes.length&&(e=e.childNodes[b+d],e=e&&e.firstChild,e=e&&e.firstChild,e&&(e.opacity=c))}}var j,k,l=["webkit","Moz","ms","O"],m={},n={lines:12,length:7,width:5,radius:10,scale:1,corners:1,color:"#000",opacity:.25,rotate:0,direction:1,speed:1,trail:100,fps:20,zIndex:2e9,className:"spinner",top:"50%",left:"50%",shadow:!1,hwaccel:!1,position:"absolute"};if(h.defaults={},f(h.prototype,{spin:function(b){this.stop();var c=this,d=c.opts,f=c.el=a(null,{className:d.className});if(e(f,{position:d.position,width:0,zIndex:d.zIndex,left:d.left,top:d.top}),b&&b.insertBefore(f,b.firstChild||null),f.setAttribute("role","progressbar"),c.lines(f,c.opts),!j){var g,h=0,i=(d.lines-1)*(1-d.direction)/2,k=d.fps,l=k/d.speed,m=(1-d.opacity)/(l*d.trail/100),n=l/d.lines;!function o(){h++;for(var a=0;a<d.lines;a++)g=Math.max(1-(h+(d.lines-a)*n)%l*m,d.opacity),c.opacity(f,a*d.direction+i,g,d);c.timeout=c.el&&setTimeout(o,~~(1e3/k))}()}return c},stop:function(){var a=this.el;return a&&(clearTimeout(this.timeout),a.parentNode&&a.parentNode.removeChild(a),this.el=void 0),this},lines:function(d,f){function h(b,c){return e(a(),{position:"absolute",width:f.scale*(f.length+f.width)+"px",height:f.scale*f.width+"px",background:b,boxShadow:c,transformOrigin:"left",transform:"rotate("+~~(360/f.lines*k+f.rotate)+"deg) translate("+f.scale*f.radius+"px,0)",borderRadius:(f.corners*f.scale*f.width>>1)+"px"})}for(var i,k=0,l=(f.lines-1)*(1-f.direction)/2;k<f.lines;k++)i=e(a(),{position:"absolute",top:1+~(f.scale*f.width/2)+"px",transform:f.hwaccel?"translate3d(0,0,0)":"",opacity:f.opacity,animation:j&&c(f.opacity,f.trail,l+k*f.direction,f.lines)+" "+1/f.speed+"s linear infinite"}),f.shadow&&b(i,e(h("#000","0 0 4px #000"),{top:"2px"})),b(d,b(i,h(g(f.color,k),"0 0 1px rgba(0,0,0,.1)")));return d},opacity:function(a,b,c){b<a.childNodes.length&&(a.childNodes[b].style.opacity=c)}}),"undefined"!=typeof document){k=function(){var c=a("style",{type:"text/css"});return b(document.getElementsByTagName("head")[0],c),c.sheet||c.styleSheet}();var o=e(a("group"),{behavior:"url(#default#VML)"});!d(o,"transform")&&o.adj?i():j=d(o,"animation")}return h});
/**
 * @namespace uvpjs
 * c 2015 CBSInteractive by Larry Doyle. Class Helper code courtesy Doug Loftus / HUB project
 *
 * @ignore
 */
//'use strict';


// global uvpjs namespace
window.uvpjs = {

    /** @lends uvpjs */

    debug: false,

    log: function () {},
    warn: function () {},
    error: function () {},

    /**
     * UVPJS events. All event handler objects contain three properties: **payload**, **target**, and **type**.
     * <pre class="prettyprint">
     *  // Example event with empty payload.
     *  {
     *      payload: {},
     *      target: 'myVideoContainer',
     *      type: 'onContentStart'
     *  }
     * </pre>
     * @typedef {Object} EventType
     * @property {String} AD_BLOCKED - Event dispatched when the `sessionOptions.adBlockerCallback()` returns `true`. The **payload** is an empty object `payload: {}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} AD_END - Event dispatched every time an ad clip has completed playback. The payload contains the ad video state `payload:{ adData:{@link adVideoState}}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} AD_ERROR - Event dispatched when an ad error occurs. The payload contains an errorInfo property (value is an ErrorInfo object) `payload:{ errorInfo:{@link uvpjs.ErrorInfo}}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * <pre class="prettyprint">
     *  // Example payload for AD_ERROR event (also applies to PLAYER_START_ERROR, VIDEO_START_ERROR, VIDEO_PLAYBACK_ERROR).
     *  {
     *      payload: {
     *          errorInfo: {
     *              eventType: string_event_type (simply echoes event type),
     *              errorCode: number_errorCode (see uvpjs.ErrorInfo.errorCodes)
     *              message: string_error_message,
     *              isFatal: boolean_fatal_indication
     *              serverCode: number_serverCode (a VAST or IMA error enum, may be null)
     *          },
     *      },
     *      target: 'myVideoContainer',
     *      type: 'onAdError'
     *  }
     * </pre>
     * @property {String} AD_PLUGIN_CONTENT_PAUSE_REQUEST - Dispatched by Ad Plugins when the plugin is about to start playing video ads from an unplayed ad pod. The payload:{} is an empty object.
     * @property {String} AD_PLUGIN_CONTENT_RESUME_REQUEST - Dispatched by Ad Plugins when the plugin has completed playing all the video ads within a given ad pod. The payload:{} is an empty object.
     * @property {String} AD_POD_END - Event dispatched every time an ad pod ends.  The ad pod object is generated by the Ad Playlist Manager (APM) `payload:{adPod: {...}}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>`. See example below.
     * @property {String} AD_POD_START - Event dispatched every time an ad pod starts. The ad pod object is generated by the Ad Playlist Manager (APM) `payload:{adPod: {...}}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>`. See example below.
     * <pre class="prettyprint">
     *  // Example payload for AD_POD_END and AD_POD_START.
     *  {
     *      payload: {
     *          adPod: {
     *              adCallUrl: 'http://www.foo.bar',
     *              adCount: 0,
     *              adPodId: 1,
     *              hasPlayed: false,
     *              podDuration: 60,
     *              startTime: 120,
     *          },
     *      },
     *      target: 'myVideoContainer',
     *      type: 'onAdStart'
     *  }
     * </pre>
     * @property {String} AD_SKIPPED - Event dispatched every time the IMA ad plugin dispatches an IMA *skipped* event. The payload contains the ad video state `payload:{ adData:{@link adVideoState}}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} AD_LOADED - Event dispatched when a new ad is laoded by IMA
     * @property {String} AD_REQUEST - Event dispatched when a new ad request is started
     * @property {String} AD_RESPONSE - Event dispatched when an ad requests returns with a valid response/ads manager
     * @property {String} AD_START - Event dispatched every time an ad clip has fully buffered and begins playback. The payload contains the ad video state `payload:{ adData:{@link adVideoState}}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} CAPTIONS_READY - Event dispatched every time a new closed captions files associated with a content video has successfully loaded and parsed. The **payload** is an empty object `payload: {}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>`.
     * <pre class="prettyprint">
     *  // Example payload for CAPTIONS_READY.
     *  {
     *      payload: {},
     *      target: 'myVideoContainer',
     *      type: 'onCaptionsReady'
     *  }
     * </pre>
     * @property {String} CAPTIONS_UNAVAILABLE - Event dispatched when closed captions become unavailable, typically during a live stream. The **payload** is an empty object `payload: {}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>`.
     * @property {String} CONTAINER_RESIZE -  Event dispatched when the video container resizes. The payload is `{e: <HTMLDOMEvent>}`.
     * @property {String} CONTENT_DATA_LOADED - Event dispatched by the a Resource Provider after all resource metadata has loaded, but before playback of the resource begins. The `payload:{}` object has the property `{vidState:{ {@link contentVideoState}} }`.
     * @property {String} CONTENT_END - Event dispatched every time a content clip has ended or paused before an ad. The `payload:{contentData:{}}` is a Content Data object. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} CONTENT_START - Event dispatched every time a content clip has started or resumed after an ad. The `payload:{contentData:{}}` is a Content Data object. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} CONTROL_MUTE - Event dispatched when a `.mute()` video API method call is made. The **payload** is an empty object `payload: {}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} CONTROL_UNMUTE - Event dispatched when a `.unMute()` video API method call is made. The **payload** is an empty object `payload: {}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} CONTROL_VOLUME_CHANGE - Event dispatched when Resource Proveider facadeVolumeChange() method is called by a low level video player. The **payload** object has a property `{vol: .5}` which is a Number bewteen 0 and 1.   The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} DIAGNOSTIC_WINDOW_CLOSE_BUTTON - Event dispatched when the diagnostic window close button is pressed.
     * @property {String} FIRST_GESTURE vents of this type are dispatched when the first touch/click of the Control bar is detected. <p>The <code>payload</code> object has form {isVolumeButton: T?F, isPlayPauseToggle: T/F}.</p>
     * @property {String} NO_AD_CONTENT - Event dispatched when an IMA ad error is encountered and the ad cannot play. The **payload** is an empty object `payload: {}`.
     * @property {String} PAUSE_AD_REQUEST - Event dispatched by custom skin manager upon user-activated Pause; results in companion ad retrieval. Since more than one ad image size is returned in the XML response, the event payload must specify the desired image width and height. Payload: {width: <IntExpectedImgWidth>, height: <IntExpectedImgHeight>}
     * @property {String} PAUSE_AD_LOADED - Event dispatched with a payload containing an image url and an ad link; event will be handled by custom skin management code. Payload: {imgSrc: <StringImgUrl>, clickThru: <StringAdPageUrl>}
     * @property {String} PLAYER_LOADED - Event dispatched when player has initialized (may not be ready for playback at this point, however, if a user gesture is required)
     * @property {String} PLAYER_INIT - Event dispatched by the Video Manager when initialization and configuration are complete, immediately before the Video Manager Ready callback is invoked. The **payload** is an empty object `payload: {}`.
     * @property {String} PLAYER_START_ERROR - Event dispatched when player fails to start. Note that this event may be dispatched prior to VCI ("player")creation; use VideoManager.addEventListener to ensure handling. The payload contains an errorInfo property (value is an ErrorInfo object) `payload:{ errorInfo:{@link uvpjs.ErrorInfo}}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} RESOURCE_END - Event dispatched by the Resource Playlist Manager every time a Resource Provider has ended playback. The `payload:{rco:rcoObject, playlistLength:Integer}` contains an rco which is the simple Resource Config Object that just ended and playlistLength which is the number of un-played Resource Config Objects remaining in the playlist.
     * @property {String} RESOURCE_START - Event dispatched by the Resource Playlist Manager every time a Resource Provider has commenced playback. The `payload:{rco:ResourceConfigObject seed}` is the simple Resource Config Object provided by the page to initialize the Resource Provider.
     * @property {String} VIDEO_CUEPOINT - Dispatched when an ID3 tag is encoutnered with a recognized owner id
     * @property {String} VIDEO_DONE - Event dispatched when playback of content and ad video has completed. The **payload** is an empty object `payload: {}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} VIDEO_LOADING - Event dispatched during download of video content. The **payload** object has a property `{loaded: <IntAmountLoaded>}` dataObj = {bufferLength: <IntAmountLoaded>, duration: <IntVideoTagDuration>}. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} VIDEO_PLAYBACK_ERROR - Event dispatched when a fatal error occurs during content playback. The `payload` object has the property msg:'error string...' containing the error string. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} VIDEO_PROGRESS - Event dispatched during playback of content and ad videos every 100 milleseconds. The **payload** object has the property `{videoProgressState: {@link contentVideoState}|{@link adVideoState}}`. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * <pre class="prettyprint">
     *  // Example payload for VIDEO_PROGRESS during ad playback.
     *  {
     *      payload: {
     *          isAd: true,
     *          duration: 240,
     *          playbackStarted: true,
     *          playbackComplete: false,
     *          sourceBitrate: 0,
     *          playbackBitrate: 0,
     *          videoFramerate: 0,
     *          isSeeking: false,
     *          isHDStreamLive: false,
     *          isPlayingLive: false,
     *          currentContentSegment: 1,
     *          currentMaxBandwidth: 0,
     *          averageDroppedFPS: 0,
     *          errorInfo: '',
     *          lastSecondCompleted: 0,
     *          lastPercentageCompleted: 0,
     *          currentTime: 100,
     *          bufferLength: 0,
     *          playbackState: {...},
     *          facadeState: {...}
     *      },
     *      target: 'myVideoContainer',
     *      type: 'onAdStart'
     *  }
     * </pre>
     * @property {String} VIDEO_START_ERROR - Event dispatched when a fatal error occurs prior to initiation of playback (typically a resource-related error). The `payload` object has the property msg:'error string...' containing the error string. The **target** is a DOM element ID string `target: <StrVideoContainerId>` .
     * @property {String} VIDEO_STATE_CHANGE - Event dispatched during playback of content and ad videos whenever the playback state changes. The **payload** object has two properties `{newState: {@link uvpjs.mediaCapabilities#PLAYING}, isAd: <Boolean>}`. `newState` is an integer and `isAd` is a boolean which is true if the video is an ad. The **target** is a DOM element ID string `target: <StrVideoContainerId>` . Current playback state can also be obtained by polling {@link uvpjs.VideoControlInterface#getCurrentPlaybackState getCurrentPlaybackState}.
     * @property {String} VIDEO_TRANSITION_START - Event dispatched when a dynamic transition from one stream to another stream (of a different bitrate) is attempted. The `payload:{index:<Number>, mode:<auto|manual>}` object for an event of this type is the index of the array that contains the information for the stream being switched to and the current switching mode (based on the `useDynamicSwitching` model property, which can have a value of 'auto' : 'manual').
     * <pre class="prettyprint">
     *  // Example payload for VIDEO_TRANSITION_START and VIDEO_TRANSITION_END events.
     *  {
     *      index: 5,
     *      mode: "auto"
     *  }
     * </pre>
     * @property {String} VIDEO_TRANSITION_COMPLETE - Event dispatched when a dynamic transition from one stream to another stream (of a different bitrate) has completed. The `payload:{index:<Number>, mode:<auto|manual>}` object for an event of this type is the index of the array that contains the information for the stream being switched to and the current switching mode (based on the `useDynamicSwitching` model property, which can have a value of 'auto' : 'manual').
     * @public
     */
    EventType: {
        AD_BLOCKED: 'onAdBlocked',
        AD_END: 'onAdEnd',
        AD_ERROR: 'adError',
        AD_CLICK: 'adClick',
        AD_PLUGIN_CONTENT_PAUSE_REQUEST: 'adPluginContentPauseRequest',
        AD_PLUGIN_CONTENT_RESUME_REQUEST: 'adPluginContentResumeRequest',
        AD_POD_START: 'onAdPodStart',
        AD_POD_END: 'onAdPodEnd',
        AD_SKIPPED: 'onAdSkipped', // VTG-326: Deprecating event; now passing `skipped` boolean with AD_END.
        AD_LOADED: 'onAdLoaded',
        AD_REQUEST: 'onAdRequest',
        AD_RESPONSE: 'onAdResponse',
        AD_START: 'onAdStart',
        CAPTIONS_READY: 'onCaptionsReady',
        CAPTIONS_UNAVAILABLE: 'onCaptionsUnavailable',
        CONTAINER_RESIZE: 'containerResize',
        CONTENT_DATA_LOADED: 'onContentDataLoaded',  // replaces 'onPlayerDataLoaded'
        CONTENT_END: 'onContentEnd',
        CONTENT_START: 'onContentStart',
        CONTROL_MUTE: 'controlMute',
        CONTROL_UNMUTE: 'controlUnmute',
        CONTROL_VOLUME_CHANGE: 'controlVolumeChange',
        DIAGNOSTIC_WINDOW_CLOSE_BUTTON: 'diagnosticWindowCloseButton',
        FIRST_GESTURE: 'firstGesture',
        NO_AD_CONTENT: 'onNoAdContent',
        PAUSE_AD_REQUEST: 'pauseAdRequest',
        PAUSE_AD_LOADED: 'pauseAdLoaded',
        PLAYER_INIT: 'playerInit',
        PLAYER_LOADED: 'onPlayerLoaded',     // rep
        PLAYER_START_ERROR: 'playerStartError',
        RESOURCE_END: 'onResourceEnd',       // replaces 'onPlayListEnd'
        RESOURCE_START: 'onResourceStart',   // replaces 'onPlaylistStart'
        VIDEO_CUEPOINT: 'videoCuepoint',
        VIDEO_DONE: 'onVideoDone',
        VIDEO_LOADING: 'onVideoLoading',
        VIDEO_PLAYBACK_ERROR: 'videoPlaybackError',
        VIDEO_PROGRESS: 'onVideoProgress',
        VIDEO_START_ERROR: 'videoStartError',
        VIDEO_STATE_CHANGE: 'onStateChange',
        VIDEO_TRANSITION_START: 'onVideoTransitionStart',
        VIDEO_TRANSITION_COMPLETE: 'onVideoTransitionComplete',
        LEVEL_LOADED: 'onLevelLoaded'
    },

    /**
     * Element ID prefix constants.
     * @typedef {Object} domConstants
     * @property {String} AD_ID_PREFIX -  'ad_',
     * @property {String} AD_LEARNMORE_ID_PREFIX -  'learnMore_',
     * @property {String} CONTENT_ID_PREFIX -  'content_',
     * @property {String} CONTROLS_ID_PREFIX -  'controls_',
     * @property {String} VIDEO_ID_PREFIX -  'video_',
     * @public
    */

    domConstants: {
        AD_ID_PREFIX: 'ad_',
        AD_LEARNMORE_ID_PREFIX: 'learnMore_',
        CAPTIONS_ID_PREFIX: 'cc_',
        CONTENT_ID_PREFIX: 'content_',
        CONTROLS_ID_PREFIX: 'controls_',
        VIDEO_ID_PREFIX: 'video_',
        ID_SELECTOR_PREFIX: '#'
    },

    /**
     * Type object to contain public constants.
     * @typedef {Object} Type
     * @property {Button} Button Skin Manager buttons.
     * @property {Gesture} Gesture User tacking gestures (CAN LEGACY).
     * @property {QOSVendor} QOSVendor QOS Vendor name strings.
     * @public
     */
    Type: {

        /**
         * Button constants to interact with the default skin.
         * @typedef {Object} Button
         * @property {String} FULLSCREEN - Fullscreen button.
         * @property {String} PLAYSTATE - Play and pause button.
         * @property {String} SETTINGS - Settings button.
         * @property {String} CLOSED_CAPTION - Closed captions button.
         * @property {String} VOLUME - Volume button.
         * @public
         */
        Button: {
            FULLSCREEN: 'btn-fullscreen',
            PLAYSTATE: 'btn-playstate',
            SETTINGS: 'btn-settings',
            CLOSED_CAPTION: 'btn-captions',
            VOLUME: 'btn-volume'
        },

        /**
         * User tacking gestures (CAN LEGACY).
         * @typedef {Object} Gesture
         * @property {String} GLOBAL_RESUME - 'globalResume'.
         * @property {String} LOCAL_RESUME - 'localResume'.
         * @property {String} CONT_CANCEL - 'cont_cancel'.
         * @property {String} RELATED_OVERLAY - 'related'.
         * @property {String} RELATED_CLICK_GESTURE - 'related_click'.
         * @property {String} SHARE_OVERLAY - 'share'.
         * @property {String} SHARE_NETWORK_GESTURE - 'share_network'.
         * @property {String} SEND_GESTURE - 'send'.
         * @property {String} EMBED_GESTURE - 'embed'.
         * @property {String} LINK_GESTURE - 'copylink'.
         * @property {String} REPLAY_GESTURE - 'replay'.
         * @property {String} END_CARD_OVERLAY - 'endCard'.
         * @property {String} ERROR_OVERLAY - 'error'.
         * @property {String} RECOMMEND_NOW - 'recommend_now'.
         * @property {String} RECOMMEND_NEXT - 'recommend_next'.
         * @property {String} RECOMMEND_CLOSE - 'recommend_close'.
         * @public
         */
        Gesture: {
            GLOBAL_RESUME: 'globalResume',
            LOCAL_RESUME: 'localResume',
            CONT_CANCEL: 'cont_cancel',
            RELATED_OVERLAY: 'related',
            RELATED_CLICK_GESTURE: 'related_click',
            SHARE_OVERLAY: 'share',
            SHARE_NETWORK_GESTURE: 'share_network',
            SEND_GESTURE: 'send',
            EMBED_GESTURE: 'embed',
            LINK_GESTURE: 'copylink',
            REPLAY_GESTURE: 'replay',
            END_CARD_OVERLAY: 'endCard',
            ERROR_OVERLAY: 'error',
            RECOMMEND_NOW: 'recommend_now',
            RECOMMEND_NEXT: 'recommend_next',
            RECOMMEND_CLOSE: 'recommend_close'
        },

        /**
         * QOS Vendor name strings
         * @typedef {Object} QOSVendor
         * @property {String} CONVIVA -  'conviva',
         * @property {String} AKAMAI -  'akamai',
         * @property {String} MUX -  'mux',
         * @property {String} NPAW - 'npaw'
         * @public
         */

        QOSVendor:{
            CONVIVA: 'conviva',
            AKAMAI: 'akamai',
            MUX: 'mux',
            NPAW: 'npaw'
        }

    },

    // UVP-318
    /**
     * Use Singleton pattern for VideoManager
     * @memberof uvpjs
     * @public
     *
     * @return {uvpjs.VideoManager}
     */
    getVideoManager: function() {
        return uvpjs.VideoManager.getInstance();
    },

    /**
     * Creates and/or returns an object; will create an object hierarchy as needed
     * e.g., supplying 'foo.bar', if neither the objects 'foo' nor 'bar' exist,
     * will result in creation of window.foo = {bar: {}}; the object 'bar' will be returned
     * If 'foo' or 'foo.bar' already exists, only the necessary object(s) are created (i.e., will not
     * overwrite existing objects).
     *
     * This method should be used in the closure/IEF pattern for all object and class creation in uvpjs:
     * @example
     *     (function (obj) {
     *          obj.SomeObject = {
     *              // define methods and properties
     *              // that will be on uvpjs.foo.SomeObject
     *          }
     *     }(uvpjs.register('uvpjs.foo'))); // <<<<-----
     *
     * @memberof uvpjs
     * @param {String}   ns namespace as dot-delimited string
     *
     * @return {Object}
     */
    register: function (ns) {
        var a = ns.split('.'),
            o = window,
            len = a.length, i, n;

        for (i = 0; i < len; i++) {
            n = a[i];
            if (o[n] === undefined) { o[n] = {}; }
            o = o[n];
        }
        return o;
    },

    /**
     * Returns a Class (or object) corresponding to the supplied 'fullyQualifiedClassName' string
     * @example
     *
     *      var d = uvpjs.getClass('uvpjs.view.control.Dialog'); // returns uvpjs.view.control.Dialog
     *      var inst = new d();
     *
     * @memberof hub
     *
     * @param {String} fullyQualifiedClassName
     *
     * @return {Object}
     */
    getClass: function(fullyQualifiedClassName) {
        var a, o, len, path, i, n;

        if ('string' !== typeof fullyQualifiedClassName) {
            return fullyQualifiedClassName;
        }

        a = fullyQualifiedClassName.split('.');
        o = window;
        len = a.length;
        path = '';

        for (i = 0; i < len; i++) {
            n = a[i];
            path += n;
            if (o[n] === undefined) {
                throw new Error('uvpjs.getClass(): ' + path + ' is undefined.');
            }
            if (i < len-1) { path += '.'; }
            o = o[n];
        }
        return o;
    },

    /**
     * Returns an  object corresponding to the supplied 'fullyQualifiedObjectName' string
     * @example
     *
     *      var d = uvpjs.getObject('uvpjs.foo.MyObject'); // returns uvpjs.foo.MyObject
     *
     * @memberof hub
     *
     * @param {String} fullyQualifiedObjectName
     *
     * @return {Object}
     */
    getObject: function(fullyQualifiedObjectName) {
        return uvpjs.getClass(fullyQualifiedObjectName);
    },

};

/*
 Simple JavaScript Inheritance
 By John Resig http://ejohn.org/
 MIT Licensed.
 Also appears in:
 Secrets of the JavaScript Ninja, John Resig (author) Manning Publications Co. 2012 ISBN: 9781933988696

 Minor modifications by doug.loftus@cbsinteractive.com
 */
(function() {
    var initing = false,
    //  test for function serialization and assign RE to check for
    //  a call to _super in a subclass method. Methods that call _super
    //  will have the super method available, otherwise, it's overwritten
        superTest = /xyz/.test(function() { var xyz; xyz = null; }) ? /\b_super\b/ : /.*/;

    this.Class = function() {}; // base Class

    // Create a new Class that inherits from this class
    Class.subClass = function(obj) {
        var _super = this.prototype,
            gfn, proto, v, name;

        // Instantiate a base class (but don't run constructor)
        initing = true;
        proto = new this();
        initing = false;

        // if a _super method exists, preserve it...
        gfn = function(name, fn) {
            return function() {
                //noinspection JSPotentiallyInvalidUsageOfThis
                var tmp = this._super, ret;
                //noinspection JSPotentiallyInvalidUsageOfThis
                this._super = _super[name];
                ret = fn.apply(this, arguments);
                //noinspection JSPotentiallyInvalidUsageOfThis
                this._super = tmp;
                return ret;
            };
        };

        // Copy the properties to new prototype
        // If a function: check if access to _super is needed
        for (name in obj) {
            if (obj.hasOwnProperty(name)) {
                v = obj[name];
                proto[name] = typeof v === 'function' && typeof _super[name] === 'function' && superTest.test(v) ? gfn(name, v) : v;
            }
        }

        // Class ctor (init does actual construction)
        function Class () {
            if(!initing && this.init) {
                this.init.apply(this, arguments);
            }
        }

        Class.prototype = proto;
        Class.prototype.constructor = Class;
        Class.subClass = arguments.callee;
        return Class;
    };
})();

uvpjs.Class = Class;
uvpjs._ = _.noConflict();


(function(obj) {
    obj.b64TestVideo = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAuhtZGF0AUAigKN4SIUtLS0tLS0tLS0tLS0tLS0tLS0tLS0vAAACsAYF//+s3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0OCByMjc5NSBhYWE5YWE4IC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNyAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTE2IGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDM6MHgxMzMgbWU9dW1oIHN1Ym1lPTEwIHBzeT0xIHBzeV9yZD0xLjAwOjAuMDAgbWl4ZWRfcmVmPTEgbWVfcmFuZ2U9MjQgY2hyb21hX21lPTEgdHJlbGxpcz0yIDh4OGRjdD0xIGNxbT0wIGRlYWR6b25lPTIxLDExIGZhc3RfcHNraXA9MSBjaHJvbWFfcXBfb2Zmc2V0PS0yIHRocmVhZHM9MSBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTggYl9weXJhbWlkPTIgYl9hZGFwdD0yIGJfYmlhcz0wIGRpcmVjdD0zIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MiBrZXlpbnQ9MjUwIGtleWludF9taW49MjUgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD02MCByYz1jcmYgbWJ0cmVlPTEgY3JmPTUxLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IGlwX3JhdGlvPTEuNDAgYXE9MToxLjAwAIAAAAAKZYiBAAn/Ix39GwAABOltb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAALwABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAACL3RyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAIgAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAA445AAIAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAACIAAAAAAAEAAAAAAadtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAAC7UAAABkBXHAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAFSbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAABEnN0YmwAAACuc3RzZAAAAAAAAAABAAAAnmF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAgACAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAA4YXZjQwFkAAr/4QAeZ2QACqxyBF+IiP/ABAACRAAAAwGQAABdqDxIlhGAAQAHaOhDgZSyLAAAABBwYXNwAAAAEAAAAAkAAAAYc3R0cwAAAAAAAAABAAAAAQAAAZAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAACwgAAAAEAAAAUc3RjbwAAAAAAAAABAAAATgAAAeR0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAAAC8AAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAAAAAAEAAABAAAAAAFcbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAABWIgAABAAVxwAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAABB21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAAy3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAABWIgAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVAAAAAAAULwAAFC8FgICAAhOIBoCAgAECAAAAGHN0dHMAAAAAAAAAAQAAAAEAAAQAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAABRzdHN6AAAAAAAAAB4AAAABAAAAFHN0Y28AAAAAAAAAAQAAADAAAABidWR0YQAAAFptZXRhAAAAAAAAACFoZGxyAAAAAAAAAABtZGlyYXBwbAAAAAAAAAAAAAAAAC1pbHN0AAAAJal0b28AAAAdZGF0YQAAAAEAAAAATGF2ZjU3LjcxLjEwMA==';

}(uvpjs.register('uvpjs')));
(function (obj) {
    'use strict';

    obj.util = {

        isLocalStorageSupported: null,

        xhrMessages: {
              0: "Request blocked or timed out",
            500: "Server error encountered.",
            404: "Resource not found.",
            403: "Access denied."
        },

        /**
         * @memberof uvpjs.util
         *
         * @returns {string}
         */
        getErrorMessageForXHRStatus: function(status) {
            return (status && this.xhrMessages[status]) || ("XHR status: " + status);
        },

        /**
         * @memberof uvpjs.util
         *
         * @returns {Object}
         */
        getLocationQueryObject: function() {
            return this.objFromQueryStr(window.location.search.substring(1))
        },

        /**
         * @memberof uvpjs.util
         *
         * @returns {Object}
         */
        parseUrl: function (url) {
            var a = document.createElement('a');

            a.href = url;

            return {
                host: a.hostname,
                pathname: a.pathname,
                protocol: a.protocol,
                search: a.search
            };
        },

        /**
         * Returns an object of name:value pairs derived from supplied query string,
         * or if omitted, window.location.search (i.e., deserializes)
         * @memberof uvpjs.util
         *
         * @param {String} qstr
         *
         * @return {Object}
         */
        objFromQueryStr: function(qstr) {
            var str = typeof qstr === 'string' ? qstr : '',
                q = str.indexOf('?') > -1 ? str.split('?')[1] : str,
                vars = q.split('&'),
                out = {},
                pair, i, n;

            for (i = 0, n = vars.length; i < n; i++) {
                pair = vars[i].split('=');
                out[pair[0]] = pair[1];
            }

            return out;
        },

        /**
         * Returns a query string assembled from an object (i.e, serializes)
         *
         * @memberof uvpjs.util
         *
         * @param {Object} obj
         * @param {Boolean} encode pass true to use encode values
         * @return {String}
         */
        queryStrFromObj: function(obj, encode) {
            var out = '', pre = false, q;

            for (q in obj) {
                out += (pre ? '&' : '') + q + '=' + (encode ? encodeURIComponent(obj[q]) : obj[q]);
                pre = true;
            }

            return out;
        },

        /**
         * Very lightweight id generator
         * @memberof uvpjs.util
         * @returns {string}
         */
        uid8: function () {
            var s4 = function() {
                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
            };
            return s4() + s4();
        },

        /**
         * @memberof uvpjs.util
         * @returns {string}
         */
        getUserStatusForQuery: function (userStatus) {
            /*	Desktop	Correlation to user state values for Omniture & DW
             sb=0 (anonymous user)	anon
             sb=1 (subscribed user)	reg;sub;pay
             sb=2 (registered user)	reg;
             sb=3 (suspended user)	reg;sub;susp;
             sb=4 (ex- subscriber)	reg;sub;exsub
             sb=5 (subscribed user - trial)	reg; sub; trial
             */

            /*
             user status now can contain multiple packages
             string from desktop looks like this:  'sb|1,sb|8,esb|6'
             final string needs to look like this: 'sb=1,8;esb=6'
             */
            var statusKey = '';

            switch (userStatus) {
                case 'anon':
                    statusKey = 'sb=0';
                    break;
                case 'reg;sub;pay':
                    statusKey = 'sb=1';
                    break;
                case 'reg':
                    statusKey = 'sb=2';
                    break;
                case 'reg;sub;susp':
                    statusKey = 'sb=3';
                    break;
                case 'reg;sub;exsub':
                    statusKey = 'sb=4';
                    break;
                case 'reg;sub;trial':
                    statusKey = 'sb=5';
                    break;
                default:

                    if (userStatus.indexOf('|') > -1) {
                        // complex user status encountered, reformat

                        var elem, keyVal, key, val, i;
                        var curKey = '';
                        var elems = userStatus.split(',');
                        var elemsLength = elems.length;

                        elems.sort(); //make sure buckets are alphabetized

                        for (i = 0; i < elemsLength; i++) {
                            elem = elems[i];
                            keyVal = elem.split('|');

                            if (keyVal.length != 2) {
                                continue;
                            }

                            key = keyVal[0];
                            val = keyVal[1];

                            if (curKey != key) {
                                if (statusKey.length > 0) {
                                    statusKey += '&';
                                }
                                statusKey += key + '=' + val;
                            }
                            else {
                                statusKey += ',' + val;
                            }

                            curKey = key;
                        }

                    }
            }

            // VTG-55; default to 'anon' (sb=0) if userStatus is empty
            if (statusKey == '') {
                statusKey = 'sb=0';
            }

            return statusKey;
        },

        /**
         * Returns first argument that's an integer. Useful when `0` is a
         * valid value but would otherwise fail a "truthy" check.
         *
         * @returns {Integer} First integer.
         */
        firstInt: function () {
            var n = arguments.length, arg, i;

            for (i = 0; i < n; i++) {
                arg = arguments[i];
                if (parseInt(arg) === arg) {
                    return arg;
                }
            }
        },

        /**
         * Check if value is in range, including upper and lower bounds.
         *
         * @param {Number} value Value to check against.
         * @param {Number} lower Includes lower limit.
         * @param {Number} upper Includes upper limit.
         *
         * @return {Boolean}
         *
         * @memberof uvpjs.util
         */
        inRange: function (value, lower, upper) {
            return typeof value === 'number' && value >= lower && value <= upper;
        },

        /**
         * Check for empty type.
         *
         * @param {*} o Type to check.
         *
         * @return {Boolean}
         *
         * @memberof uvpjs.util
         */
        isEmpty: function (o) {
            return (
                o === null ||
                o === undefined ||
                (Array.isArray(o) && o.length === 0) ||
                'object' === typeof o && Object.keys(o).length === 0 ||
                'string' === typeof o && o === ''
            );
        },

        /**
         * Returns true if supplied arg is a 'plain' object (not null, array, or class instance)
         *
         * @param {*} obj
         *
         * @return {Boolean}
         */
        isPlainObject: function(obj) {
            return obj && 'object' === typeof obj && obj.constructor === Object;
        },

        /**
         * Returns true if the passed argument is a function
         * @param a
         * @returns {boolean}
         */
        isFunction: function(a) {
            return 'function' === typeof a;
        },

        /**
         * Check if value is non-empty string.
         *
         * @param {String} s String to check.
         *
         * @return {Boolean}
         *
         * @memberof uvpjs.util
         */
        isDefinedString: function (s) {
            return !!(s && typeof s === 'string' && s.length > 0);
        },

        /**
         * Check if value is a number
         *
         * @param {*} n Type to check.
         *
         * @return {Boolean}
         *
         * @memberof uvpjs.util
         */
        isNumber: function (n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        },

        /**
         * Returns TRUE if val intended to be a flag has value consistent with 'true'
         * @memberof uvpjs.util
         *
         * @param {*} val
         *
         * @return {Boolean}
         */
        isFlagTrue: function(val) {
            return val === true || val === 'true' || val === 1 || val === '1';
        },

        /**
         * Returns first argument that's a defined string.
         *
         * @param {...*} Built-in arguments object.
         *
         * @returns {String} First defined string or empty string.
         */
        getDefinedString: function () {
            var n = arguments.length,
                arg, i;

            for (i = 0; i < n; i++) {
                arg = arguments[i];

                if (this.isDefinedString(arg)) {
                    return arg;
                }
            }

            return '';
        },

        /**
         * Determine if local storage is supported.
         *
         * @return {Boolean} true if local storage is supported.
         *
         * @memberof uvpjs.util
         */
        supportsLocalStorage: function() {
            var testKey = 'test', val;

            if (this.isLocalStorageSupported === null) {
                try {
                    localStorage.setItem(testKey, '1');
                    val = localStorage.getItem(testKey);
                    this.isLocalStorageSupported = val === '1';
                    localStorage.removeItem(testKey);
                }
                catch (e)  {
                    this.isLocalStorageSupported = false;
                }
            }

            return this.isLocalStorageSupported;
        },

        /**
         * @param {String} HTML representing a single element
         *
         * @return {Element}
         *
         * @memberof uvpjs.util
         */
        htmlToElement: function(html) {
            var div = document.createElement('div');
            div.innerHTML = html;
            return div.firstChild;
        },

        /**
         * Add a stylesheet to the DOM.
         *
         * @param {Function} cb Callback function when stylesheet added to DOM.
         * @param {String} path Path to a CSS file (optional).
         *
         * @memberof uvpjs.util
         */
        createStyleSheet: function (cb, path) {
            var ss = document.styleSheets,
                len = ss.length,
                i, hasPath, isFF, elType, styleEl, state,
                href, intvl, ffIntvl, func, cbDone;

            // Execute callback with stylesheet as parameter.
            func = function () {
                if (!cbDone) {
                    cb(styleEl);
                    cbDone = true;
                }
            };

            // Check if CSS already on the page.
            for (i = 0; i < len; i++) {
                styleEl = ss[i];

                // VTG-355 Catch Firefox permission error.
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Property_access_denied
                try {
                    href = styleEl.href && styleEl.href.replace(/http(s)?:/, '');

                    if (href === path) {
                        func();
                        return;
                    }
                } catch(e) {
                    href = null;
                }
            }

            hasPath = typeof path === 'string' && path !== '';
            isFF = uvpjs.mediaCapabilities.isFirefox();
            elType = (!hasPath || isFF) ? 'style' : 'link';

            styleEl = document.createElement(elType);
            styleEl.setAttribute('type', 'text/css');
            styleEl.appendChild(document.createTextNode('')); // WebKit.

            if (hasPath) {
                styleEl.setAttribute('rel', 'stylesheet');
                styleEl.setAttribute('href', path);
                styleEl.textContent = '@import "' + path + '"';
            }

            if (typeof cb !== 'function') {
                return;
            }

            // The following is a cross-browser approach to determine when the
            // CSS has officially loaded onto the page.
            //
            // See more: http://www.phpied.com/when-is-a-stylesheet-really-loaded/

            // First, attempt to listen to the onload event.
            styleEl.onload = func;

            // Second, listen to the load event.
            if (styleEl.addEventListener) {
                styleEl.addEventListener('load', func, false);
            }

            // Third, listen to the onreadystatechange event.
            styleEl.onreadystatechange = function () {
                state = styleEl.readyState;
                if (state === 'loaded' || state === 'complete') {
                    link.onreadystatechange = null;
                    func();
                }
            };

            // Fourth, detect new CSS in the DOM.
            intvl = setInterval(function () {
                // Firefox changes the length prematurely.
                if (document.styleSheets.length > len) {
                    func();
                    clearInterval(intvl);
                }
            }, 10);

            // Fifth, special case for Firefox for detecting new CSS in the DOM.
            if (isFF) {
                ffIntvl = setInterval(function () {
                    try {
                        styleEl.sheet.cssRules; // Only populated when file is loaded
                        clearInterval(ffIntvl);
                        func();
                    } catch (e) {
                        // console.warn('Error trying to load CSS in Firefox.', e);
                    }
                }, 10);
            }

            // Finally, start loading the CSS to the page.
            document.getElementsByTagName('head')[0].appendChild(styleEl);
        },

        /**
         * Construct selector and append styles to passed-in stylesheet.
         *
         * @example Usage
         *  uvpjs.util.addCSSObject(
         *      styleEl,
         *      htmlEl,
         *      {
         *          'font-size': '12px',
         *          'font-weight': 'bold',
         *          'padding': '10px',
         *      },
         *      '.class-name'
         *  );
         *
         * @param {HTMLElement} styleEl HTML <style> element.
         * @param {HTMLElement} el      HTML element applying style to or within.
         * @param {Object}      obj     CSS object; key-value pairs.
         * @param {String}      sel     Additional CSS selector; optional.
         *
         * @memberof uvpjs.util
         *
         * @private
         */
        addCSSObject: function (styleEl, el, obj, sel) {
            var u = uvpjs.util,
                selector = '#' + el.id + ' ' + (sel || ''),
                key;

            for (key in obj) {
                u.addCSSRule(styleEl, selector, key, obj[key]);
            }
        },

        // OPTIMIZE: Create rule cache to update selectors instead of appending.
        /**
         * Dyncamially insert one CSS style onto the page.
         *
         * @param {HTMLElement} styleEl     HTML <style> element.
         * @param {String}      selector    CSS selector.
         * @param {String}      name        CSS rule name.
         * @param {String}      value       CSS rule value.
         *
         * @memberof uvpjs.util
         *
         * @private
         */
        addCSSRule: function (styleEl, selector, name, value) {
            var sheet, rules, ruleCount, rule;

            if (!styleEl) {
                return;
            }

            sheet = styleEl.sheet;
            rules = (sheet.rules || sheet.cssRules);
            ruleCount = rules.length;
            rule = name + ':' + value;

            // Standard method; IE 9 and above.
            if (sheet.insertRule) {
                sheet.insertRule(selector + '{' + rule + '}', ruleCount);
            }
            // Non-standard method; below IE 9.
            else if (sheet.addRule) {
                sheet.addRule(selector, rule, ruleCount);
            }
        },

        /**
         * Dyncamially insert CSS style onto the page from an array of
         * key-value rule pairs.
         *
         * @param {HTMLElement} styleEl     HTML <style> element.
         * @param {String}      selector    CSS selector.
         * @param {Array}       items       Array of CSS name-value pair objects.
         *
         * @memberof uvpjs.util
         *
         * @private
         */
        addCSSRules: function (styleEl, selector, items) {
            var i = items.length,
                item;

            while (i--) {
                item = items[i];
                uvpjs.util.addCSSRule(styleEl, selector, item.name, item.value)
            }
        },

        /**
         * Copies object properties according to the specified key map.
         *
         * Sample usage:
         *   copyObjectWithKeyMap(keyMap).from(objectA).to(objectB);
         *
         * keyMap should be an object containing the key mapping to be copied.
         *
         * For example:
         *   keyMap = {contentOwner: 'ns_st_pu', programTitle: 'ns_st_pr'};
         *   objectA = {contentOwner: 'CBSSports', programTitle: 'Highlights'};
         *   objectB = {ns_st_ge: 'Sports'};
         *
         * Will produce th following object:
         *   {ns_st_pu: 'CBSSports', ns_st_pr: 'Highlights', ns_st_ge: 'Sports'}
         *
         * @param {Object} keyMap map of properties to copy.
         * @returns {Object}
         * @memberof uvpjs.util
         */
        copyObjectWithKeyMap: function (keyMap) {
            var map = keyMap,
                from = null;

            this.from = function(source) {
                from = source;
                return this;
            };

            this.to = function(destination) {
                if (!(map && from && destination)) {
                    return destination;
                }

                for (var key in map) {
                    if (map.hasOwnProperty(key) && from.hasOwnProperty(key) && from[key] !== null) {
                        destination[map[key]] = from[key];
                    }
                }

                return destination;
            };

            return this;
        }
    };

}(uvpjs.register('uvpjs')));


(function (obj) {

    var _ = uvpjs._,
        re = {
            mediaRefId: /\{mediaReferenceId}/g,
            partner: /PARTNER/g,
            ptype: /\{ptype}/g,
            vguid: /\{VGUID}/g,
            ptypeAlt: /%7Bptype%7D/g,
            vguidAlt: /%7BVGUID%7D/g,
            session: /;/g
        };


    obj.adUtil = {

        /////////////////////
        // Public

        MOAT_PARTNER_CODE: 'cbsiimajsint708425247896',

        // DFP contexts are specified using these constants
        // for methods that require a context;
        context: {
            IMA: 'ima',
            DAI: 'dai'
        },

        vpaidEvents: [
            'AdImpression',         // 0
            'AdLoaded',             // 1
            "AdStopped",            // 2
            "AdVideoStart",         // 3
            "AdVideoFirstQuartile", // 4
            "AdVideoMidpoint",      // 5
            "AdVideoThirdQuartile", // 6
            "AdVideoComplete",      // 7
            "AdPaused",             // 8
            "AdPlaying",            // 9
            'AdSkipped',            // 10
            "AdVolumeChange"        // 11
        ],

        // values are indices of vpaidEvents
        moatEventMapping: {
            ima: {
                start: 3,
                firstquartile: 4,
                midpoint: 5,
                thirdquartile: 6,
                complete: 7,
                pause: 8,
                resume: 9,
                skip: 10,
                volumeChange: 11,
                mute: 11
            },
            dai: {
                started: 3,
                firstquartile: 4,
                midpoint: 5,
                thirdquartile: 6,
                complete: 7,
                controlPause: 8,
                controlPlay: 9,
                controlVolumeSet: 11,
                controlMute: 11,
                controlUnmute: 11
            }
        },

        /**
         * @memberof uvpjs.adUtil
         *
         * @param {String} url the ad url template
         * @param {uvpjs.CVI_Model} mdl
         * @param {Boolean} isContentScenario i.e., not ad-only
         * @param {Boolean} cpAB a/b test flag being sent by cbs.com via rco
         * // TODO need a  better solution for A/B cases than hard-coding into core code
         */
        populateImaAdCallValues: function (url, mdl, isContentScenario, cpAB) {
            var u = uvpjs.util,
                custp = 'cust_params',
                uspl = url.split('?'),
                qs = uspl[1],
                useAltRe = url.indexOf('{ptype}') > -1,
                mdlAdParams = this.getAdParams(mdl, isContentScenario, cpAB),
                urlCustParamObj, qo, urlCustParams, mdlCp, qObj, cpObj, qstr, cpstr;

            // 1) Replace tokens in supplied query string with model values
            qs = qs.replace(re.mediaRefId, mdlAdParams.vid)
                   .replace(re.partner, mdlAdParams.partner);

            if (qs.indexOf('VGUID') > -1) {
                qs = qs.replace(useAltRe ? re.vguidAlt : re.vguid, mdlAdParams.vguid);
            }
            qs = qs.replace(useAltRe ? re.ptypeAlt : re.ptype, mdlAdParams.ptype);

            // 2) Convert supplied (substituted) query string to object
            qo = u.objFromQueryStr(qs);

            // VTG-454; if isExcluded...(), delete any existing 'pp' param in url
            this.isExcludedFromVpaid(mdl) && delete qo.pp;

            urlCustParams = qo[custp];

            // 3) If custom params exist in object created above, deserialize custom params
            if (urlCustParams) {
                urlCustParamObj = u.objFromQueryStr(decodeURIComponent(urlCustParams));
                delete qo[custp];
            }

            // 4) Cache model-derived custom params
            mdlCp = mdlAdParams[custp];

            // 5) Delete properties no longer needed in object
            delete mdlAdParams[custp];
            delete mdlAdParams.partner;
            delete mdlAdParams.vguid;
            delete mdlAdParams.ptype;

            // 6) merge model values into objects, then remove any null or  '' vals
            qObj = _.assign(mdlAdParams, qo); // base query object
            cpObj = _.assign(mdlCp, urlCustParamObj || {}); // custom param object

            // VTG-551; sz mod for ad inventory permitted to be muted
            mdl.contentVideoState.isMuteAtPlayStart && (qObj.sz = '640x483');

            this.removeEmpty(qObj);
            this.removeEmpty(cpObj);

            // 7) serialize merged objects
            qstr = u.queryStrFromObj(qObj, false);
            cpstr = u.queryStrFromObj(cpObj, false);

            // 8) assemble final url
            qstr += '&' + custp + "=" + encodeURIComponent(cpstr);

            return uspl[0] + '?' + qstr;
        },

        /**
         * @memberOf uvpjs.adUtil
         *
         * @param {uvpjs.CVI_Model} mdl CVI model
         * @param {Boolean} isContentScenario if content will be played (not 'ad-only')
         * @param {Boolean|String} cpAB a/b test flag being sent by cbs.com via rco
         * // TODO need a  better solution for A/B cases than hard-coding into core code
         * @return {Object}
         */
        getAdParams: function (mdl, isContentScenario, cpAB) {
            var dwp = mdl.dwPageParams,
                viewGuid = this.getDwViewGuid(mdl),
                ppidVal = this.getPpidValue(mdl),
                cvs = mdl.contentVideoState,
                partner =  encodeURIComponent(mdl.sessionOptions.partner),
                pgType = dwp.pagetype || '',
                userStatusKeyVal = this.getUserStatusKey(mdl.getSessionOption('userStatus')),
                contPlayState = cvs.contPlayState !== '',
                playStateVal = contPlayState && !uvpjs.util.isFlagTrue(cpAB) ? '1' : '0',
                isEmbedValue = mdl.getSessionOption('isEmbedded') ? '1' : '0',
                host = this.getHost(isEmbedValue === '1', mdl),
                pid = cvs.pid,
                p = {cust_params: {}},
                env = uvpjs.Configuration.env,
                cmsRefGuid, q;

            cmsRefGuid = isContentScenario ? cvs.cmsRefGuid : '';

            p.vid = cmsRefGuid;
            p.partner = partner;
            p.ptype = pgType;
            p.vguid = viewGuid;

            p.cust_params.vguid = viewGuid;
            p.cust_params.embed = isEmbedValue;
            host && (p.cust_params.host = host);

            this.populateCustParamsWithAdSessionValues(p.cust_params, pid);

            if (cvs.podsToSkip.length > 0) {
                p.cust_params.resume = 1;
                p.cust_params.skippod = cvs.podsToSkip;
            }

            for (q in userStatusKeyVal) {
                p.cust_params[q] = userStatusKeyVal[q];
            }

            if (ppidVal) {
                p.ppid = ppidVal;
                p.cust_params.ppid = ppidVal;
            }

            if (partner === 'cbs') {
                p.cust_params.cpSession = playStateVal;
                p.cust_params.cpPre = playStateVal;
            }

            if (this.isExcludedFromVpaid(mdl)) {
                p.pp = 'ssai';
            }
            else {
                (env === 'local' || env === 'dev') && (p.pp = 'vpaid_js');
            }

            return p;
        },

        /**
         * @private
         * @param {Object} mdl
         * @return {boolean}
         */
        isExcludedFromVpaid: function (mdl) {
            // VTG-454 - applies to CBS ENT VIDEO
            return mdl.contentVideoState.contentType === 'AA Original';
        },

        /**
         * @memberof uvpjs.adUtil
         *
         * @return {string}
         */
        getDwViewGuid: function(mdl) {
            var dwp = mdl.dwPageParams;

            return dwp && dwp.viewguid || dwp.pguid || '';
        },

        /**
         * Primarily used for event payload on ad error
         * @memberof uvpjs.adUtil
         *
         * @param {Object} ad ad object from an IMA-based SDK
         * @param {String} context a uvpjs.adUtil.context constant
         *
         * @return {Object}
         */
        extractAdInfo: function (ad, context) {
            var m = context === this.context.DAI ? "extractAdInfoDai" : "extractAdInfoIma",
                baseObj, contextObj;

            if (uvpjs.util.isEmpty(ad) || !context) {
                !context && console.error("No 'context' arg supplied");
                return null;
            }

            baseObj = {
                adId: ad.getAdId(),
                adSystem: ad.getAdSystem(),
                creativeAdId: ad.getCreativeAdId(),
                creativeId: ad.getCreativeId()
            };
            baseObj.adPodInfo = this.extractPodInfo(ad.getAdPodInfo());

            contextObj = this[m](ad);

            return _.assign(baseObj, contextObj);
        },

        /**
         * Assembles ad state data
         * @memberof uvpjs.adUtil
         *
         * @param {Object} ad ad object from an IMA-based SDK
         * @param {String} context a uvpjs.adUtil.context constant
         *
         * @return {Object}
         */
        extractAdStateData: function(ad, context) {
            var podInfo = ad.getAdPodInfo(),
                podIdx = podInfo.getPodIndex(),
                adPos = podInfo.getAdPosition(),
                adDur = ad.getDuration(),
                adType = podIdx === 0 ? 'pre' : (podIdx >= 1 ? 'mid' : (podIdx === -1 ? 'post' : '')),
                adClipId = (adType !== 'mid' ? adType + '_0' : 'mid_' + podIdx) + '_' + adPos,
                isIma = context === this.context.IMA,
                idInfo = isIma ? this.extractIdInfo(ad) : null,
                out = this.getAdStateBlank();

            out.adPosition = adPos;
            out.adServerName = isIma ? this.context.IMA : this.context.DAI;
            out.adVideoTitle = ad.getTitle();
            out.duration = adDur;
            out.adType = adType;
            out.adClipID = adClipId;
            out.wrapperAdId = isIma ? (idInfo.wrapperAdId || '') : '';
            out.adVideoId = isIma ? (idInfo.wrapperAdId || idInfo.adId) : ad.getAdId();
            out.creativeId = isIma ? (idInfo.wrapperCreativeId || idInfo.creativeId) : ad.getCreativeId();

            if (context === this.context.DAI) {
                out.sourceWidth = ad.getVastMediaWidth();
                out.sourceHeight = ad.getVastMediaHeight();
            }

            return out;
        },

        /**
         * Returns a blank state object
         */
        getAdStateBlank: function() {
            return {
                adPosition: null,
                adServerName: null,
                adVideoTitle: null,
                duration: null,
                adType: null,
                adClipID: null,
                wrapperAdId: null,
                adVideoId: null,
                creativeId: null
            };
        },

        /**
         * @memberof uvpjs.adUtil
         *
         * @param {Object} ad ad object from an IMA-based SDK
         *
         * @return {Object} has both ad and creative ids and wrapper ids, if applicable
         */
        extractIdInfo: function(ad) {
            var waIds = ad.getWrapperAdIds(),
                wcIds = ad.getWrapperCreativeIds(),
                alen = (Array.isArray(waIds) && waIds.length) || 0,
                clen = (Array.isArray(wcIds) && wcIds.length) || 0,
                waId = null,
                wcId = null,
                aId = ad.getAdId() || '',
                cId = ad.getCreativeId() || '';

            if (alen) {
                alen > 1 && (waId = waIds[1]);
                aId = waIds[0];
            }

            if (clen) {
                clen > 1 && (wcId = wcIds[1]);
                cId = wcIds[0];
            }

            return {
                adId: aId,
                wrapperAdId: waId,
                creativeId: cId,
                wrapperCreativeId: wcId
            };
        },

        /**
         * @memberof uvpjs.adUtil
         *
         * @param {Boolean} isEmbed
         * @param {uvpjs.CVI_Model} mdl
         *
         * @return {String|null}
         */
        getHost: function (isEmbed, mdl) {
            var ref, uinfo, host;

            if (isEmbed) {
                ref = mdl.getSessionOption('referrer');
                if (ref) {
                    uinfo = uvpjs.util.parseUrl(ref);
                    host = uinfo.host;
                }
            }
            else {
                host = window.location.hostname;
            }

            return host && host !== '' ? host : null;
        },

        /**
         * Format the userStatus string for ad calls.
         *
         * @memberof uvpjs.adUtil
         *
         * @param {String} userStatus
         *
         * @return {Object} An object with a single name:value pair
         */
        getUserStatusKey: function(userStatus) {
            var str = uvpjs.util.getUserStatusForQuery(userStatus),
                splA = str.split("&"),
                i = splA.length,
                out = {}, splE;

            while (i--) {
                splE = splA[i].split("=");
                out[splE[0]] = splE[1];
            }

            return out;
        },

        // Ad tracking (Moat)
        /**
         * Initiate tracking for an ad play
         * @memberof uvpjs.adUtil
         *
         * @param {Object}          options
         * @param {HTMLElement}     options.adVideoContainer
         * @param {String}          options.context
         * @param {uvpjs.CVI_Model} options.model
         */
        trackAd: function(options) {
            var mdl = options.model,
                context = options.context,
                adData = mdl.getAdVideoState(),
                isIma = context === this.context.IMA,
                isDai = context === this.context.DAI,
                validContext = isIma || isDai,
                ids, pgType, vguid;

            if (!validContext) {
                console.error("Invalid DFP context supplied to method.");
                return;
            }

            pgType = mdl.dwPageParams.pagetype || '';

            ids = {
                level1: '',
                level2: '',
                level3: adData.adVideoId,  // derived from getWrapperAdIds() || getAdId()
                level4: adData.creativeId, // derived from getWrapperCreativeIds() || getCreativeId()
                slicer1: 'vaw-can',
                slicer2: mdl.sessionOptions.partner,
                slicer3: pgType,
                moatVASTSystem: adData.adServerName,
                moatVASTAdID: adData.wrapperAdId
            };

            vguid = this.getDwViewGuid(mdl);
            vguid !== '' && (ids.zMoatVGUID = vguid);

            pgType !== '' && (ids.zMoatPT = pgType);

            return this.initMoatTracking(options.adVideoContainer, ids, adData.duration, this.MOAT_PARTNER_CODE, null);
        },


        /**
         * Track an ad event
         * @memberof uvpjs.adUtil
         *
         * @param {Object} data
         * @param {Object} data.trackingHandle
         * @param {String} data.eventName
         * @param {String} data.context
         * @param {String} data.volume
         */
        trackAdEvent: function(data) {
            var vpe = this.getVpaidEventForEvent(data.eventName, data.context);

            if (!vpe) return;

            data.trackingHandle.dispatchEvent({
                type: vpe,
                adVolume: data.volume
            });
        },

        /**
         * Determine if an ad blocker has been detected,
         *
         * @memberof uvpjs.adUtil
         *
         * @param {uvpjs.CVI_Model} model instance of model
         *
         * @return {Boolean} true if ad blocker is detectable and detected
         */
        checkForAdBlocker: function(model) {
            var callback = model.getSessionOption('adBlockerCallback');

            return callback && callback();
        },


        // End public
        //////////////

        //////////////
        // Private

        /**
         * @memberof uvpjs.adUtil
         *
         * @param {Object} cpobj custom params object
         * @param pid
         */
        populateCustParamsWithAdSessionValues: function (cpobj, pid) {
            var val, obj, q;

            if (typeof window.getVideoAdSessionValues === 'function') {
                val = window.getVideoAdSessionValues(pid);

                if (typeof val === 'string' && val !== '') {
                    val = val.replace(re.session, '&');
                    obj = uvpjs.util.objFromQueryStr(val);
                    for (q in obj) {
                        cpobj[q] = obj[q];
                    }
                }
            }
        },

        /**
         * Modifies supplied object by elimination null or empty ('') vals
         * @memberof uvpjs.adUtil
         *
         * @param {Object} obj
         */
        removeEmpty: function(obj) {
            for (var q in obj) {
                (obj[q] === null || obj[q] === '') && delete obj[q];
            }
        },

        // Extract ad info helpers
        /**
         * @memberof uvpjs.adUtil
         * @private
         *
         * @param {google.ima.Ad} ad
         */
        extractAdInfoIma: function(ad) {
            return {
                contentType: ad.getContentType(),
                isLinear: ad.isLinear()
            };
        },

        /**
         * @memberof uvpjs.adUtil
         * @private
         *
         * @param {google.ima.Ad} ad
         */
        extractAdInfoDai: function(ad) {
            return {
                advertiserName: ad.getAdvertiserName(),
                description: ad.getDescription(),
                duration: ad.getDuration(),
                title: ad.getTitle()
            };
        },

        /**
         * @memberof uvpjs.adUtil
         * @private
         *
         * @param {google.ima.AdPodInfo} pi
         */
        extractPodInfo: function (pi) {
            if (!pi) { return null; }

            return {
                adPosition: pi.getAdPosition(),
                podIndex: pi.getPodIndex(),
                timeOffset: pi.getTimeOffset(),
                totalAds: pi.getTotalAds(),
            };
        },

        /**
         * @memberof uvpjs.adUtil
         * @private
         *
         * @return {string}
         */
        getPpidValue: function(mdl) {
            var uppid = mdl.getSessionOption('userPPID');

            return uvpjs.util.isDefinedString(uppid) ? uppid : null;
        },

        ///////////////////////////////
        // Moat tracking (ad viewability)

        /**
         * This code supplied by Moat, minimally modified here for readability
         * @memberof uvpjs.adUtil
         *
         * @param {HTMLElement} c container ad video element parent node
         * @param {Object}      d ids (includes partner code, etc)
         * @param {Number}      e duration of ad
         * @param {String}      k partner code
         * @param {String}      l url to the video asset used to display the ad
         *
         * @return {Object}    a reference to moat api
         */
        initMoatTracking: function (c, d, e, k, l) {
            var g = document.createElement("script"), a = [],
                f, h, sfx;

            d = {
                adData: { ids: d, duration: e, url: l},
                dispatchEvent: function (b) {
                    this.sendEvent ? (a && (a.push(b), b = a, a = !1), this.sendEvent(b)) : a.push(b);
                }
            };
            sfx = "_moatApi" + Math.floor(1E8 * Math.random());

            try {
                f = c.ownerDocument;
                h = f.defaultView || f.parentWindow;
            }
            catch (b) {
                h = window;
            }

            h[sfx] = d;
            g.type = "text/javascript";
            c && c.insertBefore(g, c.childNodes[0] || null);
            g.src = "https://z.moatads.com/" + k + "/moatvideo.js#" + sfx;

            return d;
        },

        /**
         * @memberof uvpjs.adUtil
         * @private
         *
         * @param {String} name event name
         * @param {String} context dfp context 'ima' or 'dai'
         *
         * @return {String}
         */
        getVpaidEventForEvent: function(name, context) {
            var idx = this.moatEventMapping[context][name];

            if (uvpjs.util.isEmpty(idx)) return null;

            return this.vpaidEvents[idx];
        }
    }

}(uvpjs.register('uvpjs')));

/**
 * This file is auto-generated. Any changes will be overwritten during the build process.
 */

/* jshint ignore:start */
;(function (uvpjs) {

    'use strict';

    uvpjs.Configuration = {"env":"dev","hostname":"../","name":"UVPJS","version":"2.8.3","date":"03/20/18 1:09:27 PM (EDT)","path":"../build/","playerName":"CBSI-PLAYER"};

})(uvpjs);
/* jshint ignore:end */


(function(obj) {

    obj.AutoplayDetectionService = uvpjs.Class.subClass({

        /**
         *
         * @param {Object}                  options
         * @param {uvpjs.MediaCapabilities} options.mediaCapabilities
         * @param {Function}                options.completeCallback invoked when determination is complete
         * @param {uvpjs.MediaCapabilities} options.testVidPath path to test video
         */
        init: function (options) {
            this.mc = options.mediaCapabilities;
            this.completeCallback = options.completeCallback;
            this.testDom = this.createTestDom();
            this.testVidPath = options.testVidPath;

            this.isMobile = this.mc.isMobile();
            this.vidEl = null;

            this.detectCapabilities();
        },

        /**
         * Destroys instance
         * @public
         */
        destroy: function() {
            this.killVid();
            this.testDom && this.testDom.parentNode.removeChild(this.testDom);
            this.testDom = null;
            this.mc = null;
            this.completeCallback = Function.prototype;
        },

        /**
         * @private
         */
        setInfo: function (unmutedOk, mutedOk) {
            this.mc.setAutoplayInfo({
                supportsUnmutedAutoplay: unmutedOk,
                supportsMutedAutoplay: mutedOk
            });
        },

        /**
         * @private
         */
        detectCapabilities: function () {
            this.checkUnmutedAutoplay();
        },

        ///////////////////////////////
        // Promise-based determination:
        // check unmuted, then muted autoplayplay in succession

        /**
         *
         * @param {Boolean} unmutedOk  true indicates unmuted playback is supported
         * @param {Boolean} mutedOk    true indicates muted playback is suppported
         */
        finishCheck: function(unmutedOk, mutedOk) {
            this.killVid();
            this.setInfo(unmutedOk, mutedOk);
            setTimeout(this.completeCallback, 2); // make promise immune to downstream exceptions
        },

        /**
         * Check for general (un-muted) autoplay; if this passes, muted autoplay is supported as well
         * If it fails, it will kick off a test for muted autoplay.
         * @private
         */
        checkUnmutedAutoplay: function () {
            var promise, v;

            this.vidEl = v = this.createVideoElement(false);

            v.load();
            promise = v.play();

            if (promise === undefined) {
                if (this.isMobile) {
                    this.detectMobileCapabilities();
                }
                else {
                    this.finishCheck(true, true);
                }
            }
            else {
                promise
                    .then(
                        this.finishCheck.bind(this, true, true)
                    )
                    .catch(
                        this.checkMutedAutoplay.bind(this)
                    );
            }
        },

        /**
         * Check for muted autoplay
         * @private
         */
        checkMutedAutoplay: function() {
            var promise, v;

            this.killVid();
            this.vidEl = v = this.createVideoElement(true);

            v.load();
            promise = v.play();

            promise
                .then(
                    this.finishCheck.bind(this, false, true)
                )
                .catch(
                    this.finishCheck.bind(this, false, false)
                );
        },

        /**
         * @private
         */
        killVid: function () {
            if (this.vidEl) {
                this.vidEl.pause();
                this.vidEl.removeAttribute('src');
                this.testDom && this.testDom.removeChild(this.vidEl);
                this.vidEl = null;
            }
        },

        ////////////
        // mobile

        /**
         * @private
         */
        detectMobileCapabilities: function () {
            var unmutedOk = false,
                mutedOk = this.isAutoplayEligibleAndroid() || this.isAutoplayEligibleIos();

            this.finishCheck(unmutedOk, mutedOk);
        },

        /**
         * Returns TRUE if device/browser combo supports autoplay
         * @private
         *
         * @return {Boolean}
         */
        isAutoplayEligibleAndroid: function() {
            var isA = this.mc.isAndroid(),
                isOkChrome = isA && this.mc.isChrome() && this.isChromeAutoplayEligible();

            return isOkChrome;
        },

        /**
         * Returns TRUE if device/browser combo supports autoplay
         * @return {boolean}
         */
        isAutoplayEligibleIos: function() {
            var is10 = this.mc.isIOSTen(),
                isOkSafari = is10 && this.mc.isSafari(),
                isOkChrome = is10 && !isOkSafari && this.mc.isChrome() && this.isChromeAutoplayEligible();

            return isOkSafari || isOkChrome;
        },

        /**
         * Returns TRUE if Chrome version is autoplay compatible
         * @return {Boolean}
         */
        isChromeAutoplayEligible: function() {
            // Variously reported as v53 and v54; using 54 for safety
            return parseInt(this.mc.getBrowserMajorVersion()) >= 54;
        },

        /////////////
        // dom util
        /**
         * @private
         *
         * @return {Element}
         */
        createVideoElement: function(muted) {
            var v = document.createElement('video');

            if (muted) {
                v.muted = true;
                v.setAttribute('muted', 'muted');
            }

            this.mc.setVideoForInlinePlay(v, true);

            v.volume = 0.005;
            v.style.width = '100%';
            v.style.height = '100%';

            v.src = this.testVidPath;

            this.testDom.appendChild(v);

            return v;
        },

        /**
         * @private
         *
         * @return {Element}
         */
        createTestDom: function() {
            var d = document.createElement('div'),
                ds = d.style, p = '-1000px';

            ds.position = 'absolute';
            ds.top = p;
            ds.left = p;
            ds.width = '320px';
            ds.height = '180px';

            document.body.appendChild(d);

            return d;
        }

    });

}(uvpjs.register('uvpjs')));
/* CBSi uvpjs: client-side JS */
'use strict';

/**
 * @constructor uvpjs.MediaCapabilities
 * @description Detects media, browser, platform and device capabilities.
 * @extends uvpjs
 */

 /**
  * Constants that can be accessed by calling `uvpjs.mediaCapabilities.<constant>`. See example below.
  * @typedef {Object} mediaCapabilities
  * @interface
  * @example
  * // Create a Resource Config Object (RCO).
  * var resourceConfigObject = cbsiVideoManager.createResourceConfig({
  *     videoTitle: 'Big Buck Bunny',
  *     vidContId: 'cbsiVideoContainer'
  *     type: uvpjs.mediaCapabilities.RP_URL,
  *     url: 'http://vtstage.cbsinteractive.com/html5/media/mp4/BigBuckBunny.mp4',
  * });
  * @property {Constant} PLATFORM    - Used to identify the `cms` session option. Value is the string `platform`.
  * @property {Constant} RP_URL      - A Resource Provider (RP) type passsed into the `type` property of a Resource Config Object (RCO). Value is the string `rp_url`.
  * @property {Constant} RP_DAI      - DAI Resource Provider (RP) type passsed into the `type` property of a Resource Config Object (RCO). Value is the string `rp_dai`.
  * @property {Constant} RP_IMA      - IMA Resource Provider (RP) type passsed into the `type` property of a Resource Config Object (RCO). Value is the string `rp_ima`.
  * @property {Constant} RP_MDIALOG  - A Resource Provider (RP) type passsed into the `type` property of a Resource Config Object (RCO). Value is the string `rp_mDialog`.
  * @property {Constant} RP_PLATFORM - A Resource Provider (RP) type passsed into the `type` property of a Resource Config Object (RCO). Value is the string `rp_platform`.
  * @public
  */

uvpjs.MediaCapabilities = (function() {

    var _ = uvpjs._;
    var _uuid = uuid.noConflict();

    var _strictCodecDetection = false,       // strictly detect mp4, h264, aac, etc codecs instead of narrowing to specific CBSi codecs.

        _userAgent,                         // contains navigator or manual user agent string
        _overrideUserAgent,                 // (true/false) indicates if navigator user agent was overrriden
        _mimeTypesObj,                      // standard mimeTypes object returned from navigator.mimeTypes.
        _mimeTypes,                         // mimeTypes organized in an object structure.

        _videoTagRef,                       // an HTMLVideoElement used for detection.
        _audioTagRef,                       // an HTMLAudioElement used for detection.

        _device,                            // the device string. One of the device type constants above.
        _platform,                          // platform can be one of the platform or OS constants above (MAC, WiNDOWS, LINUX, CHROMEOS
        _os,                                // the operating system; one of the OS constants above
        _osVersion,                         // the numeric operating system value

        _isDesktop,                         // true/false; is the detected device a desktop machine (desktop, laptop, computer, etc)
        _isConsole = false,                 // true/false; is device some kind of console; not yet implemented yet
        _isOTT = false,                     // true/false; is device an OTT device; not yet implemented yet

        _browserName,                       // the name of the browser, one of the browser constants above (ie CHROME, FIREFOX, etc
        _browserVersion,                    // the numeric browser version
        _browserMajorVersion,               // the major browser version (ex Firefox 34.343.2111 is 34)

        _fullscreenEventName,               // String: holds the fullscreen event name based on the browser type;
                                            // fullscreen event names: "webkitfullscreenchange", "mozfullscreenchange", "msfullscreenchange", "fullscreenchange"

        _isSecure = false;                  // true/false; is device loaded over HTTPS

    // preparing object to be returned in IIFE. having an object allows the private members to work with data locally before returning obj.
    var obj = {
        // FYI: constants are put on top so you can use them immediately if you want to initialize a variable.

        // PLAYBACK STATE CONSTANTS
        EMPTY:                              -2,     // no video is loaded into an element. the element is empty.
        LOADING:                            -1,     // the video element is loading or intialized loading
        STOPPED:                            0,      // the video is stopped (ended state). Better to say stopped than ended IMO.
        PLAYING:                            1,      // the video is playing
        PAUSED:                             2,      // the video is paused
        BUFFERING:                          3,      // the video is buffering
        DATA_LOADING_ERROR_STATE:           130,
        VIDEO_NOT_AVAILABLE_ERROR_STATE:    110,
        GEO_BLOCK_ERROR_STATE:              120,

        // RESOURCE PROVIDER TYPES
        RP_URL:'rp_url',
        RP_DAI:'rp_dai',
        RP_IMA:'rp_ima',
        RP_MDIALOG:'rp_mDialog',
        RP_PLATFORM:'rp_platform',

        // FACADE TYPES
        HTML5:                              'HTML5',
        HLSJS:                              'HLSJS',
        DASHJS:                             'DASHJS',
        FLASH_HLS:                          'FLASH-HLS',

        PLATFORM: 'platform', // Used for the CMS key in the CVI Model.
        IMA: 'ima',

        // Blank video urls
        PLACEHOLDER_M3U8_URL:              '//vidtech.cbsinteractive.com/h5/blanks/blank.m3u8', // only used for iOS
        PLACEHOLDER_MP4_URL:                uvpjs.b64TestVideo, // '//vidtech.cbsinteractive.com/h5/blanks/uvp_blank.mp4',
        MP4_BLANK_FILE:                     '//vidtech.cbsinteractive.com/h5/blanks/uvp_blank.mp4',
        // Dynamic variant playlist.
        PLATFORM_OUTLET_ACCOUNT_ID:           'dJ5BDC',
        CAN_DYNAMIC_VARIANT_SERVICE_BASE_URL: 'http://can.cbs.com/thunder/player/videoManifest.php?assetType=HLS&authn=',

        // JAVASCRIPT OBJECT TYPE CONSTANTS
        STRING:                             'string',
        OBJECT:                             'object',
        BOOLEAN:                            'boolean',
        FUNCTION:                           'function',

        // PLATFORM CONSTANTS
        MAC:                                'Macintosh',
        WINDOWS:                            'Windows',
        LINUX:                              'Linux',

        /// OPERATING SYSTEM CONSTANTS
        OSX:                                'OS X',
        WINDOWS7:                           'Windows 7',
        WINDOWS8:                           'Windows 8',
        WINDOWS10:                          'Windows 10',
        WINDOWS_VISTA:                      'Windows Vista',
        IOS:                                'iOS',
        ANDROID:                            'Android',
        CHROMEOS:                           'CrOS',

        // DEVICE TYPE CONSTANTS
        PHONE:                              'Phone',
        TABLE:                              'Tablet',
        DESKTOP:                            'Desktop',
        IPHONE:                             'iPhone',
        IPAD:                               'iPad',
        IPOD:                               'iPod',
        ANDROID_PHONE:                      'Android Phone',
        ANDROID_TABLET:                     'Android Tablet',
        WINDOWS_PHONE:                      'Windows Phone',
        WINDOWS_TABLET:                     'Windows Tablet',

        // BROWSER TYPE CONSTANTS
        CHROME:                             'Chrome',
        FIREFOX:                            'Firefox',
        SAFARI:                             'Safari',
        IE:                                 'IE',
        EDGE:                               'Edge',
        OPERA:                              'Opera',
        OPERA_MOBILE:                       'Opera Mobile',
        ANDROID_BROWSER:                    'Android Browser',
        CHROMECAST:                         'Chromecast',
        AMAZON_KINDLE:                      'Silk',
        CHROMECAST_USER_AGENT:              'CrKey',
        PLAYSTATION:                        'Playstation',

        //  DELIVERY TYPE CONSTANTS
        PROGRESSIVE:                       'progressive',
        STREAMING:                         'streaming',

        // MISC CONSTANTS
        IOS_INLINE_PLAY_ATTRIBUTE:         'playsinline',

        // RENDERING ENGINES: (haven't proven to be useful detrection at this time.
        /*
         TRIDENT: 'Trident',
         GECKO: 'Gecko',
         BLINK: 'Blink',
         WEBKIT: 'WebKit',
         PRESTO: 'Presto',
         */

        // AUDIO/VIDEO ELEMENT CONSTANTS
        VIDEO: 'video',
        AUDIO: 'audio',
        PROBABLY: 'probably',
        MAYBE: 'maybe',
        MP4: 'mp4',
        M3U: 'm3u',
        MP3: 'mp3',
        MPD: 'mpd',
        MT_MP4: 'video/mp4',

        hasMse: null,
        systemInfo: {
            browser: null,
            version: null,
            isMobile: null,
            isDesktop: null,
            os: null,
            supportsMse: null,
            isHlsjsEligible: null,
            supportsNativeHls: null,
            supportsMp4: null,
            supportsDash: null,
            supportsUnmutedAutoplay: null,
            supportsMutedAutoplay: null
        },

        apDetectionService: null,

        /**
         * does initial detection based on user agent (browser, device, platform, etc.
         * @memberof uvpjs.MediaCapabilities
         * @param {Object} strictCodecDetection - strict mode uses codecs and 'probably' and 'maybe' for media type detection
         * @param {String} overrideUserAgent - manually pass in a user agent string for manual detection.
         * @returns {Object} returns the parent object for immediate use.
         */

        _detectEnvironment: function (overrideUserAgent, strictCodecDetection) {
            var si = this.systemInfo;

            if (typeof overrideUserAgent === this.STRING) {
                _userAgent = overrideUserAgent;
                _overrideUserAgent = true;
            } else {
                _userAgent = navigator.userAgent || null;
                _overrideUserAgent = false;
            }

            _videoTagRef = document.createElement(this.VIDEO);
            _audioTagRef = document.createElement(this.AUDIO);

            if (typeof strictCodecDetection === this.BOOLEAN) {
                _strictCodecDetection = strictCodecDetection; // strictly detect mp4, h264, aac, etc codecs instead of narrowing to specific CBSi codecs.
            }

            _detectPlatform();
            _detectBrowser();
            _detectFullscreenType();

            // Set protocol
            _isSecure = location.protocol === 'https:';

            si.browser = this.getBrowserName();
            si.version = parseInt(this.getBrowserMajorVersion());
            si.isMobile = this.isMobile();
            si.isDesktop = this.isDesktop();
            si.os = this.getOS() + "; ver. " + this.getOSVersion();
            si.supportsMse = this.hasMediaSourceSupport();
            si.isHlsjsEligible = this.canPlayHLSJS();
            si.supportsNativeHls = this.canPlayNativeHLS();
            si.supportsMp4 = this.canPlayH264();
            si.supportsDash = this.canPlayDASH();

            // We have an issue with Firefox 56 on Win; (won't use a data
            // url for video element). For safety; all Firefox 56 and below
            // will revert to loading the asset file, as was donw prior to 2.8.0
            if (this.checkBrowserName(this.FIREFOX) && si.version <= 56) {
                this.PLACEHOLDER_MP4_URL = this.MP4_BLANK_FILE;
            }

            // return the parent object for immediate use.
            return this;
        },

        /**
         * Determine autoplay capabilites for this device
         * @memberof uvpjs.MediaCapabilities
         *
         * @param {Function} callback function invoked when autoplay detection completes
         *
         * @private
         */
        determineAutoplayCapabilities: function (callback) {
            var callbackWrapper;

            if (this.systemInfo.supportsUnmutedAutoplay !== null) {
                callback();

                return;
            }

            callbackWrapper = function() {
                this.apDetectionService && this.apDetectionService.destroy();
                this.apDetectionService = null;
                callback();
            }.bind(this);

            this.apDetectionService = new uvpjs.AutoplayDetectionService({
                mediaCapabilities: this,
                completeCallback: callbackWrapper,
                testVidPath: this.PLACEHOLDER_MP4_URL
            });
        },

        /**
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @param {Object} infoObj object
         * @param {Boolean} infoObj.supportsUnmutedAutoplay
         * @param {Boolean} infoObj.supportsMutedAutoplay
         */
        setAutoplayInfo: function(infoObj) {
            this.systemInfo.supportsUnmutedAutoplay = infoObj.supportsUnmutedAutoplay;
            this.systemInfo.supportsMutedAutoplay = infoObj.supportsMutedAutoplay;
        },

        /**
         * Returns autoplay-related props of sys info
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {Object}
         */
        getAutoplayInfo: function () {
            return {
                supportsMutedAutoplay: this.systemInfo.supportsMutedAutoplay,
                supportsUnmutedAutoplay: this.systemInfo.supportsUnmutedAutoplay,
            };
        },

        /**
         * Get unique session id.
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */

        getSessionId: function () {
            return _uuid.v1().replace(/-/g, '');
        },

        /**
         * checks to see if a particular browser name is currently being used
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */

        checkBrowserName: function (browserName) {
            return typeof browserName === this.STRING && this.getBrowserName() === browserName;
        },

        /**
         * detects if HTML5 video is supported
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        canPlayHTML5Video: function () {
            var video = document.createElement(this.VIDEO);

            return typeof video === this.OBJECT &&
                typeof video.canPlayType === this.FUNCTION;
        },

        /**
         * detects if HTML5 audio is supported
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        canPlayHTML5Audio: function () {
            var audio = document.createElement(this.AUDIO);

            return typeof audio === this.OBJECT &&
                typeof audio.canPlayType === this.FUNCTION;
        },

        /**
         * getter for browser name instance variable
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */

        getBrowserName: function () {
            return _browserName;
        },

        /**
         * getter for browser version instance variable
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */


        getBrowserVersion: function () {
            return _browserVersion;
        },

        /**
         * getter for browser name instance variable
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */


        getBrowserMajorVersion: function () {
            return _browserMajorVersion;
        },

        /**
         * getter for browser vendor prefix
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */

        getBrowserVendorPrefix: function () {
            return (
                this.isWebKit() ? 'webkit' :
                this.isFirefox() ? 'moz' :
                this.isIE() ? 'ms' :
                this.isOpera() ? 'o' :
                undefined
            );
        },

        /**
         * sets browser name, version, and major version based on params. uses regular expression to decide.
         * @memberof uvpjs.MediaCapabilities
         * @param {String} browserName - the name of the browser to set
         * @param {Object} regstr - the user agent browser regular expression object
         * @returns {Undefined}
         * @public
         */

        setBrowserVersion: function (browserName, regex) {
            // make sure we have a valid regex object
            if (typeof regex === this.OBJECT) {

                var re = new RegExp(regex);
                var browser = re.exec(this.getUserAgent());

                var browserVersion = '',
                    browserMajorVersion = '';

                // if the desired browser is found set instance variables
                if (typeof browser === this.OBJECT &&
                browser.length && browser.length > 1) {
                    browserVersion = browser[1] || '';

                    if (browserVersion.indexOf('.')) {
                        var ar = browserVersion.split('.');

                        if (typeof ar === 'object' && ar.length && ar.length > 0) {
                            browserMajorVersion = ar[0];
                        }
                    } else {
                        browserMajorVersion = browserVersion;
                    }
                    _browserName = browserName;
                    _browserVersion = browserVersion;
                    _browserMajorVersion = browserMajorVersion;

                    return true;
                }
            }

            // the browser was not found in the user agent
            return false;
        },

        /**
         * Check if the page has Tealium.
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         */
        hasTealium: function() {
            return _.has(window, 'utag') || _.has(window, 'utag_data');
        },

        /**
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         */
        isPlaystation: function () {
            return this.checkBrowserName(this.PLAYSTATION);
        },

        /**
         * shorthand to detect if Google Chrome Browser is detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */
        isChrome: function () {
            return this.checkBrowserName(this.CHROME);
        },

        /**
         * shorthand to detect if browser is WebKit
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isWebKit: function() {
            return 'WebkitAppearance' in document.documentElement.style;
        },

        /**
         * shorthand to detect if Mozilla Firefox Browser is detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isFirefox: function () {
            return this.checkBrowserName(this.FIREFOX);
        },

        /**
         * shorthand to detect if Safari or Mobile Safari Browser is detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isSafari: function () {
            return this.checkBrowserName(this.SAFARI);
        },

        /**
         * shorthand to detect if Interent Explorer, Metro, or Microsoft mobile browser is being used
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isIE: function () {
            return this.checkBrowserName(this.IE);
        },

        /**
         * shorthand to detect if Microsoft Edge browser is being used
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isEdge: function () {
            return this.checkBrowserName(this.EDGE);
        },

        /**
         * shorthand to detect if Opera (Desktop, Mini or Mobile) Browser is detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isOpera: function () {
            return this.checkBrowserName(this.OPERA);
        },

        /**
         * shorthand to detect if Opera Mobile (Mini, Mobile) browser is detected.
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isOperaMobile: function () {
            return this.checkBrowserName(this.OPERA_MOBILE);
        },

        /**
         * shorthand to detect if an Android Browser is being used.
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isAndroidBrowser: function () {
            return this.checkBrowserName(this.ANDROID_BROWSER);
        },

        /**
         * manually override user agent string. need to redo detection if user agent changes.
         * @memberof uvpjs.MediaCapabilities
         * @param {String} userAgent - nanual user agent setter to override current user agent string
         * @returns {Boolean} was the user agent successfully set
         * @public
         */

        setUserAgent: function (userAgent) {
            if (typeof userAgent === this.STRING) {
                // need to redetect, since the user agent has changed.
                this._detectEnvironment(userAgent);
                return true;
            }

            // the user agent string is not a valid string so the user agent will not be updated
            return false;
        },

        /**
         * getter for user agent instance variable; returns the user agent string
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */

        getUserAgent: function () {
            return _userAgent;
        },

        /**
         * returns the stored navigator mimeType object
         * @memberof uvpjs.MediaCapabilities
         * @returns {Object}
         * @public
         */

        getMimeTypesObj: function () {
            if (_mimeTypesObj) {
                return _mimeTypesObj;
            }

            if (typeof navigator === this.OBJECT &&
                navigator.mimeTypes && navigator.mimeTypes.length > 0) {
                _mimeTypesObj = navigator.mimeTypes;
            }

            return _mimeTypesObj;
        },

        /**
         * returns the internally stored mime types created from the mimeType object
         * @memberof uvpjs.MediaCapabilities
         * @returns {Object}
         * @public
         */

        getMimeTypes: function () {
            if (typeof _mimeTypes === this.OBJECT) {
                return _mimeTypes;
            }

            var mimeTypes = {
                    length: 0
                },
                obj = this.getMimeTypesObj();

            if (typeof obj !== this.OBJECT) {
                return;
            }

            for (var i = 0; i < this.length; i++) {

                // below not working on Safari. investigate enabledPlugin not showing up.
                var pluginName = (obj[i].enabledPlugin && obj[i].enabledPlugin.name) ? obj[i].enabledPlugin.name : '';
                mimeTypes[obj[i].type] = {
                    'type': obj[i].type,
                    'description': obj[i].description,
                    'suffixes': obj[i].suffixes,
                    'enabledPlugin': obj[i].enabledPlugin,
                    'enabledPluginName': pluginName
                };

                mimeTypes.length++;
            }

            _mimeTypes = mimeTypes;
            return _mimeTypes;
        },

        /**
         * getter for the internal platform instance variable; if the lib hasn't detected yet then do so.
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */

        getPlatform: function () {
            return (typeof _platform === this.STRING) ? _platform : null;
        },

        /**
         * getter for the internal operating system instance variable; if the lib hasn't detected yet then do so.
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */

        getOS: function () {
            return (typeof _os === this.STRING) ? _os : null;
        },

        /**
         * getter for the internal operating system instance variable; if the lib hasn't detected yet then do so.
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @public
         */


        getOSVersion: function () {
            return (typeof _osVersion === this.STRING) ? _osVersion : null;
        },

        /**
         * determines if Windows platform was detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isWindows: function () {
            return this.getPlatform() === this.WINDOWS;
        },

        /**
         * determines if Mac platform was detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isMac: function () {
            return this.getPlatform() === this.MAC;
        },

        /**
         * determines if Windows platform was detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isLinux: function () {
            return this.getPlatform() === this.LINUX;
        },

        /**
         * determines if ChromeOS platform was detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isChromeOS: function () {
            var ua = this.getUserAgent().toLowerCase();

            return ua.indexOf(this.CHROMEOS.toLowerCase()) >= 0;
        },

        /**
         * determines if OSX operating system is detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isOSX: function () {
            return this.getOS() === this.OSX;
        },

        /**
         * determines if IOS operating system is detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isIOS: function () {
            return this.getOS() === this.IOS;
        },

        /**
         * determines if Android operating system is detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isAndroid: function () {
            return this.getDevice() === this.ANDROID;
        },

        /**
         * detects if device is a Chromecast.
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isChromecast: function () {
            return this.getDevice() === this.CHROMECAST;
        },

        /**
         * determines if Windows Phone operating system is detected
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isWindowsPhone: function () {
            return this.getOS() === this.WINDOWS_PHONE;
        },

        /**
         * determines if the device is a desktop computer, laptop, or other similar
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isDesktop: function () {
            if (typeof _isDesktop === this.BOOLEAN) {
                return _isDesktop;
            }

            _isDesktop = (this.isWindows() && !this.isWindowsPhone()) || (this.isMac() && !this.isIOS()) || (this.isLinux() && !this.isAndroid()) || this.isChromeOS();
            return _isDesktop;
        },

        /**
         * determines if HLS can be played natively
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        canPlayNativeHLS: function () {
            // if html5 video is supported and the HLS mimetype can play...
            return _getVideoElement() && this.canPlayVideoType('application/vnd.apple.mpegurl');
        },

        /**
         * Returns a boolean based on where UVPJS is currently using Hlsjs, and browser WebRTC support
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */
        canUseP2p: function () {
            // VTG-396; mainly to prevent unnecessary loading of p2p client scripts
            return this.canPlayHLSJS() && !this.isIE() && !this.isEdge();
        },

        /**
         * determines if HLSJS Library can be used (borrowed from Hlsjs library)
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */
        hasMediaSourceSupport: function () {
            if (this.hasMse === null) {
                var vidType = 'video/mp4; codecs="avc1.42E01E,mp4a.40.2"',
                    mediaSource = window.MediaSource || window.WebKitMediaSource,
                    sourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer,
                    isTypeSupported = mediaSource &&
                        typeof mediaSource.isTypeSupported === 'function' &&
                        mediaSource.isTypeSupported(vidType),

                // Safari and old versions of Chrome do not expose SourceBuffer globally;
                // check if SourceBuffer.prototype looks correct
                sourceBufferValidAPI =
                    !sourceBuffer ||
                    (
                        sourceBuffer.prototype &&
                        typeof sourceBuffer.prototype.appendBuffer === 'function' &&
                        typeof sourceBuffer.prototype.remove === 'function'
                    );

                this.hasMse = !!(isTypeSupported && sourceBufferValidAPI);
            }

            return this.hasMse;
        },

        /**
         * @param {Boolean} forceHlsjs if TRUE, and if if MSE support is detected, then Hlsjs will be used
         * for playback (even if native HLS is supported, as for Safari)
         *
         * @return {boolean}
         */
        canPlayHLSJS: function (forceHlsjs) {
            var isMobile = this.isMobile(),
                hasVidEl = !!_getVideoElement(),
                hasMse = this.hasMediaSourceSupport(),
                isFfOrChrome = this.isFirefox() || this.isChrome(),
                isValidMsBrowser = (this.isIE() && this.getBrowserMajorVersion() >= 11) || this.isEdge(),
                isValidOpera = this.isOpera() && this.getBrowserMajorVersion() >= 30,
                isPlaystation = this.isPlaystation();

            if (!hasMse || !hasVidEl || isMobile || isPlaystation) {
                return false;
            }

            if (forceHlsjs) return true;

            return isFfOrChrome || isValidMsBrowser || isValidOpera;
        },

        /**
         * determiunes if standard HLS audio can be played natively;
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        canPlayNativeHLSAudio: function () {
            return _getAudioElement() && this.canPlayVideoType('audio/mpegurl');
        },

        /**
         * determiunes if standard HLS audio can be played natively;
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        canPlayDASHMP2TS: function () {
            // not implemented yet
            return null; //return this.hasMSE() && this.canPlayMP2TS();
        },

        /**
         * determiunes if DASH mp2ts can be played natively
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        canPlayH264: function () {
            return _getVideoElement() && this.canPlayVideoType('video/mp4; codecs="avc1.42001E, mp4a.40.2"');
        },

        /**
         * determiunes if WebM VP8 codecs are supported
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        canPlayVP8: function () {
            return _getVideoElement() && this.canPlayVideoType('video/webm; codecs="vp8.0, vorbis, opus"');
        },

        /**
         * determiunes if WebM VP8 codecs are supported
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        canPlayVP9: function () {
            return _getVideoElement() && this.canPlayVideoType('video/webm; codecs="vp9.0, vorbis, opus"');
        },

        /**
         * specifically use a video media element to check media mime type
         * @memberof uvpjs.MediaCapabilities
         * @param {String} media mime type as a string
         * @param {Boolean} strict - strict mode will use only probably, non-strict used maybe and probably
         * @returns {Boolean}
         * @public
         */

        canPlayVideoType: function (type, strict) {
            return _getVideoElement() &&
                this.canPlayMediaType(this.VIDEO, type, strict || false);
        },

        /**
         * specifically use an audio media element to check media mime type
         * returns whether or not a particular media type can be played
         * @memberof uvpjs.MediaCapabilities
         * @param {String} mediaType = audio or video to pick an audio or video media element
         * @param {String} type - media mime type string (mimetype and codec; ex 'video/type codec="codec"')
         * @param {Boolean} strict - strict mode will use only probably, non-strict used maybe and probably
         * @returns {Boolean}
         * @public
         */

        canPlayAudioType: function (type, strict) {
            return _getVideoElement() &&
                this.canPlayMediaType(this.AUDIO, type, strict || false);
        },

        /**
         * can be specific about which HTML media element to use (audio or video for mediaType)
         * returns whether or not a particular media type can be played
         * @memberof uvpjs.MediaCapabilities
         * @param {String} mediaType = audio or video to pick an audio or video media element
         * @param {String} type - media mime type string (mimetype and codec; ex 'video/type codec="codec"')
         * @param {Boolean} strict - strict mode will use only probably, non-strict used maybe and probably
         * @returns {Boolean}
         * @public
         */

        canPlayMediaType: function (mediaType, type, strict) {
            // can be specific about which HTML media element to use (audio or video for mediaType)
            var element = (mediaType === this.AUDIO) ? document.createElement(this.AUDIO) : document.createElement(this.VIDEO);
            strict = (strict == true);

            if (typeof element === this.OBJECT &&
                typeof element.canPlayType === this.FUNCTION) {
                if ((strict && element.canPlayType(type) === this.PROBABLY) ||
                    (!strict && element.canPlayType(type) !== '')) {
                    return true;
                }
            }

            return false;
        },

        /**
         * determines if a particular media mime type (and additionally codec(s) can be played. returns true or false
         * @memberof uvpjs.MediaCapabilities
         * @param {String} type - media mime type string (mimetype and codec; ex 'video/type codec="codec"')
         * @param {Boolean} strict mode for codec detection and probably not maybe canPlayType support
         * @returns {Boolean}
         * @public
         */

        canPlayType: function (type, strict) {
            strict = (strict == true);
            var re = /audio\//; // look for 'audio/' in the media mime type string.

            // test for audio or video type to create element otherwise use a video element.
            // basically, if audio is not in mimeType just use video element otherise audio element
            var element = (re.test(type)) ? document.createElement(this.AUDIO) : document.createElement(this.VIDEO);

            // determine if media type can be played.
            // if strict mode then only probably returns true; non-strict = probably and maybe (anything not '') for canPlayType
            if (typeof element === this.OBJECT &&
                typeof element.canPlayType === this.FUNCTION) {
                if ((strict && element.canPlayType(type) === this.PROBABLY) ||
                    (!strict && element.canPlayType(type) !== '')) {
                    return true;
                }
            }

            return false;
        },

        /**
         * nativeCanPlayType(type, strict)
         * determines if a media mime type can be played and returns native canPlayType string off HTML Media Element
         * @memberof uvpjs.MediaCapabilities
         * @param {String} type - media mime type string (mimetype and codec; ex 'video/type codec="codec"')
         * @param {Boolean} strict mode for codec detection and probably not maybe canPlayType support
         * @returns {Boolean}
         * @public
         */

        nativeCanPlayType: function (mediaType, type) {
            // can be specific about which HTML media element to use (audio or video for mediaType)
            var element = (mediaType === this.AUDIO) ? document.createElement(this.AUDIO) : document.createElement(this.VIDEO);

            if ((typeof element === this.OBJECT) &&
                (typeof element.canPlayType === this.FUNCTION)) {
                return element.canPlayType(type) || null;
            }

            return null;
        },

        /**
         * detects if a particular dash media mime type is supported and DASH is supported
         * @memberof uvpjs.MediaCapabilities
         * @param {String} type - media mime type string (mimetype and codec; ex 'video/type codec="codec"')
         * @returns {boolean}
         * @public
         */

        canPlayDASHType: function (type) {
            if (typeof type !== this.STRING || type.length < 1) {
                return null;
            }

            var mse = window.MediaSource || window.WebKitMediaSource || null;
            return this.canPlayType(type) && this.hasMSE() && mse.isTypeSupported(type);
        },

        /**
         * detects if DASH264 v2 is supported
         * @memberof uvpjs.MediaCapabilities
         * @returns {boolean}
         * @public
         */

        canPlayDASH264: function (type) {
            type = (typeof type === this.STRING) ? type : 'video/mp4; codecs="avc1.4D401E,mp4a.40.2"';
            return this.canPlayDASHType(type);

            /*
             look into this:

             if (!!mse && !mse.isTypeSupported) {
             // When async type detection is required, fall back to canPlayType. what does that mean??
             return videoElement.canPlayType(mimeType);
             } else {
             return mse && mse.isTypeSupported(mimeType);
             }
             */
        },

        /**
         * alias for canPlayDASH264; detects if DASH264 is supported.
         * @memberof uvpjs.MediaCapabilities
         * @returns {boolean}
         * @public
         */

        canPlayDASH: function () {
            return this.canPlayDASH264();
        },

        /**
         * detects if DASH for WebM is supported
         * @memberof uvpjs.MediaCapabilities
         * @returns {boolean}
         * @public
         */

        canPlayDASHWebM: function () {
            return this.canPlayDASHType('video/webm; codecs="vp9"');
        },

        /* TODO VTG-409:  eliminate? used by DOM Manager (sort of?) */
        /**
         * Returns true if the platform requires separate tags for IMA
         * @returns {boolean}
         */
        requiresSeparateTagsForIMA: function() {
            var ua = this.getUserAgent();

            return ua && !(
                this.isChromecast() ||
                this.isIOS() ||
                ua.indexOf('Android 2.') > -1 ||
                ua.indexOf('Android 4.0') > -1 ||
                ua.indexOf('Android 4.1') > -1
            );
        },

        /**
         * Returns true if a single video lement is shared between ad(s) and content
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {Boolean}
         */
        isSingleVideoIma: function () {
            return this.isIOS();
        },
        ////////////////////////
        // Autoplay capabilities (i.e, play without a user gesture)

        /**
         * Returns true if placeholder (blank vid) content is required to kick off primary content retrieval/playback
         * @memberof uvpjs.MediaCapabilities
         *
         * @param {Boolean} isAutoplay a boolean indicating whether autoplay is enabled
         * @returns {Boolean}
         * @public
         */
        requiresPlaceholderContent: function(isAutoplay) {
            if (isAutoplay && this.supportsAutoplay()) {
                return false;
            }

            return !this.isChromecast() && !this.supportsUnmutedAutoplay();
        },

        /**
         * Returns true if muted autoplay is supported
         * @memberof uvpjs.MediaCapabilities
         *
         * @return {Boolean}
         *
         * @public
         */
        supportsMutedAutoplay: function () {
            return this.systemInfo.supportsMutedAutoplay;
        },

        /**
         * Returns true if un-muted autoplay is supported
         * @memberof uvpjs.MediaCapabilities
         *
         * @return {Boolean}
         *
         * @public
         */
        supportsUnmutedAutoplay: function () {
            return this.systemInfo.supportsUnmutedAutoplay;
        },

        /**
         * Returns true if autoplay is (in some form) supported by the device.
         * For finer discrimination, use supportsMutedAutoplay() or supportsUnmutedAutoplay()
         *
         * @return {Boolean}
         */
        supportsAutoplay: function() {
            // note that if unmuted autoplay is supported, then muted autoplay
            // is also supported
            return this.supportsMutedAutoplay();
        },

        /**
         * Returns true if "intelligent" autoplay is supported by the device. Intelligent autoplay pauses and mutes
         * one video if another video is scrolled into view.
         *
         * @return {Boolean}
         */
        supportsIntelligentMobileAutoplay: function() {
            return this.isIOSTen() && this.isIPhone();
        },

        /**
         * Returns true if a special video tag attribute to allow inline play
         *
         * @param {Boolean} isAutoplay a boolean indicating whether autoplay is enabled
         *
         * @return {Boolean}
         */
        requiresInlinePlayAttribute: function(isAutoplay) {
            return isAutoplay && this.supportsAutoplay() && this.isIOSTen();
        },

        /**
         * Returns true if a user gesture is required to initiate video play, for a given scenario
         *
         * @param {Boolean} isAutoplay a boolean indicating whether autoplay is being used
         *
         * @return {Boolean}
         */
        playRequiresUserGesture: function(isAutoplay) {
            // if autoplay is not being used and the browser
            // won't play unmuted video, we must assume a gesture is required
            return !isAutoplay && !this.supportsUnmutedAutoplay()
        },

        /**
         * Utility method; prepares a video element for inline play as necessary.
         * Sets any necessary attributes on the video tag, removes erroneously set attributes
         *
         * @param {Element} vidEl video element
         * @param {Boolean} requested
         */
        setVideoForInlinePlay: function(vidEl, requested) {
            var attrObj = this.getInlinePlayAttribute(),
                attrName = attrObj && attrObj.name;

            if (requested && attrObj) {
                attrObj && vidEl.setAttribute(attrName, attrObj.value)
            }
            else if (!requested && attrName) {
                // if the supplied video tag is carrying the attribute but
                // inline play is not explicitly requested, remove it...
                vidEl.removeAttribute(attrName);
            }
        },

        /**
         * Returns the attribute name and value (in object form) to apply if applicable.
         * Returns null if not applicable.
         *
         * @returns {Object|null}
         */
        getInlinePlayAttribute: function() {
            return this.isIPhone() && this.isIOSTen() ? {
                name: this.IOS_INLINE_PLAY_ATTRIBUTE,
                value: "true"
            } : null;
        },


        ////////////
        // captions
        /**
         * Returns the line offest for bottom-floated captions.
         *
         * @returns {String}
         */
        getCaptionsLineOffset: function () {
            return this.isSafari() ? -1 : 0;
        },

        /**
         * Returns the center line align token.
         *
         * @returns {String}
         */
        getCaptionsCenterAlignToken: function () {
            return this.isSafari() ? 'middle' : 'center';
        },

        // iOS 10 marked a turning point in playback capabilities for iOS devices,
        // and it needs to be discretely identified, since these capabilities can't be queried directly.
        /**
         * Returns true if device is running iOS 10 or greater
         *
         * @returns {Boolean}
         * @private
         */
        isIOSTen: function() {
            return this.isIOS() && parseInt(this.getBrowserVersion()) >= 10;
        },

        /**
         * Returns the appropriate placeholder video url
         *
         * @returns {string}
         */
        getPreferredPlaceholderURL: function() {
            return this.isIOS() ? this.PLACEHOLDER_M3U8_URL : this.PLACEHOLDER_MP4_URL;
        },

        /**
         * detects if Media Source Extensions are supported;
         * @memberof uvpjs.MediaCapabilities
         * @returns {boolean}
         * @public
         */

        hasMSE: function () {
            return (!!window.MediaSource && !!window.MediaSource.isTypeSupported);
        },

        /**
         * detects if Encrypted Media Extensions is supported;
         * NOTE: eme.isTypeSupported is depreciated in EME
         * @memberof uvpjs.MediaCapabilities
         * @returns {boolean}
         * @public
         */

        hasEME: function () {
            var eme = 'MediaKeys' in window ||
                'WebKitMediaKeys' in window ||
                'MSMediaKeys' in window;
            return eme && !eme.setMediaKeys;
        },

        /**
         * Detects if the "google" object is present.
         * @memberof uvpjs.MediaCapabilities
         * @returns {boolean}
         * @public
         */
        hasGoogle: function() {
            return typeof google !== 'undefined';
        },

        /**
         * detects if standalone mode is supported; iPhone feature
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        getStandaloneMode: function () {
            return navigator.standalone || null;
        },

        /**
         * Detects if fullscreen is supported
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */
        hasNativeFullscreen: function () {
            return !uvpjs.util.isEmpty(this._fullscreenEventName);
        },

        /**
         * Returns the fullscreen event name for browers supporting the fullscreeen API
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {String}
         */
        getFullscreenEventName: function () {
            return this._fullscreenEventName;
        },

        /**
         * Returns the fullscreen enter event name (applies to webkit browsers only); may return null
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {String}
         */
        getFullscreenEnterEventName: function() {
            return this._fullscreenEnterEventName || null;
        },

        /**
         * Returns the fullscreen exit event name (applies to webkit browsers only); may return null
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {String}
         */
        getFullscreenExitEventName: function() {
            return this._fullscreenExitEventName || null;
        },

        /**
         * Returns the fullscreen error event name; may return null
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {String}
         */
        getFullscreenErrorEventName: function () {
            return this._fullscreenErrorEventName;
        },

        /**
         * Returns the method name used for fullscreen entry
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {String}
         */
        getEnterFullscreenMethodName: function () {
            return this._enterFullscreenMethodName;
        },

        /**
         * Returns the method name used for fullscreen exit
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {String}
         */
        getExitFullscreenMethodName: function () {
            return this._exitFullscreenMethodName;
        },

        /**
         * Returns property name used to query fullscreen status; applies to fullscreen API only - may return null
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {String}
         */
        getIsFullscreenPropertyName: function() {
            return this._isFullscreenPropertyName;
        },

        /**
         * Returns property name (on window.document) used to identify the current fullscreen element, if it exists
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {String}
         */
        getFullScreenElementName: function() {
           return this._fullscreenElementName;
        },

        /**
         * Returns TRUE if the browser/device supports the Fullscreen API
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @return {Bool}
         */
        supportsFullscreenApi: function() {
            var d, u;

            if (this._hasFullscreenApiSupport === undefined) {
                d = document.createElement("div");
                u = uvpjs.util;

                this._hasFullscreenApiSupport = !!(
                    u.isFunction(d.requestFullscreen) ||
                    u.isFunction(d.webkitRequestFullscreen) ||
                    u.isFunction(d.mozRequestFullScreen) ||
                    u.isFunction(d.msRequestFullscreen)
                );
            }

            return this._hasFullscreenApiSupport;
        },

        /**
         * Returns TRUE if fullscreen mode may be used (ie, both supported and ALLOWED by browser policies governing
         * the context of video playback (e.g., from within an iframe).
         * @memberof uvpjs.MediaCapabilities
         *
         * @param {HTMLElement} videoEl video element; must be provided *after* metadata loaded event occurs on the
         * video element (e.g, Safari iOS will not make a definitive determination of fullscreen support until after
         * metadata loaded)
         *
         * @return {Boolean}
         */
        isFullscreenAvailable: function(videoEl) {
            var d = document,
                ok = this.supportsFullscreenApi() && (
                        d.fullscreenEnabled ||
                        d.webkitFullscreenEnabled ||
                        d.mozFullScreenEnabled	||
                        d.msFullscreenEnabled
                     );

            // likely mobile webkit
            !ok && (ok = videoEl && videoEl.webkitSupportsFullscreen);

            return ok;
        },


        /**
         * getter for internal device instance variable
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */
        getDevice: function () {
            return _device ? _device : null;
        },

        /**
         * is this an Apple iPod device
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */
        isIPhone: function () {
            return this.getDevice() === this.IPHONE;
        },

        /**
         * is this an Apple iPod device
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isIPad: function () {
            return this.getDevice() === this.IPAD;
        },

        /**
         * is this an Apple iPod device
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isIPod: function () {
            return this.getDevice() === this.IPHONE;
        },

        /**
         * determines if device is one of the supported, detectable mobile devices.
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}is
         * @public
         */

        isMobile: function () {
            // browser platform checks will indicate one of the below
            // add any additional mobile types as they are supported or desired to be detected
            return this.getOS() === this.IOS ||
                this.getOS() === this.ANDROID ||
                this.getOS() === this.WINDOWS_PHONE ||
                this.getOS() === this.OPERA_MOBILE;
        },

        /**
         * Returns true if muting video is supported
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @returns {Boolean}
         */
        supportsMute: function() {
            var isIOS = this.isIOS();
            return !isIOS || (isIOS && parseInt(this.getBrowserVersion()) >= 10) ;
        },

        /**
         * Returns true if browser supports ::cue CSS pseudo-class.
         *
         * @memberof uvpjs.MediaCapabilities
         *
         * @public
         *
         * @returns {Boolean}
         */
        supportsCaptionsCSS: function() {
            return !this.isFirefox() && !this.isIE() && !this.isEdge();
        },

        /**
         * Returns true if programmatic volume adjustment is supported
         * @memberof uvpjs.MediaCapabilities
         * @public
         *
         * @returns {Boolean}
         */
        supportsVolume: function() {
            return !this.isIOS();
        },

        /**
         * Determines if touch device.
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isTouch: function () {
            return 'ontouchstart' in window      // works on most browsers
                  || navigator.maxTouchPoints;   // works on IE10/11 and Surface
        },

        /**
         * determines if the device is a console
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         */

        isConsole: function () {
            // not implemented yet
        },

        /**
         * NOT IMPLEMENTED YET
         * determines if the device is a supported OTT device
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         */

        isOTT: function () {
            // NOT IMPLEMENTED YET.
            return false;
        },

        /**
         * determines if the provided URL is an HLS Stream type
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isHlsUrl: function(url) {
            var reHls = /\.m3u|assetType=hls/i; // hls file extension
            var isHlsStream = reHls.test(url);

            return isHlsStream;
        },

        /**
         * determines if the provided URL is an MPEG-DASH Stream type
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */

        isDashUrl: function (url) {
            var reDash = /\.mpd/i;
            var isDashStream = reDash.test(url);

            return isDashStream;
        },

        /**
         * Determines if the player is loaded in an HTTPS page.
         * @memberof uvpjs.MediaCapabilities
         * @returns {Boolean}
         * @public
         */
        isSecure: function() {
            return _isSecure;
        },

        /**
         * Makes url string HTTPS, if necessary.
         * @param {String} url.
         * @returns {String} 'https:' or 'http:'
         */
        setUrlProtocol: function(url) {
            return _isSecure ? url.replace('http:', 'https:') : url;
        },

        /**
         * Inspects the Video State DRM object to determine the DRM Type.
         * Note: This is only an attempt to derive the type from minimal
         * information in the config. The complete solution will require to wire
         * up to the webkit key added event and determine if appCert was loaded
         * and Fairplay initialized.
         *
         * @param {Object} drm options object
         * @memberof uvpjs.MediaCapabilities
         * @returns {String}
         * @private
         */
        getDrmType: function(drm) {
            var type = 'none';

            if (!drm.enabled) {
                return type;
            }

            if ((this.isIOS() || this.isSafari()) && drm.fairplay.appCertURL !== null) {
                type = 'Fairplay';

            } else if ((this.isIE() || this.isEdge()) && drm.dash.playreadyURL !== null) {
                type = 'PlayReady';

            } else if ((this.isChrome() || this.isFirefox() || this.isOpera()) && drm.dash.widevineURL !== null) {
                type = 'Widevine';
            }

            return type;
        }
    };

    /**
     * detect the current platform via the user agent string.
     * @memberof uvpjs.MediaCapabilities
     * @returns {Undefined}
     */

    var _detectPlatform = function () {
        var regstr = /\s(\([^)]+\))/; // find the platform information within parenthesis section of user agent ()
        var re = new RegExp(regstr);
        var test = re.exec(obj.getUserAgent());

        if (test && test.length && test.length > 1) {
            test = test[1].replace(/_/gi, '.'); // grab the found platform string of array

            if (_detectMac(test)) {
            } else if (_detectWindows(test)) {
            } else if (_detectLinux(test)) {
            } else if (_detectChromecast((test))) {
            }
        }
    };

    /**
     * detect if platform is linux (and specifically Android and other device types.
     * determines device, operating system, os version, and platform, desktop/mobile
     * @param {String} test - platform string from regex results
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} - true/false depending on if Linux OS is detected
     */

    var _detectLinux = function (test) {
        if (test.indexOf(obj.LINUX) !== -1 ||
            test.indexOf(obj.ANDROID) !== -1) {

            _platform = obj.LINUX;

            if (test.indexOf(obj.ANDROID) !== -1) {

                var regstr = /\ Android\ ([^\s]+);/,
                    re = new RegExp(regstr);

                test = re.exec(test);

                _device = obj.ANDROID;
                _os = obj.ANDROID;
                _osVersion = (test && test[1]) ? test[1] : '';
            } else {

            }

            return true;
        }

        return false;
    };

    /**
     * detect if platform is Mac (and specifically OSX and iOS and other device types.
     * determines device, operating system, os version, and platform, desktop/mobile
     * @memberof uvpjs.MediaCapabilities
     * @param {String} test - platform string from regex results
     * @returns {Boolean} true/false depending on if Mac OS/iOS is detected.
     */

    var _detectMac = function (test) {
        var regstr, re;
        var ios = 'like Mac OS X'; // used for non-OSX Mac devices.

        if (test.indexOf(obj.MAC) !== -1) {
            // OSX desktop detected.
            _platform = obj.MAC;
            _device = obj.DESKTOP;

            if (test.indexOf(obj.OSX) !== -1) {

                regstr = /Mac\ OS\ X\ ([\d\.]+)/;
                re = new RegExp(regstr);
                test = re.exec(test);

                _os = obj.OSX;
                _osVersion = (test && test[1]) ? test[1] : null;
            }

            return true;

        } else if (test.indexOf(ios) !== -1) {
            // iOS detected.
            _platform = obj.MAC;
            _os = obj.IOS;

            var iPhone = /\(iPhone;/,
                iPad = /\(iPad;/,
                iPod = /\(iPod;/;
            re = /\sOS\s([^\s]*)\s/;
            var version = re.exec(test);

            if (version && version[1]) {
                _osVersion = version[1];
            }

            if (iPhone.test(test)) {
                _device = obj.IPHONE;
            } else if (iPad.test(test)) {
                _device = obj.IPAD;
            } else if (iPod.test(test)) {
                _device = obj.IPOD;
            } else {
                return false;
            }

            return true;
        }

        return false;
    };

    /**
     * detect if platform is Windows (and specifically Windows desktop and mobile and other device types.
     * determines device, operating system, os version, and platform, desktop/mobile
     * @memberof uvpjs.MediaCapabilities
     * @param {String} test - platform string from regex results
     * @returns {Boolean} true/false depending on if Windows OS is detected.
     */

    var _detectWindows = function (test) {
        var regstr1 = /(Windows\ Phone\ |Windows\ Phone\ OS\ )([^\s]+);/,
            regstr2 = /Windows\ NT\ ([^\s]+)[;\)]/;

        var re = new RegExp(regstr1);
        test = re.exec(obj.getUserAgent());

        if (test && test[2]) {
            _platform = obj.WINDOWS;
            _os = obj.WINDOWS_PHONE;
            _osVersion = test[2];
            _device = obj.PHONE;
            return true;

        } else {
            re = new RegExp(regstr2);
            test = re.exec(obj.getUserAgent());

            if (test && test[1]) {
                _platform = obj.WINDOWS;
                _os = obj.WINDOWS;
                var osVersionNbr = test[1];

                // Windows uses a different numbering system for windows OS versions
                if (osVersionNbr == 6.0) {
                    _os = obj.WINDOWS_VISTA;
                } else if (osVersionNbr == 6.1) {
                    _os = obj.WINDOWS7;
                    _osVersion = 7; // WIN 7 is UA as 6.1
                } else if (osVersionNbr == 6.2) {
                    _os = obj.WINDOWS8;
                    _osVersion = 8; // WIN 8 is UA as 6.2
                } else if (parseInt(osVersionNbr) == 10) {
                    _os = obj.WINDOWS10;
                    _osVersion = osVersionNbr; // WIN 10
                }

                _device = obj.DESKTOP;
                return true;
            }
        }
        return false;
    };

    /**
     * determines the browser, browser version, etc for all major and most used browsers,
     * generic for less supported browsers
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} true/false depending on if a know browser is detected or not.
     */

    var _detectBrowser = function () {
        if (_detectChrome()) {
            return true;
        } else if (_detectIE()) {
            return true;
        } else if (_detectFirefox()) {
            return true;
        } else if (_detectSafari()) {
            return true;
        } else if (_detectOpera()) {
            return true;
        } else if (_detectSilk()) {
            return true;
        } else if (_detectAndroidBrowser()) {
            return true;
        }else if(_detectPlaystation()) {
            return true;
        }

        // if we don't find a major browser return false;
        return false;
    };

    /**
     * getter for video instance variable
     * @memberof uvpjs.MediaCapabilities
     * @returns {HTMLVideoElement} returns the video DOM element
     */

    var _getVideoElement= function () {
        return _videoTagRef;
    };

    /**
     * getter for video instance variable
     * @memberof uvpjs.MediaCapabilities
     * @returns {HTMLAudioElement} returns the audio DOM element.
     */

    var _getAudioElement = function () {
        return _audioTagRef;
    };

    /**
     * check if the browser is Google Chrome
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} true/false detects if Chrome is detected or not.
     */

    var _detectChrome = function () {
        // there are several edge cases that use Chrome engine, but are not Google Chrome browser specifically
        // ignore modern Opera, Microsoft Edge, and Chromecast.
        var re1 = /Chrome\/(\S+)/,
            re2 = /CriOS\/(\S+)/,
            re3 = /(Opera|OPR)/,
            re4 = /Edge/,
            re5 = /CrKey/,
            ua = obj.getUserAgent(),
            isChromeForIOS = re2.test(ua),
            test = (re1.test(ua) || isChromeForIOS) && (!re3.test(ua) && !re4.test(ua) && !re5.test(ua));

        if (test) {
            obj.setBrowserVersion(obj.CHROME, isChromeForIOS ? re2 : re1);
            return true;
        }

        // Google Chrome not detected
        return false;
    };

    /**
     * Detect if Playstation is being used
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} - true/false if Playstation browser is detected.
     */
    var _detectPlaystation = function () {
        var re = /Playstation (\S+)/i;

        if (re.test(obj.getUserAgent())) {
            obj.setBrowserVersion(obj.PLAYSTATION, re);
            return true;
        }

        return false;
    };

    /**
     * detect the Chromecast device
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} true/false depending on if Chromecast is detected or not.
     */

    var _detectChromecast = function () {
        if (obj.getUserAgent() != null) {
            if (obj.getUserAgent().indexOf(obj.CHROMECAST_USER_AGENT) > -1) {
                _platform = obj.LINUX;
                _device = obj.CHROMECAST;
                _os = obj.ANDROID;
                return true;
            }
        }
        return false;
    };

    /**
     * detect if Internet Explorer is being used or Microsoft Edge or a Microsoft mobile browser
     * Microsoft Edge is a marketing change, it's still IE12. maybe consider a function name change
     * as all Microsoft browsers are detected with this function.
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} true/false if IE/Metro browser is detected.
     */

    var _detectIE = function () {
        // keep these in order because Trident should be detected last to differentiate IE and Edge
        var re1 = /MSIE\ ([^\s]+)[\)\;]\ Windows\ /,   // Microsoft Internet Explorer
            re2 = /\ Edge\/([^\s]+)/, // Microsoft Edge
            re3 = /Trident.[^\s]+;.*rv:([^\s]+)[\)\;]/;  // Microsoft Trident engine means IE

        // based on the above tests, set the correct browser
        if (re1.test(obj.getUserAgent())) {
            obj.setBrowserVersion(obj.IE, re1);
            return true;
        } else if (re2.test(obj.getUserAgent())) {
            obj.setBrowserVersion(obj.EDGE, re2);
            return true;
        } else if (re3.test(obj.getUserAgent())) {
            obj.setBrowserVersion(obj.IE, re3);
            return true;
        }

        // Microsoft Browser is not being used
        return false;
    };

    /**
     * detect if Mozilla Firefox is being used
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} - true/false if Firefox browser is detected.
     */

    var _detectFirefox = function () {
        var re = /Firefox\/(\S+)/;

        if (re.test(obj.getUserAgent())) {
            obj.setBrowserVersion(obj.FIREFOX, re);
            return true;
        }

        return false;
    };

    /**
     * does Safari detection.
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} true/false if Safari is detected.
     */

    var _detectSafari = function () {
        var re1 = /Version\/(\S+).*Safari\//;
        var test = re1.test(obj.getUserAgent());
        var browserName;

        if (_os === obj.ANDROID) {
            browserName = obj.ANDROID;
        } else {
            browserName = obj.SAFARI;
        }

        if (test) {
            //obj.setBrowserVersion(obj.SAFARI, /Version\/(\d*)\.(\d*)\.(\d*)/);
            obj.setBrowserVersion(browserName, re1);
            return true;
        }
        return false;
    };

    /**
     * detects if Opera, Opera Mini, Opera Mobile, or any Opera browser is being used.
     * Opera detection is tricky as both Opera Mini and Opera Mobile are seperate confusing technologies
     * Opera has the most irresponsible of user agent strings so detection needs to
     * carefully looked at in future library versions.
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} - true/false if Opera browser is detected or not.
     */

    var _detectOpera = function () {
        var regstr = /Opera|OPR\/(\S+)/;
        var re = new RegExp(regstr);
        var test = re.exec(obj.getUserAgent());

        if (test) {
            var browser = (test.indexOf('Opera Mini/') !== -1 || test.indexOf('Opera Mobi') !== -1) ? obj.OPERA_MOBILE : obj.OPERA;
            obj.setBrowserVersion(browser, /Opera|OPR\/(\S+)/);
            return true;
        }

        // Opera browers not detected
        return false;
    };

    /**
     * detect Amazon Kindle browser. There are many versions of the operating system, but this is specific for devices.
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} true/false if Amazon Silk browser is detected.
     */

    var _detectSilk = function () {
        var re = /Silk/i;

        if (re.test(obj.getUserAgent())) {
            obj.setBrowserVersion(obj.AMAZON_KINDLE, /Silk\/(\S+)/);
            return true;
        }

        // Amazon Kindle Silk browser not detected
        return false;
    };

    /**
     * detect if native android browser is being used.
     * @memberof uvpjs.MediaCapabilities
     * @returns {Boolean} true/false if Android browser is detected or not.
     *
     */

    var _detectAndroidBrowser = function () {
        var re = /Android/;
        var test = re.test(obj.getUserAgent());

        if (test) {
            _browserName = obj.ANDROID_BROWSER;
            return true;

        }
        return false;
    };

    /*
        VTG-347: _detectFullscreenType() initially only determined the fullscreen event name,
        now determines all names relevant to the fullscreen lifecycle.
    */
    /**
     * detects the type of fullscreen capabilities depending on web rendering engine / browser.
     * @memberof uvpjs.MediaCapabilities
     * @returns {Object} returns the fullscreen object used across browers/devices
     */
    var _detectFullscreenType = function () {
        var v = _getVideoElement(),
            makeNames = function(o, a) {
                o._fullscreenEventName       = !a ? null : a[0]; // enter && exit
                o._fullscreenEnterEventName  = !a ? null : a[1]; // enter (webkit/non-FS API only)
                o._fullscreenExitEventName   = !a ? null : a[2]; // exit (webkit/non-FS API only)

                o._enterFullscreenMethodName = !a ? null : a[3]; // enter method
                o._exitFullscreenMethodName  = !a ? null : a[4]; // exit method

                o._isFullscreenPropertyName  = !a ? null : a[5]; // the property to query for "is @ fullscreen?"
                o._fullscreenElementName     = !a ? null : a[6]; // The element that is currently fullscreen
                o._fullscreenErrorEventName  = !a ? null : a[7]; // error
            },
            stdNames = ['fullscreenchange', null, null, 'requestFullscreen', 'exitFullscreen',
                        'fullScreen','fullScreenElement', 'fullscreenError'],
            names = null;

        // Test for fullscreen API support and assign all names accordingly (Aren't standards wonderful)?

        if (v.requestFullscreen) { // supports Fullscreen API 'standard'
            names = stdNames;
        }
        else if (v.webkitRequestFullscreen) { // webkit (chrome/safari/edge)
            names = ['webkitfullscreenchange', null, null,
                     'webkitRequestFullscreen', 'webkitExitFullscreen',
                     'webkitIsFullScreen', 'webkitFullscreenElement', 'webkitfullscreenerror'];

        }
        else if (v.mozRequestFullScreen) { //firefox
            names = ['mozfullscreenchange', null, null,
                     'mozRequestFullScreen', 'mozCancelFullScreen',
                     'mozFullScreen', 'mozFullScreenElement', 'mozfullscreenerror'];
        }
        else if (v.msRequestFullscreen) { // ie browser
            // note: no 'fullscreen' or 'isfullscreen' equivalent
            if (obj.getBrowserVersion() < 12) {
                names = ['MSFullscreenChange', null, null,
                         'msRequestFullscreen', 'msExitFullscreen',
                         null,  'msFullscreenElement', 'MSFullscreenError'];
            }
            else {
                names = stdNames.slice();
                names[5] = null;
            }
        }
        else if (obj.isIOS() || obj.isAndroid()) {
            // If we're here, there's no FS API support, i.e,
            // only the video element itself can be taken fullscreen.
            // Note that not all Android will land here - devices supporting
            // the FS API will be caught above.
            names = [null, 'webkitbeginfullscreen', 'webkitendfullscreen',
                     'webkitEnterFullscreen', 'webkitExitFullscreen',
                     'webkitDisplayingFullscreen', null, 'webkitfullscreenerror']
        }

        makeNames(obj, names);
    };

    return obj;
});

// automatically assign and call the detected Environment.
// can do this in one line as detectEnvironment returns its parent object.
uvpjs.mediaCapabilities = uvpjs.MediaCapabilities()._detectEnvironment();

/**
 * Created by ldoyle on 8/31/15.
 */
'use strict';

/**
 * UVPJS DebugManager - logs to the console. Initialized by the VideoManager.
 * @constructor uvpjs.DebugManager
 * @extends uvpjs
 **/

 uvpjs.DebugManager = {

    CONFIG_MODULE_NAME: 'UVPJSDebug',

    configParams: {

        // Output configuration
        SHOW_ALL: 'showAll',
        SHOW_TIMESTAMPS: 'showTimestamps',
        SHOW_CLOCK_TIME: 'showClockTime',

        // Logging identifiers
        CODE_LOADER: 'CodeLoader',
        CONFIG_MANAGER: 'ConfigManager',
        CORE_VIDEO_INSTANCE: 'CoreVideoInstance',
        CVI_MODEL: 'CVI_Model',
        DEBUG_MANAGER: 'DebugManager',
        DOM_MANAGER: 'DOMManager',
        EVENTS_MANAGER: 'EventsManager',
        RESOURCE_CONFIG_OBJECT: 'ResourceConfigObject',
        RESOURCE_PLAYLIST_MANAGER: 'ResourcePlaylistManager',
        RESOURCE_PROVIDER: 'ResourceProvider',
        SKIN_MANAGER: 'SkinManager',
        CONTENT_DATA_PROXY: 'ContentDataProxy',
        VIDEO_CONTROL_INTERFACE: 'VideoControlInterface',
        VIDEO_MANAGER: 'VideoManager',
        STUCK_AD: 'StuckAd',
        FAIRPLAY_DRM: 'FairPlayDRM',
        P2P_CLIENT: 'P2pClient',

        // Captions
        CAPTIONS_MANAGER: 'CaptionsManager',
        CAPTIONS_AGENT: 'CaptionsDisplayAgent',

        // Tracking
        TRACKING_MANAGER: 'TrackingManager',
        TRACKING_LIB: 'TrackingLib'        ,
        MUX_DEBUG: 'MuxDebug',

        // Video Player Facade
        VIDEO_PLAYER_FACADE: 'VideoPlayerFacade',

        // HTML5 specific
        VPF_HTML5: 'VPF_HTML5',

        // HLSJS specific
        VPF_HLSJS: 'VPF_HLSJS',
        HLSJS_LIB: 'HLSJS_LIB',
        HLSJS_LEVEL: 'HLSJS_LEVEL',
        HLSJS_FRAG: 'HLSJS_FRAG',
        HLSJS_FRAME_DROP: 'HLSJS_FRAME_DROP',

        // DASHJS specific
        VPF_DASHJS: 'VPF_DASHJS',
        DASHJS_LIB: 'DASHJS_LIB',
        DASHJS_LEVEL: 'DASHJS_LEVEL',
        DASHJS_FRAG: 'DASHJS_FRAG',
        DASHJS_FRAME_DROP: 'DASHJS_FRAME_DROP'
    },

    isEnabled: false,

    showAll: false,
    showTimestamps: false,
    showClockTime: false,

    sessionStartTime: 0,
    timezoneOffset: 0,
    adjustedStartTime: 0,
    adjustedTimezone: 0,

    supportsFormatting: false,

    COOKIE_NAME: 'UVPJSDebug',
    cookie: {},

    initialize: function (cdo) {
        var _ = uvpjs._,
            mc = uvpjs.mediaCapabilities;

        this.DEBUG_ID = this.configParams.DEBUG_MANAGER;
        this.debugCount = 0;

        if (!_.isObject(cdo)) {
            this.warn(this.DEBUG_ID, 'DebugManager requires an instance of the ConfigDataObject.');
            return;
        }

        this.cookie = this._getCookie();

        this.CDO = cdo; // CDO required to check if logging enabled for given parameter.
        this.isEnabled = (this.cookie.enabled === true) || this._isEnabled();

        this.showAll = (this.cookie.showAll === true) || this.CDO.getModuleParam(this.CONFIG_MODULE_NAME, this.configParams.SHOW_ALL);
        this.showTimestamps = (this.cookie.showTimestamps === true) || this.CDO.getModuleParam(this.CONFIG_MODULE_NAME, this.configParams.SHOW_TIMESTAMPS);
        this.showClockTime = (this.cookie.showClockTime === true) || this.CDO.getModuleParam(this.CONFIG_MODULE_NAME, this.configParams.SHOW_CLOCK_TIME);

        this.supportsFormatting = mc.isChrome() || mc.isFirefox() || mc.isSafari();

        this.setSessionStartTime(); // Check again in case the CDO parameters alter the values.
    },

    /**
     * Set session start time.
     * @memberof uvpjs.DebugManager
     * @return {Undefined} Undefined
     */
    setSessionStartTime: function() {
        this.sessionStartTime = this.sessionStartTime || new Date();
        this._setupTime();
    },

    /**
     * Shortcut method to output a console.log message.
     * @memberof uvpjs.DebugManager
     * @return {Undefined} Undefined
     */
    log: function() {
        [].unshift.call(arguments, 'log');
        this.output.apply(this, arguments);
    },

    /**
     * Shortcut method to output a console.warn message.
     * @memberof uvpjs.DebugManager
     * @return {Undefined} Undefined
     */
    warn: function() {
        [].unshift.call(arguments, 'warn');
        this.output.apply(this, arguments);
    },

    /**
     * Shortcut method to output a console.error message.
     * @memberof uvpjs.DebugManager
     * @return {Undefined} Undefined
     */
    error: function() {
        [].unshift.call(arguments, 'error');
        this.output.apply(this, arguments);
    },

    /**
     * Output a message to the console.
     * @param {String} type - Type of output: log, warn, or error.
     * @param {String} param - CDO module parameter name.
     * @param {String} message - String containing the debug / error message.
     * @memberof uvpjs.DebugManager
     * @return {Undefined} Undefined
     */
    output: function(type, param, msg) {
        this.debugCount++;

        var _ = uvpjs._;

        // Ensure messages are shown before DebugManager initialized and this.CDO declared.
        if (!this.isEnabled && !_.isUndefined(this.CDO)) {
            return;
        }

        if (!_.isString(type) || !_.isString(param) || _.isUndefined(msg)) {
            console.warn('UVPJS DebugManager unable to display to console because of missing arguments.' + msg, param);
            return;
        }

        if (this.showAll || _.isUndefined(this.CDO) || this.isParamEnabled(param) || (this.cookie[param] === true) ) {
            // Show formatted timestamp or empty string.
            var timestamp = this.showTimestamps ? '[' + this._timestamp() + '] ' : '';

            // Show additional arguments in message output or empty string.
            var extraArgs = _.drop(arguments, 3),
                extraMsg = _.isEmpty(extraArgs) ? '' : extraArgs;

            // CSS format strings.
            var fmt = {
                bold: ';font-weight:bold;',
                normal: ';text-decoration:none;',
                underline: ';text-decoration:underline;',
            }

            // IE doesn't allow formatting in the console.
            if (!this.supportsFormatting) {
                console[type]('%sUVPJS %s %s', timestamp, param, msg, extraMsg);
                return;
            }

            // Output a formatted message to console.
            console[type]('%s%cUVPJS %c%s%c %s', timestamp, fmt.bold, fmt.underline, param, fmt.normal, msg, extraMsg);
        }
    },

    /**
     * Is CDO parameter enabled.
     * @param {String} param - CDO module parameter name.
     * @memberof uvpjs.DebugManager
     * @private
     */
    isParamEnabled: function(param) {
        return this.CDO.getModuleParam(this.CONFIG_MODULE_NAME, param) === true;
    },

    /**
     * Setup timestamp.
     * @memberof uvpjs.DebugManager
     * @returns {Undefined} Undefined.
     * @private
     */
    _setupTime: function() {
        this.timezoneOffset = (this.sessionStartTime.getTimezoneOffset()) / 60;
        this.adjustedStartTime = this.showClockTime ? 0 : this.sessionStartTime;
        this.adjustedTimezone = this.showClockTime ? this.timezoneOffset : 0;
    },

    /**
     * Is debug enabled.
     * @param {String} param - CDO module parameter name.
     * @memberof uvpjs.DebugManager
     * @private
     */
    _isEnabled: function() {
        // Check if the browser supports console.
        if (!window.console) {
            return false;
        }

        return this.CDO.isModuleEnabled(this.CONFIG_MODULE_NAME) === true;
    },

    /**
     * Format timestamp in military with milliseconds.
     * @memberof uvpjs.DebugManager
     * @returns {String} Returns timestamp in format hh:MM:ss.mmm.
     * @private
     */
    _timestamp: function() {
        var _ = uvpjs._;

        var now = new Date();

        // Subtract start time when showing running clock.
        var ts = now - this.adjustedStartTime;

        var ms = ts % 1000;
        ts = (ts - ms) / 1000;

        var secs = ts % 60;
        ts = (ts - secs) / 60;

        var mins = ts % 60;
        ts = (ts - mins) / 60;

        // Subtract timezone offset when showing clock time.
        var hrs = (ts % 24) - this.adjustedTimezone;

        return (
            _.padStart(hrs,  2, '0') + ':' +
            _.padStart(mins, 2, '0') + ':' +
            _.padStart(secs, 2, '0') + '.' +
            _.padStart(ms,   3, '0')
        );
    },


    /**
     * Parse JSON cookie for debugging.
     * @memberof uvpjs.DebugManager
     * @returns {Object} Returns the debug cookie as an object.
     * @private
     */
    _getCookie: function() {
        var cookie = this._readCookie(this.COOKIE_NAME),
            obj = {};

        if (!cookie) {
            return obj;
        }

        uvpjs.log(this.DEBUG_ID, '_getCookie cookie', cookie);

        try {
            obj = JSON.parse(cookie);
        } catch(e) {
            uvpjs.error(this.DEBUG_ID, 'Error reading cookie.', e);
        }

        uvpjs.log(this.DEBUG_ID, '_getCookie obj', obj);

        return obj;
    },

    /**
     * Search for a cookie.
     * @param {String} name - Cookie name.
     * @memberof uvpjs.DebugManager
     * @returns {String} Returns cookie value.
     * @private
     */
    _readCookie: function(name) {
        var nameEQ = name + '=';
        var ca = document.cookie.split(';');

        for (var i = 0, j = ca.length; i < j; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    },
};

'use strict';

(function (obj) {

    var _getDOMObj,
        _ = obj._;

    obj.DOMManager = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.DOM_MANAGER,

        PLAY: 'play',
        PAUSE: 'pause',
        CAN_PLAY: 'canplay',
        CAN_PLAY_THROUGH: 'canplaythrough',
        LOADED_METADATA: 'loadedmetadata',

        /**
         * @constructor uvpjs.DOMManager
         *
         * @param {String}      options.containerID Main outer container ID (aka `vidContId`).
         * @param {Boolean}     options.useMutedAttribute
         * @param {Boolean}     options.useInlinePlayAttribute
         * @param {Boolean}     options.createControls Whether to create the controls container element.
         * @param {Boolean}     options.createAds Whether to create the ads container element.
         * @param {Boolean}     options.usePlaceholderContent
         * @param {Function}    options.callback DOM ready callback function.
         * @param {Boolean}     options.useAutoplayAttribute if TRUE, the 'autoplay' attribute will be added to vid tag
         *
         * @description Manages video container DOM
         */
        init: function (options) {
            this.debug = uvpjs.debug;

            this.debug && uvpjs.log(this.DEBUG_ID, 'init', options);

            this.mc = null;

            this._createControls = options.createControls;
            this._createAds = options.createAds;

            this._useInlinePlayAttribute = options.useInlinePlayAttribute;
            this._useMutedAttribute = options.useMutedAttribute;
            this._usePlaceholderContent = options.usePlaceholderContent;

            this._DOMReadyCB = options.callback;
            this._useAutoplayAttribute = options.useAutoplayAttribute;

            this._userAgent = null;

            this.dom = _getDOMObj();
            this.dom.outer.id = options.containerID;
        },

        //
        // Public methods.
        //

        /**
         * @memberof uvpjs.DOMManager#
         */
        initialize: function () {
            uvpjs.log(this.DEBUG_ID, 'initialize');

            this.mc = uvpjs.mediaCapabilities;
            this._userAgent = this.mc.getUserAgent();

            this._setupDOM();
        },

        /**
         * @memberof uvpjs.DOMManager#
         */
        destroy: function() {
            var vidEl = this.dom.video.el;
            if (vidEl && vidEl instanceof HTMLElement) {
                vidEl.removeEventListener(this.LOADED_METADATA, this._handleEvent, false);
                vidEl.removeEventListener(this.CAN_PLAY_THROUGH, this._handleEvent, false);
                vidEl.removeEventListener(this.CAN_PLAY, this._handleEvent, false);
                vidEl.removeEventListener(this.PLAY, this._handleEvent, false);
                vidEl.removeEventListener(this.PAUSE, this._handleEvent, false);
            }

            this.mc = null;
            this.dom = null;
            this._DOMReadyCB = null;
        },

        /**
         * @memberof uvpjs.DOMManager#
         *
         * @returns {Object} A copy of the `dom` object.
         */
        getDOM: function() {
            return _.clone(this.dom);
        },

        //
        // DOM setup.
        //

        /**
         * Disable the context menu on right-click.
         * @memberof uvpjs.DOMManager#
         * @private
         */
        _disableVideoContextMenu: function() {
            var el = this.dom.video.el;

            if (el.addEventListener) {
                el.addEventListener('contextmenu', function (e) { e.preventDefault(); }, false);
            } else {
                el.attachEvent('oncontextmenu', function () { window.event.returnValue = false; });
            }
        },

        /**
         * Add elements to the DOM.
         * @memberof uvpjs.DOMManager#
         * @private
         */
        _setupDOM: function() {
            var dom = this.dom;

            dom.outer.el = document.getElementById(dom.outer.id);

            if (_.isNull(this.dom.outer.el)) {
                if (this.debug) {
                    uvpjs.error(this.DEBUG_ID, 'Fatal error: UVPJS outer container does not exist. UVPJS initialization failed!', dom.outer.id);
                }
                return;
            }

            // Construct DOM IDs.
            dom.content.id = this._getIdByPrefix('CONTENT_ID_PREFIX');
            dom.video.id = this._getIdByPrefix('VIDEO_ID_PREFIX');
            dom.ad.id = this._getIdByPrefix('AD_ID_PREFIX');
            dom.controls.id = this._getIdByPrefix('CONTROLS_ID_PREFIX');

            // Create content container.
            dom.content.el = this._getOrCreateElement('content');
            dom.outer.el.insertBefore(dom.content.el, dom.outer.el.firstChild);

            // Create video element.
            this._createVideoElement();

            // Create ad container.
            if (this._createAds) {
                this._useSeparateTags = this.mc.requiresSeparateTagsForIMA();

                dom.ad.el = this._getOrCreateElement('ad');
                dom.outer.el.insertBefore(dom.ad.el, dom.content.el.nextSibling);
            }

            // Create controls container.
            if (this._createControls) {
                dom.controls.el = this._getOrCreateElement('controls');
                dom.outer.el.appendChild(dom.controls.el);
            } else {
                this._addInlineStyles();
            }

            // Disable context menu.
            this._disableVideoContextMenu();

            if (this._usePlaceholderContent) {
                this._createPlaceholderContent();
                return;
            }

            this._DOMReadyCB();
        },

        /**
         * Need to detect the video element. The scenarios are:
         *   1 - Video container div with video tag exist within outer container.
         *   2 - Video tag exists directly within outer container.
         *   3 - The two other scenarios don't exist, so remove everything from
         *       outer container and add video tag within a video container div.
         * @memberof uvpjs.DOMManager#
         * @private
         */
        _createVideoElement: function() {

            // First, search for outer container -> content -> video.
            var selector = [this.dom.outer.id, this.dom.content.id, this.dom.video.id].join(' '),
                el = document.querySelectorAll(selector),
                vidEl;

            // the video tag already exists
            if (el instanceof NodeList && el[0] instanceof HTMLElement && el[0].id) {
                this._checkVideoTagAttributes(el);
                return;
            }

            // Second, search for outer container -> video.
            selector = [this.dom.outer.id, this.dom.video.id].join(' ');
            el = document.querySelectorAll(selector);

            if (el instanceof NodeList && el[0] instanceof HTMLElement) {

                if (el[0].id) {
                    return;
                }

                el[0].id = this.dom.video.id;
                this.dom.content.el.appendChild(el[0]);
                return;
            }

            // Lastly, create the video element.
            vidEl = this._getOrCreateElement('video');

            this._checkVideoTagAttributes(vidEl);
            this.dom.content.el.appendChild(vidEl);
            this.dom.video.el = vidEl;
        },

        /**
         * @memberof uvpjs.DOMManager#
         * @private
         */
        _createPlaceholderContent: function() {
            var vidEl = this.dom.video.el;

            uvpjs.log(this.DEBUG_ID, '_createPlaceholderContent');

            this.dom.video.url = this.mc.getPreferredPlaceholderURL();

            // TODO - is this hack still valid? what is this doing?
            // 3/6/2014 Hack for CBS Sports development, allows iPhones to insert a blank video.
            if (this._useSeparateTags || (_.isNull(this._userAgent) && this.mc.isIPhone())) {
                vidEl.innerHTML = '<source src="'+ this.dom.video.url + '">';
            }
            else {
                vidEl.src = this.dom.video.url;
            }

            // Bind the callback for all addEventListener methods.
            //
            // Note: Using this._handleEvent.bind(this) creates a new function, so
            // you can't remove the event listener unless the new bound function is
            // declared beforehand and passed to each removeEventListener method.

            this._handleEvent = this._handleEvent.bind(this);

            vidEl.addEventListener(this.LOADED_METADATA, this._handleEvent, false); // listen to this to support IMA ads
            vidEl.addEventListener(this.CAN_PLAY_THROUGH, this._handleEvent, false);
            vidEl.addEventListener(this.CAN_PLAY, this._handleEvent, false);
            vidEl.addEventListener(this.PLAY, this._handleEvent, false);
            vidEl.addEventListener(this.PAUSE, this._handleEvent, false);

            vidEl.style.width = '100%'; // Don't flow outside the container.

            this._DOMReadyCB();
        },

        /**
         * Special case to handle video events while a blank video is being loaded.
         * @memberof uvpjs.DOMManager#
         * @private
         *
         * @param {Event} e - Event object.
         */
        _handleEvent: function(e) {
            var vidEl = this.dom.video.el;

            this.debug && uvpjs.log(this.DEBUG_ID, '_handleEvent', e);

            if (_.isNull(vidEl)) {
                return;
            }

            var el = this._useSeparateTags ? vidEl.getElementsByTagName('source')[0] : vidEl;

            if (_.isNull(el)) {
                return;
            }

            if (e.type === this.LOADED_METADATA) {

                this.debug && uvpjs.log(this.DEBUG_ID, '_handleEvent this._areAdsRequired, this._useSeparateTags', this._areAdsRequired, this._useSeparateTags);

                if (this._createAds && this._useSeparateTags) {
                    // TODO: Not sure what needs to go in here based on Hi5 code. ima.startAds()?
                }

                this.debug && uvpjs.log(this.DEBUG_ID, 'removeEventListener', this.LOADED_METADATA, e.target);
                vidEl.removeEventListener(this.LOADED_METADATA, this._handleEvent, false);
            }

            // Check indexOf to support protocol-less blank url.
            if (el.src.indexOf(this.dom.video.url) === -1) {
                vidEl.removeEventListener(this.LOADED_METADATA, this._handleEvent, false);
                vidEl.removeEventListener(this.CAN_PLAY_THROUGH, this._handleEvent, false);
                vidEl.removeEventListener(this.CAN_PLAY, this._handleEvent, false);
                vidEl.removeEventListener(this.PLAY, this._handleEvent, false);
                vidEl.removeEventListener(this.PAUSE, this._handleEvent, false);
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'removeEventListener', e.type);

            switch (e.type) {
                case this.CAN_PLAY :
                    vidEl.removeEventListener(this.CAN_PLAY, this._handleEvent, false);
                    vidEl.removeAttribute('controls', '');
                    break;
                case this.CAN_PLAY_THROUGH:
                    vidEl.removeEventListener(this.CAN_PLAY_THROUGH, this._handleEvent, false);
                    break;
                case this.PLAY:
                    vidEl.removeEventListener(this.PLAY, this._handleEvent, false);
                    vidEl.pause();
                    if (!_.isFunction(this.dom.video.callback)) {
                        this.debug && uvpjs.warn(this.DEBUG_ID, 'No video placeholder callback specified.');
                        break;
                    }
                    this.dom.video.callback();
                    break;
                case this.PAUSE:
                    vidEl.removeEventListener(this.PAUSE, this._handleEvent, false);
                    break;
            }
        },

        /**
         * Sets any necessary attributes on the video tag, removes erroneous/potentially undesirable attributes
         * @param {HTMLElement} vidTag
         * @memberof uvpjs.DOMManager#
         * @private
         */
        _checkVideoTagAttributes: function(vidTag) {
            this._useMutedAttribute && vidTag.setAttribute("muted", "muted");
            this._useAutoplayAttribute && vidTag.setAttribute("autoplay", "autoplay");

            this.mc.setVideoForInlinePlay(vidTag, this._useInlinePlayAttribute);
        },

        /**
         * Apply inline styles for `skin: false`.
         * @memberof uvpjs.DOMManager#
         * @private
         */
        _addInlineStyles: function() {
            // Make child elements position relative to this outer container.
            this.dom.outer.el.style.position = 'relative';

            // Fill the width of the outer container.
            this.dom.video.el.style.width = '100%';

            if (!this._createAds) {
                return;
            }

            var adEl = this.dom.ad.el;

            // Height, width, top, and left are necessary when absolutely positioning
            // the ads container underneath the content container, forcing the element
            // to fill out the full outer container area.
            adEl.style.position = 'absolute';
            adEl.style.width = '100%';
            adEl.style.height = '100%';
            adEl.style.left = '0';
            adEl.style.top = '0';
        },


        //////////////////
        // Helpers.
        //

        /**
         * Get an element ID by the id prefix.
         * @memberof uvpjs.DOMManager#
         * @private
         *
         * @param {String} prefix - Element ID prefix.
         */
        _getIdByPrefix: function(prefix) {
            if (_.isNull(prefix)) {
                return;
            }
            return uvpjs.domConstants[prefix] + this.dom.outer.id;
        },

        /**
         * Get or create an element.
         * @memberof uvpjs.DOMManager#
         * @private
         *
         * @param {String} name - Name of the element.
         */
        _getOrCreateElement: function(name) {
            var obj = this.dom[name],
                el = document.getElementById(obj.id);

            if (_.isNull(el)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'Creating element <'+ obj.type +' id="'+ obj.id +'">.');
                el = document.createElement(obj.type);
                el.id = obj.id;
            }

            return el;
        },
    });

    _getDOMObj = function () {
        return {
            outer:          {id: null, el: null},
            content:        {id: null, el: null, type: 'div'},
            video:          {id: null, el: null, type: 'video', url: null, callback: null},
            ad:             {id: null, el: null, type: 'div'},
            controls:       {id: null, el: null, type: 'div'},
        };
    };

}(uvpjs.register('uvpjs')));
/**
 * Created by ldoyle on 8/11/15.
 */
'use strict';

(function (obj) {

    var _ = obj._;
    var NIELSEN_MODULE = 'NielsenTracking_SDK';

    /**
     * Core Video Instance Model Contains:<br>
     * CDO Config Data Object which includes modules, classes, appState and sessionState.<br>
     * Content Video State.<br>
     * Content Playback State.<br>
     * Ad Video State.<br>
     * Ad Playback State.<br>
     * Setters for video and playback state.<br>
     * Allows direct access to video and playback state props.<br>
     * The CDO has its own methods for extracting configuration data. The CVI Model uses those methods as needed to service config data requests.<br>
     * @constructor uvpjs.CVI_Model
     * @extends uvpjs
     */

    obj.CVI_Model = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.CVI_MODEL,

        PREROLL: 'pre',
        MIDROLL: 'mid',
        POSTROLL: 'post',
        ALT_AD_BLOCK_URL: 'https://dai.google.com/ssai/content/{cmsid}/vid/{vid-id}/master.m3u8',
        AD_SETTINGS: 'AdSettings',
        DFP_CMS_ID: 'dfpCmsId',
        VIDEO_PLAYBACK_SETTINGS: 'VideoPlaybackSettings',
        START_BITRATE: 'startBitrate',
        MIN_BITRATE: 'minBitrate',
        MAX_BITRATE: 'maxBitrate',
        LIVE_SYNC_DURATION_COUNT: 'liveSyncDurationCount',
        CAP_LEVEL_TO_PLAYER_SIZE: 'capLevelToPlayerSize',
        DASHJS_FAST_SWITCH_ABR: 'enableDashJSFastSwitchABR',
        TRACKING_CONFIG_OVERRIDES: 'trackingConfigOverrides',

        // Default values - Cloned by CVI_Model to init and re-init model properties. Cloned by Resource Provider children and used to aggregate load data.

        /**
         * Object containing the current content video metadata.
         * @typedef {Object} contentVideoState
         * @property {Array} abrInfo - Contains an array of objects with nominal info about how many levels there are.
         * @property {String} assetURL - URL of the video asset.
         * @property {String} audioPreviewImageUrl - URL of the audio preview image.
         * @property {String} category - From the Platform metadata of RCO.
         * @property {String} cdn - The Content Distribution Network for the current video, typically 'akamai' or 'akamai_hd'.
         * @property {Array} chapterStartTimes - array of chapter start times in seconds.
         * @property {String} closedCaptionDivName - element ID of the closed Captions div
         * @property {String} closedCaptionPath - URL of the closed captions sidecar file.
         * @property {String} closedCaptionType - tbd
         * @property {String} cms - Current Content Management Server.
         * @property {String} cmsRefGuid - platfrom 'guid' prop or RCO cmsRefGuid property.
         * @property {String} contentType - BU-specific label
         * @property {Object} contextMetadata - arbitrary set of name/value pairs supplied by user (in resource cfg)
         * @property {String} contPlayState - Continuous Play State from previdus video, '', 'endcard' or 'endcard_click'.
         * @property {String} copyright - from Platform metadata or RCO
         * @property {Number} defaultBitrate - 0,
         * @property {String} deliveryType - uvpjs.mediaCapabilities.PROGRESSIVE or uvpjs.mediaCapabilities.STREAMING
         * @property {Number} duration - Video duration in seconds.
         * @property {Number} endTime - Video end time in seconds.
         * @property {String} episodeAbstract - from Platform metadata or RCO.
         * @property {Boolean} episodeFlag - from Platform metadata or RCO.
         * @property {String} episodeNumber - from Platform metadata or RCO.
         * @property {String} episodeTitle - from Platform metadata or RCO.
         * @property {String} excludeNielsenTracking - from Platform; default false
         * @property {String} fileType - 'm3u', 'mp4', .
         * @property {Boolean} isAffiliateFeed - false,
         * @property {Boolean} isAutoplay - false,
         * @property {Boolean} isEmbedable - false,
         * @property {Boolean} isGeoRestricted - false,
         * @property {Boolean} isLive - false,
         * @property {Boolean} isMuteAtPlayStart - false,
         * @property {Boolean} isPaidContent - false,
         * @property {Boolean} isResumed - false,
         * @property {Boolean} isFlash - false Set to TRUE if using UVP Flash
         * @property {String} keywords - from Platform metadata.
         * @property {String} mediaId - from Platform metadata.
         * @property {String} overrideAssetURL - Override asset URL used for dynamic variant playlists.
         * @property {String} pid - Platform Public ID.
         * @property {String} restrictionCheckResult.
         * @property {Boolean} sendResumeEvent used in local and global resume cases.
         * @property {Number} elapsedTime - Integer seconds. If not available default to zero.
         * @property {Boolean} showPreroll: false - Boolean. Never show preroll in global resume case. Default true.
         * @property {Number} playedChapterTime - Integer seconds. Derive this from Platform Chapter times or IMA cue points.
         * @property {String} previousSessionId - String, MD5 hash session ID.
         * @property {String} seasonNumber - from Platform metadata.
         * @property {String} seriesTitle - from Platform metadata.
         * @property {Number} sourceHeight - 0.
         * @property {String} sourceOwner.
         * @property {Number} sourceWidth - 0.
         * @property {Number} startTime - 0.
         * @property {Boolean} useWatermark - false.
         * @property {String} videoTitle
         * @property {Boolean} is360 - false.
         * @public
         */
        contentVideoStateDefaults: {
            abrInfo: [],
            assetURL: '',
            audioPreviewImageUrl: '',
            category: '',
            cdn: '',
            chapterStartTimes: [],
            closedCaptionDivName: '',
            closedCaptionPath: '',
            closedCaptionType: '',
            cms: '',
            cmsRefGuid: '',
            contentType: '',
            contextMetadata: null,
            contPlayState: '',
            copyright: '',
            defaultBitrate: 0,
            deliveryType: uvpjs.mediaCapabilities.PROGRESSIVE,
            duration: -1,
            endTime: -1,
            episodeAbstract: '',
            episodeFlag: false,
            episodeNumber: '',
            episodeTitle: '',
            excludeNielsenTracking: false,
            fileType: '',
            isAffiliateFeed: false,
            isAutoplay: false,
            isEmbedable: false,
            isGeoRestricted: false,
            isLive: false,
            isMuteAtPlayStart: false,
            isPaidContent: false,
            isResumed: false,
            isFlash: false,
            keywords: '',
            mediaId: '',
            overrideAssetURL: null,
            pid: '',
            restrictionCheckResult: '',
            liveSyncDurationCount: 3,
            // Global and Local Resume cbs.com
            sendResumeEvent: false,   // Boolean. Used to send resume event after video playback starts.
            elapsedTime: 0,           // Integer seconds. If not available default to zero.
            showPreroll: true,       // Boolean. Never show preroll in global resume case. Default true.
            playedChapterTime: 0,     // Integer seconds. Derive this from Platform Chapter times or IMA cue points.
            previousSessionId: '',    // String, MD5 hash session ID.
            podsToSkip: '',           // String, In Global or Local resume case hold the comma seperated preroll and ad pods indexes that are added to the IMA AdCall. 1 indicates preRoll, 2, indicates midroll 1 etc.

            // Local storage params
            resumePid:'',           // String.
            resumeContentTime:0,    // Integer seconds.
            resumeEpochTime:0,      // Integer seconds.
            resumeSessionId:'',     // String, MD5 hash session ID.

            seasonNumber: '',
            seriesTitle: '',

            sourceHeight: 0,
            sourceOwner: '',
            sourceWidth: 0,
            startTime: 0,
            useWatermark: false,
            videoTitle: '',
            is360: false,
            drm: {
                enabled: false,
                sessionId: null,
                ticket: null,
                fairplay: {
                    appCertURL: null
                },
                dash: {
                    widevineURL: null,
                    playreadyURL: null
                }
            }
        },

        /**
         * Object containing the current content playback metadata.
         * @typedef {Object} contentPlaybackState
         * @property {Array} abrInfo - Contains an array of objects with nominal info about how many levels there are.
         * @property {Number} absoluteStreamTime - Applicable where a single stream exists for ads + content; e.g. DAI
         * @property {Number} averageDroppedFPS -
         * @property {Number} bufferLength -
         * @property {Number} currentMaxBandwidth -
         * @property {Number} currentContentSegment - Integer, 1 - based counter for long form content segments.
         * @property {Number} currentTime - Current video time in seconds.
         * @property {Number} duration - Video duration in seconds. -1 if live.
         * @property {String} errorInfo - Error message string.
         * @property {Object} facadeState - Facade level video state for debugging.
         * @property {String} isAd - Always set to false.
         * @property {Boolean} isHDStreamLive - isHDStreamLive = true for live stream. isHDStreamLive = false for DVR stream.
         * @property {Boolean} isPlayingLive - True: video is playing at the live point of of a live stream. False: video is 'behind' the live point. Default = true. (Duration of a live stream increasing or is the live stream being played as an archive.)
         * @property {Boolean} isSeeking - true if the video is in the middle of a seek.
         * @property {Number} lastPercentageCompleted -
         * @property {Number} lastSecondCompleted -
         * @property {Number} maxBitrate - Used by the dynamic bitrate switching engine to set the maximum level/rendition bitrate (kbps). Set Explicitly. A value of -1 indicates there no explicitly set maximum value.
         * @property {Number} minBitrate - Used by the dynamic bitrate switching engine to set the minimum level/rendition bitrate (kbps). Set Explicitly. A value of -1 indicates there no explicitly set minimum value.
         * @property {Number} liveSyncDurationCount - Used to determine how many segments are buffered at live point.
         * @property {Number} startBitrate - Set at instantiation, this is the bitrate the player was started at. -1 if unset / unknown / invalid.
         * @property {Number} playbackBitrate - // TODO - Implement / Not currently used that I know of. Ask ChrisX About [TJ]
         * @property {Boolean} playbackComplete - Boolean.
         * @property {Boolean} playbackStarted - Boolean.
         * @property {Number} playbackState - Always gets updated with this.contentPlaybackState.playbackState = this.playbackState. Default =  uvpjs.mediaCapabilities.EMPTY.
         * @property {Number} sourceBitrate -
         * @public
         */
        contentPlaybackStateDefaults: {
            abrInfo: [],
            absoluteStreamTime: 0,
            averageDroppedFPS: 0,
            bufferLength: 0,
            currentMaxBandwidth: 0,
            currentContentSegment: 1,
            currentTime: 0,
            duration: -1,
            errorInfo: '',
            facadeState: {},
            isAd: false,
            isHDStreamLive: false,
            isPlayingLive: false,
            isSeeking: false,
            lastPercentageCompleted: 0,
            lastSecondCompleted: 0,
            maxBitrate: this.maxBitrate || -1,
            minBitrate: this.minBitrate || -1,
            startBitrate: this.startBitrate || -1,
            liveSyncDurationCount: this.liveSyncDurationCount || 3,
            playbackBitrate: 0,
            playbackComplete: false,
            playbackStarted: false,
            playbackState: uvpjs.mediaCapabilities.EMPTY,
            sourceBitrate: 0
        },

        /**
         * Object containing the current ad's video metadata.
         * @typedef {Object} adVideoState
         * @property {String} adClipID - Ex. 'pre_0_1', 'mid_1_1', etc.
         * @property {String} adParameters -
         * @property {Integer} adPosition -
         * @property {String} adServerName -
         * @property {String} adType - Ex. 'pre', 'mid', or 'post'
         * @property {String} adVatId -
         * @property {String} adVideoId -
         * @property {String} adVideoTitle -
         * @property {String} adVideoUrl -
         * @property {String} assetURL -
         * @property {String} clickThru -
         * @property {Number|String} creativeId
         * @property {Number} defaultBitrate -
         * @property {String} deliveryType - uvpjs.mediaCapabilities.PROGRESSIVE or uvpjs.mediaCapabilities.STREAMING
         * @property {Number} duration -
         * @property {Boolean} isCustomClickTrackingUsed -
         * @property {Boolean} isLinear -
         * @property {Boolean} isRewindable -
         * @property {Boolean} isVPAID - true when current IMA ad is a VPAID ad. Set in the IMA STARTED event callback using the IMA ad.getContentType() method.
         * @property {Number} sourceHeight -
         * @property {Number} sourceWidth -
         * @property {Number|String} wrapperAdId -
         * @public
         */
        adVideoStateDefaults: {
            adClipID: '',
            adParameters: '',
            adPosition: -1,
            adServerName: '',
            adType: '',
            adVatId: '',
            adVideoId: '',
            adVideoTitle: '',
            adVideoUrl: '',
            assetURL: '',
            clickThru: '',
            creativeId: '',
            defaultBitrate: 0,
            deliveryType: uvpjs.mediaCapabilities.PROGRESSIVE,
            duration: -1,
            isCustomClickTrackingUsed: false,
            isLinear: true,
            isRewindable: false,
            isVPAID: false,
            sourceHeight: 0,
            sourceWidth: 0,
            wrapperAdId: '',
            adAssetUrl: ''
        },

        /**
         * Object containing the current ad playback metadata.
         * @typedef {Object} adPlaybackState
         * @property {Number} currentTime - Current Ad Video time in seconds.
         * @property {Number} absoluteStreamTime - Current stream time in seconds.
         * @property {Number} duration - Duration of the ad in seconds.
         * @property {String} errorInfo - Error message string.
         * @property {String} isAd - Always set to true.
         * @property {Number} lastPercentageCompleted -
         * @property {Number} lastSecondCompleted -
         * @property {Number} playbackBitrate -
         * @property {Boolean} playbackComplete - Boolean
         * @property {Boolean} playbackStarted - Boolean
         * @property {String} playbackState - Always gets updated with this.contentPlaybackState.playbackState = this.playbackState. Default = uvpjs.mediaCapabilities.EMPTY.
         * @property {Number} sourceBitrate -
         * @public
         */
        adPlaybackStateDefaults: {
            currentTime: 0,
            absoluteStreamTime: 0,
            duration: -1,
            errorInfo: '',
            isAd: true,
            lastPercentageCompleted: 0,
            lastSecondCompleted: 0,
            playbackBitrate: 0,
            playbackComplete: false,
            playbackStarted: false,
            playbackState: uvpjs.mediaCapabilities.EMPTY,
            sourceBitrate: 0
        },

        init: function() {
            this.initTime = Date.now();
            this.debug = uvpjs.debug;
            this.vidContId = ''; // Video tag container element id.
            this.cviMgr = {}; // Core Video Instance Manager.
            this.eventsMgr = {}; // Events Manager.
            this.CDO = {}; // Config Data Object - generated by Config Manager and passed to CVI upon instantiation.
            this.sessionOptions = {};

            // Unique MD5 value to identify a video instance.
            this.sessionId = uvpjs.mediaCapabilities.getSessionId();

            // Four large data objects holding Content and Ad state properties.
            this.contentVideoState = {};
            this.adVideoState = {};
            this.contentPlaybackState = {};
            this.adPlaybackState = {};
            this.playbackState = uvpjs.mediaCapabilities.EMPTY;

            // Initialize four main data objects holding content and ad state.
            this.resetAdPlaybackState();
            this.resetAdVideoState();
            this.resetContentPlaybackState();
            this.resetContentVideoState()

            // Common player state properties. Session Level metadata from config or skin.
            this.nativeControls = false;    // Used by the Resource Provider and eventually the Video Facade to remove or include native controls. Set by the skin or Video Control Interface.
            this.volume = 1;                // Player volume. Set in the CONTROL_VOLUME_SET callback onVideoVolumeChange().
            this.isMuted = false;           // Player volume. Set in the CONTROL_MUTE and CONTROL_UNMUTE callbacks onVideoMute() and onVideoUnMute().
            this.useDynamicSwitching = true;//
            this.isFullscreen = false;
            this.startBitrate = -1;      // used by ABR facades to set bitrate of first segment.
            this.maxBitrate = -1;        // used by ABR facades to set bitrate of future segments.
            this.minBitrate = -1;        // used by ABR facades to set bitrate of future segments.
            this.liveSyncDurationCount = 3;
            this.adNum = 0;                         // counts total number of ads played, incremented with this.incrementAdNum(), accessed with myCVIModelRef.getAdNum();
            this.medNum = 0;                        // the total number of unique content plays or replays, incremented with this.incrementMedNum(), accessed with myCVIModelRef.getMedNum();
            this.capLevelToPlayerSize = false;      // default for capLevelToPlayerSize in hls.js should be false
            this.enableDashJSFastSwitchABR = false; //allow buffer overlapping (may increase segments downloaded and thus CDN cost - but should improve QOE metrics).

            // Super important, is the current video an Ad or Content? TODO review initialization in IMA Platform case VS other content cases.
            this.isCurrVideoAd = false; // Used to determine if the currently playing video is Content video or an Ad video. Set in the VIDEO_PROGRESS callback onVideoProgress().

            this.daiStreamId = null;

            this.APM = null; // reference to the current Ads Playlist Manager. Holds ad pod data objects and helper methods.

            // DW page params.
            this.dwPageParams = (window.DW && window.DW.pageParams) || {};

            this.trackingConfigOverrides = null; // trackingConfigOverrides from Player Options.
        },

        /**
         * Core Video Instance Model initialize.
         * @param {String} vidContId - Video container ID for this Core Video Instance.
         * @param {Object} cviMgr - Core Video Instance Manager Reference.
         * @param {Object} CDO - Config Data Object.
         * @param {Object} playerOptions - A copy of the CDO sessionOptions for each player instance.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        initialize: function(vidContId, cviMgr, CDO, playerOptions) {
            if (!_.isString(vidContId) || !_.isObject(cviMgr) || !_.isObject(CDO)) {
                if (this.debug) {
                    uvpjs.error(this.DEBUG_ID, 'initialize ------------------------------- ERROR BAD INITIALIZATION PARAMS RETURN');
                }
                return;
            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'initialize vidContId = ' + vidContId);
            }
            this.vidContId = vidContId;
            this.cviMgr = cviMgr; // OPTIMIZE? Could we just pass in the eventsMgr here? If not, is this instance variable needed?
            this.CDO = CDO;
            this.sessionOptions = playerOptions;
            this.eventsMgr = cviMgr.getEventsMgr();
            this.internalNS = '.' + this.vidContId + '.cvi_model';
            this.addEventListeners();
            this.setAbrMinBitrateFromCDO();
            this.setAbrMaxBitrateFromCDO();
            this.setAbrStartBitrateFromCDO();
            this.setLiveSyncDurationCountFromCDO();
            this.setCapLevelToPlayerSizeFromCDO();
            this.setDashJSFastSwitchABRFromCDO();

            //TODO (djs) understand this more.
            if (this.sessionOptions.capLevelToPlayerSize !== null) {
                this.setCapLevelToPlayerSize(this.sessionOptions.capLevelToPlayerSize);
            }

            if (this.sessionOptions[this.TRACKING_CONFIG_OVERRIDES] !== null) {
                this.trackingConfigOverrides = this.sessionOptions[this.TRACKING_CONFIG_OVERRIDES];
            }

            // Merge Last
            this.mergeCDOData();

        },

        /**
         * Register for Event Manger dispatches.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        addEventListeners: function() {
            // Playback State Events dispatched by the Resource Provider
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.VIDEO_STATE_CHANGE + this.internalNS, this.onVideoStateChange.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.VIDEO_PROGRESS + this.internalNS, this.onVideoProgress.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.CONTROL_VOLUME_SET + this.internalNS, this.onVideoVolumeChange.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.CONTROL_MUTE + this.internalNS, this.onVideoMute.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.CONTROL_UNMUTE + this.internalNS, this.onVideoUnMute.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.CONTROL_FULLSCREEN + this.internalNS, this.onFullscreen.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.RESOURCE_START + this.internalNS, this.onResourceStart.bind(this));

            // CONTEXT_METADATA from VCI public API setPageContextMetadata(contextData)
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.CONTEXT_METADATA + this.internalNS, this.onContextMetadata.bind(this));
        },

        //-------------- EVENT CALLBACKS --------------//

        /**
         * VIDEO_STATE_CHANGE callback. The .payload: object has two properties <code>{newState:uvpjs.mediaCapabilities.PLAYING,isAd:Boolean}</code>. newState is an integer and isAd is a boolean which is true if the video is an ad.
         * newState can be EMPTY:-2, LOADING:-1, STOPPED:0, PLAYING:1, PAUSED:2, BUFFERING:3, DATA_LOADING_ERROR_STATE:130, VIDEO_NOT_AVAILABLE_ERROR_STATE:110, GEO_BLOCK_ERROR_STATE:120
         * NOTE: Current playback state can also be obtained by polling the CVI_Model using getCurrentPlaybackState().
         * @param {Object} evtObj - evtObj.type, evtObj.payload, evtObj.target = target.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        onVideoStateChange: function(evtObj) {
            if (!_.isPlainObject(evtObj) || evtObj.target !== this.vidContId || !_.isNumber(evtObj.payload.newState)) { return; }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'onVideoStateChange  this.vidContId = ' + this.vidContId + ' current this.playbackState = ' + this.playbackState + ' CHANGE TO evtObj.payload.newState = ' + evtObj.payload.newState);
            }

            var newState = evtObj.payload.newState;
            if (newState === uvpjs.mediaCapabilities.EMPTY || newState === uvpjs.mediaCapabilities.LOADING || newState === uvpjs.mediaCapabilities.STOPPED ||
                newState === uvpjs.mediaCapabilities.PLAYING || newState === uvpjs.mediaCapabilities.PAUSED || newState === uvpjs.mediaCapabilities.BUFFERING ) {
                this.playbackState = newState;

                if (this.isCurrVideoAd) {
                    this.adPlaybackState.playbackState = this.playbackState;
                } else {
                    this.contentPlaybackState.playbackState = this.playbackState;
                }
            }
        },

        /**
         * VIDEO_PROGRESS callback. Populates CVI_Model video playback state properties branching if an ad video is playing or not.
         * @param {Object} evtObj - evtObj.type, evtObj.payload, evtObj.target = target.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        onVideoProgress: function(evtObj) {
            var d = evtObj.payload;

            if (evtObj.target !== this.vidContId) return;

            this.isCurrVideoAd = d.isAd;
            this.playbackState = d.playbackState;

            if (this.isCurrVideoAd) {
                // Ad Properties
                this.adPlaybackState.currentTime = d.currentTime;
                this.adPlaybackState.absoluteStreamTime = d.absoluteStreamTime || d.currentTime;
                this.adPlaybackState.duration = d.duration;
                this.adPlaybackState.isAd = true;
                this.adPlaybackState.playbackStarted = d.playbackStarted;
                this.adPlaybackState.playbackComplete = d.playbackComplete;
                this.adPlaybackState.sourceBitrate = d.sourceBitrate;
                this.adPlaybackState.playbackBitrate = d.playbackBitrate;
                this.adPlaybackState.errorInfo = d.errorInfo;
                this.adPlaybackState.lastSecondCompleted = d.lastSecondCompleted;
                this.adPlaybackState.lastPercentageCompleted = d.lastPercentageCompleted;
                this.adPlaybackState.playbackState = this.playbackState;
            }
            else {
                // Content Properties
                this.contentPlaybackState.currentTime = d.currentTime;
                this.contentPlaybackState.absoluteStreamTime = d.absoluteStreamTime || d.currentTime;
                this.contentPlaybackState.duration = this.contentVideoState.duration;
                this.contentPlaybackState.isAd = false;
                this.contentPlaybackState.playbackStarted = d.playbackStarted;
                this.contentPlaybackState.playbackComplete = d.playbackComplete;
                this.contentPlaybackState.sourceBitrate = d.sourceBitrate;
                this.contentPlaybackState.playbackBitrate = d.playbackBitrate;
                this.contentPlaybackState.videoFramerate = d.videoFramerate;
                this.contentPlaybackState.isSeeking = d.isSeeking;
                this.contentPlaybackState.isHDStreamLive = d.isHDStreamLive;
                this.contentPlaybackState.isPlayingLive = d.isPlayingLive;
                this.contentPlaybackState.currentContentSegment = d.currentContentSegment;
                this.contentPlaybackState.currentMaxBandwidth = d.currentMaxBandwidth;
                this.contentPlaybackState.averageDroppedFPS = d.averageDroppedFPS;
                this.contentPlaybackState.lastSecondCompleted = d.lastSecondCompleted;
                this.contentPlaybackState.lastPercentageCompleted = d.lastPercentageCompleted;
                this.contentPlaybackState.bufferLength = d.bufferLength;
                this.contentPlaybackState.switchingMode = (this.useDynamicSwitching === true) ? 'auto' : 'manual';
                this.contentPlaybackState.playbackState = this.playbackState;
                this.contentPlaybackState.facadeState = d.facadeState;
                this.contentPlaybackState.startBitrate = this.startBitrate;
                this.contentPlaybackState.minBitrate = this.minBitrate;
                this.contentPlaybackState.maxBitrate = this.maxBitrate;
                this.contentPlaybackState.liveSyncDurationCount = this.liveSyncDurationCount;
            }
        },

        /**
         * CONTROL_VOLUME_SET callback.
         * @param {Object} evtObj - evtObj.type, evtObj.payload, evtObj.target = target.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        onVideoVolumeChange: function(evtObj) {
            if (!_.isPlainObject(evtObj) || evtObj.target !== this.vidContId || !_.isNumber(evtObj.payload.vol)) {return;}
            this.volume = evtObj.payload.vol;
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'onVideoUnMute ***********************************      onVideoVolumeChange       this.volume now = ', this.volume);
            }
        },

        /**
         * CONTROL_MUTE callback.
         * @param {Object} evtObj - evtObj.type, evtObj.payload, evtObj.target = target.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        onVideoMute: function(evtObj) {
            if (!_.isPlainObject(evtObj) || evtObj.target !== this.vidContId) {return;}
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'onVideoMute ***********************************       onVideoMute          this.isMuted now true;');
            }
            this.isMuted = true;
        },

        /**
         * CONTROL_UNMUTE callback.
         * @param {Object} evtObj - evtObj.type, evtObj.payload, evtObj.target = target.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        onVideoUnMute: function(evtObj) {
            if (!_.isPlainObject(evtObj)  || evtObj.target !== this.vidContId) {return;}
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'onVideoUnMute ***********************************      onVideoUnMute        this.isMuted now false;');
            }
            this.isMuted = false;
        },

        /**
         * CONTROL_FULLSCREEN callback.
         * Toggles the fullscreen attribute of the video player.
         *
         * @param {Object} evtObj - evtObj.type, evtObj.payload = {isFs:Boolean}, evtObj.target = target.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        onFullscreen: function(evtObj) {
            if (!_.isPlainObject(evtObj)  || evtObj.target !== this.vidContId) {return;}
            this.isFullscreen = evtObj.payload.isFs;
        },

        /**
         * CONTEXT_METADATA callback.
         * @param {Object} evtObj - evtObj.type, evtObj.payload, evtObj.target = target.
         * @memberof uvpjs.CVI_Model
         * @returns {undefined} undefined
         */

        onContextMetadata: function(evtObj) {
            if (!_.isPlainObject(evtObj) || evtObj.target !== this.vidContId || !_.isPlainObject(evtObj.target.contextMetadata)) {return;}
            // TODO place this data in the correct place TBD
        },

        /**
         * RESOURCE_START callback. Reset playback state in model.
         *
         * NOTE: Not updating video state here; handled by resource provider.
         *
         * @param {Object} evtObj - Event object payload.
         * @memberof uvpjs.CVI_Model
         */
        onResourceStart: function (evtObj) {
            this.resetAdPlaybackState();
            this.resetContentPlaybackState();
        },

        /**
         * Reset ad playback state to defaults.
         * @memberof uvpjs.CVI_Model#
         */
        resetAdPlaybackState: function () {
            _.assign(this.adPlaybackState, this.adPlaybackStateDefaults);
        },

        /**
         * Reset ad video state to defaults.
         * @memberof uvpjs.CVI_Model#
         */
        resetAdVideoState: function () {
            this.setAdVideoState();
        },

        /**
         * Reset content playback state to defaults.
         * @memberof uvpjs.CVI_Model#
         */
        resetContentPlaybackState: function () {
            _.assign(this.contentPlaybackState, this.contentPlaybackStateDefaults);
        },

        /**
         * Reset content video state to defaults.
         * @memberof uvpjs.CVI_Model#
         */
        resetContentVideoState: function () {
            _.assign(this.contentVideoState, this.contentVideoStateDefaults);
        },

        //-------------- GETTERS --------------// You can also access the property values directly ex: this.myCVIModel.contentVideoState.isLive.

        /**
         * @memberof uvpjs.CVI_Model#
         *
         * @return {Boolean}
         */
        isId3HandlingRequired: function() {
            return this.getConfiguredId3OwnerIds() || this.isNielsenTrackingEnabled();
        },

        /**
         * @memberof uvpjs.CVI_Model#
         *
         * @return {String|null}
         */
        getConfiguredId3OwnerIds: function() {
            var oids = this.CDO.getSessionOption("id3OwnerIds");

            return typeof oids == 'string' && oids.length ? oids : null;
        },

        /**
         * @memberof uvpjs.CVI_Model#
         * @return {boolean}
         */
        isNielsenTrackingEnabled: function() {
            return this.getModule(NIELSEN_MODULE).enabled === true;
        },

        /**
         * @memberof uvpjs.CVI_Model#
         *
         * @param {String} key
         *
         * @return {*|undefined}
         */
        getValueForKey: function(key) {
            var rtnVal = undefined;

            if (key && _.isString(key) && this.hasOwnProperty(key) && !_.isFunction(this[key])) {
                rtnVal = this[key];
            }
            return rtnVal;
        },

        /**
         * Config Module getter.
         * @param {String} name - the name of the module.
         * @memberof uvpjs.CVI_Model
         * @return {Object} The Module.
         * @return {undefined} Undefined if no module is found with that name or if the name param is missing or not a 'string'.
         */

        getModule: function(name) {
            if (!_.isString(name)) {return;}

            return this.CDO.getModule(name);
        },

        /**
         * Config module-param getter.
         * @param {String} moduleName - the name of the module.
         * @param {String} paramName - the name of the param.
         * @memberof uvpjs.CVI_Model
         * @return {Object} The Module.
         * @return {undefined} Undefined if no Module is found with that name or if the name param is missing or not a 'string'.
         */

        getModuleParam: function(moduleName, paramName) {
            if (!_.isString(moduleName) || !_.isString(paramName)) {return;}

            return this.CDO.getModuleParam(moduleName, paramName);
        },

        /**
         * Pass-thru to CDO Config Data Object, returns the modules array.
         * @memberof uvpjs.CVI_Model
         * @returns {Array} Array of config modules from the CDO.
         */

        getModules: function() {
            return this.CDO.getModules();
        },

        /**
         * Pass-thru to Config Data Object
         * @param {String} name - The name of the module.
         * @memberof uvpjs.CVI_Model
         * @returns {Boolean} true if the Module is enabled, false if it isn't enabled.
         */

        isModuleEnabled: function(name) {
            if (!name || !_.isString(name)) {
                return false;
            } else {
                return this.CDO.isModuleEnabled(name);
            }
        },

        /**
         * Pass-thru to Config Data Object
         * @param {String} name - The name of the module.
         * @memberof uvpjs.CVI_Model
         * @returns {Boolean} true if the Module is in UVPC, false if it isn't.
         */

        isModuleSet: function(name) {
            return !uvpjs.util.isEmpty(name) && this.CDO.isModuleSet(name);
        },

        /**
         * @memberof uvpjs.CVI_Model
         * @param key
         * @returns {*|Object}
         */
        getSessionOption: function(key) {
            return key ? this.sessionOptions[key] : null;
        },

        // Config Object Classes

        /**
         * Get a class by name from the Config Data Object
         * @param {String} name - the name of the class
         * @memberof uvpjs.CVI_Model
         * @return {Object} The Module.
         * @return {undefined} Undefined if no Module is found with that name or if the name param is missing or not a 'string'.
         */
        getClass: function(name) {
            if (!_.isString(name)) {return;}
            return this.CDO.getClass(name);
        },

        /**
         * Returns the config object's classes arrays.
         * @memberof uvpjs.CVI_Model
         * @return {Array} - The config object's classes arrays.
         */
        getClasses: function() {
            return this.CDO.getClasses();
        },

        /**
         * Get the value of a class property from a specified class.
         * @param {String} className - the name of the class.
         * @param {String} propertyName - the name of the property.
         * @memberof uvpjs.CVI_Model
         * @return {String} - value of the class property.
         */
        getClassProperty: function(className, propertyName) {
            return this.CDO.getClassProperty(className, propertyName);
        },

        /**
         * Get a class' list array.
         * @param {String} className - the name of the class.
         * @memberof uvpjs.CVI_Model
         * @return {Array} - Array of class names.
         */
        getClassListItems: function(className) {
            return this.CDO.getClassListItems(className);
        },

        /**
         * Get a property values from a class' list item.
         * @param {String} className - the name of the class
         * @param {String} listItemId - the id of the list item
         * @param {String} propertyName - the name of the property
         *
         * @memberof uvpjs.CVI_Model
         *
         * @return {String} - The property value.
         */
        getClassListItemProperty: function(className, listItemId, propertyName) {
            return this.CDO.getClassListItemProperty(className, listItemId, propertyName);
        },

        /**
         * Gets the current ad or content playback state.
         *
         * @memberof uvpjs.CVI_Model
         *
         * @returns {Object} Current playback state object.
         */
        getCurrentPlaybackState: function() {
            return this.isCurrVideoAd ? this.getAdPlaybackState() : this.getContentPlaybackState();
        },

        /**
         * Gets the current ad or content video state.
         *
         * @memberof uvpjs.CVI_Model
         *
         * @returns {Object} Current video state object.
         */
        getCurrentVideoState: function() {
            return this.isCurrVideoAd ? this.getAdVideoState() : this.getContentVideoState();
        },

        /**
         * Content video state getter.
         * @memberof uvpjs.CVI_Model
         * @returns {Object} Content Video State object.
         */

        getContentVideoState: function() {
            var rtnObj = {};
            _.assign(rtnObj, this.contentVideoState);
            return rtnObj;
        },

        /**
         * Ad video state getter.
         * @memberof uvpjs.CVI_Model
         * @returns {Object} Ad Video State object
         */

        getAdVideoState: function() {
            var rtnObj = {};
            _.assign(rtnObj, this.adVideoState);
            return rtnObj;
        },

        /**
         * Content playback state getter.
         * @memberof uvpjs.CVI_Model
         * @returns {Object} Content Playback State object.
         */

        getContentPlaybackState: function() {
            var rtnObj = {};
            _.assign(rtnObj, this.contentPlaybackState);
            return rtnObj;
        },

        /**
         * Ad playback state getter.
         * @memberof uvpjs.CVI_Model
         * @returns {Object}  Ad Playback State object.
         */
        getAdPlaybackState: function() {
            return _.assign({}, this.adPlaybackState);;
        },

        /**
         * Pass through method for the APM to get the number of ad pods.
         * @memberof uvpjs.CVI_Model
         *
         * @return {Number} Number of adPods in the video.
         */
        getNumberOfAdPods: function () {
            if (this.APM) {
                return this.APM.getNumberOfPods();
            }

            return (this.contentVideoState.chapterStartTimes && this.contentVideoState.chapterStartTimes.length) || 0;
        },

        //-------------- SETTERS --------------//

        /**
         * Sets ABR info obtained from a manifest
         * @memberof uvpjs.CVI_Model
         *
         * @param {Array} abrInfoArr
         */
        setAbrInfo: function(abrInfoArr) {
            this.contentVideoState.abrInfo = abrInfoArr;
            this.contentPlaybackState.abrInfo = abrInfoArr;
        },

        /**
         * Sets the ad video state object
         * @param obj
         */
        setAdVideoState: function(obj) {
            this.adVideoState = _.assign({}, this.adVideoStateDefaults, obj || {});
        },

        /**
         * Content Video State setter.
         * @param {object} items - Object with one or more Content video state properties and their new values ex: {partner:'cbs', isAffiliateFeed:false}.
         * @memberof uvpjs.CVI_Model
         */

        setContentVideoStateItems: function (items) {
            this._addItemsToInstanceObj('contentVideoState', items);
        },

        /**
         * Content Playback State setter.
         * @param {object} items - Object with one or more Content playback state properties and their new values ex: {playbackStarted:true, duration:90}.
         * @memberof uvpjs.CVI_Model
         */
        setContentPlaybackStateItems: function (items) {
            this._addItemsToInstanceObj('contentPlaybackState', items);
        },

        /**
         * Ad Video State setter.
         * @param {object} items - Object with one or more Ad video state properties and their new values ex: {partner:'cbs', isAffiliateFeed:false}.
         * @memberof uvpjs.CVI_Model
         */
        setAdVideoStateItems: function (items) {
            this._addItemsToInstanceObj('adVideoState', items);
        },

        /**
         * Ad Playback State setter.
         * @param {object} items - Object with one or more Ad playback state properties and their new values ex: {playbackStarted:true, duration:90}.
         * @memberof uvpjs.CVI_Model
         */
        setAdPlaybackStateItems: function (items) {
            this._addItemsToInstanceObj('adPlaybackState', items);
        },

        /**
         * Called by the ResourceProvider. Removes defaults before forwarding new object to setContentVideoStateItems.
         * @param {object} items - Object with one or more content video state properties and their new values.
         * @memberof uvpjs.CVI_Model
         */
        setNonDefaultContentVideoStateItems: function(items) {
            this.setContentVideoStateItems(this._removeDefaults(items, this.contentVideoStateDefaults));
        },

        /**
         * Called by the ResourceProvider. Removes defaults before forwarding new object to setContentVideoStateItems.
         * @param {object} items - Object with one or more ad video state properties and their new values.
         * @memberof uvpjs.CVI_Model
         */
        setNonDefaultAdVideoStateItems: function(items) {
            this.setAdVideoStateItems(this._removeDefaults(items, this.adVideoStateDefaults));
        },

        /**
         * Called by the IMA Resource Provider everytime a new ad starts.
         * @memberof uvpjs.CVI_Model
         */
        incrementAdNum: function() {
            this.adNum++;
        },

        /**
         * Called by a Resource Provider every time a new content video starts.
         * @memberof uvpjs.CVI_Model
         */
        incrementMedNum: function() {
            this.medNum++;
        },

        /**
         * Get bitrate value from CDO property.
         *
         * @param {String} property
         *
         * @return {Number} Value from the CDO.
         *
         * @memberof uvpjs.CVI_Model#
         *
         * @private
         */
        _getCDOBitrate: function (property) {
            var module = this.VIDEO_PLAYBACK_SETTINGS,
                isEnabled = this.isModuleEnabled(module),
                value = this.getModuleParam(module, property);

            if (!isEnabled || !value) {
                return;
            }

            if (isNaN(value)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Non-number bitrate value from CDO:', value);
                return;
            }

            return +value;
        },

        /**
         * Sets the ABR Start Bitrate using the 'VideoPlaybackSetting' Config Module.
         * @memberof uvpjs.CVI_Model
         *
         */
        setAbrStartBitrateFromCDO: function() {
            var bitrate = this._getCDOBitrate(this.START_BITRATE);

            if (!bitrate) return;

            this.setStartBitrate(Number(bitrate));
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set ABR Start Bitrate from CDO:', bitrate);
        },

        /**
         * Sets the ABR Min Bitrate using the 'VideoPlaybackSetting' Config Module.
         *
         * @memberof uvpjs.CVI_Model
         *
         */
        setAbrMinBitrateFromCDO: function() {
            var bitrate = this._getCDOBitrate(this.MIN_BITRATE);

            if (!bitrate) return;

            this.setMinBitrate(Number(bitrate));
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set ABR Min Bitrate from CDO:', bitrate);
        },

        /**
         * Sets the ABR Max Bitrate using the 'VideoPlaybackSetting' Config Module.
         *
         * @memberof uvpjs.CVI_Model
         *
         */
        setAbrMaxBitrateFromCDO: function() {
            var bitrate = this._getCDOBitrate(this.MAX_BITRATE);

            if (!bitrate) return;

            this.setMaxBitrate(bitrate);
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set ABR Max Bitrate from CDO:', bitrate);
        },

        setLiveSyncDurationCountFromCDO: function() {
            var module = this.VIDEO_PLAYBACK_SETTINGS,
                isEnabled = this.isModuleEnabled(module),
                value = this.getModuleParam(module, this.LIVE_SYNC_DURATION_COUNT);

            if (!isEnabled || !value) {
                return;
            }

            if (isNaN(value)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Non-number duration count value from CDO:', value);
                return;
            }

            this.setLiveSyncDurationCount(value);
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Live Sync Duration Count from CDO:', value);
        },

        /**
         * Sets hls.js capLevelToPlayer size config value from the Config Data Object
         *
         * @memberof uvpjs.CVI_Model
         *
         */
        setCapLevelToPlayerSizeFromCDO: function() {
            var module = this.VIDEO_PLAYBACK_SETTINGS,
                isEnabled = this.isModuleEnabled(module),
                value = this.getModuleParam(module, this.CAP_LEVEL_TO_PLAYER_SIZE);

            if (!isEnabled || typeof value !== 'boolean') {
                return;
            }

            this.setCapLevelToPlayerSize(value);
        },

        /**
         * @memberof uvpjs.CVI_Model
         */
        setDashJSFastSwitchABRFromCDO: function() {
            var module = this.VIDEO_PLAYBACK_SETTINGS,
                isEnabled = this.isModuleEnabled(module),
                value = this.getModuleParam(module, this.DASHJS_FAST_SWITCH_ABR);

            if (!isEnabled || typeof value !== 'boolean') {
                return;
            }

            this.setDashJSFastSwitchABR(value);
        },

        setStartBitrate: function(bitrate) {
            this.startBitrate = bitrate;
            this.setContentPlaybackStateItems({startBitrate: bitrate});
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Start Bitrate:', this.startBitrate)
        },

        setMinBitrate: function(bitrate) {
            this.minBitrate = bitrate;
            this.setContentPlaybackStateItems({minBitrate: bitrate});
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Min Bitrate:', this.minBitrate);
        },

        setMaxBitrate: function(bitrate) {
            this.maxBitrate = bitrate;
            this.setContentPlaybackStateItems({maxBitrate: bitrate});
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Max Bitrate:', this.maxBitrate);
        },

        setLiveSyncDurationCount: function(count) {
            this.liveSyncDurationCount = count;
            this.setContentPlaybackStateItems({liveSyncDurationCount: count});
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Live Sync Duration Count:', this.liveSyncDurationCount);
        },

        /**
         * Sets hls.js capLevelToPlayer size config value directly.
         * NOTE: This method will only be applicable when called before the HLSJS facade is created.
         *
         * @param {Boolean} capLevelToPlayerSize If hls.js capLevelToPlayerSize config should be enabled
         * @memberof uvpjs.CVI_Model
         *
         */
        setCapLevelToPlayerSize: function(capLevelToPlayerSize) {
            this.capLevelToPlayerSize = capLevelToPlayerSize;
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Cap Level To Player Size:', this.capLevelToPlayerSize);
        },


        /**
         * Sets Dash.js FastSwitchABR on or off
         * @param {Boolean}
         * @memberof uvpjs.CVI_Model
         */
        setDashJSFastSwitchABR: function(value) {
            this.enableDashJSFastSwitchABR = value;
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Dash.js FastSwitchABR to: ', this.enableDashJSFastSwitchABR);
        },


        /**
         * Sets useDynamicStreaming for Auto vs Manual ABR switching if avaialbe for stream type.
         * @param {Boolean}
         * @memberof uvpjs.CVI_Model
         */
        setUseDynamicSwitching: function(value) {
            this.useDynamicSwitching = value;
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set useDynamicSwitching to: ', this.useDynamicSwitching);
        },




        //-------------- HELPER METHODS --------------//

        /**
         * Merge-in String data from the ConfigDataObject.
         * @memberof uvpjs.CVI_Model
         */
        mergeCDOData: function() {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'CVI_Model mergeCDOData this.contentVideoState before merge', this.contentVideoState);
            }

            var self = this;

            _.forOwn(this.sessionOptions, function(value, key) {

                // Only accept strings. We don't want to copy across objects or arrays or functions.
                if (!_.isString(value)) {
                    return;
                }

                // Check video state.
                if (_.has(self.contentVideoState, key)) {
                    self.contentVideoState[key] = value;
                    return;
                }

                // Check ad state.
                if (_.has(self.adVideoState, key)) {
                    self.adVideoState[key] = value;
                    return;
                }
            });

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'CVI_Model mergeCDOData this.contentVideoState after merge', this.contentVideoState);
                uvpjs.log(this.DEBUG_ID, 'CVI_Model mergeCDOData      this.adVideoState after merge', this.adVideoState);
            }
        },


        //////////////////
        // Private

        /**
         * Returns object with default values removed.
         * @param {object} items - New object to be filtered.
         * @param {object} defaults - Object of default key-values to check against.
         * @memberof uvpjs.CVI_Model
         * @returns {Object} Filtered object with default values removed.
         * @private
         */
        _removeDefaults: function(items, defaults) {
            return _.omitBy(items, function(value, key) { return items[key] === defaults[key]; });
        },

        // todo - might be more efficient to iterate over supplied object here
        /**
         * Add item key-values to instance-level object.
         *
         * @param {String} name Name of object (e.g. adVideoState, adPlaybackState, contentVideoState, contentPlaybackState).
         * @param {Object} items Object of key-value pairs.
         *
         * @private
         *
         * @memberof uvpjs.CVI_Model
         */
        _addItemsToInstanceObj: function (name, items) {
            var obj, key, value;

            obj = this[name];

            if (!obj) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, '_addItemsToInstanceObj instance object named ' + name);
                }
                return;
            }

            if (!_.isObject(items)) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, '_addItemsToInstanceObj `items` is not an object. ', items);
                }
                return;
            }

            if (this.debug) {
                // uvpjs.log(this.DEBUG_ID, '_addItemsToInstanceObj this.' + name + ' items', items);
            }

            for (key in obj) {
                value = items[key];

                if (items.hasOwnProperty(key) && !_.isUndefined(value) && !_.isFunction(value)) {
                    obj[key] = value;
                }
            }
        },
    });

}(uvpjs.register('uvpjs')));

'use strict';

(function (obj) {

    var _ = obj._;

    obj.CodeLoader = uvpjs.Class.subClass({

        /**
         * @constructor uvpjs.CodeLoader
         *
         * @description <span class="class-desc">An XHR-based script Loader</span>
         *
         * @memberof uvpjs.CodeLoader
         */
        init: function() {
            this.debug = uvpjs.debug;
            // uvpjs.log(this.DEBUG_ID, 'init');

            // Shortcut to setUrlProtocol method.
            this._setUrlProtocol = uvpjs.mediaCapabilities.setUrlProtocol;

            this.DEBUG_ID = uvpjs.DebugManager.configParams.CODE_LOADER;
            this.REQUEST_TIMEOUT = 4000;

            this.timeout = 0;
            this.timeoutHandle = 0;
            this.urls = [];
            this.scriptsLoadedCB = {};
        },

        /**
         * @memberof uvpjs.CodeLoader
         *
         * @returns {Undefined} Undefined
         */
        initialize: function() {
            // no impl
        },

        /**
         * Destroy instance
         *
         * @memberof uvpjs.CodeLoader
         */
        destroy: function() {
            this._setUrlProtocol = null;
            this.clearInterval(this.timeoutHandle);
            this.timeoutHandle = null;
        },

        /**
         * Primitive method for dynamically loading a script.
         * @memberof uvpjs.CodeLoader
         *
         * @param {String|Array} urls - URL of the script(s) to load.
         * @param {Function} callback - Callback function to execute after the script is loaded.
         * @param {Integer} timeout - Amount of time in ms allowed to attempt script load. Defaults to this.REQUEST_TIMEOUT.
         *
         * @returns {Undefined} Undefined
         */
        loadScript: function(urls, callback, timeout) {
            var i, n;

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'loadScript urls', urls);
            }

            this.scriptsLoadedCB = callback;
            this.timeout = timeout || this.REQUEST_TIMEOUT;

            if (_.isString(urls)) {
                this.urls.push(urls);
            }

            if (_.isArray(urls)) {
                this.urls = urls;
            }

            n = this.urls.length;

            for (i = 0; i < n; i++) {
                this._getScript(this.urls[i]);
            }
        },

        /**
         * Fetch the script and add it to the DOM.
         * @memberof uvpjs.CodeLoader
         *
         * @param {String} url - URL of the script(s) to load.
         *
         * @returns {Undefined} Undefined
         */
        _getScript: function(url) {

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, '_getScript url', url);
            }

            var self = this;

            var _doCallback = function(url, error) {
                if (!_.isFunction(self._onScriptLoaded) || self._onScriptLoaded.done) {
                    if (self.debug) {
                        uvpjs.warn(self.DEBUG_ID, '_getScript _doCallback callback not a function or already called.');
                    }
                    return;
                }

                self.urls = _.without(self.urls, url);
                self._onScriptLoaded(error);
            };

            var s = document.createElement('script');

            s.src = this._setUrlProtocol(url);
            s.async = true;

            s.onreadystatechange = s.onload = function() {
                if (!s.readyState || /loaded|complete/.test(s.readyState)) {
                    _doCallback(url);
                }
            };

            s.onerror = function(error) {
                uvpjs.error(self.DEBUG_ID, '_getScript ' + error.target.src + ' is not accessible.');
                _doCallback(url, error);
            };

            document.querySelector('head').appendChild(s);

            this.timeoutHandle = setTimeout(function(url) {
                var isLoaded = _.indexOf(self.urls, url) === -1;

                if (!isLoaded) {
                    this.debug && uvpjs.warn(self.DEBUG_ID, '_getScript request timeout');
                    _doCallback(url, 'timeout');
                }
            }.bind(this, url), this.timeout);
        },

        /**
         * Callback each time a script is done loading to the page.
         * @memberof uvpjs.CodeLoader
         */
        _onScriptLoaded: function(error) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, '_onScriptLoaded');
            }

            // Determine if all scripts are loaded.
            var scriptsLoaded = _.isEmpty(this.urls);

            if (this.debug)  uvpjs.log(this.DEBUG_ID, '_onScriptLoaded scriptsLoaded', this.urls);

            if (scriptsLoaded && _.isFunction(this.scriptsLoadedCB)) {
                this.scriptsLoadedCB.done = true;
                this.scriptsLoadedCB(error);
            }
        },


        /**
         * Creates XMLHttpRequest request object for CORS.
         * @param {String} method - http request method (i.e. GET, POST, PUT, DELETE)
         * @param {String} url - http request url
         * @memberof uvpjs.CodeLoader
         * @return {Object} XMLHttpRequest
         */
        createCORSRequest: function(method, url) {
            var xhr = new XMLHttpRequest();

            url = this._setUrlProtocol(url);

            if ('withCredentials' in xhr) {
                // XHR for Chrome/Firefox/Opera/Safari.
                xhr.open(method, url, true);
            } else if (typeof XDomainRequest != 'undefined') {
                // XDomainRequest for IE.
                xhr = new XDomainRequest();
                xhr.open(method, url);
            } else {
                // CORS not supported.
                xhr = false;
            }

            return xhr;
        },

        /**
         * Loads contets of remote URL via XHR
         * @memberof uvpjs.CodeLoader#
         *
         * @param {String} url - url to remove JSON config file.
         * @param {Function} success - event callback on successful fetch.
         * @param {Function} error - event callback on unsuccessful fetch.
         * @param {String} responseType - if specified, will set the responseType property of XHR object
         */
        loadXHR: function(url, success, error, responseType) {
            var xhr, message;

            url = this._setUrlProtocol(url);
            xhr = this.createCORSRequest('GET', url);

            if (xhr === false) {
                message = 'loadXHR CORS not supported for url = ' + url;
                uvpjs.warn(this.DEBUG_ID, message);

                error(xhr);

                return;
            }

            responseType && !uvpjs.util.isEmpty(responseType) && (xhr.responseType = responseType);

            xhr.timeout = this.REQUEST_TIMEOUT;

            xhr.onload = function() {
                if (_.inRange(xhr.status, 200, 400)) {
                    success(xhr);
                    return;
                }
                error(xhr);
            };

            xhr.onerror = function() {
                error(xhr);
            };

            xhr.ontimeout = function() {
                error(xhr);
            };

            xhr.send();
        },

        /**
         * Loads url as XML doc
         * @memberof uvpjs.CodeLoader#
         *
         * @param {String} url
         * @param {Function} success
         * @param {Function} error
         */
        loadXML: function(url, success, error) {
            this.loadXHR(url, success, error, 'document');
        },

        /**
         * Loads url as ArrayBuffer
         * @memberof uvpjs.CodeLoader#
         *
         * @param {String} url
         * @param {Function} success
         * @param {Function} error
         */
        loadArrayBuffer: function(url, success, error) {
            this.loadXHR(url, success, error, 'arraybuffer');
        },

    });

}(uvpjs.register('uvpjs')));
/**
 * Created by ldoyle on 8/11/15.
 */

'use strict';

(function (obj) {

    var _ = obj._;

    /**
     * @constructor uvpjs.CoreVideoInstanceManager
     * @description Each Core Video Instance is controlled by a Core Video Instance Manager.
     * @extends uvpjs
     */

    obj.CoreVideoInstanceManager = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.CORE_VIDEO_INSTANCE,

        init: function(options) {
            var vidContId = options.vidContId;

            if (!options.readyCallback) {
                throw new Error("readyCallback missing from CoreVideoInstanceManager.options");
            }

            this.debug = uvpjs.debug;
            this.vidContId = vidContId;
            this.eventsMgr = options.eventsMgr;
            this.cviModel = new uvpjs.CVI_Model();
            this.RPM = {};
            this.trackingMgr = {};

            this.imaAdDisplayContainer = {};
            this.adsLoader = {};
            this.pauseAdRetriever = null;
            this.contentInitializedForIMA = false;
            this.adVideoDiv = {};
            this.containers = null;

            this.deliveryPluginSvc = null;
            this.readyCallback = options.readyCallback;

            this.cachedOptions = {
                suppressFacadePlay: options.suppressFacadePlay,
                deferLoadingCaptions: options.playerOptions.deferLoadingCaptions
            }

            this.cviModel.initialize(vidContId, this, options.CDO, options.playerOptions);

            this.initialPlaybackInfo = {};

            setTimeout(this.initialize.bind(this), 1);
        },

        /**
         * Each Core Video Instance is controlled by a Core Video Instance Manager.
         * @memberof uvpjs.CoreVideoInstanceManager#
         *
         */
        initialize: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'Checking video delivery plugins... ', this.vidContId);

            this.deliveryPluginSvc = new uvpjs.VideoDeliveryPluginService(this.finishInit.bind(this), this.cviModel);
            this.deliveryPluginSvc.createPlugins();
        },

        /**
         * @memberof uvpjs.CoreVideoInstanceManager#
         * @param {Object}  obj
         * @param {Element} obj.contentVideoDom
         * @param {Element} obj.playerDom
         */
        setContainers: function(obj) {
            if (!this.RPM) {
                throw new Error("Must be called after cviMgr init completes");
            }
            this.RPM.setContainers(obj);
        },

        /**
         * @memberof uvpjs.CoreVideoInstanceManager#
         * @param {boolean} autoplay
         * @param {boolean} muted
         */
        setInitialPlaybackType: function(autoplay, muted) {
            this.initialPlaybackInfo.isAutoplay = autoplay;
            this.initialPlaybackInfo.isMuteAtPlayStart = muted;
        },

        /**
         * @memberof uvpjs.CoreVideoInstanceManager#
         *
         * @param {Object} data
         */
        setContextMetadata: function (data) {
            this.cviModel.contentVideoState.contextMetadata = data || null;
        },

        /**
         * @memberof uvpjs.CoreVideoInstanceManager#
         */
        setPlaybackInfoOnModel: function() {
            this.cviModel.contentVideoState.isAutoplay = this.initialPlaybackInfo.isAutoplay;
            this.cviModel.contentVideoState.isMuteAtPlayStart = this.initialPlaybackInfo.isMuteAtPlayStart;
        },

        /**
         * @memberof uvpjs.CoreVideoInstanceManager#
         * @private
         */
        finishInit: function (p2pClient, multiCdnClient) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'Initializing... ', this.vidContId);
            var o = this.cachedOptions;

            this.RPM = new uvpjs.ResourcePlaylistManager({
                vidContId: this.vidContId,
                suppressFacadePlay: o.suppressFacadePlay,
                p2pClient: p2pClient || null,
                multiCdnClient: multiCdnClient || null,
                deferLoadingCaptions: o.deferLoadingCaptions,
                cviMgr: this
            });

            this.trackingMgr = new uvpjs.TrackingManager({
                vidContId: this.vidContId,
                cviMgr: this
            });

            this.captionsMgr = new uvpjs.CaptionsManager({
                containerId: this.vidContId,
                cviModel: this.cviModel,
                eventsMgr: this.eventsMgr,
                deferLoadingCaptions: o.deferLoadingCaptions
            });

            this.cachedOptions = null;
            this.checkForPauseAd();

            this.deliveryPluginSvc.destroy();
            this.deliveryPluginSvc = null;

            this.readyCallback();
        },

        /**
         * Called by the VCI after initialization and after the skin has been created, if IMA ads are expected to be requested.
         * Creates the shared this.imaAdDisplayContainer and this.adsLoader.
         * @memberof uvpjs.CoreVideoInstanceManager#
         * @return {Undefined}
         */
        constructSharedIMAClasses: function(){
            var callback = this.cviModel.getSessionOption('adBlockerCallback'),
                isBlocked  = !!(callback && callback()),
                evtTypes = this.eventsMgr.eventTypes,
                ei = uvpjs.ErrorInfo,
                imaPresent = window.google && google.ima;

            this.debug && uvpjs.log(this.DEBUG_ID, 'constructSharedIMAClasses; ads blocked =  ' + isBlocked);

            // Ad Block Case
            isBlocked && this.eventsMgr.dispatchEvent(
                evtTypes.AD_BLOCKED,
                {
                    errorInfo: new ei({
                        eventType: evtTypes.AD_BLOCKED,
                        errorCode: ei.errorCodes.AD_BLOCKING_DETECTED,
                        message: ei.messages.AD_BLOCKING_DETECTED,
                        isFatal: false
                    })
                },
                this.vidContId
            );

            // IMA missing due to developer or server error, or a failure to detect ad blocking
            if (!isBlocked && !imaPresent) {
                this.eventsMgr.dispatchEvent(
                    evtTypes.PLAYER_START_ERROR,
                    {
                        errorInfo: new ei({
                            eventType: evtTypes.PLAYER_START_ERROR,
                            errorCode: ei.errorCodes.IMA_SDK_MISSING,
                            message: ei.messages.IMA_SDK_MISSING,
                            isFatal: false
                        })
                    },
                    this.vidContId
                );

                return;
            }
            // If IMA is not present, go no further.
            if (!imaPresent) { return; }

            // Only continue here if no ad blocking and IMA SDK present
            if (!_.isEmpty(this.imaAdDisplayContainer)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'constructSharedIMAClasses RETURN constructSharedIMAClasses already constructed');
                return;
            }

            this.imaAdDisplayContainer = this._createIMAAdDisplayContainer();
            this.imaAdDisplayContainer.initialize();

            this.adsLoader = new google.ima.AdsLoader(this.imaAdDisplayContainer);
            var imaSettings = this.adsLoader.getSettings();
            imaSettings.setAutoPlayAdBreaks(true);//default
            imaSettings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.INSECURE);

            this.adsLoader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdsManagerLoaded.bind(this), false);
            this.adsLoader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR,	this.onAdError.bind(this), false);
        },

        /**
         * Creates the IMA Ad Display Container.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {object} The IMA ad display container returned by the Google IMA SDK or an empty object {}.
         */

        _createIMAAdDisplayContainer: function(){
            var contentVideoDiv, contentVideoTag,
                adClickElement, adDisplayContainer;

            this.debug && uvpjs.log(this.DEBUG_ID, '_createIMAAdDisplayContainer');

            this.adVideoDiv = document.getElementById(uvpjs.domConstants.AD_ID_PREFIX + this.vidContId);

            contentVideoDiv = document.getElementById(uvpjs.domConstants.CONTENT_ID_PREFIX + this.vidContId);
            contentVideoTag = contentVideoDiv.getElementsByTagName('video')[0];

            adClickElement =  document.getElementById(uvpjs.domConstants.AD_LEARNMORE_ID_PREFIX + uvpjs.domConstants.ID_SELECTOR_PREFIX + this.vidContId);
            adDisplayContainer = new google.ima.AdDisplayContainer(this.adVideoDiv, contentVideoTag, adClickElement);

            this.debug && uvpjs.log(this.DEBUG_ID, '_createIMAAdDisplayContainer     adClickElement = ', adClickElement);
            this.debug && uvpjs.log(this.DEBUG_ID, '_createIMAAdDisplayContainer adDisplayContainer = ', adDisplayContainer);

            return adDisplayContainer;
        },

        /**
         *  onAdsManagerLoaded is the this.adsLoader.requestAds(adsRequest) callback.
         *  this.adsLoader.requestAds(adsRequest) is only called in the current IMA Resource Provider which calls back here
         *  and passes event .onAdsManagerLoaded().
         *  @param {Object} adsManagerLoadedEvent - The ad manager loaded event object.
         *
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Undefined} Undefined
         */
        onAdsManagerLoaded: function(adsManagerLoadedEvent) {
            var u = uvpjs.util,
                noRpm = u.isEmpty(this.RPM),
                noRp = u.isEmpty(this.RPM.currRP),
                wrongRp = this.RPM.currRP.getProviderType() !== uvpjs.mediaCapabilities.RP_IMA,
                info;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onAdsManagerLoaded; event = ',  adsManagerLoadedEvent);

            if (noRpm || noRp || wrongRp) {
                info = 'CVI mgr: onAdsManagerLoaded; ';
                info += noRpm ? 'no RPM found' : (noRp ? 'no current RP found' : 'RP not of type RP_IMA');

                this.debug && uvpjs.log(this.DEBUG_ID, info);

                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.AD_ERROR,
                    {
                        errorInfo: new uvpjs.ErrorInfo({
                            eventType: this.eventsMgr.eventTypes.AD_ERROR,
                            errorCode: uvpjs.ErrorInfo.errorCodes.UNEXPECTED_CONDITION,
                            message: uvpjs.ErrorInfo.messages.UNEXPECTED_CONDITION + info,
                            isFatal: false
                        })
                    },
                    this.vidContId
                );

                return;
            }

            this.RPM.currRP.onAdsManagerLoaded(adsManagerLoadedEvent);
        },

        /**
         * Ads Loader Ad Error callback.<br>
         * Passes the error to the IMA Resource Provider onAdError method and does nothing else.
         *
         * @param {Object} adErrorEvent - Object containing ad error state.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        onAdError: function(adErrorEvent) {
            var rpm = !_.isEmpty(this.RPM) && this.RPM,
                currRp = rpm && !_.isEmpty(rpm.currRP) && rpm.currRP;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onAdError; adErrorEvent = ',  adErrorEvent);

            if (!rpm || !currRp) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'CVI.onAdError: this.RPM or this.RPM.currRP is empty; early return');

                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.AD_ERROR,
                    {
                        errorInfo: new uvpjs.ErrorInfo({
                            eventType: this.eventsMgr.eventTypes.AD_ERROR,
                            errorCode: uvpjs.ErrorInfo.errorCodes.UNEXPECTED_CONDITION,
                            message: uvpjs.ErrorInfo.messages.UNEXPECTED_CONDITION +
                                     ' Encountered null ResourcePlaylistManager and/or ResourceProvider',
                            isFatal: false
                        })
                    },
                    this.vidContId
                );

                return;
            }

            typeof currRp.handleAdsLoaderError == 'function' && currRp.handleAdsLoaderError(adErrorEvent);
        },

        /**
         * Destroy the Ads Loader: remove event listeners, destroy adsManager and null out ads manager.
         *
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        destroyIMAAdsLoader: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'destroyIMAAdsLoader this.adsLoader = ',  this.adsLoader);

            if (this.adsLoader){
                this.debug && uvpjs.log(this.DEBUG_ID, ' destroyIMAAdsLoader this.adsLoader  exists so destroy it');

                this.adsLoader.removeEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, this.onAdsManagerLoaded.bind(this), false);
                this.adsLoader.removeEventListener(google.ima.AdErrorEvent.Type.AD_ERROR,	this.onAdError.bind(this), false);
                this.adsLoader = null;
            }
        },

        /**
         * Tell the Resource Playlist manager that a dynamic ad call request has been made.
         * @param {String} adCall - A fully qualified and baked IMA ad call.
         * @memberof uvpjs.CoreVideoInstanceManager#
         */
        loadDynamicAdCall: function(adCall){
            this.debug && uvpjs.log(this.DEBUG_ID, 'loadDynamicAdCall adCall =', adCall);

            this.RPM.loadDynamicAdCall(adCall);
        },

        /**
         * Tell the Resource Playlist manager to end any dynamic ad session in progress
         * @memberof uvpjs.CoreVideoInstanceManager#
         */
        forceDynamicMidrollPodEnd: function() {
            this.RPM.forceDynamicMidrollPodEnd();
        },

        /**
         * Events Manager reference getter.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {object}  Events Manager Reference.
         */

        getEventsMgr: function(){
            return this.eventsMgr;
        },

        /**
         * CVI_Model reference getter.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {object}  CVI_Model Reference.
         */

        getModelRef: function(){
            return this.cviModel;
        },

        // *********          Video Playback Methods        ********* //

        /**
         * Starts video playback.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        // Always initialize the container first for iDevices and Android
        // Initializes the video playback. On mobile platforms, including iOS and Android browsers,
        // first interaction with video playback is only allowed within a user action
        // (a click or tap) to prevent unexpected bandwidth costs.
        // Call this method as a direct result of a user action before starting the ad playback.
        // This method has no effect on desktop platforms and when custom video playback is used.

       // adDisplayContainer.initialize();

        playVideoRequest: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'playVideoRequest this.vidContId = ', this.vidContId);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_PLAY, {}, this.vidContId);
        },

        /**
         * Pauses video playback.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        pauseVideoRequest: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'pauseVideo', this.vidContId);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_PAUSE, {}, this.vidContId);
        },

        /**
         * Move video playback to seekToRealTime where seekToRealTime is the content video time in content 'realtime' seconds.
         * @param {Number} seekToRealTime - Integer seek to video "real" time between 0 and content duration.
         * NOTE: Setting to -1 will attempt a seek to live request.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */
        seekToRequest: function(seekToRealTime){
            this.debug && uvpjs.log(this.DEBUG_ID, 'seekToRequest = ' + seekToRealTime);

            if (_.isNaN(seekToRealTime)){
                this.debug && uvpjs.warn(this.DEBUG_ID, 'invalid seekToRequest value = ' + seekToRealTime);
                return;
            } else if(seekToRealTime === -1) {
                this.seekToLiveRequest();
            }

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_SEEK, {seekTime: seekToRealTime}, this.vidContId);
        },

        /**
         * Move video playback to the live point [live stream only]. If not a live stream do nothing.
         * Note: Duration in HLS live streams is equivalent to video.seekable.end(0).
         * Piggybacks seekToRequest once live point is determined
         */
        seekToLiveRequest: function(){
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'seekToLiveRequest');
            }
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_SEEK_TO_LIVE_POINT, {}, this.vidContId);
        },

        /**
         * Stops playback of current video. todo question: define pauseVideo, stopVideo, clearVideo?
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        stopVideoRequest: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'stopVideoRequest');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_STOP, {}, this.vidContId);
        },

        /**
         * Clears current video. todo question: define pauseVideo, stopVideo, clearVideo?
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        clearVideoRequest: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'clearVideoRequest');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_CLEAR, {}, this.vidContId);
        },

        /**
         * Mute video or capture current volume and set volume to 0.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        muteRequest: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'muteRequest');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_MUTE, {}, this.vidContId);
        },

        /**
         * Unmute the video or return volume to pre-muted level.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        unmuteRequest: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'unmuteRequest');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_UNMUTE, {}, this.vidContId);
        },


        /**
         * Return muted state of player.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Boolean} true is the player is muted, false if the player is not muted.
         */

        getPlayerMuted: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'getPlayerMuted');

            return this.cviModel.isMuted;
        },

        /**
         * Called by the VCI Video Control Interface, dispatches a CONTROL_VOLUME_SET event with the new volume.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @param {Number} newVolume - New volume between 0 and 1.
         * @return {undefined} undefined
         */

        volumeChangeRequest: function(newVolume){
            this.debug && uvpjs.log(this.DEBUG_ID, 'volumeChangeRequest newVolume = ', newVolume);

            if (!_.isNaN(newVolume)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_VOLUME_SET, {vol:newVolume}, this.vidContId);
            }
        },

        /**
         * Current volume getter.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Number} Current volume number >= 0.
         */

        getVolume: function(){
            // uvpjs.log(this.DEBUG_ID, 'getVolume');
            return this.cviModel.volume;
        },

        /**
         * Initiates loading of closed captions file.
         * @param {String} captionsPath - URL string of the closed captions sidecar file.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        loadCaptionsRequest: function(captionsPath){
            this.debug && uvpjs.log(this.DEBUG_ID, 'loadCaptionsRequest captionsPath = ', captionsPath);

            if (_.isString(captionsPath)){    // todo validate as fully qualified url sing regEx
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_LOAD_CAPTIONS, {url:captionsPath}, this.vidContId);// todo decide which API fails should dipatch WARNINGS or ERRORs
            }
        },

        /**
         * Turns on display of closed captions.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        showCaptionsRequest: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'showCaptionsRequest');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_SHOW_CAPTIONS, {}, this.vidContId);
        },

        /**
         * Turns off display of closed captions.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        hideCaptionsRequest: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'hideCaptionsRequest');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_HIDE_CAPTIONS, {}, this.vidContId);
        },

        /**
         * Sets style on closed captions.
         * @param {Array} props - Array of CSS key-value properties.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Undefined} Undefined
         * @public
         */

        setCaptionsStyleRequest: function(props) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'setCaptionsStyleRequest', props);

            // hack for UVP Flash facade
            if (this.cviModel.contentVideoState.isFlash) {
                this.RPM.setCaptionStyle(props);
            }
            else {
                this.captionsMgr.setStyles(props);
            }
        },

        /**
         * Sets cue property for closed captions.
         * @param {String} name - Cue property name.
         * @param {String} value - Cue property value.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Undefined} Undefined
         * @public
         */

        setCaptionsCuePropertyRequest: function(name, value) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'setCaptionsCuePropertyRequest', name, value);

            this.captionsMgr.setCueProperty(name, value);
        },

        /**
         * Gets closed captions style object.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Object} CSS style object.
         * @public
         */

        getCaptionsStyleRequest: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'getCaptionsStyleRequest');

            return this.captionsMgr.getStyles();
        },

        /**
         * Sets width and height of video window. todo -  Do we need this? If x and y are not specified they are set to 0.
         * @param {integer} width - Width to set video player size // may end up getting rid of this..
         * @param {integer} height - Height to set video player size // may end up getting rid of this.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        resizeRequest: function(width, height){
        // resizeRequest: function(width, height, x, y){ // todo are we impelemnting x,y locations?
            this.debug && uvpjs.log(this.DEBUG_ID,('resizeRequest  width = ' + width + '  height = ' + height));

            if (!_.isNaN(width) && !_.isNaN(height) && width >= 0 && height >= 0) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESIZE, {width:width, height:height},this.vidContId);
            }
        },

        /**
         * Turn FullScreen mode on or off.
         * @param {Boolean} onOrOff - true to turn FS on, false to turn FS off.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        fullscreenRequest: function(onOrOff){
            this.debug && uvpjs.log(this.DEBUG_ID, 'fullscreenRequest onOrOff = ', onOrOff);

            if (_.isBoolean(onOrOff)){
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_FULLSCREEN, {isFs:onOrOff},this.vidContId);
            }
        },

        /**
         * Dispatches a USER_GESTURE event
         * @param {String|Array} info - Gesture info array or string event payload. If it is an Array it has the following form: [gestureType, info1, info2, ...].
         * If it is a string it has this form 'event=someEvent&gestval=someGestVal:getValAttribute...' for example'event=autoplay&gestval=autoplay:credit_click'.</p>
         * @memberof uvpjs.CoreVideoInstanceManager
         */

        setUserGesture: function(info){
            this.debug && uvpjs.log(this.DEBUG_ID, 'setUserGesture info = ', info);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.USER_GESTURE,{gestureInfo:info},this.vidContId);
        },

        /**
         * Returns an object containing playback-level state for the currently playing facade.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Object} Object containing playback-level state.
         */

        getCurrentPlaybackState: function(){
            // uvpjs.log(this.DEBUG_ID, 'getCurrentPlaybackState');
            return this.cviModel.getCurrentPlaybackState();
        },

        /**
         * Returns an object containing all video_level state info for the current content resource.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Object} Object containing the video_level state.
         */

        getContentVideoData: function(){
            //uvpjs.log(this.DEBUG_ID, 'getContentVideoData');
            var contentVideoData = this.cviModel.getContentVideoState();
            return contentVideoData;
        },

        /**
         * Returns an object containing all video_level state info for the current ad resource.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {Object} Object containing all video_level state info for the current ad resource.
         */

        getAdVideoData: function(){
            //uvpjs.log(this.DEBUG_ID, 'getAdVideoData');
            var adVideoData = this.cviModel.getAdVideoState();
            return adVideoData;
        },

        /**
         * Returns an string containing the unique player session ID.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @return {String} - Player session ID.
         */

        getPlayerSessionId: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'getPlayerSessionId');
            var sessionId = this.cviModel.sessionId;
            return (sessionId);
        },

        /**
         * Captures page context data.
         * @param {object} contextData - Object containing page context data.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        setPageContextMetadata: function(contextData){
            this.debug && uvpjs.log(this.DEBUG_ID, 'setPageContextMetadata contextData = ', contextData);

            if (_.isPlainObject(contextData)){
                // todo implement  todo validate contextData
            }

        },

        /**
         * Set flag in CVI_Model and tells Resource Provider to tell Video Facade to remove native controls.
         * @Param {Boolean} true - use native controls, false - remove native controls.
         * @memberof uvpjs.CoreVideoInstanceManager
         * @return {undefined} undefined
         */

        setNativeControls: function(onOff) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'setNativeControls onOff = ', onOff);

            if (!_.isBoolean(onOff)) {return;}
            this.cviModel.nativeControls = onOff;
            // todo implement call to Resource Provider to turn on / off native controls if they exist. something like:
            //var curRP = ar curRP = this.RPM.vidContId;
            // var curRP = this.RPM.getCurRP()
            // if (curRP) { curRP.manageNativeControls(); } // which looks at the cviModel.nativeControls bool;
        },


        ////////////////////
        // Pause Ad "Plugin"

        /**
         * @private
         * @memberof uvpjs.CoreVideoInstanceManager
         */
        createPauseAdRetriever: function() {
            var adCallUrl = this.cviModel.getModuleParam("PauseAd", "adcallurl") ||
                            this.cviModel.getModuleParam("PauseAd", "adCallURL") ||
                            this.cviModel.getModuleParam("PauseAd", "adCallUrl");
            var opts = {
                eventsMgr: this.eventsMgr,
                adCallUrl: adCallUrl,
                partner: this.cviModel.getSessionOption("partner"),
                userStatus: this.cviModel.getSessionOption("userStatus"),
                model: this.cviModel,
                vidContId: this.vidContId,
                debugId: this.DEBUG_ID
            };

            if (!adCallUrl) {
                this.debug && uvpjs.warn(this.DEBUG_ID, "PauseAd module enabled with invalid ad call url: " + adCallUrl);
                return;
            }

            if (!uvpjs.PauseAdRetriever) {
                this.debug && uvpjs.warn(this.DEBUG_ID, "Class 'PauseAdRetriever' not loaded; please confirm path.");
                return;
            }

            this.pauseAdRetriever = new uvpjs.PauseAdRetriever(opts);
        },

        /**
         * Check if "pause ad" module is enabled and initialize accordingly
         * (This module enables companion ad display upon user-initiated pause of playback)
         * @private
         * @memberof uvpjs.CoreVideoInstanceManager
         */
        checkForPauseAd: function() {
            var enabled = this.cviModel.isModuleEnabled("PauseAd"),
                path = uvpjs.Configuration.path + 'lib/PauseAdRetriever.js',
                codeLdr;

            if (!enabled) { return; }

            if (!uvpjs.PauseAdRetriever) {
                codeLdr = new uvpjs.CodeLoader();
                codeLdr.loadScript(path, this.createPauseAdRetriever.bind(this));
            }
            else {
                this.createPauseAdRetriever();
            }
        }

    });

}(uvpjs.register('uvpjs')));

(function(obj) {

    obj.ErrorInfo =  uvpjs.Class.subClass({

        /**
         * @constructor uvpjs.ErrorInfo
         * @description Holds error information
         *
         * @param {Object} infoObj                  Object that describes an error
         * @param {Number} infoObj.adInfo           Info extracted from an IMA ad; applies to some AD_ERROR events; may be null
         * @param {Number} infoObj.errorCode        A UVPJS-defined error code (one of ErrorInfo.errorCodes)
         * @param {String} infoObj.eventType        An error type defined in EventsMnager.eventTypes
         * @param {Boolean} infoObj.isFatal         Set to TRUE if error prevents video play
         * @param {String} infoObj.message          A short description of the error
         * @param {String} infoObj.imaErrorCode     IMA error code, if applicable (AD_ERROR only)
         * @param {String} infoObj.imaVastErrorCode IMA VAST error code, if applicable (AD_ERROR only)
         * @param {Number} infoObj.serverCode       An optional server-supplied error code
         * @param {Number} infoObj.hlsjsErrorCode . hls.js specifc error code (HLSJS_PLAYBACK_ERROR only)
         */
        init: function(infoObj) {
            var o = infoObj || {};

            /** @member {Number} */
            this.errorCode = o.errorCode || null;

            /** @member {String} */
            this.eventType = o.eventType || null;

            /** @member {Boolean} */
            this.isFatal = !!o.isFatal;

            /** @member {Number|null} */
            this.imaErrorCode = null;

            /** @member {Number|null} */
            this.imaVastErrorCode = null;

            /** @member {String} */
            this.message = o.message || null;

            this.adInfo = o.adInfo || null;

            /** @member {*} */
            this.serverCode = o.serverCode || null;

            /** @member {Number|null} */
            this.hlsjsErrorCode = null;
        }
    });

    /**
     * Constants defining UVPJS-defined error codes
     * @memberof uvpjs.ErrorInfo
     * @alias uvpjs.ErrorInfo.errorCodes
     *
     * @property {Number} uvpjs.ErrorInfo.errorCodes.AD_BLOCKING_DETECTED
     * @property {Number} uvpjs.ErrorInfo.errorCodes.DAI_STREAM_ERROR
     * @property {Number} uvpjs.ErrorInfo.errorCodes.DASH_START_ERROR
     * @property {Number} uvpjs.ErrorInfo.errorCodes.DYNAMIC_VARIANT_MANIFEST_PARSE_ERROR
     * @property {String} uvpjs.ErrorInfo.errorCodes.FAIRPLAY_APP_CERT_ERROR
     * @property {String} uvpjs.ErrorInfo.errorCodes.FAIRPLAY_LIC_ERROR
     * @property {String} uvpjs.ErrorInfo.errorCodes.FLASH_RELATED_ERROR
     * @property {String} uvpjs.ErrorInfo.errorCodes.FLASH_PLAYBACK_ERROR
     * @property {Number} uvpjs.ErrorInfo.errorCodes.HLSJS_NETWORK_ERROR
     * @property {Number} uvpjs.ErrorInfo.errorCodes.HLSJS_MEDIA_ERROR
     * @property {Number} uvpjs.ErrorInfo.errorCodes.HLSJS_MUX_ERROR
     * @property {Number} uvpjs.ErrorInfo.errorCodes.HLSJS_OTHER_ERROR
     * @property {Number} uvpjs.ErrorInfo.errorCodes.IMA_AD_ERROR
     * @property {Number} uvpjs.ErrorInfo.errorCodes.IMA_SDK_MISSING
     * @property {Number} uvpjs.ErrorInfo.errorCodes.IMA_SCENARIO_UNKNOWN
     * @property {Number} uvpjs.ErrorInfo.errorCodes.INVALID_RESOURCE_FORMAT
     * @property {Number} uvpjs.ErrorInfo.errorCodes.MEDIA_ERR_ABORTED
     * @property {Number} uvpjs.ErrorInfo.errorCodes.MEDIA_ERR_NETWORK
     * @property {Number} uvpjs.ErrorInfo.errorCodes.MEDIA_ERR_DECODE
     * @property {Number} uvpjs.ErrorInfo.errorCodes.MEDIA_ERR_SRC_NOT_SUPPORTED
     * @property {Number} uvpjs.ErrorInfo.errorCodes.RESOURCE_GEOBLOCKED
     * @property {Number} uvpjs.ErrorInfo.errorCodes.RESOURCE_UNAVAILABLE
     * @property {Number} uvpjs.ErrorInfo.errorCodes.SELECTOR_CALL_ERROR
     * @property {String} uvpjs.ErrorInfo.errorCodes.UNEXPECTED_CONDITION
     * @property {String} uvpjs.ErrorInfo.errorCodes.USER_GESTURE_REQUIRED
     */
    obj.ErrorInfo.errorCodes = {
        // PLAYER_START_ERROR
        IMA_SDK_MISSING: 1001, // also applies to VIDEO_START_ERROR
        DAI_SDK_MISSING: 1003,
        IMA_SCENARIO_UNKNOWN: 1002,
        FLASH_RELATED_ERROR: 1003,

        // VIDEO_START_ERROR
        INVALID_RESOURCE_FORMAT: 2000,
        RESOURCE_GEOBLOCKED: 2001,
        RESOURCE_UNAVAILABLE: 2002,
        SELECTOR_CALL_ERROR: 2003,
        DASH_START_ERROR: 2004,
        DYNAMIC_VARIANT_MANIFEST_PARSE_ERROR: 2005,
        USER_GESTURE_REQUIRED: 2006,

        // VIDEO_PLAYBACK_ERROR
        UNSPECIFIED_VIDEO_PLAYBACK_ERROR:  3000,
        MEDIA_ERR_ABORTED: 3001,
        MEDIA_ERR_NETWORK: 3002,
        MEDIA_ERR_DECODE:  3003,
        MEDIA_ERR_SRC_NOT_SUPPORTED: 3004,
        HLSJS_PLAYBACK_ERROR: 3005,
        HLSJS_NETWORK_ERROR: 3006,
        HLSJS_MEDIA_ERROR: 3007,
        HLSJS_MUX_ERROR: 3008,
        HLSJS_OTHER_ERROR: 3009,
        DAI_STREAM_ERROR: 3010,
        FAIRPLAY_APP_CERT_ERROR: 3011,
        FAIRPLAY_LIC_ERROR: 3012,
        FLASH_PLAYBACK_ERROR: 3013,

        // AD_ERROR
        IMA_AD_ERROR: 4000,
        DAI_AD_ERROR: 4002,
        AD_BLOCKING_DETECTED: 4001,
        STUCK_AD_ERROR: 4003,

        // *
        UNEXPECTED_CONDITION: 9000,
    };

    /**
     * Constants defining messages for errors
     * @memberof uvpjs.ErrorInfo
     * @alias uvpjs.ErrorInfo.messages
     *
     * @property {String} uvpjs.ErrorInfo.messages.AD_BLOCKING_DETECTED
     * @property {String} uvpjs.ErrorInfo.messages.DAI_ADPOD_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.DAI_ASSET_URL_ERROR
     * @property {String} uvpjs.ErrorInfo.message.DASH_ERROR_TEMPLATE
     * @property {String} uvpjs.ErrorInfo.messages.DYNAMIC_VARIANT_MANIFEST_PARSE_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.FAIRPLAY_APP_CERT_LOAD
     * @property {String} uvpjs.ErrorInfo.messages.FAIRPLAY_NO_CONTENTID
     * @property {String} uvpjs.ErrorInfo.messages.FAIRPLAY_KEYSYSTEM_NOT_SUPPORTED
     * @property {String} uvpjs.ErrorInfo.messages.FAIRPLAY_CREATE_MEDIAKEYS
     * @property {String} uvpjs.ErrorInfo.messages.FAIRPLAY_CREATE_SESSION
     * @property {String} uvpjs.ErrorInfo.messages.FAIRPLAY_LIC_RESPONSE_CODE
     * @property {String} uvpjs.ErrorInfo.messages.FAIRPLAY_LIC_REQUEST
     * @property {String} uvpjs.ErrorInfo.messages.FAIRPLAY_KEY_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.HLSJS_NETWORK_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.HLSJS_MEDIA_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.HLSJS_MUX_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.HLSJS_OTHER_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.IMA_AD_ERROR_EVENT_RECEIVED
     * @property {String} uvpjs.ErrorInfo.messages.IMA_ADPOD_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.IMA_ADSMGR_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.IMA_AD_START_FAILED
     * @property {String} uvpjs.ErrorInfo.messages.IMA_SCENARIO_UNKNOWN
     * @property {String} uvpjs.ErrorInfo.messages.IMA_SDK_MISSING
     * @property {String} uvpjs.ErrorInfo.messages.INVALID_RESOURCE_FORMAT
     * @property {String} uvpjs.ErrorInfo.messages.MEDIA_ERR_ABORTED
     * @property {String} uvpjs.ErrorInfo.messages.MEDIA_ERR_NETWORK
     * @property {String} uvpjs.ErrorInfo.messages.MEDIA_ERR_DECODE
     * @property {String} uvpjs.ErrorInfo.messages.MEDIA_ERR_SRC_NOT_SUPPORTED
     * @property {String} uvpjs.ErrorInfo.messages.RESOURCE_GEOBLOCKED
     * @property {String} uvpjs.ErrorInfo.messages.RESOURCE_UNAVAILABLE
     * @property {String} uvpjs.ErrorInfo.messages.SELECTOR_CALL_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.UNSPECIFIED_VIDEO_PLAYBACK_ERROR
     * @property {String} uvpjs.ErrorInfo.messages.UNEXPECTED_CONDITION
     * @property {String} uvpjs.ErrorInfo.messages.UNEXPECTED_NULL_VALUE_FOR_AD
     * @property {String} uvpjs.ErrorInfo.messages.UNEXPECTED_ABSENCE_OF_VIDEO
     * @property {String} uvpjs.ErrorInfo.messages.USER_GESTURE_REQUIRED
     */
    obj.ErrorInfo.messages = {
        AD_BLOCKING_DETECTED: "Ad blocking detected; one or more SDKs may be unusable.",
        DAI_ASSET_URL_ERROR: "DAI stream 'loaded' event has no asset url.",
        DASH_ERROR_TEMPLATE: 'dash.js Error. Type = {TYPE}, ID = {ID}, Message = {MESSAGE}',
        DYNAMIC_VARIANT_MANIFEST_PARSE_ERROR: 'Error parsing dynamic variant manifest.',
        FAIRPLAY_APP_CERT_LOAD: 'Request to load FairPlay Application Certificate failed',
        FAIRPLAY_NO_CONTENTID: 'FairPlay URI does not contain ContentId',
        FAIRPLAY_KEYSYSTEM_NOT_SUPPORTED: 'FairPlay Key System(com.apple.fps.1_0) is not supported in this browser',
        FAIRPLAY_CREATE_MEDIAKEYS: 'Could not create WebKit MediaKeys',
        FAIRPLAY_CREATE_SESSION: 'Could not create FairPlay Key Session',
        FAIRPLAY_LIC_RESPONSE_CODE: 'FairPlay getckc request returned an error response code',
        FAIRPLAY_LIC_REQUEST: 'FairPlay getckc request failed',
        FAIRPLAY_KEY_ERROR: 'Failed to load FairPlay key',
        HLSJS_NETWORK_ERROR: "An HLSJS network error occurred: {INFO}",
        HLSJS_MEDIA_ERROR: "An HLSJS media error occurred: {INFO}",
        HLSJS_MUX_ERROR: "An HLSJS mux error occurred: {INFO}",
        HLSJS_OTHER_ERROR: "An HLSJS other error occurred: {INFO}",
        IMA_AD_ERROR_EVENT_RECEIVED: 'An IMA ad error occurred.',
        IMA_ADPOD_ERROR: 'Ad event received but current ad pod is undefined.',
        DAI_ADPOD_ERROR: 'Ad start event received but current ad pod is undefined.',
        IMA_ADSMGR_ERROR: 'google.ima.AdsManager failed to start.',
        IMA_AD_START_FAILED: "Ad load request made but ad start event not received.",
        IMA_SCENARIO_UNKNOWN: 'Possible resource configuration issue.',
        IMA_SDK_MISSING: 'Ad (IMA) SDK is missing.',
        INVALID_RESOURCE_FORMAT: 'Error parsing requested resource.',
        MEDIA_ERR_ABORTED: 'Fetching of resource aborted by user.',
        MEDIA_ERR_NETWORK: 'A network error caused resource to stop being fetched',
        MEDIA_ERR_DECODE: 'A decoding error caused resource to stop being fetched.',
        MEDIA_ERR_SRC_NOT_SUPPORTED: 'Resource format not supported.',
        RESOURCE_GEOBLOCKED: 'Resource is geo-blocked.',
        RESOURCE_UNAVAILABLE: 'Resource PID is expired or otherwise unavailable.',
        SELECTOR_CALL_ERROR: 'Unable to create selector call; possible resource configuration issue.',
        UNSPECIFIED_VIDEO_PLAYBACK_ERROR: "An unspecified video playback error occurred.",
        UNEXPECTED_CONDITION: 'An unexpected condition was encountered.',
        UNEXPECTED_NULL_VALUE_FOR_AD: 'Unexpected null value for ad.',
        UNEXPECTED_ABSENCE_OF_VIDEO: "Unable to locate a video node in SMIL response.",
        USER_GESTURE_REQUIRED: "A user gesture is required to initiate playback."

    };

}(uvpjs.register("uvpjs")));



/* CBSi uvpjs: client-side JS */
'use strict';

(function (obj) {

    var _ = obj._,
        secret = Math.random();


    obj.EventsManager = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.EVENTS_MANAGER,
        sessionStartTime: 0,
        sessionMilliseconds: 0,
        uvpjsClockInterval: 100, // todo Dynamically or manually set interval to shortest required...? would evaluate everytime a callback is added or removed.
        TENTH_SECOND: 100,
        QUARTER_SECOND: 250,
        HALF_SECOND: 500,
        ONE_SECOND: 1000,
        THREE_SECONDS: 3000,
        internalNS: 'EventsManager',

        /**
         * @constructor uvpjs.EventsManager
         * @description Centralized event dispatcher; registers, dispatches, and removes all events in the UVPJS space.
         * Interfaces with the App / Page through the EventsManager class. Controls the UVPJS Master Clock.
         * Registers and removes timed callbacks. Dispatches clock tick events.
         * @param singletonKey - private key used for Singleton creation
         */
        init: function(singletonKey) {
            this.debug = uvpjs.debug;
            // uvpjs.log(this.DEBUG_ID,'Init');

            if (!singletonKey || singletonKey !== secret) {
                if (this.debug) {
                    uvpjs.error(this.DEBUG_ID, 'ERROR: ', 'EventsManager is a Singleton; obtain instance via EventsManager.getInstance().');
                }
                return;
            }

            this.timerCBOs = [];
            /*
             Events table structure
             {
                eventName_1: {
                    ns1: callback1,
                    ns2: callback2 // etc
                },
                eventName_2: {
                    ns1: callback3,
                    ns2: callback4 // etc
                }
             }
             */
            this.registeredEventsTable = {};

            this._startUVPJSClock(this.uvpjsClockInterval);
        },

        /**
         * Destroys this instance
         */
        destroy: function() {
            this.registeredEventsTable = {};
            this.timerCBOs = [];
            uvpjs.EventsManager.destroyInstance();
        },

        /**
         * Register event callbacks.
         * this.registeredEventsTable = ['content_start':[ ns1:callback1, ns2:callback2, ... ], 'content_end':[ ns1:callback3, ns2:callback4, ... ], ...  ]
         * @memberof uvpjs.EventsManager
         * @param {String} evt_ns - One of the EventManger.eventTypes CONST event type strings with jQuery-like namespace string.
         * @param {Function} cb - Bound event callback.
         * @returns {undefined} undefined
         */

        addEventListener: function(evt_ns, cb){
            // validate params
            if (!evt_ns || !_.isString(evt_ns) || !cb || !_.isFunction(cb)) {
                this.dispatchEvent(this.eventTypes.UVPJS_WARNING, {msg:'EventsManager addEventListener MISSING OR MISS-TYPED PARAMS RETURN'}, this.internalNS);

                return;
            }

            // allow nested name spacing, remove the eventType and replace "." with "_" so it can be used as a property name
            var evtNSResult = this._returnValidEvtTypeAndNameSpace(evt_ns);
            if (evtNSResult === false){
                this.dispatchEvent(this.eventTypes.UVPJS_WARNING, {msg:'EventsMgr addEventLr; ivalid namespace ' + evt_ns}, this.internalNS);

                return;
            }
            var evtType = evtNSResult[0];
            var ns = evtNSResult[1];

            // if first listener for this event create the event table
            if(!this.registeredEventsTable[evtType]) {
                this.registeredEventsTable[evtType] = {};
            }

            // Block duplicate callbacks from the same event.namespace
            if(this.registeredEventsTable[evtType][ns]) {
                this.debug && uvpjs.warn(this.DEBUG_ID,'addEventListener  DUPLICATE CALLBACK FOR EVENTTYPE.NS RETURN evtType = ', evtType, ' ns = ', ns );

                return;
            }

            // set the callback in the event table using the namespace as the index:
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID,'addEventListener ADD LISTENER evtType = ', evtType, ' ns = ', ns );
            }
            this.registeredEventsTable[evtType][ns] = cb;
        },

        /**
         * De-register event callbacks.
         * this.registeredEventsTable = ['content_start':[ ns1:callback1, ns2:callback2, ... ], 'content_end':[ ns1:callback3, ns2:callback4, ... ], ...  ]
         * @param {String} evt_ns - one of the EventManger.eventTypes CONST event type strings with a jQuery-like namespace string. For eventType evt_ns removes the callback array with nameSpace ns extracted from the evt_ns argument
         * @memberof uvpjs.EventsManager
         * @returns {undefined} undefined
         */

        removeEventListener: function(evt_ns){
            if (!evt_ns || !_.isString(evt_ns)) {
                this.debug && uvpjs.log(this.DEBUG_ID,'removeEventListener evt_ns MISSING or not a STRING evt_ns = ', evt_ns);
                this.dispatchEvent(this.eventTypes.UVPJS_ERROR, {msg:'EventsManager removeEventListener EventsManager removeEventListener evt_ns MISSING or not a STRING'}, this.internalNS);
                return;
            }
            // allow nested name spacing, remove the eventType and replace "." with "_" so it can be used as a property name
            var evtNSResult = this._returnValidEvtTypeAndNameSpace(evt_ns);
            if (evtNSResult === false){
                this.debug && uvpjs.log(this.DEBUG_ID,'removeEventListener INVALID EVENTTYPE OR BROKEN NAME SPACE evt_ns = ', evt_ns);

                return;
            }
            var evtType = evtNSResult[0];
            var ns = evtNSResult[1];

            // make sure the callback exits before trying to remove it
            if(!this.registeredEventsTable[evtType] || !this.registeredEventsTable[evtType][ns]) {
                this.debug && uvpjs.log(this.DEBUG_ID,'removeEventListener name space not found in this.registeredEventsTable[evtType][ns] evt_ns = ', evt_ns);

                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID,'removeEventListener delete this.registeredEventsTable[evtType][ns]; evt_ns = ', evt_ns);

            delete this.registeredEventsTable[evtType][ns];
        },

        /**
         * Dispatches UVPJS Events.
         * this.registeredEventsTable = ['content_start':[ ns1:callback1, ns2:callback2, ... ], 'content_end':[ ns1:callback3, ns2:callback4, ... ], ...  ]
         * @param {String} evtType one of the EventManger.eventTypes CONST event type strings listed below.
         * @param {Object} (optional) payload  object containing the event specific .payload
         * @param {Object|String} (optional) target  source of the event. In the CVI the .target is the video tag elementID string.
         * @memberof uvpjs.EventsManager
         * @returns {undefined} undefined
         * todo QA - test param error trapping and messaging. test missing evtType, payload, payload.target
         * todo qa - the "return false" cases have been 'unit' tested 8/27/2015.
         */

        dispatchEvent: function(evtType, payload, target){
            var eventObj = {};

            if (!evtType || !_.isString(evtType)) {
                this.dispatchEvent(this.eventTypes.UVPJS_WARNING, {msg:'EventsManager dispatchEvent evtType "' + evtType + '" MISSING, UNDEFINED, or INCORRECT TYPE *EXIT METHOD*'}, this.internalNS);
                return;
            }
            if (!_.isUndefined(payload) && !_.isPlainObject(payload)) {
                this.dispatchEvent(this.eventTypes.UVPJS_WARNING, {msg:'EventsManager dispatchEvent payload IS NOT A PLAIN OBJECT'}, this.internalNS);
                return;
            }
            if (!_.isUndefined(target) && !_.isString(target)) {
                this.dispatchEvent(this.eventTypes.UVPJS_WARNING, {msg:'EventsManager dispatchEvent target IS NOT A STRING'}, this.internalNS);
                return;
            }
            // get the callbacks for this event type
            var callbacks = this.registeredEventsTable[evtType];
            if(!callbacks) {
                //dev this.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'EventsManager.dispatchEvent NO callbacks in this.registeredEventsTable[evtType]    RETURN'}, this.internalNS);
                return;
            }

            // NOTE:  Allow payload to be optional and allow target to be optional.

            // replace missing optional payload and target params
            if (_.isUndefined(payload)){
                payload = {}; // must be an object.
            }
            if (_.isUndefined(target)){
                target = '';
            }

            // populate the Event Object
            eventObj.type = evtType;
            eventObj.payload = payload;
            eventObj.target = target;

            // invoke all callbacks registered for this evtType in this.registeredEventsTable[evtType][ns]
            // loop thru callbacks objects for this particular evtType and dispatch event for each namespace indexed callback [ ns1:callback1, ns2:callback2, ... ]
            for (var nsProp in callbacks) {
                if (callbacks.hasOwnProperty(nsProp)) {
                    callbacks[nsProp](eventObj);
                }
            }
        },

        /**
         * Extracts event type from evt_ns and legal property name string from namespace portion of evt_ns. Legal property name can be any string.
         * Replaces '.' in name space string with '_'.
         * @param {String} evt_ns - one of the EventManger.eventTypes CONST event type strings with jQuery-like namespace string ex: this.cbsiVideoMgr.eventTypes.CONTENT_START + '.SOME_OTHER_NS.thirdLevelNS'
         * @memberof uvpjs.EventsManager
         * @returns {Array} - Returns [evtType, ns] array.
         * @returns {Boolean} - Returns false if the namespace is invalid.
         */

        _returnValidEvtTypeAndNameSpace: function(evt_ns) {
            var rtnArray = [];
            var splt = evt_ns.split(".");
            if (splt.length < 2) {
                return false;
            }
            // allow nested name spacing, remove the eventType and replace "." with "_" so it can be used as a property name
            var evtType = splt[0];
            splt.shift();
            var ns = splt.join('_');
            if (!this._validateEventType(evtType) || ns.indexOf('undefined') > -1) {
                return false;
            }
            rtnArray[0] = evtType;
            rtnArray[1] = ns;
            return rtnArray;
        },

        /**
         * Determines if the eventType is legal.
         * @param {String} evtType Event type to to tested.
         * @memberof uvpjs.EventsManager
         * @returns {Boolean} true if evtType is a legal event type otherwise returns false.
         */

        _validateEventType: function(evtType) {
            var isValid = false;
            var evtTypes = this.eventTypes;
            for(var prop in evtTypes) {
                if(evtTypes.hasOwnProperty(prop)) {
                    if(evtTypes[prop] === evtType) {
                        isValid = true;
                        break;
                    }
                }
            }
            return isValid;
        },


        /**
         * Returns all Events Manager event type string constant properties.
         * @memberof uvpjs.EventsManager
         * @returns {Object} The eventTypes object containing all the event type string constants.
         */

        getAllEventTypes: function() {
            return(this.eventTypes);
        },


        /**
         * video progress, video mile stones (duration tracking), live video timer, error timeouts,caption timing, skin animation timing
         * @param {number} milliSecs interval in milliseconds.
         * @memberof uvpjs.EventsManager
         * @returns {undefined} undefined
         */

        _startUVPJSClock: function(milliSecs) {
            // uvpjs.log(this.DEBUG_ID,'_startUVPJSClock');
            this.sessionStartTime = Date.now();
            this.sessionMilliseconds = 0;   // time since the UVPJS session started, updated on timer ticks = Date.now() - this.sessionStartTime
            if (this.uvpjsClockId != 0) {
                clearInterval(this.uvpjsClockId);
            }
            this.uvpjsClockId = 0;
            this.uvpjsClockId = setInterval(this.uvpClockTick.bind(this), milliSecs);
        },

        /**
         * Stop and clear the UVPJS clock.
         * @memberof uvpjs.EventsManager
         * @returns {undefined} undefined
         */

        destroyUVPJSClock: function() {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID,'destroyUVPJSClock');
            }
            if (this.uvpjsClockId != 0) {
                clearInterval(this.uvpjsClockId);
            }
            this.uvpjsClockId = 0;
        },

        /**
         * Register a callback for a timed event.
         * this.timerCBOs = [{freq: 250, ns: nameSpace, cb: callback1, rptCnt: -1, nextTime: lastTime + freq}, {freq: 100, ns: nameSpace, cb: callback1, rptCnt: -1, nextTime: lastTime + freq}, ...]
         * @param {Number} freq - milliseconds callback frequency.
         * @param {String} ns - jQuery like namespace string used to identify a callback during removeTimedEventCallback.
         * @param {Function} cb - bound timer event callback.
         * @param {Number} optRepeatCount - optional number of times to execute the callback. defaults to -1 meaning repeat forever.
         * @memberof uvpjs.EventsManager
         * @returns {undefined} undefined
         */

        addTimedEventCallback: function(freq, ns, cb, optRepeatCount){
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID,'addTimedEventCallback ns =', ns);
            }

            var callBackObject = {};    // {freq: 250, ns: nameSpace, cb: callback1, rptCnt: -1, nextTime: lastTime + freq}
            var nextTime = 0;           // holds the next time to invoke the callback in epoch milliseconds

            if (!freq || !_.isNumber(freq) || !ns || !_.isString(ns) || !cb || !_.isFunction(cb) || (optRepeatCount && !_.isNumber(optRepeatCount) && (optRepeatCount >=1 || optRepeatCount === -1))) {
                this.dispatchEvent(this.eventTypes.UVPJS_WARNING, {msg:'EventsManager addTimedEventCallback MISSING OR MISS-TYPED PARAMS RETURN'}, this.internalNS);
                return;
            }

            // todo Lower is the timer frequency, upper would be ?

            if (freq < this.uvpjsClockInterval){
                freq = this.uvpjsClockInterval;
            }

            // allow nested name spacing, replace "." with "_" so it can be used as a property name
            var splt = ns.split(".");
            ns = splt.join('_');

            callBackObject = {freq: freq, ns: ns, cb: cb, rptCnt: -1, nextTime: Date.now() + freq};

            if (optRepeatCount) {
                callBackObject.rptCnt = optRepeatCount;
            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID,'addTimedEventCallback ADD Timed Callback freq =', freq);
            }

            this.timerCBOs.push(callBackObject);
        },

        /**
         * De-Register a callback for a timed event.
         * this.timerCBOs = [{freq: 250, ns: nameSpace, cb: callback1, rptCnt: -1, nextTime: lastTime + freq}, {freq: 100, ns: nameSpace, cb: callback1, rptCnt: -1, nextTime: lastTime + freq}, ...]
         * @param {Number} freq - milliseconds callback frequency.
         * @param {String} ns - jQuery like namespace string used to identify a callback during removeTimedEventCallback.
         * @memberof uvpjs.EventsManager
         * @returns {undefined} undefined
         */

        removeTimedEventCallback: function(freq, ns){

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID,'removeTimedEventCallback freq = ', (freq  + ' ns = ' + ns));
            }

            if (!freq || !_.isNumber(freq) || !ns || !_.isString(ns)) {
                this.dispatchEvent(this.eventTypes.UVPJS_WARNING, {msg:'EventsManager removeTimedEventCallback MISSING OR MISS-TYPED PARAMS RETURN'}, this.internalNS);
                return;
            }
            var i;
            var CBO;
            // allow nested name spacing, replace "." with "_" so it can be used as a property name
            var splt = ns.split(".");
            ns = splt.join('_');

            i = this.timerCBOs.length;
            while (i--) {
                CBO = this.timerCBOs[i];

                if (CBO.freq === freq && CBO.ns === ns) {
                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID,'removeTimedEventCallback delete this.timerCBOs[freq][ns]; CBO.freq = ', (CBO.freq  + ' CBO.ns = ' + CBO.ns));
                    }
                    this.timerCBOs.splice(i, 1); // the loop doesn't 'break' so all duplicates will be removed
                }

            }
        },

        /**
         * UVPJS Master Clock Heartbeat.
         * this.timerCBOs = [{freq: 250, ns: nameSpace, cb: callback1, rptCnt: -1, nextTime: lastTime + freq}, {freq: 100, ns: nameSpace, cb: callback1, rptCnt: -1, nextTime: lastTime + freq}, ...]
         * @memberof uvpjs.EventsManager
         * @returns {undefined} undefined
         */

        uvpClockTick: function(){
            this.sessionMilliseconds = Date.now() - this.sessionStartTime;
            var i;
            var CBO;
            var now = Date.now();

            for (i = this.timerCBOs.length -1; i >= 0; i--) {
                CBO = this.timerCBOs[i];

                if (now >= CBO.nextTime) {
                    CBO.cb();   // invoke the callback
                    CBO.nextTime = now + CBO.freq;   // set the time for the next callback

                    // manage repeat count if necessary. '-1' means repeat forever
                    if (CBO.rptCnt !== -1){
                        CBO.rptCnt = CBO.rptCnt - 1;
                        // remove callback if all repeats executed
                        if (CBO.rptCnt === 0){
                            this.timerCBOs.splice(i,1);
                        }
                    }
                }
            }
        },


        /**
         * eventTypes - Object - contains EventsManager event type string constants.
         * @memberof uvpjs.EventsManager
         */

        eventTypes: {

            // Event data object props are {type:eventNameString, payload:{payload object as defined below}, target:eventSourceRef}.

            /**
             * FIRST_GESTURE
             *
             * Events of this type are dispatched when the first touch/click of the Control bar is detected.
             * <p>The <code>payload</code> object has form {isVolumeButton: T/F, isPlayPauseToggle: T/F}.</p>
             * @memberof uvpjs.EventsManager
             */
            FIRST_GESTURE: 'firstGesture',

            /**
             * UVPJS_ERROR
             *
             * Events of this type are dispatched when an internal fatal error is trapped.
             * <p>The <code>payload</code> object has the property msg:'error string...' containing the error string.</p>
             * @memberof uvpjs.EventsManager
             */
            UVPJS_ERROR:'uvpjs_error',

            /**
             * UVPJS_WARNING
             *
             * Events of this type are dispatched when the program encounters something of possible concern.
             * <p>The <code>payload</code> object has the property msg:'warning string...' containing the warning string.</p>
             * @memberof uvpjs.EventsManager
             */
            UVPJS_WARNING:'uvpjs_warning',

            /**
             * Events of this type are dispatched when an IMA ad error is encountered and the ad cannot play.
             * <p>The <code>payload</code> is an empty object {}</p>
             * @memberof uvpjs.EventsManager
             * @public
             */

            NO_AD_CONTENT:uvpjs.EventType.NO_AD_CONTENT,

            PLAYER_DATA_LOADED:'onPlayerDataLoaded',    // superceeded by the new CONTENT_DATA_LOADED event

            /**
             * Events of this type are dispatched by the a Resource Provider after all resource metadata has loaded and right before playback of the resource begins.
             *
             * <p>The <code>payload:{}</code> object has the property <code>{vidState:{videoStateObject}</code> containing </p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            CONTENT_DATA_LOADED:uvpjs.EventType.CONTENT_DATA_LOADED,

            /**
             * Events of this type are dispatched by the a Resource Provider after all resource metadata has loaded and right before playback of the resource begins.
             *
             * * <p>The <code>payload:{}</code> object has the property <code>{vidState:{videoStateObject}</code> containing </p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            RESOURCE_AD_DATA_LOADED:uvpjs.EventType.RESOURCE_AD_DATA_LOADED,


            // Startup events //

            /**
             * Events of this type are dispatched by the Video Manager when initialization and configuration are complete, immediately before the Video Manager Ready callback is invoked.
             * <p>The <code>payload:{}</code> object is an empty placeholder object.
             * @memberof uvpjs.EventsManager
             * @public
             */
            PLAYER_LOADED:uvpjs.EventType.PLAYER_LOADED,

            /**
             * Dispatched when player has initialized (may not be ready for playback at this point, however, if a user gesture is required)
             * payload: VCI instance
             */
            PLAYER_INIT: uvpjs.EventType.PLAYER_INIT,

            /**
             * Events of this type are dispatched each time a SMIL response is loaded from the Platfrom CMS.
             * <p>The <code>data</code> property for an event of this type is an XML object.
             * The XML object will contain the entire contents of the response</p>
             * @memberof uvpjs.EventsManager
             */
            PLATFORM_XML_LOADED:'onPlatformXmlLoaded',


            // RESOURCE PLAYLIST EVENTS //


            /**
             * Events of this type are dispatched by the VideoControlInterface when the the client
             * requests that a Resource Config object be loaded and played immediately.
             *
             * * <p>The <code>payload:{}</code> object has the property <code>{rcObj:ResourceConfigOject}</code> containing a Resource Config object. The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             */
            RESOURCE_LOAD_REQUEST:'resourceLoadRequest',

            /**
             * Events of this type are dispatched by the VideoControlInterface when the client requests that
             * one or more Resource Config Objects be added to the Resource Playlist for later playback.
             *
             * <p>The <code>payload:{}</code> object has the property <code>{rcObjs:[rcObj1, ...]}</code> containing an array of Resource Config objects. The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             */
            RESOURCE_ADD_REQUEST:'resourceAddRequest',

            /**
             * Events of this type are dispatched by the VideoControlInterface when the client requests that
             * one or more Resource Config objects be removed from the Resource Playlist.
             *
             * <p>The <code>payload:{}</code> object has the property <code>{rcObjs:[rcObj1, ...]}</code> containing an array of Resource Config objects. The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            RESOURCE_REMOVE_REQUEST:'resourceRemoveRequest',

            /**
             * Events of this type are dispatched by the VideoControlInterface pause the Resource Playlist.
             *
             * <p>The <code>payload:{}</code> object is an empty placeholder object.  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            RESOURCE_PLAYLIST_PAUSE:'resourcePlaylistPause',

            /**
             * Events of this type are dispatched by the VideoControlInterface to resume the Resource Playlist .
             *
             * <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            RESOURCE_PLAYLIST_RESUME:'resourcePlaylistResume',

            /**
             * Events of this type are dispatched by the VideoControlInterface to stop playback of the currently playing element and advance to next unplayed element in the Resource Playlist.
             *
             * <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            RESOURCE_PLAYLIST_ADVANCE:'resourcePlaylistAdvance',

            /**
             * Events of this type are dispatched by the VideoControlInterface to stop playback of the currently playing element and remove all elements from the Resource Playlist.
             *
             * <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            RESOURCE_PLAYLIST_DESTROY:'resourcePlaylistDestroy',


            // PLATFORM 'PLAYLIST' EVENTS  //


            /**
             * Events of this type are dispatched by the Resource Playlist Manager every time a Resource Provider has commenced playback.
             *
             * <p>The <code>payload:{rco:ResourceConfigObject seed}</code> is the simple Resource Config Object provided by the page to initialize the Resource Provider.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */

            RESOURCE_START:uvpjs.EventType.RESOURCE_START,

            /**
             * Events of this type are dispatched by the Resource Playlist Manager every time a Resource Provider has ended playback.
             *
             * <p>The <code>payload:{rco:rcoObject, playlistLength:Integer}</code> contains an rco which is the simple Resource Config Object that just ended
             * and playlistLength which is the number of un-played Resource Config Objects remaining in the playlist.</p>
             *
             * @memberof uvpjs.EventsManager
             * @public
             */

            RESOURCE_END:uvpjs.EventType.RESOURCE_END,


            // CONTENT AND AD EVENTS //

            /**
             * Events of this type are dispatched every time a content clip has started or resumed after an ad.
             *
             * </p><p>The <code>payload:{contentData:{}}</code> is a Content Data object.</p> The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */

            CONTENT_START:uvpjs.EventType.CONTENT_START,

            /**
             * Events of this type are dispatched every time a content clip has ended or paused before an ad.
             *
             * </p><p>The <code>payload:{contentData:{}}</code> is a Content Data object.</p> The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            CONTENT_END:uvpjs.EventType.CONTENT_END,

            /**
             * Events of this type are dispatched every time an ad clip has been loaded, but not yet started playing.
             *
             * @example Payload for AD_LOADED event
             *  {
             *      payload: {
             *          adCallUrl: 'https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/8264/vaw-can/desktop/test&ciu_szs=300x60,728x90&impl=s&gdfp_req=1&env=vp&output=xml_vmap1&unviewed_position_start=1&url=[referrer_url]&correlator=[timestamp]&cust_params=vid%3D2FE7478A-897C-7FEE-4C84-45E079587729%26partner%3Dcbs%26embed%3D0%26host%3Dlocalhost%26sb%3D0%26cpSession%3D0%26cpPre%3D0&vid=2FE7478A-897C-7FEE-4C84-45E079587729&cmsid=2289&pp=vpaid_js',
             *          adAssetUrl: 'https://s-static.innovid.com/mobileapps/s/js/vpaid/1htmdd?cb=cb86c0c0-fb37-d096-c1d8-56f2930eca0e&deviceid=&ivc=[ecp'
             *      },
             *      target: 'myVideoContainer',
             *      type: 'onAdLoaded'
             *  }
             *
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_LOADED:uvpjs.EventType.AD_LOADED,

            /**
             * Events of this type are dispatched every time an ad request is started
             *
             * @example Payload for AD_REQUEST event
             *  {
             *      payload: {
             *          adCallUrl: 'https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/8264/vaw-can/desktop/test&ciu_szs=300x60,728x90&impl=s&gdfp_req=1&env=vp&output=xml_vmap1&unviewed_position_start=1&url=[referrer_url]&correlator=[timestamp]&cust_params=vid%3D2FE7478A-897C-7FEE-4C84-45E079587729%26partner%3Dcbs%26embed%3D0%26host%3Dlocalhost%26sb%3D0%26cpSession%3D0%26cpPre%3D0&vid=2FE7478A-897C-7FEE-4C84-45E079587729&cmsid=2289&pp=vpaid_js'
             *      },
             *      target: 'myVideoContainer',
             *      type: 'onAdLoaded'
             *  }
             *
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_REQUEST:uvpjs.EventType.AD_REQUEST,

            /**
             * Events of this type are dispatched every time an ad requests returns a successful response
             *
             * @example Payload for AD_RESPONSE event
             *  {
             *      payload: {
             *          adCallUrl: 'https://pubads.g.doubleclick.net/gampad/ads?sz=640x480&iu=/8264/vaw-can/desktop/test&ciu_szs=300x60,728x90&impl=s&gdfp_req=1&env=vp&output=xml_vmap1&unviewed_position_start=1&url=[referrer_url]&correlator=[timestamp]&cust_params=vid%3D2FE7478A-897C-7FEE-4C84-45E079587729%26partner%3Dcbs%26embed%3D0%26host%3Dlocalhost%26sb%3D0%26cpSession%3D0%26cpPre%3D0&vid=2FE7478A-897C-7FEE-4C84-45E079587729&cmsid=2289&pp=vpaid_js'
             *      },
             *      target: 'myVideoContainer',
             *      type: 'onAdResponse'
             *  }
             *
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_RESPONSE:uvpjs.EventType.AD_RESPONSE,

            /**
             * Events of this type are dispatched every time an ad clip has fully buffered and begins playback.
             *
             * </p><p>The <code>payload:{adData:{}}</code> is an Ad Data object.</p> The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_START:uvpjs.EventType.AD_START,

            /**
             * Events of this type are dispatched every time an ad clip has completed playback.<br>
             * </p><p>The <code>payload:{adData:{}}</code> is an Ad Data object.</p> The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_END:uvpjs.EventType.AD_END,

            // VTG-326: Deprecating event; now passing `skipped` boolean with AD_END.
            /**
             * Events of this type are dispatched every time the IMA Ad Plugin dispatches an IMA SKIPPED event.<br>
             * </p><p>The <code>payload:{adData:{}}</code> is an Ad Data object.</p> The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_SKIPPED:uvpjs.EventType.AD_SKIPPED,

            /**
             * Events of this type are dispatched every time the IMA Ad Plugin dispatches an IMA CLICK event.<br>
             * </p><p>The <code>payload:{adData:{}}</code> is an Ad Data object.</p> The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_CLICK:uvpjs.EventType.AD_CLICK,

            /**
             * Events of this type are dispatched every time an ad pod starts.<br>
             * <p>The <code>payload:{adPod:currAdPod}</code> is an Ad Pod Object generated by the Ad Playlist Manager (APM) that contains .startTime, .hasPlayed, .adPodId, .adCount, .podDuration, and .adCallURL. </p>
             * <p>The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_POD_START:uvpjs.EventType.AD_POD_START,

            /**
             * Events of this type are dispatched every time an ad pod ends.<br>
             * <p>The <code>payload:{adPod:currAdPod}</code> is an Ad Pod Object generated by the Ad Playlist Manager (APM) that contains .startTime, .hasPlayed, .adPodId, .adCount, .podDuration, and .adCallURL. </p>
             * <p>The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_POD_END:uvpjs.EventType.AD_POD_END,

            /**
             * Events of this type are dispatched when the <code>sessionOptions.adBlockerCallback()</code> returns <code>true</code><br>
             * <p>The <code>payload:{}</code> is empty. </p>
             * <p>The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            AD_BLOCKED:uvpjs.EventType.AD_BLOCKED,


            // closed caption events //


            /**
             * Events of this type are dispatched every time a new closed captions files associated with a content video has ben successfuly loaded and parsed.
             * <p>The <code>data</code> property for an event of this type an null</p>
             *
             */
            CAPTIONS_READY:'onCaptionsReady',

            /**
             * Events of this type are dispatched every time the UI of the Closed captions plugin is expressly hidden or shown.
             * <p>The <code>data</code> property for an event of this type an Boolean, <code>false</code> when captions have been hidden</p>
             *
             */
            CAPTIONS_DISPLAYED:'onCaptionsDisplayed',

            /**
             * Events of this type are dispatched during content playback at each playhead time that is associated with a unique caption.
             * <p>The <code>data</code> property for an event of this type a String that represnts the text of a given caption</p>
             *
             */
            CAPTION_AVAILABLE:'onCaptionAvailable',

            /**
             * Events of this type are dispatched when closed captions become unavailable, typically during a live stream.
             * <p>The <code>data</code> property for an event of this type an null</p>
             *
             */
            CAPTIONS_UNAVAILABLE:'onCaptionsUnavailable',

            /**
             * Events of this type are dispatched when an error is detected during the process of loading or parsing an captions file.
             * <p>The <code>data</code> property for an event of this type a String that represents the error details</p>
             *
             */
            CAPTIONS_ERROR:'onCaptionsError',

            /**
             * Events of this type are dispatched when a .loadCaptions() Video API method call is made.
             *
             * <p>The <code>payload: {}</code> object has a property <code>{url:"https:www.yyz.com/..."}</code> which is a fully qualified url string for a captions xml file.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_LOAD_CAPTIONS:'controlLoadCaptions',

            /**
             * Events of this type are dispatched when a .showCaptions() Video API method call is made.
             *
             *  <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_SHOW_CAPTIONS:'controlShowCaptions',

            /**
             * Events of this type are dispatched when a .hideCaptions() Video API method call is made.
             *
             * <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_HIDE_CAPTIONS:'controlHideCaptions',


            // tracking events //


            /**
             * Events of this type are dispatched during playback of an Ad when the ad playhead crosses a quartile milestone.
             * <p>The <code>payload: {}</code> object has a property <code>{percent:25, 50, or 75}</code>
             * with 25 corresponding to the first quartile, 50 corresponding to the middle quartile, and 75 corresponding to the third quartile .
             * The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            AD_QUARTILE:'adQuartile',

            /**
             * Events of this type are dispatched during playback of content at interval determined by configuration data provided at session startup.
             * </p><p>The <code>payload:{contentData:{}}</code> is a Content Data object.</p> The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * To obtain the duration info look for CBSI_Video_Info.lastSecondCompleted.</p>
             *
             */
            PLAYBACK_DURATION_RESUME:'playbackDurationResume',

            ///**
            // * Events of this type are dispatched during playback of content and ad videos every 15 seconds for
            // * the first minute of playback and once every minute after that.
            // *
            // * <p>The <code>payload: {}</code> object has a property <code>{TBD:0}</code> which is TBD.
            // *  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
            // *
            // * todo remove <p>The <code>data</code> property for an event of this type a CBSI_Video_Info object.
            // * todo remove  To obtain the duration info look for CBSI_Video_Info.lastSecondCompleted.</p>
            // *
            // */
            //PLAYBACK_DURATION_SECONDS:'playbackDurationSeconds',

            ///**
            // * Events of this type are dispatched during playback of content and ad videos at every 10 percent interval as long as clip duration >= 10.
            // * <p>The <code>data</code> property for an event of this type a CBSI_Video_Info object.
            // * To obtain the duration info look for CBSI_Video_Info.lastPercentageCompleted.</p>
            // *
            // */
            //PLAYBACK_DURATION_PERCENT:'playbackDurationPercent',

            /**
             * Events of this type are dispatched every time a new unique 'segment' starts during a live stream.
             * <p>The <code>data</code> property for an event of this type a CBSI_Video_Info object.</p>
             *
             */
            LIVE_SEGMENT_START:'onLiveSegmentStart',

            /**
             * Events of this type are dispatched every time a new unique 'segment' ends during a live stream.
             * <p>The <code>data</code> property for an event of this type a CBSI_Video_Info object.</p>
             *
             */
            LIVE_SEGMENT_END:'onLiveSegmentEnd',

            /**
             * Events of this type are dispatched during playback of content and ad videos whenever the playback state changes.
             *
             * <p>The <code>payload: {}</code> object has two properties <code>{newState:uvpjs.mediaCapabilities.PLAYING,isAd:Boolean}</code>. newState is an integer and isAd is a boolean which is true if the video is an ad.
             *  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             * // PLAYBACK STATE CONSTANTS  ex: uvpjs.mediaCapabilities.PLAYING </p>
             * EMPTY:                          -2,     // no video is loaded into an element. the element is empty. </p>
             * LOADING:                        -1,     // the video element is loading or intialized loading. </p>
             * STOPPED:                        0,      // the video is stopped (ended state). </p>
             * PLAYING:                        1,      // the video is playing. </p>
             * PAUSED:                         2,      // the video is paused. </p>
             * BUFFERING:                      3,      // the video is buffering. </p>
             * DATA_LOADING_ERROR_STATE:       130, </p>
             * VIDEO_NOT_AVAILABLE_ERROR_STATE:110, </p>
             * GEO_BLOCK_ERROR_STATE:          120, </p>
             *
             * Current playback state can also be obtained by polling the CVI_Model using getCurrentPlaybackState()</p>
             */
            VIDEO_STATE_CHANGE:'onStateChange',


            /**
             * Events of this type are dispatched when the facade video duration changes.
             *
             * <p>The <code>payload: {}</code> object has a properties <code>{duration: this._videoTagRef.duration, currentTime: this._videoTagRef.currentTime}
             *  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             * Events of this type should be listened for to obtain the most accurate video state information.</p>
             *
             *
             */
            VIDEO_DURATION_CHANGE:'onVideoDurationChange',

            /**
             * Events of this type are dispatched during download of video content.
             *
             * <p>The <code>payload: {}</code> object has a property <code>{loaded: amountLoaded}</code> dataObj = {bufferLength: amountLoaded, duration: this.videoTagRef.duration }
             * The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             * Events of this type should be listened for to obtain the most accurate video state information.</p>
             *
             *
             */
            VIDEO_LOADING:'onVideoLoading',

            /**
             * Events of this type are dispatched during playback of content and ad videos every 100 milleseconds.
             *
             * <p>The <code>payload: {}</code> object has a property <code>{videoProgressState:{}}</code> which contains:
             *
             *    var payload = {
                isAd: ,
                duration: currentVideoDuration,
                playbackStarted: false,
                playbackComplete: false,
                sourceBitrate: 0,
                playbackBitrate: 0,
                videoFramerate: 0,
                isSeeking: false,
                isHDStreamLive: false,  // isHDStreamLive = true for live stream.	// isHDStreamLive: false for dvr stream.  //is user at the 'true' live point of a live stream or are they watching 'behind' the live point
                isPlayingLive: false,   // isPlayingLive - is the duration of a live stream increasing or is the live stream being played as an archive // currently unimplemented in mobile web	true -> video is playing at the live point of of a live stream		false-> video is 'behind' the live point. default = true
                currentContentSegment: 1,
                currentMaxBandwidth: 0,
                averageDroppedFPS: 0,
                errorInfo: '',
                lastSecondCompleted: 0,
                lastPercentageCompleted: 0,
                currentTime: 0,
                bufferLength: 0,
                playbackState: uvpjs.mediaCapabilities.EMPTY,   // default value
                facadeState: {}
            };
             *  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             * Events of this type should be listened for to obtain the most accurate video state information.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            VIDEO_PROGRESS:uvpjs.EventType.VIDEO_PROGRESS,

            /**
             * Events of this type are dispatched at content startup in the case where a viewing unfinished content.
             *
             * <p>The <code>payload: {}</code> object has a property <code>{contentTime:0}</code> which is an integer.
             *  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             * The value represents the time in seconds relative to the start of the content at which the video is resuming.</p>
             *
             */
            VIDEO_RESUME:'onVideoResume',

            /**
             * Events of this type are dispatched when playback of content and ad video has completed.
             *
             * <p>The <code>payload: {}</code> object has a property is an empty object.
             *  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             * @memberof uvpjs.EventsManager
             * @public
             */
            VIDEO_DONE:uvpjs.EventType.VIDEO_DONE,

            /**
             * Events of this type are dispatched when an embedded video cuepoint is encountered during video playback.
             * <p>The <code>data</code> property for an event of this type an object contining the cue point payload.</p>
             *
             */
            VIDEO_CUEPOINT:'videoCuepoint',

            /**
             * Events of this type are dispatched when a user-initiated seek is complete.
             *
             * @example Payload for SEEK_DONE event
             *  {
             *      payload: {
             *          seekFromTime: 10,
             *          seekToTime: 50
             *      },
             *      target: 'myVideoContainer',
             *      type: 'seekDone'
             *  }
             *
             */
            SEEK_DONE:'seekDone',


            /////////////////
            // Action Events (dispatchable) - Event actions derived from requests generated by the user (skin, plugin) //


            /**
             * Events of this type are dispatched when a .playVideo() Video API method call is made.
             *
             *  <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_PLAY:'controlPlay',

            /**
             * Events of this type are dispatched when a .pauseVideo() Video API method call is made.
             *
             *  <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_PAUSE:'controlPause',

            /**
             * Events of this type are dispatched when a .stopVideo() Video API method call is made.
             * The video will be stopped and the net connection will be dropped.
             *
             * <p>The <code>payload:{}</code> object is an empty placeholder object.  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             *
             */
            CONTROL_STOP:'controlStop',

            /**
             * Events of this type are dispatched when a .clearVideo() Video API method call is made.
             * The video will be stopped and the net connection will be dropped and the video image will be removed.
             *
             *  <p>The <code>payload:{}</code> object is an empty placeholder object.  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_CLEAR:'controlClear',

            /**
             * Events of this type are dispatched when a .mute() Video API method call is made.
             *
             *  <p>The <code>payload:{}</code> object is an empty placeholder object.  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_MUTE:'controlMute',

            /**
             * Events of this type are dispatched when a .unMute() Video API method call is made.
             *
             * <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_UNMUTE:'controlUnmute',

            /**
             * Events of this type are dispatched when Resource Provider facadeVolumeChange() method is called by a low level video player.
             *
             * <p>The <code>payload: {}</code> object has a property <code>{vol: .5}</code> which is a Number bewteen 0 and 1.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_VOLUME_CHANGE:'controlVolumeChange',

            /**
             * Events of this type are dispatched when a Video API method is called to change the volume.
             * Need another event for setting from API instead of change from facade
             *
             * <p>The <code>payload: {}</code> object has a property <code>{vol: .5}</code> which is a Number bewteen 0 and 1.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_VOLUME_SET:'controlVolumeSet',

            /**
             * Events of this type are dispatched when a .setFullscreen() Video API method call is made.
             *
             * <p>The <code>payload: {}</code> object has a property <code>{isFs: true or false}</code> which is a boolean.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_FULLSCREEN:'controlFullscreen',

            /**
             * Events of this type are dispatched when a .seekTo() Video API method call is made.
             *
             * <p>The <code>payload: {}</code> object has a property <code>{seekTime: 420}</code> which is a Integer representing the requested seek time in seconds.  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_SEEK:'controlSeek',

            /**
             * Events of this type are dispatched when a when a request is made to seek to the live point of a live Akamai-HD stream.
             * The event will have no effect if the stream is not being served as an akamai_HD stream
             *
             *  <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTROL_SEEK_TO_LIVE_POINT:'controlSeekToLivePoint',

            /**
             * Events of this type are dispatched when a preview screen has been clicked or touched.
             *
             *  <p>The <code>payload:{}</code> object is an empty placeholder object.   The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            PREVIEW_BUTTON:'previewButton',


            /**
             * Event dispatched when the diagnostic window close button is pressed.
             *
             * Payload: {e: <HTML DOM Event Object>}
             *
             * @event uvpjs.eventTypes.diagnosticWindowClosed
             */
            DIAGNOSTIC_WINDOW_CLOSE_BUTTON: 'diagnosticWindowCloseButton',

            /**
             * Events of this type communicate user interaction info to UVP tracking classes.
             * <p>The <code>gestureInfo</code> property for an event of this type can be an Array or a String. If it is an Array the form is: ['gestureType', info1, info2, ...].
             * If it is a string the form is 'event=someEvent&gestval=someGestVal:getValAttribute...' for example'event=autoplay&gestval=autoplay:credit_click'.</p>
             *
             * See uvpjs.Type.Gesture for list of all array gestureType constant definitions.
             *
             */
            USER_GESTURE: 'controlGesture',

            /**
             * Events of this type are dispatched when a request is issued to resize the video display rectange of the skin.
             * <p>The <code>payload: {}</code> object has a property <code>{width:width, height:height, x:optional, y:optional}</code> which is a Integer representing the requested seek time in seconds.  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             * If x and y are not specified they are set to 0.</p>
             *
             */
            RESIZE:'resize',

            /**
             * Events of this type are dispatched by the VCI page API method setPageContextMetadata(contextData). Currently used by page to communicate Adobe Heartbeat metadata to Tracking.
             * <p>The <code>payload: {contextMetadata: contextData}</code> object has a property <code>contextMetadata:</code> which is the contextData argument.
             *  The <code>target:'videoContainerID'</code> is a DOM element ID string.</p>
             *
             */
            CONTEXT_METADATA:'contextMetadata',


            // Dynamic bitrate switching requests //

            /**
             * Events of this type are dispatched to request a 'manual' rendition switch from one bitrate to another.
             * <p>The <code>payload:{bitrate: integer or 'up' or 'down'}</code> is either a string with the value 'up' or 'down', or an integer.
             * Bitrate: refers to the bitrate of the rendition requested.
             * 'up' or 'down' will request a switch to the next highest or next lowest rendition (if available).</p>
             *
             */
            SWITCH_REQUEST:'switchRequest',

            /**
             * Events of this type are dispatched to toggle auto dynamic bitrate switching on or off.
             * <p>The <code>payload:{data:true/false}</code> is a Boolean.
             * A value of <code>false</code> tells UVP to only switch bitrates when explicitly requested.
             * A value of <code>true</code> tells UVP to use it's internal switching rules to dictate bitrate switches.</p>
             *
             */
            USE_DYNAMIC_SWITCHING:'useDynamicSwitching',

            /**
             * Events of this type are dispatched to set a maximum bitrate for auto dynamic bitrate switching.
             * <p>The <code>payload:{bitrate:integer}</code> is the reported bitrate of the closest rendition which
             * is not greater than the value requested.</p>
             * <p>NOTE: This value may be different than the one requested if original value is not exact.</p>
             *
             */
            MAXIMUM_BITRATE_ALLOWED:'maximumBitrateAllowed',

            /**
             * Events of this type are dispatched to set a minimum bitrate for auto dynamic bitrate switching.
             * <p>The <code>payload:{bitrate:integer}</code> is the reported bitrate of the closest rendition which
             * is not greater than the value requested.</p>
             * <p>NOTE: This value may be different than the one requested if original value is not exact.</p>
             *
             */
            MINIMUM_BITRATE_ALLOWED:'minimumBitrateAllowed',

            /**
             * Events of this type are dispatched when transition between renditions is initiated.
             *
             * <p>The <code>payload:{bitrate:Number, mode:'auto' or 'manual'}</code> object for an event of this type includes properties for
             * the bitrate of the rendition selected and the current switching mode based on the cviModel.useDynamicSwitching() [translated
             * into 'auto' or 'manual' strings for readability].
             *
             */
            VIDEO_TRANSITION_START:'onVideoTransitionStart',

            /**
             * Events of this type are dispatched when a specific rendition (HLSJS - level) manifest is parsed, prior to fragment requests / playback.
             *
             * <p>The <code>payload:{details: Object}</code> object for an event of this type includes properties for
             * the details for the level as provided by HLSJS. Properties of that object include the fragments, media sequence and the start / end
             * sequence numbers for the fragments in question.
             *
             * More information for HLSJS Level Details Object can be found here: https://github.com/video-dev/hls.js/blob/master/doc/API.md#leveldetails
             *
             */
            LEVEL_LOADED: 'onLevelLoaded',

            /**
             * Events of this type are dispatched when transition between renditions is completed.
             *
             * <p>The <code>payload:{bitrate:Number, mode:'auto' or 'manual'}</code> object for an event of this type includes properties for
             * the bitrate of the rendition selected and the current switching mode based on the cviModel.useDynamicSwitching() [translated
             * into 'auto' or 'manual' strings for readability].
             *
             */
            VIDEO_TRANSITION_COMPLETE:'onVideoTransitionComplete',


            // Model Error events - events thrown at startup that are fatal //


            /**
             * Events of this type are dispatched when data for a particular video can not be loaded.
             *  <p>The <code>payload:{vidOrImg:'video' or 'image'}</code> object for an event is a String and can have the values "image" or "video".</p>
             *
             * @private
             */
            VIDEO_NOT_AVAILABLE:'videoNotAvailable',

            /**
             * Events of this type are dispatched when various neccessary data (content, ad, config, etc.) can not be loaded.
             * <p>The <code>data</code> property for an event of this type is a String that describes the type of data that could not be loaded.</p>
             *
             * @private
             */
            DATA_LOADING_ERROR:'dataLoadingError',

            /**
             * Events of this type are dispatched whenever a video is blocked based on the controls geo location.
             * <p>The <code>payload: {}</code> object has a property <code>{country:''}</code> which is the geo-blocked country name string or ''.
             * <p>The <code>data</code> property for an event of this type is a String that describes the user's country.</p>
             *
             * @private
             */
            VIDEO_GEO_BLOCKED:'videoGeoBlocked',

            /**
             * Events of this type are dispatched whenever a video is blocked based on the users internet service provider.
             * <p>The <code>data</code> property for an event of this type is a String.</p>
             *
             * @private
             */
            VIDEO_ISP_BLOCKED:'videoIspBlocked',

            /**
             * Events of this type are dispatched whenever a video is blocked based on the device being used.
             * <p>The <code>data</code> property for an event of this type is a Boolean.</p>
             *
             * @private
             */
            VIDEO_DEVICE_BLOCKED:'videoDeviceBlocked',

            /**
             * Events of this type are dispatched whenever the data for an ad request can not be loaded.
             * <p>The <code>data</code> property for an event of this type is a String that describes the type of error.</p>
             *
             * @private
             */
            AD_LOAD_ERROR:'adLoadError',

            //Ad Plug-In events//

            /**
             * Dispatched by Ad Plugins when the plugin is about to start playing video ads from an unplayed ad pod.
             * <p>The <code>payload:{} is an empty object.
             *
             */
            AD_PLUGIN_CONTENT_PAUSE_REQUEST:uvpjs.EventType.AD_PLUGIN_CONTENT_PAUSE_REQUEST,

            /**
             * Dispatched by Ad Plugins when the plugin has completed playing all the video ads within a given ad pod.
             * <p>The <code>payload:{} is an empty object.
             *
             */
            AD_PLUGIN_CONTENT_RESUME_REQUEST:uvpjs.EventType.AD_PLUGIN_CONTENT_RESUME_REQUEST,

            /**
             * Event to be dispatched by custom skin manager upon user-activated Pause;
             * results in companion ad retrieval. Since more than one ad image size is returned in the
             * XML response, the event payload must specify the desired image width and height
             * Payload: {width: <IntExpectedImgWidth>, height: <IntExpectedImgHeight>}
             * @event uvpjs.eventTypes.pauseAdRequest
             */
            PAUSE_AD_REQUEST: 'pauseAdRequest',

            /**
             * Event to be dispatched with a payload containing an image url and an ad link; event will be handled
             * by BU custom skin mgt code.
             * Payload: {imgSrc: <StringImgUrl>, clickThru: <StringAdPageUrl>}
             * @event uvpjs.eventTypes.pauseAdLoaded
             */
            PAUSE_AD_LOADED: 'pauseAdLoaded',

            /**
             * Event to be dispatched when the video window resizes.
             *
             * Payload: {e: <HTML DOM Event Object>}
             *
             * @event uvpjs.eventTypes.containerResize
             */
            CONTAINER_RESIZE: 'containerResize',

            /**
             * Dispatched when a setQosMetadata(vendorArray, paramsObj) API call is made by the skin.
             *
             * Payload: {vendorArray: [an array of names of QOS vendors who the metadata is targeting, ie Conviva, MUX, etc], paramsObj: {n1:v1, n2,v2,..} }
             * See uvpjs.Type.QOSVendor.CONVIVA, .AKAMAI, .MUX, .NPAW
             *
             * @event uvpjs.eventTypes.QOSMetadata
             */
            QOS_METADATA: 'QOSMetadata',

            /**
             * Event to be dispatched when the content facade is created.
             *
             * Payload: {e: <HTML DOM Event Object>}
             *
             * @event uvpjs.eventTypes.contentFacadeCreated
             */
            CONTENT_FACADE_CREATED: 'contentFacadeCreated',


            ///////////////////
            //  ERROR EVENTS //
            ///////////////////

            /**
             * Event dispatched upon any ad error; some errors may have originated in IMA SDK and will
             * convey IMA or VAST-specific error codes in addition to internal (UVPJS-defined) error codes.
             * See also uvpjs.ErrorInfo.errorCodes static constants
             * @example Payload for AD_ERROR event (also PLAYER_START_ERROR, VIDEO_START_ERROR, VIDEO_PLAYBACK_ERROR).
             *  {
             *      payload: {
             *          errorInfo: {
             *              eventType: string_event_type (simply echoes event type),
             *              errorCode: number_errorCode (see uvpjs.ErrorInfo.errorCodes)
             *              message: string_error_message,
             *              isFatal: boolean_fatal_indication
             *              serverCode: number_serverCode (a VAST or IMA error enum, may be null)
             *          }
             *      },
             *      target: 'myVideoContainer',
             *      type: 'onAdError'
             *  }
             *
             * @event uvpjs.eventTypes.AD_ERROR
             */
            AD_ERROR: 'adError',

            /**
             * Event dispatched upon (fatal) error encountered during start-up phase of player lifecycle.
             * Payload contains an 'errorInfo' property (documented under AD_ERROR, q.v.). See also
             * uvpjs.ErrorInfo
             *
             * @event uvpjs.eventTypes.PLAYER_START_ERROR
             */
            PLAYER_START_ERROR: 'playerStartError',

            /**
             * Event dispatched upon (fatal) error encountered in a resource request, or following
             * user click of preview button, but prior to commencement of playback. Payload contains an
             * 'errorInfo' property (documented under AD_ERROR, q.v.). See also uvpjs.ErrorInfo.
             *
             * @event uvpjs.eventTypes.VIDEO_START_ERROR
             */
            VIDEO_START_ERROR: 'videoStartError',

            /**
             * Event dispatched upon error encountered during resource (content) playback. Payload contains an
             * 'errorInfo' property (documented under AD_ERROR, q.v.). See also uvpjs.ErrorInfo.
             *
             * @event uvpjs.eventTypes.VIDEO_PLAYBACK_ERROR
             */
            VIDEO_PLAYBACK_ERROR: 'videoPlaybackError',
        }

    });

    // Singleton pattern
    obj.EventsManager._instance = null;

    obj.EventsManager.destroyInstance = function() {
        this._instance = null;
    };

    obj.EventsManager.getInstance = function() {
        if (!this._instance) {
            // note use of private "secret" for singletonKey
            this._instance = new uvpjs.EventsManager(secret);
        }

        return this._instance;
    };

}(uvpjs.register('uvpjs')));


(function (obj) {

    var nielsenOwnerName = 'www.nielsen.com';

    obj.AbstractId3Parser = uvpjs.Class.subClass({

        /**
         * @constructor uvpjs.AbstractId3Parser
         *
         * @param {Object}                  options
         * @param {String}                  options.ownerIdList         private frame owner ids, commad delimieted list
         * @param {Function}                options.dataCallback        method to invoke with parsed metadata
         * @param {Boolean}                 options.findNielsen         if TRUE, will scan for nielsen ID3 tags
         */
        init: function(options) {
            this.findNielsen = options.findNielsen;
            this.dataCallback = options.dataCallback;
            this.ownerIds = this.assembleOwnerIds(options.ownerIdList, this.findNielsen);
            this.idLengths = this.setLengths(this.ownerIds);
            this.totalIds = this.idLengths.length;
        },

        /**
         * @memberof uvpjs.AbstractId3Parser#
         */
        destroy: function() {
            this.dataCallback = null;
        },

        /**
         * Abstract implementation of public method to parse ID3 data
         * @memberof uvpjs.AbstractId3Parser#
         *
         * @param {Array} frames sample frames to process
         */
        parse: function(frames) {
            throw new Error('Abstract method parse() must be implemented in subclass');
        },

        /**
         * Pre-calculate string lengths to speed up parsing
         * @memberof uvpjs.AbstractId3Parser#
         * @private
         *
         * @param ids
         */
        setLengths: function(ids) {
            var i = ids.length,
                out = [];

            while(i--) {
                out[i] = ids[i].length;
            }

            return out;
        },

        /**
         * Create array of owner ids to scan for
         *
         * @private
         *
         * @param {String|null} oids private frame owner ids
         * @param {Boolean}     addNielsen
         */
        assembleOwnerIds: function (oids, addNielsen) {
            var oarr = [], ospl, i;

            if (typeof oids === 'string') {
                ospl = oids.split(',');
                i = ospl.length;

                while(i--) {
                    oarr.push(ospl[i].trim())
                }
            }

            if (addNielsen && oarr.indexOf(nielsenOwnerName) === -1) {
                oarr.push(nielsenOwnerName);
            }

            return oarr;
        }
    });


}(uvpjs.register('uvpjs')));

(function (obj) {

    var nielsenOwnerName = 'www.nielsen.com',
        nielsenDataLength = 249;

    obj.FrameId3Parser = uvpjs.AbstractId3Parser.subClass({

        /**
         * Parse ID3 data frames, and pass back to dataCallback
         * @memberof uvpjs.FrameId3Parser#
         *
         * @param {Array} frames sample frames to process
         */
        parse: function(frames) {
            var n = frames.length, i;

            for (i = 0; i < n; i++) {
                frames[i].data && this.findId3(frames[i]);
            }
        },

        /**
         * Method adapted from HLS library 'ID3' class.
         * @memberof uvpjs.FrameId3Parser#
         * @private
         *
         * @param {Object} frame
         */
        findId3: function(frame) {
            var offset = 0,
                data = frame.data,
                byte1, byte2, byte3, byte4, tagSize, endPos, header;

            header = this.readStr(data, offset, 3);
            offset += 3;

            if (header === 'ID3') {
                // skip 24 bits
                offset += 3;
                // retrieve tag(s) length
                byte1 = data[offset++] & 0x7f;
                byte2 = data[offset++] & 0x7f;
                byte3 = data[offset++] & 0x7f;
                byte4 = data[offset++] & 0x7f;
                tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
                endPos = offset + tagSize;

                this.findId3PrivateFrame(frame, offset, endPos);
            }
        },

        /**
         * Extract ID3 data; method adapted from HLS library 'ID3' class.
         * @memberof uvpjs.FrameId3Parser#
         * @private
         *
         * @param {Object} frame
         * @param {Number} offset
         * @param {Number} endPos
         *
         * @return {String|null}
         *
         */
        findId3PrivateFrame: function (frame, offset, endPos) {
            var data = frame.data,
                tagId, tagLen, tagStart, tagFlags;

            while (offset + 8 <= endPos) {
                tagId = this.readStr(data, offset, 4);
                offset += 4;

                tagLen = data[offset++] << 24 +
                         data[offset++] << 16 +
                         data[offset++] << 8 +
                         data[offset++];

                tagFlags = ( data[offset++] << 8 ) + data[offset++];

                tagStart = offset;

                if (tagId === "PRIV") {
                    this.parseFrame(frame, offset);
                }
            }
        },

        /**
         * @memberof uvpjs.FrameId3Parser#
         * @private
         *
         * @param {Object}  frame
         * @param {Number}      offset
         */
        parseFrame: function(frame, offset) {
            var larr = this.idLengths,
                i = this.totalIds,
                data = frame.data,
                payload, id, strLen;

            while(i--) {
                strLen = larr[i];

                // read owner id from data
                id = this.readStr(data, offset, strLen);

                if (id === this.ownerIds[i]) {
                    offset += strLen;

                    // VTG-294: Note that below, for Nielsen, we retain the null byte separator between
                    // owner id and payload. For all others, we increment the offset to remove the separator.
                    payload = id === nielsenOwnerName ?
                              this.parseNielsen(id, data, offset) :
                              this.readStr(data, ++offset, data.length);

                    this.dataCallback({
                        name: id,
                        data: payload,
                        pts: frame.pts
                    });

                    break;
                }
            }
        },

        /**
         * @memberof uvpjs.FrameId3Parser#
         * @private
         *
         * @param {String} ownerId
         * @param {Uint8Array} data
         * @param {Number} offset
         *
         * @returns {*}
         */
        parseNielsen: function(ownerId, data, offset) {
            // yields a string (length *should* be consistent) beginning with the nielsen owner id;
            // 2 junk bytes are eliminated from the end of data, i.e, the trailing null terminator
            // (1 byte) and the trailing place holder (1 byte)

            var str = ownerId + this.readStr(data, offset, data.length - (offset + 2));

            return str.length === nielsenDataLength ? str : null;
        },

        /**
         * String conversion - accepts array of unisgned 8 bit integers, returns text
         * @memberof uvpjs.FrameId3Parser#
         * @private
         *
         * @param {Uint8Array} data
         * @param {Number} start index
         * @param {Number} len length
         *
         * @return {string}
         */
        readStr: function (data, start, len) {
            var result = '',
                offset = start || 0,
                end = start + len;

            do {
                result += String.fromCharCode(data[offset++]);
            }
            while (offset < end);

            return result;
        }
    });


}(uvpjs.register('uvpjs')));

(function (obj) {

    var nielsenOwnerName = 'www.nielsen.com';

    obj.TrackId3Parser = uvpjs.AbstractId3Parser.subClass({

        /**
         * * Parse ID3 data frames, and pass back to dataCallback
         * @memberof uvpjs.TrackId3Parser#
         *
         * @param {Array} cues Array of WebKitDataCue objects to parse
         */
        parse: function(cues) {
            if (cues.length !== 1) return;
            var cue = cues[0];

            // Only parse private frames
            if (cue.value.key !== 'PRIV') {
                return;
            }

            for (var i = 0; i < this.ownerIds.length; i++) {
                var ownerId = this.ownerIds[i];
                if (cue.value.info.indexOf(ownerId) !== -1) {
                    this.dataCallback({
                        name: ownerId,
                        data: ownerId === nielsenOwnerName ? cue.value.info : String.fromCharCode.apply(null, new Uint8Array(cue.value.data)),
                        pts: cue.startTime
                    });
                }
            }
        }
    });


}(uvpjs.register('uvpjs')));
/**
 * Created by ldoyle on 8/11/15.
 */
'use strict';

(function (obj) {

    var _ = obj._;

    obj.ResourcePlaylistManager = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PLAYLIST_MANAGER,

        /**
         * UVPJS interface with the App / Page via the UVPJS API and UVPJS Events.<br>
         *     <br>
         * - instantiates Resource Providers using Resource Config objects passed into UVPJS from client.<br>
         * - Resource Providers persist for the entire session.<br>
         * - A Resource Provider’s state changes from UNPLAYED to PLAYING to PLAYED.<br>
         *
         * @constructor uvpjs.ResourcePlaylistManager
         *
         * @param {Object}                         options
         * @param {String}                         options.vidContId - id of the video container element
         * @param {uvpjs.CoreVideoInstanceManager} options.cviMgr - reference to the Core Video Instance Manager.
         * @param {Boolean}                        options.suppressFacadePlay - used by ResourceProvider
         * @param {uvpjs.P2pClient}                options.p2pClient - used by ResourceProvider
         * @param {Object}                         options.multiCdnClient - used by ResourceProvider,
         * @param {Boolean}                        options.deferLoadingCaptions
         */
        init: function(options) {
            this.debug = uvpjs.debug;
            this.vidContId = '';
            this.cviMgr = {};
            this.eventsMgr = {};
            this.cviModel = {};
            this.internalNS = '';
            this.rscProviders = [];
            this.usedRPs = [];  // array of used resource providers
            this.currRP = {};

            this.p2pClient = options.p2pClient || null;
            this.multiCdnClient = options.multiCdnClient || null;

            this.mc = uvpjs.mediaCapabilities;
            this.suppressFacadePlay = options.suppressFacadePlay;
            this.deferLoadingCaptions = options.deferLoadingCaptions;

            this.playlistPaused = false;

            !_.isEmpty(options) && this.initialize(options.vidContId, options.cviMgr);
        },

        /**
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {String} vidContId - elementID string of the Video Container on the page.
         * @param {uvpjs.CoreVideoInstanceManager} cviMgr - reference to the Core Video Instance Manager.
         */
        initialize: function(vidContId, cviMgr) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'initialize  vidContId = ', vidContId);

            if (!_.isString(vidContId) || !_.isObject(cviMgr)) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'initialize BAD PARAMS');
                return;
            }
            this.vidContId = vidContId;
            this.cviMgr = cviMgr;
            this.eventsMgr = this.cviMgr.getEventsMgr();
            this.cviModel = this.cviMgr.getModelRef();
            this.internalNS = '.' + this.vidContId + '.rpm';
            this.containers = null;
            this._addEventListeners();
        },

        /**
         * @memberof uvpjs.ResourcePlaylistManager#
         * @param {Object}  obj
         * @param {Element} obj.playerDom
         * @param {Element} obj.contentVideoDom
         */
        setContainers: function(obj) {
            this.containers = obj;
        },

        /**
         * @memberof uvpjs.ResourcePlaylistManager#
         * @param {array} propArr
         */
        setCaptionStyle: function(propArr) {
            // hack for flash
            !uvpjs.util.isEmpty(this.currRP) && this.currRP.setCaptionStyle(propArr);
        },

        /**
         * Interrupts the currently playing resource and starts playing the rcoObj in the request.<br>
         * Callback for RESOURCE_LOAD_REQUEST event dispatched by the VCI.loadAndPlayResource() API method. <br>
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} evtObj - Event object with .type, .payload, and .target properties.
         */
        onResourceLoadRequest: function(evtObj){
            if (evtObj.target !== this.vidContId){return;}
            this.debug && uvpjs.log(this.DEBUG_ID, 'onResourceLoadRequest evtObj.payload.rcObj = ', evtObj.payload.rcObj);

            this.playlistPaused = false;

            // IMPORTANT NOTE: evtObj.payload.rcObj is always valid and authentic at this point.
            var rp = this._createResourceProvider(evtObj.payload.rcObj);

            this.rscProviders.unshift(rp);  // add new resource provider to the front of thep playlist
            this.playlistInterruptionCleanup();
        },

        /**
         * Callback for RESOURCE_ADD_REQUEST event dispatched by the VCI.<br>
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} evtObj - Event object with .type, .payload, and .target properties.
         */
        onResourceAddRequest: function(evtObj){
            if (evtObj.target !== this.vidContId){return;}
            this.debug && uvpjs.log(this.DEBUG_ID, 'onResourceAddRequest evtObj.payload.rcObjs= ', evtObj.payload.rcObjs);  // IMPORTANT NOTE: evtObj.payload.rcObjs are always valid and authentic at this point and the array will have at least one element.

            var rcosArray = evtObj.payload.rcObjs;
            var n = rcosArray.length,
                i, rp;

            // Create Resource Providers
            for (i = 0; i < n; i++) {
                rp = this._createResourceProvider(rcosArray[i]);
                this.rscProviders.push(rp);
            }

            // if there are no currently playing Resource Providers prod the RPM to play the next RP.
            if (_.isEmpty(this.currRP)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'onResourceAddRequest finished creating Resource Providers and there is no Current Resource Provider -> call this._loadNextRP()');
                this._loadNextRP();
            }
        },

        /**
         * callback for RESOURCE_REMOVE_REQUEST event dispatched by the VCI.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} evtObj - Event object with .type, .payload, and .target properties.
         */
        onResourceRemoveRequest: function(evtObj){
            if (evtObj.target !== this.vidContId){return;}
            //uvpjs.log(this.DEBUG_ID, 'onResourceRemoveRequest this.vidContId = ', this.vidContId);
            this.debug && uvpjs.log(this.DEBUG_ID, 'onResourceRemoveRequest this.vidContId = ', this.vidContId);
        },

        /**
         * Callback for RESOURCE_PLAYLIST_PAUSE event dispatched by the VCI.
         * Sets this.playlistPaused = true so the resource playlist pauses after the current video has ended.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} evtObj - Event object with .type, .payload, and .target properties.
         */
        onResourcePlaylistPause: function(evtObj){
            this.debug && uvpjs.log(this.DEBUG_ID, 'onResourcePlaylistPause this.vidContId = ', this.vidContId);

            if (evtObj.target !== this.vidContId || this.playlistPaused){return;}

            this.playlistPaused = true;
        },

        /**
         * Unpauses a 'paused' playlist and allows it to load the next RCO when the current RCO ends. <br>
         * If there is no current RCO playing the first RCO in the playlist is started.
         * callback for RESOURCE_PLAYLIST_RESUME event dispatched by the VCI.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} evtObj - Event object with .type, .payload, and .target properties.
         */
        onResourcePlaylistResume: function(evtObj){
            if (evtObj.target !== this.vidContId || !this.playlistPaused){return;}
            this.debug && uvpjs.log(this.DEBUG_ID, 'onResourcePlaylistResume this.vidContId = ', this.vidContId);

            this.playlistPaused = false;

            // if there is no currently playing RP and there are RP in the playlist, play the next RP.
            if (_.isEmpty(this.currRP) && this.rscProviders.length > 0){
                this.debug && uvpjs.log(this.DEBUG_ID, 'onResourcePlaylistResume  (_.isEmpty(this.currRP) && this.rscProviders.length > 0) LOAD NEXT RP this._loadNextRP();');
                this._loadNextRP();
            }
        },

        /**
         * callback for RESOURCE_PLAYLIST_ADVANCE event dispatched by the VCI.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} evtObj - Event object with .type, .payload, and .target properties.
         */
        onResourcePlaylistAdvance: function(evtObj) {
            if (evtObj.target !== this.vidContId) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'onResourcePlaylistAdvance this.vidContId = ', this.vidContId);

            this.advancePlaylist();
        },

        /**
         * callback for RESOURCE_PLAYLIST_DESTROY event dispatched by the VCI.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} evtObj - Event object with .type, .payload, and .target properties.
         */
        onResourcePlaylistDestroy: function(evtObj){
            if (evtObj.target !== this.vidContId) return;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onResourcePlaylistDestroy this.vidContId = ', this.vidContId);

            this.rscProviders = [];
            this.playlistInterruptionCleanup();

            this.currRP = null;
        },


        //     END API Event CALLBACKS        //


        /**
         * Advance playlist.
         *
         * @memberof uvpjs.ResourcePlaylistManager#
         */
        advancePlaylist: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'advancePlaylist');

            this.playlistPaused = false;
            this.playlistInterruptionCleanup();
        },

        /**
         * Tell the Resource Playlist Manager that a dynamic ad call request has been made.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {String} adCall - A fully qualified and baked IMA ad call.
         */
        loadDynamicAdCall: function(adCall){
            this.debug && uvpjs.log(this.DEBUG_ID, 'loadDynamicAdCall adCall =', adCall);

            if (!_.isEmpty(this.currRP) && !_.isEmpty(this.currRP.rco) && this.currRP.rco.type === this.mc.RP_IMA) {
                this.currRP.loadDynamicAdCall(adCall);
            } else {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'loadDynamicAdCall trying to load a dynamic ad call but currRP is either empty or not rco.type === RP_IMA');
            }
        },

        /**
         * Tell the Resource Provider to end any dynamic ad session in progress
         * @memberof uvpjs.CoreVideoInstanceManager#
         */
        forceDynamicMidrollPodEnd: function() {
            if (!_.isEmpty(this.currRP) && this.currRP.forceDynamicMidrollPodEnd) {
                this.currRP.forceDynamicMidrollPodEnd();
            }
        },

        /**
         * Cleans up current Resource Provider or if no current Resource Provider loads the next one in the Playlist.
         * The RP cleanup calls resource end which loads the next resource in the playlist.
         * @memberof uvpjs.ResourcePlaylistManager#
         */
        playlistInterruptionCleanup: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, 'playlistInterruptionCleanup this.vidContId = ', this.vidContId);

            if (!_.isEmpty(this.currRP) && !_.isNull(this.currRP.rco)) {

                if (this.currRP.rco.type === this.mc.RP_IMA) {
                    this.debug && uvpjs.log(this.DEBUG_ID, 'playlistInterruptionCleanup CLEANUP PREVIOUS RP BEFORE LOADING NEXT ONE. IMA case calling -> this.currRP.cleanUpRP_IMA()');
                    this.currRP.cleanUpRP_IMA();
                }
                else {
                    this.debug && uvpjs.log(this.DEBUG_ID, 'playlistInterruptionCleanup CLEANUP PREVIOUS RP BEFORE LOADING NEXT ONE. non-IMA case calling -> this.currRP.cleanUp()');
                    this.currRP.cleanUp();
                }
            }
            else {
                this.debug && uvpjs.log(this.DEBUG_ID, 'playlistInterruptionCleanup NO PREVIOUS RP so this._loadNextRP();');
                this._loadNextRP();
            }
        },


        /**
         * Instantiates, initializes, and stores a Resource Provider. <br>
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} rcObj Validated Resource Config Object.
         *
         * @returns {Object} A valid Resource Provider.
         */
        _createResourceProvider: function(rcObj){
            var opts = {
                    rco: rcObj,
                    cviMgr: this.cviMgr,
                    vidContId: this.vidContId,
                    containers: this.containers,
                    p2pClient: this.p2pClient,
                    deferLoadingCaptions: this.deferLoadingCaptions,
                    multiCdnClient: this.multiCdnClient
                },
                rp, C;

            this.debug && uvpjs.log(this.DEBUG_ID, '_createResourceProvider rcObj = ', rcObj);

            switch (rcObj.type) {
                case this.mc.RP_URL:
                    rp = new uvpjs.RP_URL(opts);
                    break;
                case this.mc.RP_PLATFORM:
                    rp = new uvpjs.RP_Platform(opts);
                    break;
                case this.mc.RP_DAI:
                    C = rcObj.useSsb() ? uvpjs.DaiSsbResourceProvider : uvpjs.DaiResourceProvider;
                    rp = new C(opts);
                    break;
                case this.mc.RP_IMA:
                    rp = new uvpjs.RP_IMA(opts);
                    break;
                case this.mc.RP_MDIALOG:
                    rp = new uvpjs.RP_Mdialog(opts);
                    break;
            }

            return rp;
        },

        /**
         * Tells the next Resource Provider in the queue to load.
         * @memberof uvpjs.ResourcePlaylistManager#
         */
        _loadNextRP: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, '_loadNextRP this.rscProviders.length = ', this.rscProviders.length);
            this.debug && uvpjs.log(this.DEBUG_ID, '_loadNextRP this.playlistPaused = ', this.playlistPaused);

            if (!_.isEmpty(this.currRP) && !_.isNull(this.currRP.rco)){

                if (this.currRP.rco.type === this.mc.RP_IMA) {
                    this.debug && uvpjs.log(this.DEBUG_ID, '_loadNextRP CLEANUP PREVIOUS RP BEFORE LOADING NEXT ONE.         IMA case calling -> this.currRP.cleanUpRP_IMA()');
                    this.currRP.cleanUpRP_IMA();
                } else {
                    this.debug && uvpjs.log(this.DEBUG_ID, '_loadNextRP CLEANUP PREVIOUS RP BEFORE LOADING NEXT ONE.     non-IMA case calling -> this.currRP.cleanUp()');
                    this.currRP.cleanUp();
                }

            }

            if (this.rscProviders.length > 0 && !this.playlistPaused){

                this.currRP = this.rscProviders.shift(); // currently removing RPs from the main resource provider Queue.
                this.usedRPs.push(this.currRP); // preserve this RP for later abuse.

                this.debug && uvpjs.log(this.DEBUG_ID, '_loadNextRP JUST AFTER SETTING NEW currRP  this.currRP.rco.id = ', this.currRP.rco.id );

                this.currRP.loadData(this.rpDataLoadCB.bind(this), this.rpDataLoadErrorCB.bind(this));

            } else {

                this.debug && uvpjs.log(this.DEBUG_ID, '_loadNextRP this.rscProviders.length = 0 OR this.playlistPaused TRUE SETTING NEW this.currRP = {}; ' );

                this.currRP = {};
            }
        },

        // VTG-79; unused param optData; intent?
        /**
         * this.currRP.loadData() Success callback. Loads and plays the next Resource Object in the queue.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {object} optData (optional) metadata object.
         */
        rpDataLoadCB: function(optData){
            this.debug && uvpjs.log(this.DEBUG_ID, 'rpDataLoadCB');
            this.debug && uvpjs.log(this.DEBUG_ID, 'rpDataLoadCB this.currRP =', this.currRP);

            if (!_.isObject(this.currRP)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'rpDataLoadCB  WARNING !_.isObject(this.currRP) RETURN WITHOUT PLAYING VIDEO');
                this.advancePlaylist();
                return;
            }

            // RP creates a Video Facade and starts video playback
            this.currRP.loadVideoAndBeginPlayback(this.suppressFacadePlay);
        },

        /**
         * this.currRP.loadData() load error callback.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {uvpjs.ErrorInfo} errorInfo
         */
        rpDataLoadErrorCB: function(errorInfo){
            this.debug && uvpjs.warn(
                this.DEBUG_ID,
                'rpDataLoadErrorCB  WARNING Data Load Error Skip current video rpDataLoadErrorCB errMsg = ',
                errorInfo.message
            );

            this.eventsMgr.dispatchEvent(errorInfo.eventType, {errorInfo: errorInfo}, this.vidContId);

            this.advancePlaylist();
        },

        /**
         * Called by the current Resource Provider (this.currRP) when the Resource Provider has started. Dispatches a RESOURCE_START event with the Resource Config Object as the payload.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} rcoSeed - Simple Resource Config Object to be passed by the page to the player to initiate video playback.
         */
        resourceStart: function(rcoSeed){
            this.debug && uvpjs.log(this.DEBUG_ID, 'resourceStart dispatch RESOURCE_START rcoSeed = ', rcoSeed);

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_START, {rco: rcoSeed}, this.vidContId);
        },

        /**
         * Called by the current Resource Provider (this.currRP) when the Resource Provider has ended.
         * Dispatches a RESOURCE_END event with the payload {rco:rcoObject, playlistLength:Integer}
         * where rco is the Resource Config Object that just ended and playlistLength is the number of unplayed Resource Config Objects remaining in the playlist.
         *
         * Loads the next Resource Provider.
         * @memberof uvpjs.ResourcePlaylistManager#
         *
         * @param {Object} rcoSeed - Simple Resource Config Object to be passed to the page.
         */
        resourceEnd: function(rcoSeed) {


            // VTG-216 QUESTION?
            //
            // Why is the rcoSeed argument necessary? Couldn't we use this.currRP.rco.rcoSeed? It's
            // making the cleanUp routine in the RP class cumbersome because it has to store rcoSeed
            // in a local variable in order to later call resourceEnd after the rco instance is reset.
            // Looks to be a similar issue in cleanUpRP_IMA.


            this.debug && uvpjs.log(this.DEBUG_ID, 'resourceEnd dispatch RESOURCE_END rcoSeed = ', rcoSeed);
            this.currRP && this.debug && uvpjs.log(this.DEBUG_ID, 'resourceEnd this.currRP.rco = ', this.currRP.rco);

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_END,
            {
                rco: rcoSeed,
                playlistLength: this.rscProviders.length
            },
            this.vidContId);

            this.currRP && this.debug && uvpjs.log(this.DEBUG_ID, 'resourceEnd dispatch AFTER this.currRP.rco = ', this.currRP.rco);

            // if there are more resources then load and play them.
            // if _.isNull(this.currRP.rco) then no resource provider was loaded by the the page in response to the Resource End Event. This prevents a race condition.

            if (this.rscProviders.length > 0 && (!_.isEmpty(this.currRP) && _.isNull(this.currRP.rco))) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'resourceEnd dispatch _loadNextRP()');
                this._loadNextRP();
            }
        },


        /**
         * Register callbacks for UVPJS Events Manager events.
         * @memberof uvpjs.ResourcePlaylistManager#
         */
        _addEventListeners: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, '_addEventListeners this.internalNS = ', this.internalNS);

            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.RESOURCE_LOAD_REQUEST + this.internalNS, this.onResourceLoadRequest.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.RESOURCE_ADD_REQUEST + this.internalNS, this.onResourceAddRequest.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.RESOURCE_REMOVE_REQUEST + this.internalNS, this.onResourceRemoveRequest.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_PAUSE + this.internalNS, this.onResourcePlaylistPause.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_RESUME + this.internalNS, this.onResourcePlaylistResume.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_ADVANCE + this.internalNS, this.onResourcePlaylistAdvance.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_DESTROY + this.internalNS, this.onResourcePlaylistDestroy.bind(this));
        },

        /**
         * De-register callbacks for UVPJS Events Manager events.
         * @memberof uvpjs.ResourcePlaylistManager#
         */
        _removeEventListeners: function(){
            this.debug && uvpjs.log(this.DEBUG_ID, '_removeEventListeners this.internalNS = ', this.internalNS);

            this.eventsMgr.removeEventListener(this.eventsMgr.eventTypes.RESOURCE_LOAD_REQUEST + this.internalNS);
            this.eventsMgr.removeEventListener(this.eventsMgr.eventTypes.RESOURCE_ADD_REQUEST + this.internalNS);
            this.eventsMgr.removeEventListener(this.eventsMgr.eventTypes.RESOURCE_REMOVE_REQUEST + this.internalNS);
            this.eventsMgr.removeEventListener(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_PAUSE + this.internalNS);
            this.eventsMgr.removeEventListener(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_RESUME + this.internalNS);
            this.eventsMgr.removeEventListener(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_ADVANCE + this.internalNS);
            this.eventsMgr.removeEventListener(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_DESTROY + this.internalNS);
        }

    });

}(uvpjs.register('uvpjs')));
/**
 * Created by ldoyle on 8/11/15.
 */
'use strict';

(function (obj) {

    var _ = obj._;


    obj.VideoControlInterface = uvpjs.Class.subClass({

        AD_SETTINGS: 'AdSettings',

        /**
         * @constructor uvpjs.VideoControlInterface
         * @description Instantiated by UVPJS Video Manager to mediate between Core Video Instances, the Video Manager, and the page.
         *
         * @public
         */
        init: function () {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.VIDEO_CONTROL_INTERFACE;
            this.vciReadyCB = {};
            this.skinMgr = {};      // UVPJS Custon Skin Manager
            this.DOMMgr = {};
            this.vidContId = '';     // VideoContainer ID
            this.eventsMgr = {};        // Events Manager
            this.CDO = {};              // Config Data Object
            this.CVI_Mgr = {};       // CVI_Mgr : Core Video Instance Manager
            this.mc = uvpjs.mediaCapabilities;
            this.rcoIdIndex = 0;

            this.namespace = null;
            this.diagnostic = null;

            this._loadSkinFlag = false;
            this._vciReadySent = false;
            this._playBlankVideoDone = false;
            this._previewButtonDone = false;
            this._playBlankVideoCallback = null;
            this._replayRco = null;

            this._isUnmutedAutoplay = false;
            this._isMutedAutoplay = false;
            this._autoPlay = false;

            this.hasDispatchedFirstGesture = false;

            this.isWaitingForFirstTouch = false;
            this.isPreparedForAutoplay = false;
        },

        /**
         * Used by the Video Manager to initializes an instance of the video player.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {String} vidContId - Video container ID string for this Video Control Interface aka VCI.
         * @param {Object} eventsMgr - Events Manager Reference.
         * @param {Object} CDO - Config Data Object.
         * @param {Object} vciReadyCB - Callback to page when the Video Control Interface startup initialization is complete.
         * @param {Object} playerOpts - A copy of the CDO sessionOptions for each player instance.
         *
         * @public
         */
        initialize: function (vidContId, eventsMgr, CDO, vciReadyCB, playerOpts) {
            var useNativeSkin = playerOpts.skin === true;

            this.debug && uvpjs.log(this.DEBUG_ID, 'initialize vidContId =', vidContId);

            if (!_.isString(vidContId) || !_.isObject(eventsMgr) || !_.isObject(CDO) || !_.isFunction(vciReadyCB)) {
                this.debug && uvpjs.log(this.DEBUG_ID, '-');
                return;
            }

            this.vidContId = vidContId;
            this.namespace = '.vci_' + vidContId;
            this.eventsMgr = eventsMgr;
            this.CDO = CDO;
            this.vciReadyCB = vciReadyCB;

            this._usesIMA = playerOpts.usesIMA;

            this._loadSkinFlag = useNativeSkin;
            this._isPreviewBtnInternallyManaged = useNativeSkin;

            this._isUnmutedAutoplay = playerOpts.enableUnmutedAutoplay;
            this._isMutedAutoplay = playerOpts.enableMutedAutoplay;

            this._autoPlay = this._isUnmutedAutoplay || this._isMutedAutoplay;
            this.playRequiresUserGesture = this.mc.playRequiresUserGesture(this._autoPlay);

            this.listenForAdEvents();

            this.CVI_Mgr = new uvpjs.CoreVideoInstanceManager({
                vidContId: vidContId,
                eventsMgr: eventsMgr,
                CDO: CDO,
                playerOptions: playerOpts,
                suppressFacadePlay: this.checkNativeAutoplay(playerOpts.enableNativeMobileAutoplay),
                readyCallback: this.handleCviMgrReady.bind(this, playerOpts)
            });
        },

        /**
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        destroy: function () {
            // OPTIMIZE  TODO - implement fully; see also destroyVideoPlayer in VideoManager

            this._replayRco = null;
            this.skinMgr && this.skinMgr.destroy();

            // Destroy diagnostic window.
            this.diagnostic && this.diagnostic.destroy();
            removeResizeListener(this.dom.outer.el, this._dispatchResizeEvent.bind(this));
        },

        /**
         * @private
         * @param playerOpts
         */
        handleCviMgrReady: function (playerOpts) {
            var skinConfig = {
                    skin: playerOpts.skin === true,
                    isUnmutedAutoplay: this._isUnmutedAutoplay,
                    isMutedAutoplay: this._isMutedAutoplay,
                    customCSS: playerOpts.customCSS,
                    enableReplay: playerOpts.enableReplay,
                    previewImage: playerOpts.previewImage,
                    themeName: playerOpts.themeName
                };

            this.CVI_Mgr.setInitialPlaybackType(this._autoPlay, this._isMutedAutoplay);

            this.DOMMgr = new uvpjs.DOMManager({
                containerID: this.vidContId,
                createControls: this._loadSkinFlag,
                createAds: this._usesIMA,
                useMutedAttribute: this._isMutedAutoplay,
                useInlinePlayAttribute: playerOpts.playsInline || this.mc.requiresInlinePlayAttribute(this._autoPlay),
                useAutoplayAttribute: this.checkNativeAutoplay(playerOpts.enableNativeMobileAutoplay),
                usePlaceholderContent: this.mc.requiresPlaceholderContent(this._autoPlay),
                callback: this.onDOMReady.bind(this, skinConfig)
            });

            this.DOMMgr.initialize();
        },


        /*-------------------------------------------------------------------------------
        Special case treatment
        Content and ad video elements are separate everywhere except on iPhone

        In these cases, where autoplay is used with IMA ads, and silent autoplay is in effect,
        unmuting the video while a pre-roll ad is playing will result in a 'gesture required' error if content
        subsequently starts unmuted.

        If the VCI is made aware of the first gesture made during pre-roll ad play
        we can load/play a blank first to ensure that content can start with sound on.
        -------------------------------------------------------------------------------*/
        /**
         * Ad start must be handled to determine how to act upon first gesture (autoplay/ad issue)
         * Ad pod end must be handled to clear pending 'waitingForFristGesture' flag
         * @memberof uvpjs.VideoControlInterface#
         * @private
         */
        listenForAdEvents: function () {
            this.addEventListener(uvpjs.EventType.AD_START + this.namespace, this.onAdStart.bind(this));
            this.addEventListener(uvpjs.EventType.AD_POD_END + this.namespace, this.onAdPodEnd.bind(this));
            this.addEventListener(this.eventsMgr.eventTypes.AD_CLICK + this.namespace, this.handleFirstGesture.bind(this));
        },

        /**
         * Ad pod end must be handled to clear pending 'waitingForFristGesture' flag
         * @memberof uvpjs.VideoControlInterface#
         * @private
         */
        onAdPodEnd: function () {
            this.isWaitingForFirstTouch = false;
            this.removeEventListener(uvpjs.EventType.AD_POD_END + this.namespace);
        },

        /**
         * Ad start must be handled to determine how to act upon first gesture (autoplay/ad issue)
         * @memberof uvpjs.VideoControlInterface#
         * @private
         */
        onAdStart: function (e) {
            if (this.vidContId !== e.target) return;

            this.checkAutoplayRestriction(e.payload.adData);
            this.removeEventListener(uvpjs.EventType.AD_START + this.namespace);
        },

        /**
         * Determine if video el will need to be prepared for autoplay if a user
         * unmutes a preroll ad
         * @memberof uvpjs.VideoControlInterface#
         * @private
         */
        checkAutoplayRestriction: function(adData) {
            adData.adType === 'pre' &&                 //  if it's a pre-roll and
            adData.adServerName === 'ima' &&           //  it's an IMA ad, and
            this._isMutedAutoplay &&                   //  silent autoplay is being used, and
            !this.mc.isSingleVideoIma() &&             //  we're in a 2 video element sheme, and
            !this.mc.supportsUnmutedAutoplay() &&      //  we can't autoplay with sound, and
            !this.isPreparedForAutoplay &&             //  content vid tag not yet prepeared, then
            (this.isWaitingForFirstTouch = true);      //  set flag to capture first touch
        },


        /**
         * For internal use only
         * @public
         */
        dispatchFirstGesture: function(infoPayload) {
            this.eventsMgr.dispatchEvent(uvpjs.EventType.FIRST_GESTURE, infoPayload, this.vidContId);
        },

        /**
         * Load/play a blank video on the content video element
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Boolean} isPreviewBtn true if triggered by preview button
         *
         * @private
         */
        prepForRestrictedAutoplay: function(isPreviewBtn) {
            var v = this.dom.video.el,
                fn = Function.prototype;

            this.hPrePlay = function() {
                this.isPreparedForAutoplay = true;
                v.removeEventListener('play', this.hPrePlay, false);
                if (isPreviewBtn) {
                    this._playBlankVideoDone = true;
                    this._playBlankVideoCallback();
                }
            }.bind(this);

            this.debug && uvpjs.log(this.DEBUG_ID, 'Prep for restricted autoplay...');

            v.src = this.mc.getPreferredPlaceholderURL();
            v.addEventListener('play', this.hPrePlay, false);
            v.muted = true;
            v.load();

            var p = v.play();

            p !== undefined && p.then(fn).catch(function(e){return;});
        },

        /**
         * Generally for internal use only, but may be called from a custom skin implementation
         * @memberof uvpjs.VideoControlInterface#
         * @public
         *
         * @param {Object} optional info object
         */
        handleFirstGesture: function(info) {
            if (this.isWaitingForFirstTouch) {
                this.isWaitingForFirstTouch = false;
                this.prepForRestrictedAutoplay();
            }
            if (!this.hasDispatchedFirstGesture) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.FIRST_GESTURE,
                    {info: info || null},
                    this.vidContId
                );

                this.hasDispatchedFirstGesture = true;
            }
        },

        // end special treatment for restricted autoplay
        //////////////////////////////////////////////////

        /**
         * Call when the DOM is constructed.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        onDOMReady: function (skinConfig) {
            this.dom = this.DOMMgr.getDOM();

            // Add event listener to dispatch CONTAINER_RESIZE.
            addResizeListener(this.dom.outer.el, this._dispatchResizeEvent.bind(this));

            this.CVI_Mgr.setContainers({
                playerDom: this.dom.outer.el,
                contentVideoDom: this.dom.content.el
            })

            // Create diagnostic window.
            if (this.mc.isDesktop()) {
                this.diagnostic = new uvpjs.Diagnostic({
                    eventsMgr: this.eventsMgr,
                    containerEl: this.dom.outer.el,
                    videoEl: this.dom.video.el
                });
            }

            // Create default skin.
            if (this._loadSkinFlag) {
                this.skinMgr = new uvpjs.SkinManager({
                    vci: this,
                    skinReadyCallback: this.onVCIReady.bind(this),
                    skinConfig: skinConfig
                });

                return;
            }

            this.onVCIReady();
        },
        /**
         * @private
         *
         * @param {Boolean} nativeApRequested
         *
         * @return {*}
         */
        checkNativeAutoplay: function (isRequested) {
            return isRequested && this.mc.supportsIntelligentMobileAutoplay();
        },

        /**
         * Call the VCI Ready Callback when the skin is ready or if there is no skin.
         * Tell the Core Video Instance (CVI_Mgr) to initialize the IMA ad display container and event capture div.
         * @memberof uvpjs.VideoControlInterface#
         */
        onVCIReady: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'onVCIReady');

            if (this._vciReadySent) {
                return;
            }

            // Don't call VCI ready if internal skin is being used and not
            // auto-playing and preview button hasn't been clicked or touched.
            if (!this._autoPlay && this._isPreviewBtnInternallyManaged && !this._previewButtonDone) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.PLAYER_INIT, {player: this}, this.vidContId);
                return;
            }

            // Only load ads here if play does not require a user gesture
            if (this._usesIMA && !this.playRequiresUserGesture) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'onVCIReady   call this.CVI_Mgr.constructSharedIMAClasses()');
                this.CVI_Mgr.constructSharedIMAClasses();
            }

            this._isMutedAutoplay && this.mute();

            this._vciReadySent = true;
            this.vciReadyCB(this);
        },

        /**
         * Tell the Core Video Instance (CVI_Mgr) to tell the current RP that a dynamic ad call request has been made.
         *
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {String} adCall - A fully qualified and baked IMA ad call.
         *
         * @public
         */
        loadDynamicAdCall: function (adCall) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'loadDynamicAdCall adCall =', adCall);

            if (!_.isString(adCall)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'loadDynamicAdCall !_.isString(adCall)');
                return;
            }

            this.CVI_Mgr.loadDynamicAdCall(adCall);
        },

        /**
         * Tell the Core Video Instance (CVI_Mgr) to end any dynamic ad session in progress.
         *
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        forceDynamicMidrollPodEnd: function() {
            this.CVI_Mgr.forceDynamicMidrollPodEnd();
        },

        /**
         * Called by a preview button click or touch event
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Function} cb Callback function to execute when the preview button is clicked or touched.
         *                     In the desktop case, the callback will be called immediately. In the mobile
         *                     case, the callback is called after the content 'blank' video is loaded
         *                     and, if there are ads, after IMA has been initialized.
         *
         * @public
         */
        onPreviewButton: function (cb) {
            uvpjs.log(this.DEBUG_ID, 'onPreviewButton');

            if (!uvpjs.util.isFunction(cb)) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'onPreviewButton method called without a callback function.');

                return;
            }

            if (this._usesIMA && this.playRequiresUserGesture) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'onPreviewButton   call this.CVI_Mgr.constructSharedIMAClasses()');
                this.CVI_Mgr.constructSharedIMAClasses();
            }

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.PREVIEW_BUTTON, {}, this.vidContId);
            this._previewButtonDone = true;

            // Handle special mobile touch-to-play condition.
            if (this.playRequiresUserGesture && !this._playBlankVideoDone) {
                uvpjs.log(this.DEBUG_ID, 'onPreviewButton playing blank video in mobile.');
                this._playBlankVideoCallback = cb;
                this.playBlankVideo();

                return;
            }

            uvpjs.log(this.DEBUG_ID, 'onPreviewButton executing callback in desktop.');

            cb();
        },

        /**
         * @memberof uvpjs.VideoControlInterface#
         * @public
         *
         * @return {boolean|*|Boolean}
         */
        canOverrideUserGesture: function() {
            return !this.playRequiresUserGesture || (this.playRequiresUserGesture && this._playBlankVideoDone);
        },

        /**
         * Override the preview button click (or emulate a user click)
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         * @param {Boolean}
         */
        overrideUserGesture: function(force) {
            var ei, em;

            if (force !== true && !this.canOverrideUserGesture()) {
                ei = uvpjs.ErrorInfo;
                em = this.eventsMgr;

                em.dispatchEvent(
                    em.eventTypes.PLAYER_START_ERROR,
                    {
                        errorInfo: new ei({
                            eventType: em.eventTypes.PLAYER_START_ERROR,
                            errorCode: ei.errorCodes.USER_GESTURE_REQUIRED,
                            message: ei.messages.USER_GESTURE_REQUIRED,
                            isFatal: false
                        })
                    },
                    this.vidContId
                );

                return;
            }

            this.onPreviewButton(this.onVCIReady.bind(this));
        },


        /**
         * UVPJS Page API, passes event registration through to EventManager.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {EventType} evt - One of the EventManger.eventTypes CONST event type strings with jQuery-like namespace string.
         * @param {Function} cb - Bound event callback.
         *
         * @public
         */
        addEventListener: function (evt, cb) {
            if (!evt || !_.isString(evt) || !_.isFunction(cb)) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.UVPJS_WARNING,
                    {
                        msg: 'VideoControlInterface addEventListener MISSING OR MISS-TYPED PARAMS RETURN'
                    },
                    this.vidContId
                );
                return;
            }
            this.eventsMgr.addEventListener(evt, cb);
        },

        /**
         * UVPJS Page API, passes event de-registration through to EventManager.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {EventType} evt - One of the EventManger.eventTypes CONST event type strings with jQuery-like namespace string.
         *
         * @public
         */
        removeEventListener: function (evt) {
            if (!evt || !_.isString(evt)) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.UVPJS_WARNING,
                    {
                        msg: 'VideoControlInterface removeEventListener !evt || evt !== string INVALID RETURN'
                    },
                    this.vidContId
                );
                return;
            }
            this.eventsMgr.removeEventListener(evt);
        },

        /**
         * Gets the video container div id.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @returns {String} The video container ID for the video player instance.
         *
         * @public
         */
        getVidContId: function () {
            return (this.vidContId);
        },

        // *********          load video with Resource Config Object methods by dispatching events        ********* //

        /**
         * Play placeholder content for mobile devices.
         * @memberof uvpjs.VideoControlInterface#
         */
        playBlankVideo: function () {
            uvpjs.log(this.DEBUG_ID, 'playBlankVideo');

            this.prepForRestrictedAutoplay(true);
        },

        /**
         * Ends the currently playing resource (if there is one) and starts playing the RCO in the request.<br>
         * This is the simplest way to play a video. Dispatches RESOURCE_LOAD_REQUEST with resource config object payload.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Object} rcObj - Resource config object.
         *
         * @public
         */
        loadAndPlayResource: function (rcObj) {
            var rco;

            this.debug && uvpjs.log(this.DEBUG_ID, 'loadAndPlayResource -> dispatches RESOURCE_LOAD_REQUEST event    rcObj = ', rcObj);

            // Catch pre-touch event call when {skin: false}.
            if (this.playRequiresUserGesture && !this._playBlankVideoDone) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'loadAndPlayResource was called before a mobile touch event.');
                this._playBlankVideoCallback = this.loadAndPlayResource.bind(this, rcObj);
                this.playBlankVideo();
                return;
            }

            rco = this.createResourceConfig(rcObj);

            if (_.isObject(rco)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_LOAD_REQUEST, {rcObj: rco}, this.vidContId);
            } else {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.UVPJS_WARNING,
                    {
                        msg: 'VideoControlInterface  loadAndPlayResource INVALID RESOURCE CONFIG OBJECT RETURN'
                    },
                    this.vidContId
                );
            }
        },

        /**
         * Adds one or more Resource Config Objects (RCOs) to the end of the resource playlist queue.<br>
         * If no video is currently loaded the first video in the queue loads.<br>
         * Use this method to play a  known set of videos sequentially. Use the Playlist Manager API to control the playlist.<br>
         * Dispatches RESOURCE_ADD_REQUEST with resource config object payload.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Array} rcObjsArray - Array of Resource Config Objects (RCOs).
         *
         * @public
         */
        addResourcesToPlaylist: function (rcObjsArray) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'addResourcesToPlaylist rcObjsArray = ', rcObjsArray);

            // Catch pre-touch event call when {skin: false}.
            if (this.playRequiresUserGesture && !this._playBlankVideoDone) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'addResourcesToPlaylist was called before a mobile touch event.');
                this._playBlankVideoCallback = this.addResourcesToPlaylist.bind(this, rcObjsArray);
                this.playBlankVideo();
                return;
            }

            if (_.isArray(rcObjsArray) && rcObjsArray.length > 0) {
                var vettedRCObjs = [],
                    i,
                    nuRC;

                // create and vet the Resource Config Objects in the rcObjsArray

                for (i in rcObjsArray) {
                    nuRC = this.createResourceConfig(rcObjsArray[i]);

                    if (_.isObject(nuRC)) {
                        vettedRCObjs.push(nuRC);
                    } else {
                        this.eventsMgr.dispatchEvent(
                            this.eventsMgr.eventTypes.UVPJS_WARNING,
                            {
                                msg: 'VideoControlInterface addResourcesToPlaylist INVALID RESOURCE CONFIG OBJECT IN rcObjsArray DO NOT ADD TO PLAYLIST'
                            },
                            this.vidContId
                        );
                    }

                }

                if (vettedRCObjs.length > 0) {
                    this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_ADD_REQUEST, {rcObjs: vettedRCObjs}, this.vidContId);
                }

            } else {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.UVPJS_WARNING,
                    {
                        msg: 'VideoControlInterface addResourcesToPlaylist rcObjsArray argument is EMPTY OR NOT AN ARRAY    RETURN'
                    },
                    this.vidContId
                );
            }
        },

        /**
         * Dispatches UVPJS_WARNING messages if the Resource Config Object is invalid.
         * @memberof uvpjs.VideoControlInterface#
         * @private
         *
         * @param {Object} rcObj - Resource Config Object (RCO) containing video playback metadata.</br>
         *
         * @returns {Object|Boolean} A validated Resource Configuration Object, or false if RCO is invalid.
         */
        createResourceConfig: function (rcObj) {
            var errMsg = '',
                hasError = false,
                isImaType = rcObj.type === this.mc.RP_IMA,
                auxMsg = '',
                doAdBlockCheck = false,
                isBlocked = false,
                missingSDK = null,
                id, type, rco, cErrorInfo, eCodes, ecode, validnObj;

            this.debug && uvpjs.log(this.DEBUG_ID, 'createResourceConfig rcObj = ', rcObj);

            // check for vlaid object and RP type param...
            validnObj = this.prevalidateRcObj(rcObj);

            if (validnObj.error) {
                errMsg = 'Resource configuration error: ' + validnObj.message + ' this.vidContId = ' + this.vidContId;
                this.dispatchStartError(errMsg, null);

                return false;
            }

            // choose RCO type
            switch (rcObj.type) {
                case this.mc.RP_URL:
                    type = uvpjs.RCO_URL;
                    break;
                case this.mc.RP_PLATFORM:
                    type = uvpjs.RCO_Platform;
                    break;
                case this.mc.RP_IMA:
                    if (!this._usesIMA) {
                        errMsg = 'Resource type is IMA, but sessionOptions.usesIMA is set to FALSE';
                        hasError = true;
                    }
                    doAdBlockCheck = true;
                    type = uvpjs.RCO_IMA;
                    break;
                case this.mc.RP_MDIALOG:
                    type = uvpjs.RCO_Mdialog;
                    break;
                case this.mc.RP_DAI:
                    doAdBlockCheck = !rcObj.useSsb;
                    type = uvpjs.DaiRco;
                    break;
                default:
                    auxMsg = 'Unknown resource type ' + rcObj.type;
                    errMsg = 'VCI createResourceConfig ' + auxMsg + '; this.vidContId = ' + this.vidContId;
                    hasError = true;
                    break;
            }

            if (hasError) {
                this.dispatchStartError(errMsg, null);

                return false;
            }

            this.rcoIdIndex++;
            id = this.rcoIdIndex + '_' + this.vidContId;

            // create RCO and validate further
            rco = new type(rcObj, id, this.vidContId);
            validnObj = rco.getValidationInfo();

            // check for an ad blocker first
            if (doAdBlockCheck) {
                isBlocked = this.checkForAdBlocker();

                if (isBlocked) {
                    validnObj.missingSDK === true && (missingSDK = isImaType ? 'IMA' : 'DAI');
                    this.dispatchAdBlocked(missingSDK, true);

                    return false;
                }
            }

            if (validnObj.error) {
                errMsg = 'VCI error initializing RCO: ' + validnObj.message;
                cErrorInfo = uvpjs.ErrorInfo;
                eCodes = cErrorInfo.errorCodes;

                if (validnObj.missingSDK === true) {
                    // Missing SDK at this point for some unknown reason
                    // e.g., not included in page source, or a server issue, or ad block detection
                    // has not been implemented or is yielding a false negative
                    ecode = isImaType ? eCodes.IMA_SDK_MISSING : eCodes.DAI_SDK_MISSING;
                    this.dispatchStartError(errMsg, ecode);
                }
                else {
                    // any other config errors caught internally by RCO fall into this block
                    this.dispatchStartError(errMsg, null);
                }

                return false;
            }

            this._replayRco = rcObj;

            return (rco);
        },

        /**
         * @memberof uvpjs.VideoControlInterface#
         * @private
         *
         * @param {Object} rcObj
         *
         * @return {Object}
         */
        prevalidateRcObj: function(rcObj) {
            var u = uvpjs.util,
                errMsg = '',
                hasError = false;

            if (!u.isPlainObject(rcObj)) {
                errMsg = "Invalid resource config object format";
                hasError = true;
            }
            else if (!u.isDefinedString(rcObj.type)) {
                errMsg = "Invalid resource type encountered";
                hasError = true;
            }

            return {
                error: hasError,
                message: errMsg
            };
        },

        /**
         * @memberof uvpjs.VideoControlInterface#
         * @private
         *
         * @param {String} msg
         * @param {Number} code
         */
        dispatchStartError: function(msg, code) {
            this.debug && uvpjs.error(this.DEBUG_ID, msg);

            this.eventsMgr.dispatchEvent(
                this.eventsMgr.eventTypes.VIDEO_START_ERROR,
                {
                    errorInfo: new uvpjs.ErrorInfo({
                        eventType: this.eventsMgr.eventTypes.VIDEO_START_ERROR,
                        errorCode: code || uvpjs.ErrorInfo.errorCodes.UNEXPECTED_CONDITION,
                        message: uvpjs.ErrorInfo.messages.UNEXPECTED_CONDITION + ' ' + msg,
                        isFatal: true
                    })
                },
                this.vidContId
            );
        },

        /**
         * @memberof uvpjs.VideoControlInterface#
         * @private
         */
        dispatchAdBlocked: function (missingSDK, fatal) {
            var xmsg = missingSDK ? ' (Missing ' + missingSDK + ' SDK)' : '';

            this.debug && uvpjs.error(this.DEBUG_ID, "Ad Blocking detected" + xmsg, this.vidContId);

            this.eventsMgr.dispatchEvent(
                this.eventsMgr.eventTypes.AD_BLOCKED, {
                    errorInfo: new uvpjs.ErrorInfo({
                        eventType: this.eventsMgr.eventTypes.AD_BLOCKED,
                        errorCode: uvpjs.ErrorInfo.errorCodes.AD_BLOCKING_DETECTED,
                        message: uvpjs.ErrorInfo.messages.AD_BLOCKING_DETECTED + xmsg,
                        isFatal: !!fatal
                    })
                },
                this.vidContId
            );
        },

        /**
         * Determine if an ad blocker is detectable and present,
         *
         * @memberof uvpjs.VideoControlInterface#
         * @private
         *
         * @return {Boolean} True if ad blocker detectable and enabled, false if ad blocker not detectable or detected.
         */
        checkForAdBlocker: function() {
            return uvpjs.adUtil.checkForAdBlocker(this.CVI_Mgr.cviModel);
        },

        // *********        Manage Resource Playlist Methods        ********* //

        /**
         * Pauses the resource playlist after the current video has ended.<br>
         * If you don't want the first RCO to play when adding an array of RCOs call the pausePlaylist() method before loading.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        pausePlaylist: function () {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_PAUSE, {}, this.vidContId);
        },

        /**
         * Unpauses a 'paused' playlist and allows it to load the next RCO when the current RCO ends. <br>
         * If there is no current RCO playing the first RCO in the playlist is started.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        resumePlaylist: function () {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_RESUME, {}, this.vidContId);
        },

        /**
         * Ends the currently playing resource and starts the next RCO in the resource playlist. <br>
         * Calling advancePlayList() unpauses the playlist if it is in a paused state.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        advancePlayList: function () {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_ADVANCE, {}, this.vidContId);
        },

        /**
         * Removes one or more resources from the resource playlist.<br>
         * The player compares the properties in each of the RCOs in the rcObjsArray with the RCOs in the playlist <br>
         * and removes the first matching RCO in the playlist. It does not inspect or remove the currently playing RCO.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Array} rcObjsArray - Array of resource config objects to be removed from the playlist.
         *
         * @public
         */
        removeResourcesFromPlaylist: function (rcObjsArray) {
            if (_.isArray(rcObjsArray) && rcObjsArray.length > 0) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_REMOVE_REQUEST, {rcObjs: rcObjsArray}, this.vidContId);
            }
        },

        /**
         * Ends the current resource and empties the playlist. Playlist paused state is not altered
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        destroyPlaylist: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'destroyPlaylist RESOURCE_PLAYLIST_DESTROY this.vidContId = ', this.vidContId);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.RESOURCE_PLAYLIST_DESTROY, {}, this.vidContId);
        },

        // *********          Video Playback Methods        ********* //

        /**
         * Starts video playback.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        playVideo: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'playVideo this.vidContId = ', this.vidContId);
            this.CVI_Mgr.playVideoRequest();
        },

        /**
         * Pauses video playback.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        pauseVideo: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'pauseVideo this.vidContId = ', this.vidContId);
            this.CVI_Mgr.pauseVideoRequest();
        },

        /**
         * Reloads last RCO.
         *
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        replayVideo: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'replayVideo', this._replayRco);
            this._replayRco && this.loadAndPlayResource(this._replayRco);
        },

        /**
         * Start playing the video at the specified time.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Number} seekToRealTime - integer seek to video "real" time
         *
         * @public
         */
        seekTo: function (seekToRealTime) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'seekToRealTime = ', seekToRealTime);
            if (isNaN(seekToRealTime)) {
                return; // todo are all seek times > 0? Should we trap that?
            }
            this.CVI_Mgr.seekToRequest(seekToRealTime);
        },

        /**
         * Seek to the live point of a live stream.
         * @memberOf uvpjs.VideoControlInterface#
         *
         * @public
         */
        seekToLive: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'seekToLive Attempt');
            this.CVI_Mgr.seekToLiveRequest();
        },

        /**
         * Stops playback of the current video.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        stopVideo: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'stopVideo');
            this.CVI_Mgr.stopVideoRequest();
        },

        /**
         * (Unimplemented) The video will be stopped, the net connection will be dropped, and the video image will be removed.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        clearVideo: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'clearVideo');
            this.CVI_Mgr.clearVideoRequest();
        },

        /**
         * Mute the video. Save the current player volume then sets player volume to 0. *Note: Most mobile devices don't allow the volume to be changed programatically.*
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        mute: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'mute');

            this.CVI_Mgr.muteRequest();
        },

        /**
         * Unmute the video and return volume to the pre-muted level.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        unMute: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'unMute');
            this.CVI_Mgr.unmuteRequest();
        },

        /**
         * Disable a Skin Manager button.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Button} name - The name of the button.
         *
         * @public
         */
        disableButton: function (name) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'disableButton', name);

            if (_.isEmpty(this.skinMgr) || _.isEmpty(name)) {
                return;
            }

            this.skinMgr.disableButton(name);
        },

        /**
         * Enable a Skin Manager button.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Button} name - The name of the button.
         *
         * @public
         */
        enableButton: function (name) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'enableButton', name);

            if (_.isEmpty(this.skinMgr) || _.isEmpty(name)) {
                return;
            }

            this.skinMgr.enableButton(name);
        },

        /**
         * Returns the muted state of the video player.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @returns {Boolean} True if the player is muted. False if the player is not muted.
         *
         * @public
         */
        getPlayerMuted: function () {
            return (this.CVI_Mgr.getPlayerMuted());
        },

        /**
         * Sets playback volume.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Number} newVolume - New volume between 0 and 1.
         *
         * @public
         */
        setVolume: function (newVolume) {
            if (_.isNaN(newVolume)) {
                return;
            }
            this.CVI_Mgr.volumeChangeRequest(newVolume);
        },

        /**
         * Returns the playback volume.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @returns {Number} Current volume between 0 and 1.
         *
         * @public
         */
        getVolume: function () {
            return this.CVI_Mgr.getVolume();
        },

        /**
         * Initiates loading of a closed captions file.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {String} captionsPath - URL string of the closed captions sidecar file.
         *
         * @public
         */
        loadCaptions: function (captionsPath) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'loadCaptions captionsPath = ', captionsPath);
            if (_.isString(captionsPath)) {
                this.CVI_Mgr.loadCaptionsRequest(captionsPath); // todo test for url string with regex
            }
        },

        /**
         * Displays the closed captions.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        showCaptions: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'showCaptions');
            this.CVI_Mgr.showCaptionsRequest();
        },

        /**
         * Hides the closed captions.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        hideCaptions: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'hideCaptions');
            this.CVI_Mgr.hideCaptionsRequest();
        },

        /**
         * Displays the diagnostic window.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        showDiagnosticWindow: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'showDiagnosticWindow');
            this.diagnostic && this.diagnostic.show();
        },

        /**
         * Hides the diagnostic window.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        hideDiagnosticWindow: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'hideDiagnosticWindow');
            this.diagnostic && this.diagnostic.hide();
        },

        /**
         * Sets multiple CSS properties on closed captions.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Array} props - Array of CSS name-value properties.
         *
         * @public
         */
        setCaptionsStyle: function (props) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'setCaptionsStyle', props);
            this.CVI_Mgr.setCaptionsStyleRequest(props);
        },

        /**
         * Sets a single CSS property for closed captions.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {String} name - CSS property name.
         * @param {String} value - CSS property value.
         *
         * @public
         */
        setCaptionsStyleProperty: function (name, value) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'setCaptionsStyleProperty', name, value);
            this.CVI_Mgr.setCaptionsStyleRequest([{name: name, value: value}]);
        },

        /**
         * Gets closed captions style object.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @returns {Object} CSS style object.
         *
         * @public
         */
        getCaptionsStyle: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'getCaptionsStyle');
            return this.CVI_Mgr.getCaptionsStyleRequest();
        },

        /**
         * Sets cue property for closed captions.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {String} name - Cue property name.
         * @param {String} value - Cue property value.
         *
         * @public
         */
        setCaptionsCueProperty: function (name, value) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'setCaptionsCueProperty', name, value);
            this.CVI_Mgr.setCaptionsCuePropertyRequest(name, value);
        },

        /**
         * (Unimplemented) Sets width and height of the video window. *Note: If width and height are not specified, they're set to 0.*
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Integer} width - Width to set video player size // may end up getting rid of this.
         * @param {Integer} height - Height to set video player size // may end up getting rid of this.
         */
        setSize: function (width, height) {
            // setSize: function(width, height, x, y){ / todo are we supporting x,y placement with this player?
            this.debug && uvpjs.log(this.DEBUG_ID, ('setSize  width = ' + width + '  height = ' + height));
            if (!_.isNumber(width) && !_.isNumber(height)) {
                this.CVI_Mgr.resizeRequest(width, height);
            }
        },

        /**
         * Returns the autoplay-related properties of MediaCapabilities.systemInfo
         *
         * @memberof uvpjs.VideoControlInterface#
         * @public
         * @return {Object}
         */
        getAutoplayInfo: function () {
            return this.mc.getAutoplayInfo();
        },

        /**
         * Allows the page to set a user gesture.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {String|Array} info - Gesture info array or string event payload. If it is an Array it has the following form: [gestureType, info1, info2, ...].
         * If it is a string it has this form 'event=someEvent&gestval=someGestVal:getValAttribute...' for example'event=autoplay&gestval=autoplay:credit_click'.</p>
         *
         * @public
         */
        setUserGesture: function (info) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'setUserGesture info = ', info);
            if (!_.isEmpty(info) &&
                ((_.isArray(info) && info.length > 0) || uvpjs.util.isDefinedString(info))) {
                this.CVI_Mgr.setUserGesture(info);
            }
        },

        /**
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Array} vendorArray - an array of names of QOS vendors who the metadata is targeting. For string constants see uvpjs.Type.QOSVendor.
         * @param {Object} paramsObj -  {n1:v1, n2,v2,..}
         *
         * @public
         */
        setQosMetadata: function (vendorArray, paramsObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'setQosMetadata vendorArray = ', vendorArray);
            this.debug && uvpjs.log(this.DEBUG_ID, 'setQosMetadata   paramsObj = ', paramsObj);

            if (_.isEmpty(vendorArray) || _.isEmpty(paramsObj) || !_.isArray(vendorArray)) {return;}

            this.debug && uvpjs.log(this.DEBUG_ID, 'setQosMetadata dispatch QOS_METADATA event');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.QOS_METADATA, {vendorArray:vendorArray, paramsObj:paramsObj}, this.vidContId);
        },

        /**
         * Toggles the fullscreen attribute of the video player.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Boolean} onOff notifies player of change in full screen state.
         *
         * @public
         */
        fullscreen: function (onOff) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'fullscreen onOff = ', onOff);
            if (_.isBoolean(onOff)) {
                this.CVI_Mgr.fullscreenRequest(onOff);
            }
        },

        /**
         * Returns an object containing the current content playback metadata. If the current video is ad, the object is the ad playback state. Otherwise, the object is the content video state.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @returns {contentPlaybackState|adPlaybackState} Object containing the current content playback metadata.
         *
         * @public
         */
        getCurrentPlaybackState: function () {
            return this.CVI_Mgr.getCurrentPlaybackState();
        },

        /**
         * @summary Returns an object containing the current content video metadata.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @returns {contentVideoState}
         *
         * @public
         */
        getContentVideoData: function () {
            return (this.CVI_Mgr.getContentVideoData());
        },

        /**
         * Returns an object containing the current ad video metadata.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @returns {adVideoState}
         *
         * @public
         */
        getAdVideoData: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'getAdVideoData');
            return (this.CVI_Mgr.getAdVideoData());
        },

        /**
         * Returns an string containing the unique player session ID.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @returns {String} - Player session ID.
         *
         * @public
         */
        getPlayerSessionId: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'getPlayerSessionId');
            return (this.CVI_Mgr.getPlayerSessionId());
        },

        /**
         * Called by the page to set page-level metadata for Adobe Heartbeat tracking. (May absorb DW Page Params)
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Object} contextData - Context metatdata from the page for CVI_Model.
         *
         * @public
         */
        setPageContextMetadata: function (contextData) {
            if (contextData && _.isPlainObject(contextData)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'setPageContextMetadata', contextData);
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTEXT_METADATA, {contextMetadata: contextData}, this.vidContId);
            }
        },

        /**
         * Set flag in CVI_Model and tell Resource Provider to tell Video Facade to remove native controls.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        removeNativeControls: function (onOff) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'removeNativeControls onOff = ', onOff);

            if (!_.isBoolean(onOff)) {
                return;
            }

            this.CVI_Mgr.setNativeControls(onOff);
        },

        // Start Live API

        /**
         * Switches dynamic switching on or off for manual or auto mode.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Boolean} onOff - a boolean that turns switching on or off.
         *
         * @returns {Boolean} - true/false value. true is auto switching, false is manual switching
         *
         * @public
         */
        useDynamicSwitching: function (onOff) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'useDynamicSwitching', onOff);

            if (!_.isBoolean(onOff)) {
                return;
            }

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.USE_DYNAMIC_SWITCHING, {data: onOff}, this.vidContId);
        },

        /**
         * Switches the bitrate level up.
         *
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        switchUp: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'switchUp');
            this.switchTo('up');
        },

        /**
         * Switches the bitrate level down.
         *
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        switchDown: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'switchDown');
            this.switchTo('down');
        },

        /**
         * Switches the level based on bitrate. Will map to a level index.
         * @param bitrate - Bitrate value in native denomination.
         * @memberOf uvpjs.VideoControlInterface#
         *
         * @public
         */
        switchBitrateTo: function (bitrate) {
            if (!bitrate || typeof bitrate !== 'number') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Unable to switch to a selected bitrate based on the value:', bitrate);
                return;
            } else {
                this.debug && uvpjs.log(this.DEBUG_ID, 'switch to bitrate:', bitrate);
            }

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.SWITCH_REQUEST, {bitrate: bitrate}, this.vidContId);
        },

        /**
         * Switches the level based on the level index.
         *
         * @param {Number|String} bitrate Numeric value of bitrate, or string `up` or `down`
         *                              (`up` switches up if less than max; `down` switches
         *                              down if above min). If index is numeric, switch to
         *                              that bitrate, if between max and min bitrates.
         *
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         */
        switchTo: function (bitrate) {
            var validStringValues = 'up,down';
            var validString = (bitrate !== null && bitrate !== undefined && typeof bitrate === 'string' && validStringValues.indexOf(bitrate) !== -1);
            var validNumber = (bitrate !== null && bitrate !== undefined && typeof bitrate === 'number' && !isNaN(bitrate));

            if(validString || validNumber) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'Switch To:', bitrate);
            } else {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Unable to switch to value', bitrate, validString, validNumber, typeof bitrate);
                return;
            }

            if(validNumber) {
                this.switchBitrateTo(bitrate);
            } else {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.SWITCH_REQUEST, {bitrate: bitrate}, this.vidContId);
            }
        },

        /**
         * Sets the minimum allowable bitrate. Will map to a rendition index.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Number} bitrate - numeric value of the bitrate.
         *
         * @public
         */
        setMinimumBitrateAllowed: function (bitrate) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Minimum Bitrate:', bitrate);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.MINIMUM_BITRATE_ALLOWED, {bitrate: bitrate}, this.vidContId);
        },

        /**
         * Sets the maximum allowable bitrate. Will map to a rendition index.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @param {Number} bitrate - numeric value of the bitrate.
         *
         * @public
         */
        setMaximumBitrateAllowed: function (bitrate) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'Set Maximum Bitrate:', bitrate);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.MAXIMUM_BITRATE_ALLOWED, {bitrate: bitrate}, this.vidContId);
        },

        // END LIVE API

        /**
         * Companion ad retrieval request by a skin manager. Since more than one ad image size is returned in the
         * XML response, the event payload must specify the desired image width and height.
         *
         * @param {Number} w - Integer Expected Img Width.
         * @param {Number} h - Integer Expected Img Height.
         * @memberof uvpjs.VideoControlInterface#
         *
         * @public
         *
         */
        pauseAdRequest: function (w, h) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'pauseAdRequest called');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.PAUSE_AD_REQUEST, {
                    width: w || null,
                    height: h || null
            }, this.vidContId);
        },

        /**
         * Dispatch a content-window resize event.
         *
         * @memberof uvpjs.VideoControlInterface#
         */
        _dispatchResizeEvent: function (e) {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTAINER_RESIZE, {e: e}, this.vidContId);
        },

        /**
         * Dispatches LIVE_SEGMENT_START event containing the live segment metadata.
         *
         * @param {Object} data - video metadata
         * @memberof uvpjs.VideoControlInterface#
         * @public
         */
        liveSegmentStart: function(data) {
            var event = this.eventsMgr.eventTypes.LIVE_SEGMENT_START,
                bundle = {liveSegmentData: data};

            this.eventsMgr.dispatchEvent(event, bundle, this.vidContId);
        },

        /**
         * Dispatches LIVE_SEGMENT_END event containing the live segment metadata.
         *
         * @param {Object} data - video metadata
         * @memberof uvpjs.VideoControlInterface#
         * @public
         */
        liveSegmentEnd: function(data) {
            var event = this.eventsMgr.eventTypes.LIVE_SEGMENT_END,
                bundle = {liveSegmentData: data};

            this.eventsMgr.dispatchEvent(event, bundle, this.vidContId);
        }
    });

}(uvpjs.register('uvpjs')));

/* CBSi uvpjs: client-side JS */
'use strict';

(function (obj) {

    var secret = Math.random(),
        _ = obj._;

    obj.VideoManager = uvpjs.Class.subClass({

        /**
         * @constructor uvpjs.VideoManager
         * @description Used to instantiate a singleton UVPJS Video Manager in a page.
         *
         * @param {Number} singletonKey - private key to ensure that this class is created via VideoManager.getInstance()
         *
         * @public
         */
        init: function(singletonKey) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.VIDEO_MANAGER;

            if (singletonKey !== secret) {
                // Throw an error here when direct instantiation by user is officially obsolete;
                // see also uvpjs.getVideoManager()
            }

            // Provisionally protect against multiple instantiation
            if (uvpjs.VideoManager._instance) {
                console.warn("UVPJS: An instance of VideoManager has already been created.");
                return;
            }

            uvpjs.VideoManager._instance = this;

            this.initComplete = false;
            this.initializing = false;
            this.successCallbacks = [];
            this.internalNS = '.Video_Manager';     // namespace for adding event listeners
            this.VCIs = {};                         // holds instances of Video Control Instance indexed by video tag ID string
            this.CDO = {};                          // config Data Object aka CDO
            this.currActiveVCI = null;
            this._allowConcurrentPlayback = false;
            this._disableAutoplay = false;

            this.mc = uvpjs.mediaCapabilities;
            this.eventsMgr = null;
            this.configMgr = null;
        },

        /**
         * Although the single instance of VideoManager will have a lifetime equal to that of a given page,
         * SPA scenarios could necessitate killing all UVPJS instances and starting fresh.
         * @memberof uvpjs.VideoManager#
         *
         * @public
         */
        destroy: function() {
            for (var id in this.VCIs) {
                // OPTIMIZE: not fully impl'd - see note in destroyVideoPlayer
                this.destroyVideoPlayer(id);
            }
            this.VCIs = null;

            this.eventsMgr && this.eventsMgr.destroy();
            this.configMgr && this.configMgr.destroy();
            this.eventsMgr = null;
            this.configMgr = null;

            this.currActiveVCI = null;
            this.CDO = null;
            this.mc = null;

            uvpjs.VideoManager.destroyInstance();
        },

        /**
         * Used to instantiate a singleton UVPJS Video Manager in a page.
         * @memberof uvpjs.VideoManager#
         *
         * @param {sessionOptions} options - Application and session level metadata.
         * @param {Function} successCallback - Bound callback in the page invoked when UVPJS has loaded config files and is ready to receive Resource Config Objects (RCOs).
         * @param {Function} errorCallback - Bound callback in the page invoked when the UVPJS Video Manager has encountered an error during initialization.
         *
         * @public
         */
        initialize: function(options, successCallback, errorCallback) {
            var cfg = uvpjs.Configuration,
                inst = uvpjs.VideoManager._instance,
                dbgMgr = uvpjs.DebugManager,
                vdnObj = this.validateParams(options, successCallback, errorCallback),
                vmsg = vdnObj.message,
                isValid = vdnObj.isValid;

            // If a message is included in the validation return obj, something's amiss...
            if (vmsg) {
                // if not valid, it's fatal error (options or successCallback are invalid);
                console[!isValid ? 'error' : 'warn'](vmsg);
                !isValid && vdnObj.errorCb && vdnObj.errorCb(vmsg);

                if (!isValid) {
                    return;
                }
            }

            // prevent initialize from being called more than once
            if (inst) {
                if (inst.isInitializing()) {
                    inst.addInitCallback(successCallback);

                    return;
                }
                else if (inst.isReady()) {
                    uvpjs.util.isFunction(successCallback) && successCallback(this.mc.systemInfo);

                    return;
                }
            }

            // NOTE: This always outputs player info to the console.
            // e.g. UVPJS 1.9.0 01/25/17 2:38:24 PM (EST)
            console.log([cfg.name, cfg.version, cfg.date].join(' '));

            // Create global logging shortcuts.
            uvpjs.log = dbgMgr.log.bind(dbgMgr);
            uvpjs.warn = dbgMgr.warn.bind(dbgMgr);
            uvpjs.error = dbgMgr.error.bind(dbgMgr);

            // Create session start time for pre-initialized console output.
            dbgMgr.setSessionStartTime();

            this.initializing = true;
            this.useNativeAutoplay = !!(options.enableNativeMobileAutoplay && this.mc.supportsIntelligentMobileAutoplay());

            this.addInitCallback(successCallback);

            this.debug && uvpjs.log(this.DEBUG_ID, 'initialize options = ', options);

            // Create EventsManager Singleton used by all UVPJS entities.
            this.eventsMgr = uvpjs.EventsManager.getInstance();

            // Listen for Events Manager errors and warnings.
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.UVPJS_ERROR + this.internalNS, this.uvpjsError.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.UVPJS_WARNING + this.internalNS, this.uvpjsWarning.bind(this));

            // Listeners to establish current active player in non-concurrent video case.
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.CONTROL_PLAY + this.internalNS, this.onVideoPlaybackInitiated.bind(this));
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.PREVIEW_BUTTON + this.internalNS, this.onVideoPlaybackInitiated.bind(this));

            // Listener to monitor current active player in non-concurrent video case and pause any video instances that should not be playing.
            this.eventsMgr.addEventListener(this.eventsMgr.eventTypes.VIDEO_PROGRESS + this.internalNS, this.onVideoProgress.bind(this));

            // construct configMgr, calls this.onCongfigMgrReady when ready.
            this.configMgr = uvpjs.ConfigManager.getInstance(options, this.onCongfigMgrReady.bind(this));
        },

        /**
         * Returns true if constructor params are
         *
         * @param options
         * @param successCallback
         * @param errorCallback
         *
         * @returns {Object}
         */
        validateParams: function(options, successCb, errorCb) {
            var util = uvpjs.util,
                msg = null,
                isFatal = false,
                m = 'VideoManager.initialize()',
                errCb = util.isFunction(errorCb) ? errorCb : null;

            // session options
            if (!options || !_.isPlainObject(options)) {
                msg = m + ' was invoked with invalid session options.';
                isFatal = true;
            }

            // success callback
            if (!util.isFunction(successCb)) {
                msg = m + ': A success callback function is required.';
                isFatal = true;
            }

            // error callback
            if (!errCb) {
                msg = m + ' did not receive a valid error callback function.';
                isFatal = false;
            }

            return {
                errorCb: errCb,
                message: msg,
                isValid: !isFatal
            };
        },

        /**
         * Returns a boolean indicating whether VideoManageer has completed initialization
         * @returns {boolean}
         */
        isReady: function() {
            return this.initComplete;
        },

        /**
         * Returns a boolean indicating whether VideoManageer initialization is in progress
         * @returns {boolean}
         */
        isInitializing: function() {
            return this.initializing;
        },

        /**
         * Adds a 'success' callback invoked when this video manager has completed initializing.
         * @memberof uvpjs.VideoManager#
         * @private
         *
         * @param {Function} successCB
         */
        addInitCallback: function(successCB) {
            var i = this.successCallbacks.length;

            if (uvpjs.util.isFunction(successCB))  {
                while(i--) {
                    if (this.successCallbacks[i] === successCB) {
                        return;
                    }
                }
                this.successCallbacks.push(successCB);
            }
        },

        /**
         * Startup configuration complete callback, invoked by the Configuration Manager.
         * @memberof uvpjs.VideoManager#
         *
         * @param {Object} CDO - Config Data Object aka CDO.
         */
        onCongfigMgrReady: function(CDO) {
            if (!_.isObject(CDO)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager onCongfigMgrReady CDO MISSING OR MISS-TYPED - RETURN'}, this.internalNS);
                return;
            }

            this.CDO = CDO;
            this.checkForForcedHlsjs(this.CDO);

            this.setupDebugManager();

            var trackingMgr = new uvpjs.TrackingManager();
            trackingMgr.loadAgentPlugins(this.CDO, this.trackingAgentsLoadedCB.bind(this));
        },

        /**
         * @param {uvpjsConfigDataObject}
         */
        checkForForcedHlsjs: function (cdo) {
            var hasVps = cdo.isModuleEnabled('VideoPlaybackSettings'),
                force = hasVps && cdo.getModuleParam('VideoPlaybackSettings', 'forceHlsjs'),
                isString = typeof force === 'string',
                ftl =  isString && force.toLowerCase(),
                isEligible;

            if (!force || uvpjs.util.isEmpty(force)) return;

            if (force === true || force === 1 || (isString && (ftl === '1' || ftl === 'y' || ftl === 'yes'))) {
                isEligible = this.mc.canPlayHLSJS(true);

                // if eligible, use partial application to pre-supply canPlayHlsjs with the 'force' param -
                // all subsequent calls to this method (which normally takes no args) will have
                // the forceHlsjs param set to true.
                isEligible && (this.mc.canPlayHLSJS = this.mc.canPlayHLSJS.bind(this.mc, true));

                // reset the value of this property before we pass it back to user code
                this.mc.systemInfo.isHlsjsEligible = isEligible;
            }
        },


        /**
         * Callback when all tracking agents are loaded (as well as all configuration). Dispatches PLAYER_LOADED (for
         * internal consumption only) and invokes 'video manager ready' callback.
         * @memberof uvpjs.VideoManager#
         */
        trackingAgentsLoadedCB: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'Tracking agents have loaded; now checking autoplay...');
            this.checkAutoplay();
        },

        /**
         * @private
         */
        checkAutoplay: function () {
            uvpjs.mediaCapabilities.determineAutoplayCapabilities(this.onAutoplayCheckComplete.bind(this));
        },

        /**
         * @private
         */
        onAutoplayCheckComplete: function () {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.PLAYER_LOADED, {}, this.internalNS);

            this._allowConcurrentPlayback = this._determineConcurrentPlaybackStatus();

            this.initComplete = true;
            this.initializing = false;

            while (this.successCallbacks.length) {
                this.successCallbacks.shift()(this.mc.systemInfo);
            }
        },


        /**
         * Will return the boolean value for allowConcurrentPlayback, based on whether other session settings
         * require this value to be coerced.
         * @private
         */
        _determineConcurrentPlaybackStatus: function() {
            return this.useNativeAutoplay === true || !!this.CDO.sessionOptions.allowConcurrentPlayback
        },

        /**
         * Setup UVPJS logging.
         * @memberof uvpjs.VideoManager#
         */
        setupDebugManager: function() {
            // uvpjs.log(this.DEBUG_ID, 'setupDebugManager');

            // Setup debug logging.
            uvpjs.DebugManager.initialize(this.CDO);

            // TODO: Investigate whether initial debug statements are needed.
            //       Currently not shown until the below flag is set, but the
            //       debug cookie could be read earlier, if needed.
            uvpjs.debug = uvpjs.DebugManager.isEnabled;
        },



        /**
         * UVPJS Page API, passes event registration through to EventsManager.
         * @memberof uvpjs.VideoManager#
         *
         * @param {String} evt - One of the EventManger.eventTypes CONST event type strings with jQuery-like namespace string.
         * @param {Function} cb - Bound event callback.
         */
        addEventListener: function(evt, cb){
            if (!this.eventsMgr) { return; }

            if (!evt || !_.isString(evt) || !_.isFunction(cb)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager addEventListener MISSING OR MISS-TYPED PARAMS RETURN'}, this.internalNS);
                return;
            }
            this.eventsMgr.addEventListener(evt, cb);
        },

        /**
         * UVPJS Page API, passes event de-registration through to EventsManager.
         * @memberof uvpjs.VideoManager#
         *
         * @param {String} evt - One of the EventManger.eventTypes CONST event type strings with jQuery like namespace string.
         */
        removeEventListener: function(evt){
            if (!evt || !_.isString(evt)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager removeEventListener !evt || evt !== string INVALID RETURN'}, this.internalNS);
                return;
            }
            this.eventsMgr.removeEventListener(evt);
        },

        /**
         * Returns and object keyed on video container (element) ids; values are VideoControlInterface objects.
         * @memberof uvpjs.VideoManager#
         * @public
         *
         * @returns {Object}
         */
        getVideoPlayers: function() {
            var out = {}, q;

            for (q in this.VCIs) {
                out[q] = this.VCIs[q];
            }

            return out;
        },

        /**
         * Create a single Video Control Interface (VCI) and returns a reference to the page.
         * @memberof uvpjs.VideoManager#
         *
         * @param {String} videoContainerId - The video container div ID for this VCI - Video Control Interface.
         * @param {Function} vciReadyCallback - Callback in page invoked by the Core Video Manager when the video player has been created.
         * @param {Object} playerOptions - Optional per video player session option overrides.
         *
         * @public
         */
        createVideoPlayer: function(videoContainerId, vciReadyCallback, playerOptions) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'createVideoPlayer');
            }

            if (!_.isString(videoContainerId) || !_.isFunction(vciReadyCallback) || (playerOptions && !_.isPlainObject(playerOptions))) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager createVideoPlayer initialization PARAMS MISSING OR MISS-TYPED - RETURN'}, this.internalNS);
                return;
            }
            var videoPlayerArgs = [videoContainerId, vciReadyCallback];

            if (playerOptions) {
                videoPlayerArgs.push(playerOptions);
            }

            this.createMultipleVideoPlayers([videoPlayerArgs]);
        },


        /**
         * Remove a single VCI from the global `VCIs` object.
         * @memberof uvpjs.VideoManager#
         *
         * @param {String} videoContainerId - The video container ID for the VCI.
         *
         * @returns {Boolean} Whether the removal was successful.
         *
         * @public
         */
        destroyVideoPlayer: function(videoContainerId) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'destroyVideoPlayer');
            }

            if (!_.isString(videoContainerId)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager destroyVideoPlayer missing parameters'}, this.internalNS);
                return false;
            }

            if (_.isEmpty(this.VCIs) || !this.VCIs[videoContainerId]) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager destroyVideoPlayer container VCI does not exist ' + videoContainerId}, this.internalNS);
                return false;
            }

            // OPTIMIZE - need to fully implement destroy on VCI and its children.
            // This will touch a lot of files and might be better handled in a separately ticketed task.
            // (destroy currently impl'd on VCI as a noop)
            this.VCIs[videoContainerId].destroy();
            return delete this.VCIs[videoContainerId];
        },

        /**
         * Returns the autoplay-related properties of MediaCapabilities.systemInfo
         *
         * @memberof uvpjs.VideoManager#
         *
         * @return {Object}
         */
        getAutoplayInfo: function () {
            return this.mc ? this.mc.getAutoplayInfo() : {
                supportsMutedAutoplay: null,
                supportsUnmutedAutoplay: null
            };
        },

        /**
         * Create multiple Video Control Interface (VCI) and returns each reference to the page. See example below.
         * @example var videoArray = [['cbsiVideoContainer1', videoDisplayReadyCallback, playerOptions1], ['cbsiVideoContainer2', videoDisplayReadyCallback, playerOptions2]];
         * @memberof uvpjs.VideoManager#
         *
         * @param {Array} initArrays - An array of Video Control Interface initialization arrays.
         *
         * @public
         */
        createMultipleVideoPlayers: function(initArrays) {
            var isValidAutoplay, VCI, i, len, args, vidContId, vciReadyCB, playerOptions;

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'createMultipleVideoPlayers');
            }

            if (this._disableAutoplay) {
                this._disableAutoplay = !_.isEmpty(this.VCIs); // Reset to `false` if there are no VCIs.
            }

            if (!_.isArray(initArrays)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager createMultipleVideoPlayers PARAMS IS NOT AN ARRAY - RETURN'}, this.internalNS);
                return;
            }

            len = initArrays.length;

            // OPTIMIZE? - if any one player object has a flaw, no players created?
            // Verify all video player objects are constructed correctly.
            for (i = 0; i < len; i++) {
                args = initArrays[i];
                vidContId = args[0];
                vciReadyCB = args[1];
                playerOptions = args[2];

                if (args.length < 2 || !_.isString(vidContId) || !_.isFunction(vciReadyCB) || (!_.isUndefined(playerOptions) && !_.isPlainObject(playerOptions))) {
                    this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager createMultipleVideoPlayers initialization ARRAY PARAMS MISSING OR MISS-TYPED - RETURN'}, this.internalNS);
                    return;
                }
            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'createMultipleVideoPlayers Arrays OK. Create VCIs.');
            }

            // Construct Video Control Interfaces aka VCIs.
            // ['cbsiVideoContainer_1', videoDisplayReadyCallback, playerOptions1]
            for (i = 0; i < len; i++) {
                args = initArrays[i];
                vidContId = args[0];
                vciReadyCB = args[1];
                playerOptions = args[2] || {};

                if (this.debug) {
                    uvpjs.log(this.DEBUG_ID, 'createMultipleVideoPlayers LOOP containerID = args[0] = ', vidContId);
                }

                // Create playerOptions for each player instance.
                playerOptions = this.CDO.getSessionOptions(playerOptions);

                isValidAutoplay = this.validateAutoplay(playerOptions);

                // Allow the first player using autoplay to autoplay; set all others players to `autoPlay:false`.
                // TODO - autoplay May need better logic around concurrent playback
                if (this._allowConcurrentPlayback === false && isValidAutoplay) {

                    // Set all other players `autoPlay:false`.
                    if (this._disableAutoplay) {
                        playerOptions.enableMutedAutoplay = false;
                        playerOptions.enableUnmutedAutoplay = false;
                    }

                    this._disableAutoplay = true;
                }

                // Now create the next Video Control Interface (VCI).
                VCI = new uvpjs.VideoControlInterface();

                this.VCIs[vidContId] = VCI; // Use the vidContId as the index for the VCI instance.
                VCI.initialize(vidContId, this.eventsMgr, this.CDO, vciReadyCB, playerOptions);
            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'createMultipleVideoPlayers after loop this._disableAutoplay', this._disableAutoplay);
                uvpjs.log(this.DEBUG_ID, 'createMultipleVideoPlayers this.VCIs = ', this.VCIs);
            }
        },

        /**
         * @private
         * @param {Object} playerOptions
         *
         * @return {Boolean}
         */
        validateAutoplay: function (playerOptions) {
            var unMutedAp = playerOptions.enableUnmutedAutoplay && this.mc.supportsUnmutedAutoplay(),
                valid = !!(
                    (playerOptions.enableMutedAutoplay && this.mc.supportsMutedAutoplay()) || unMutedAp
                );

            if (unMutedAp) {
                playerOptions.enableMutedAutoplay = false;
            }

            if (!valid) {
                // Coerce options to false if autoplay choice isn't supported
                playerOptions.enableMutedAutoplay = false;
                playerOptions.enableUnmutedAutoplay = false;
            }

            return valid;
        },

        /**
         * @memberof uvpjs.VideoManager#
         *
         * @param {Object} optionsOverride - Object with session properties and new values ex: {ursuid:'LarryDoyle', userStatus:'stayinAlive'}.
         */
        overrideSessionOptions: function(optionsOverride) {
            if (!optionsOverride || !_.isPlainObject(optionsOverride)){
                // this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg:'VideoManager overrideSessionOptions optionsOverride missing or not an object  RETURN'}, this.internalNS);
                return;
            }
            // pass thru to Config Data Object
            this.CDO.overrideSessionOptions(optionsOverride);
        },

        /**
         * VIDEO_PROGRESS event callback. Manages play/pause state when concurrent video playback is not allowed.
         * @memberof uvpjs.VideoManager#
         *
         * @param {Object} evtObj - Event data object. payload = {video playback properties} including payload.playbackState
         */
        onVideoProgress: function(evtObj) {
          //  uvpjs.log(this.DEBUG_ID, 'onVideoProgress');

            if (this._allowConcurrentPlayback ||
                !_.isPlainObject(evtObj) ||
                _.isUndefined(evtObj.target) ||
                _.isUndefined(evtObj.payload) ||
                _.isUndefined(evtObj.payload.playbackState) ||
                evtObj.payload.playbackState !== this.mc.PLAYING) {
                return;
            }

            var vidContId = evtObj.target;

            if (_.isEmpty(this.currActiveVCI) && !_.isUndefined(this.VCIs[vidContId]) ) {
                this.currActiveVCI = this.VCIs[vidContId];
            }

            if (vidContId !== this.currActiveVCI.vidContId && !_.isUndefined(this.VCIs[vidContId]) ) {
                if (this.debug) {
                    uvpjs.log(this.DEBUG_ID, 'onVideoProgress this.VCIs[vidContId].pauseVideo();', vidContId);
                }
                this.VCIs[vidContId].pauseVideo();
            }

        },

        /**
         * PREVIEW_BUTTON or CONTROL_PLAY callback. Keeps track of current active Resource Provider when not allowing concurrent playback.
         * @memberof uvpjs.VideoManager#
         *
         * @param {Object} evtObj - Event data object. payload = {}
         */
        onVideoPlaybackInitiated: function(evtObj) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'onVideoPlaybackInitiated', evtObj);
            }

            if (this._allowConcurrentPlayback || !_.isPlainObject(evtObj) || _.isUndefined(evtObj.target)) {
                return;
            }

            var vidContId = evtObj.target;

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'onVideoPlaybackInitiated this.VCIs', Object.keys(this.VCIs), this.VCIs);
            }

            // return if there are no VCIs or if there is no VCI with the index this.vidContId aka evtObj.target
            if (_.isEmpty(this.VCIs) || _.isUndefined(this.VCIs[vidContId])) {
                //uvpjs.warn(this.DEBUG_ID, 'onVideoPlaybackInitiated  EMPTY this.VCIs OR this.VCIs[vidContId] is UNDEFINED!  WTF ->  RETURN');
                return;
            }

            // Set currActiveVCI if it is empty or different.
            if (!this.currActiveVCI || this.currActiveVCI.vidContId !== vidContId) {
                //uvpjs.log(this.DEBUG_ID, 'onVideoPlaybackInitiated   RESET this.currActiveVCI.vidContId WAS = ', this.currActiveVCI.vidContId);
                this.currActiveVCI = this.VCIs[vidContId];
                if (this.debug) {
                    uvpjs.log(this.DEBUG_ID, 'onVideoPlaybackInitiated   RESET this.currActiveVCI NEW = ', this.currActiveVCI);
                }
            }

        },

        /**
         * Displays error string in the console.
         * @memberof uvpjs.VideoManager#
         *
         * @param {Object} evtObj - Error event data object.
         */
        uvpjsError: function(evtObj) {
            if (evtObj) {
                if (this.debug) {
                    uvpjs.error(this.DEBUG_ID, 'ERROR: ', evtObj.payload.msg);
                }
            } else {
                if (this.debug) {
                    uvpjs.error(this.DEBUG_ID, 'ERROR: uvpjsError MISSING evtObj !!!!!!!!!!!' );
                }
            }
        },

        /**
         * Displays warning string in the console.
         * @memberof uvpjs.VideoManager#
         *
         * @param {Object} evtObj - Warning event data object.
         */
        uvpjsWarning: function(evtObj) {
            if (evtObj) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'WARNING: ',  evtObj.payload.msg);
                }
            } else {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'WARNING: uvpjsWarning MISSING evtObj !!!!!!!!!!!' );
                }
            }
        }

    });


    // Singleton pattern
    obj.VideoManager._instance = null;

    obj.VideoManager.destroyInstance = function() {
        this._instance = null;
    };

    obj.VideoManager.getInstance = function() {
        if (!this._instance) {
            // note use of private "secret" for singletonKey
            this._instance =  new uvpjs.VideoManager(secret);
        }

        return this._instance;
    };


}(uvpjs.register('uvpjs')));

'use strict';

(function (obj) {

    var _ = obj._,
        getAlpha,
        getColor,
        getDefaultStyles,
        getFontSizePercent,
        getNumLines,
        getTime,
        hexToRgb,
        isCaptionsTrack,
        isValidCSS,
        nameToHex,
        metadataToPosition,
        rgbaToRgb,
        toRgba,
        toKebabCase,
        toTextShadow,
        xmlToJson;

    /**
     * @constructor uvpjs.CaptionsManager
     * @extends uvpjs
     */

    obj.CaptionsManager = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.CAPTIONS_MANAGER,

        VIDEO_ID_PREFIX: uvpjs.domConstants.VIDEO_ID_PREFIX,
        CAPTIONS_ID_PREFIX: uvpjs.domConstants.CAPTIONS_ID_PREFIX,

        CAPTIONS_CONTAINER_CLASSNAME: 'uvpjs__cc-container',
        CAPTIONS_TEXT_CLASSNAME: 'uvpjs__cc-text',
        CUE_PSEUDO_CLASS: '::cue',

        CONFIG_MODULE_NAME: 'ClosedCaptions',
        LOAD_VTT_WAIT: 50, // Timeout to prevent executing captions file load callback too quickly.

        BASE_CONTROLS_HEIGHT: '50px', // OPTIMIZE: Should calculate video window bottom vs content window to make sure this isn't raised too much.
        BASE_FONT_SIZE: '22px',
        BASE_VIDEO_WIDTH: '848px',
        MIN_FONT_SIZE: '10px',


        /**
         * Constructor function.
         *
         * @param {Object}               options
         * @param {String}               options.containerId  Main outer container id.
         * @param {uvpjs.CVI_Model}      options.cviModel     Instance of CVI_Model.
         * @param {uvpjs.EventsManager}  options.eventsMgr    Instance of EventsManager.
         * @param {Boolean}               options.deferLoadingCaptions If loading of captions should be delayed until enabled
         *
         * @constructor uvpjs.CaptionsManager
         * @extends uvpjs
         */
        init: function (options) {
            var mc = uvpjs.mediaCapabilities;

            this.debug = uvpjs.debug;

            if (!options) {
                return;
            }

            this._cviModel = options.cviModel;
            this._eventsMgr = options.eventsMgr;
            this._containerId = options.containerId;

            this._videoId = this.VIDEO_ID_PREFIX + this._containerId;
            this._captionsId = this.CAPTIONS_ID_PREFIX + this._containerId;

            this._namespace = '.' + this._containerId + '.captionsMgr';
            this._supportsVTTCue = window.VTTCue !== undefined;

            this.debug && uvpjs.log(this.DEBUG_ID, 'init', this._containerId);

            // Store merged style information.
            this.styles = getDefaultStyles();

            // Store cue position properties.
            this._props = {};

            this._videoEl = null;
            this._ccEl = null;

            // In order of rank.
            this._pageStyles = {};
            this._configStyles = null;
            this._inlineStyles = null;

            this._captionsJson = null;
            this._liveCaptionsInitalized = false;
            this.hasDispatchedCaptionsReady = false;
            this._lineOffset = mc.getCaptionsLineOffset();
            this._lineAlign = mc.getCaptionsCenterAlignToken();
            this._captionsUrl = null;
            this._deferLoadingCaptions = options.deferLoadingCaptions;

            this._trackCount = 0;
            this._trackId = null;
            this._trackMode = 'hidden';
            this._disabled = false;

            this.ccDisplayRequested = false;

            // Method bindings
            this._onAddTrack = this._onAddTrack.bind(this);
            this._onLoadedData = this._onLoadedData.bind(this);
            this._onTimeUpdate = this._onTimeUpdate.bind(this);
            this._finalizeInit = this._finalizeInit.bind(this);
            this._onVideoProgress = this._onVideoProgress.bind(this)

            uvpjs.util.createStyleSheet(this._finalizeInit);

            this._setCDOParams();
            this._addEventListeners();
        },

        /**
         * @memberof uvpjs.CaptionsManager
         */
        destroy: function () {
            this.styles = null;
            this._cviModel = null;
            this._eventsMgr = null;
            this._videoEl = null;
            this._videoId = null;
            this._captionsId = null;
            this._ccEl = null;
            this._styleSelector = null;
            this._containerId = null;
            this._namespace = null;
            this._pageStyles = null;
            this._configStyles = null;
            this._inlineStyles = null;
            this._defaultStyles = null;
            this._captionsJson = null;
            this._captionsUrl = null;
            this._props = null;
            this._supportsVTTCue = false;
            this._liveCaptionsInitalized = false;
            this._lineOffset = null;
            this._lineAlign = null;
            this._onLoadedData = null;
            this._trackCount = 0;
            this._trackId = null;
            this._trackMode = 'hidden';

            this._removeEventListeners();
        },

        /**
         * Callback after stylesheet is added to the page.
         *
         * @param {HTMLElement} styleEl
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _finalizeInit: function (styleEl) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_finalizeInit');

            this._styleEl = styleEl;

            // CBSVIDEO-524 Create container for non-native captions after stylesheet added.
            // VTG-407 Use non-native captions only.
            !this._ccEl && this._createCaptionsElement();
        },

        ////////////////////
        // Public accessors

        /**
         * API for showing tracks.
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined}
         */
        showCaptions: function (evtObj) {
            if (this._deferLoadingCaptions && !this._hasCaptions()) {
                this._loadCaptionsUrl(this._captionsUrl);
                this._eventsMgr.addEventListener(this._eventsMgr.eventTypes.CAPTIONS_READY + this._namespace, this.showCaptions.bind(this));

                return;
            }

            this.ccDisplayRequested = true;
            if (!this._getActiveTrack()) {
                this.enableCaptionsTracks();
            }
            this._eventsMgr.removeEventListener(this._eventsMgr.eventTypes.CAPTIONS_READY + this._namespace);
            this._toggleVisibility(evtObj, 'showing');
        },

        /**
         * API for hiding tracks.
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined}
         */
        hideCaptions: function (evtObj) {
            this.ccDisplayRequested = false;
            this._toggleVisibility(evtObj, 'hidden');
        },

        /**
         * Get captions CSS style object.
         *
         * @memberof uvpjs.CaptionsManager
         *
         * @returns {Object} CSS style object.
         */
        getStyles: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'getCaptionsStyle');

            if (this._disabled) return {};

            return _.clone(this.styles);
        },

        /**
         * Set captions CSS.
         *
         * @param {Array} props Array of CSS key-value properties.
         *
         * @memberof uvpjs.CaptionsManager
         */
        setStyles: function (props) {
            var styles = this._pageStyles,
                i = props.length,
                name, value, p;

            if (this._disabled) return;

            this.debug && uvpjs.log(this.DEBUG_ID, 'setStyles', props);

            while (i--) {
                p = props[i];
                name = toKebabCase(p.name);
                value = p.value;
                styles[name] = value;
            }

            this._updateStylesObject(styles);
            this._applyStyles();
        },

        /**
         * Change property of all VTTCue objects.
         *
         * NOTE: TextTrackCues don't contain the same properties as VTTCues.
         * NOTE: We should be normalizing around VTT. If we don't have VTT,
         *       we should be loading a polyfill. - Tom
         *
         * @param {String} key Property key name.
         * @param {String|Number} value Property value.
         *
         * @memberof uvpjs.CaptionsManager
         */
        setCueProperty: function (key, value) {
            var track;

            if (this._disabled) return;

            track = this._getActiveTrack();

            if (!key || !value || !track || !this._supportsVTTCue) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Unable to set captions cue property:', key, value);
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'setCueProperty', track, key, value);

            this._props[key] = isNaN(value) ? value : Number(value);
        },


        /////////////////
        // UVPJS events

        /**
         * Register callbacks to events dispatched by UVPJS.
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined}
         */
        _addEventListeners: function () {
            var em = this._eventsMgr,
                et = em.eventTypes,
                ns = this._namespace,
                isLive = this._cviModel.contentVideoState.isLive;

            this.debug && uvpjs.log(this.DEBUG_ID, '_addEventListeners', isLive);

            em.addEventListener(et.CONTAINER_RESIZE + ns, this._onContainerResize.bind(this));
            em.addEventListener(et.CONTROL_LOAD_CAPTIONS + ns, this._onControlLoadCaptions.bind(this));
            em.addEventListener(et.CONTENT_DATA_LOADED + ns, this._onContentDataLoaded.bind(this));
            em.addEventListener(et.CONTROL_SHOW_CAPTIONS + ns, this.showCaptions.bind(this));
            em.addEventListener(et.CONTROL_HIDE_CAPTIONS + ns, this.hideCaptions.bind(this));
            em.addEventListener(et.CONTENT_FACADE_CREATED + ns, this._onContentFacadeCreated.bind(this));
            em.addEventListener(et.RESOURCE_END + ns, this._onVideoComplete.bind(this));

            this._addVideoProgressHandler();
        },

        /**
         * Remove callbacks.
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined}
         */
        _removeEventListeners: function () {
            var em = this._eventsMgr,
                et = em.eventTypes,
                ns = this._namespace,
                isLive = this._cviModel.contentVideoState.isLive;

            this.debug && uvpjs.log(this.DEBUG_ID, '_removeEventListeners');

            em.removeEventListener(et.CONTAINER_RESIZE + ns);
            em.removeEventListener(et.CONTROL_LOAD_CAPTIONS + ns);
            em.removeEventListener(et.CONTENT_DATA_LOADED + ns);
            em.removeEventListener(et.CONTROL_SHOW_CAPTIONS + ns);
            em.removeEventListener(et.CONTROL_HIDE_CAPTIONS + ns);
            em.removeEventListener(et.CONTENT_FACADE_CREATED + ns);
            em.removeEventListener(et.RESOURCE_END + ns);

            this._removeVideoProgressHandler();
        },

        /**
         * Add VIDEO_PROGRESS callback.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _addVideoProgressHandler: function () {
            var em = this._eventsMgr,
                et = em.eventTypes,
                ns = this._namespace;

            this.debug && uvpjs.log(this.DEBUG_ID, '_addVideoProgressHandler');

            em.addEventListener(et.VIDEO_PROGRESS + ns, this._onVideoProgress);
        },

        /**
         * Remove VIDEO_PROGRESS callback.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _removeVideoProgressHandler: function () {
            var em = this._eventsMgr,
                et = em.eventTypes,
                ns = this._namespace;

            this.debug && uvpjs.log(this.DEBUG_ID, '_removeVideoProgressHandler');

            em.removeEventListener(et.VIDEO_PROGRESS + ns, this._onVideoProgress);
        },


        ///////////////////
        // DOM interaction

        /**
         * Create <track> element for WebVTT files.
         *
         * NOTE: This method is not called for standard DFXP XML files.
         *
         * @param url - The url of the WebVTT file.
         *
         * @memberof uvpjs.CaptionsManager
         */
        _createTrackElement: function (url) {
            var videoEl = this._videoEl,
                isFileLoaded = false,
                onLoad, track;

            this.debug && uvpjs.log(this.DEBUG_ID, '_createTrackElement', url);

            // Allow cross-origin WebVTT files.
            if (url.indexOf(window.location.host) === -1) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_createTrackElement adding crossorigin="use-credentials" to <video> element.');
                videoEl.setAttribute('crossorigin', 'use-credentials');
            }

            // Create new track tag.
            track = document.createElement('track');
            track.kind = 'captions';
            track.label = 'English';
            track.srclang = 'en';
            track.id = this._trackId;
            track.mode = this._trackMode;
            track.src = url;

            videoEl.appendChild(track);

            // Captions loaded callback.
            onLoad = function () {
                // Prevent from being called twice if both events execute.
                if (!isFileLoaded) {
                    this.debug && uvpjs.log(this.DEBUG_ID, '_createTrackElement loaded', track);
                    isFileLoaded = true;
                    this._finalizeCaptions();
                }
            }.bind(this);

            // Listen for both load and loaded events.
            track.addEventListener('load', setTimeout(onLoad, this.LOAD_VTT_WAIT));
            track.addEventListener('loaded', setTimeout(onLoad, this.LOAD_VTT_WAIT));
        },

        /**
         * Create the cc container element.
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _createCaptionsElement: function () {
            var u = uvpjs.util,
                styleEl = this._styleEl,
                ccEl = document.createElement('div'),
                contentEl = document.getElementById(uvpjs.domConstants.CONTENT_ID_PREFIX + this._containerId);

            ccEl.id = this._captionsId;

            this.debug && uvpjs.log(this.DEBUG_ID, '_createCaptionsElement');

            if (!contentEl) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Can\'t create captions container. No video content container.');
                return;
            }

            contentEl.appendChild(ccEl);

            this._ccEl = ccEl;

            // Container styles.
            u.addCSSObject(styleEl, ccEl, {
              'width': '100%',
              'height': '100%',
              'position': 'absolute',
              'top': 0,
              'bottom': 0,
              'left': 0,
              'right': 0,
              'display': 'none',
              'font-size': this.BASE_FONT_SIZE
            });

            // Container styles.
            u.addCSSObject(styleEl, ccEl, {
              'position': 'absolute',
              'top': 'auto',
              'bottom': this.BASE_CONTROLS_HEIGHT,
              'left': 0,
              'right': 0,
              'text-align': 'center',
              'font-size': '100%'
            }, '.' + this.CAPTIONS_CONTAINER_CLASSNAME);

            // Text styles.
            u.addCSSObject(styleEl, ccEl, {
              'display': 'inline-block',
              'padding': '3px 5px',
              'font-size': '100%'
            }, '.' + this.CAPTIONS_TEXT_CLASSNAME);
        },


        /////////////////////
        // Event dispatchers

        /**
         * Dispatch CAPTIONS_ERROR event.
         * @param {String} msg - Error message.
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined} Undefined
         */
        _dispatchCaptionsError: function (msg) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_dispatchCaptionsError', msg);
            this._eventsMgr.dispatchEvent(this._eventsMgr.eventTypes.CAPTIONS_ERROR, {msg: msg}, this._containerId);
        },

        /**
         * Dispatch CAPTIONS_READY event.
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined} Undefined
         */
        _dispatchCaptionsReady: function () {
            if (!this.hasDispatchedCaptionsReady) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_dispatchCaptionsReady');
                this.hasDispatchedCaptionsReady = true;
                this._eventsMgr.dispatchEvent(this._eventsMgr.eventTypes.CAPTIONS_READY, {}, this._containerId);
            }
        },

        /**
         * Dispatch CAPTIONS_UNAVAILABLE event.
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined} Undefined
         */
        _dispatchCaptionsUnavailable: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, '_dispatchCaptionsUnavailable');
            this._eventsMgr.dispatchEvent(this._eventsMgr.eventTypes.CAPTIONS_UNAVAILABLE, {}, this._containerId);
        },


        //////////////////
        // Event handlers

        /**
         * CONTAINER_RESIZE event callback.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.CaptionsManager
         *
         * @private
         */
        _onContainerResize: function (evtObj) {
            // this.debug && uvpjs.log(this.DEBUG_ID, '_onContainerResize');
            (evtObj.target === this._containerId) && this._setRect();
        },

        // VTG-150: Added to ensure that if a video is played and has no captions available
        // (due to error, e.g.), that any previously loaded captions don't remain on the caption TextTrack.
        /**
         * Handler for VIDEO_DONE and RESOURCE_END events.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _onVideoComplete: function (evtObj) {
            var target = evtObj.target,
                videoEl = this._videoEl,
                track, tt;

            if (target !== this._containerId) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_onVideoComplete', target);

            this._clearAllCaptionTracks();

            this._captionsUrl = null;
            this._captionsJson = null;
            this._liveCaptionsInitalized = false;

            // Remove event listeners.
            videoEl && videoEl.removeEventListener('loadeddata', this._onLoadedData);
            videoEl && videoEl.removeEventListener('timeupdate', this._onTimeUpdate);

            // Remove function binding.
            tt = this._getTextTracks();
            tt && (tt.onaddtrack = null);
            track = this._getActiveTrack();

            // CBSVIDEO-552 Force hlsjs to create a new text track.
            // VTG-372 Only work on captions track
            if (isCaptionsTrack(track)) {
                track.mode = 'disabled';
                track.oncuechange = null;
                track.textTrack1 && (track.textTrack1 = false);
                track.textTrack2 && (track.textTrack2 = false);
            }

            // Increment track counter.
            this._trackCount++;
        },

        /**
         * CONTENT_DATA_LOADED callback.
         *
         * @param {Object} evtObj Event payload data.
         *
         * @memberof uvpjs.CaptionsManager
         *
         * @private
         */
        _onContentDataLoaded: function (evtObj) {
            var u = uvpjs.util,
                target = evtObj.target,
                vs = evtObj.payload.vidState,
                url = vs.closedCaptionPath,
                isLive = vs.isLive,
                tt;

            if (target !== this._containerId) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_onContentDataLoaded', target);

            // Store instance of video element.
            this._videoEl = document.getElementById(this._videoId);

            // QUESTION: Is this needed? Andi 3/29/17
            this._videoEl.addEventListener('loadeddata', this._onLoadedData);

            this._trackId = 'track_' + this._trackCount;

            // Get `textTracks` object.
            tt = this._getTextTracks();

            // Bind `onaddtrack` event to listen for live captions.
            tt && (tt.onaddtrack = this._onAddTrack);

            // Also setup progress events to detect when captions are added to the <video> element.
            isLive && this._addVideoProgressHandler();

            // Create instance of style-selector for inserting CSS rules.
            this._styleSelector = this._getStyleSelector();

            u.isDefinedString(url) && (this._captionsUrl = url);
        },

        /**
         * Check for captions file. Called when <video> tag created.
         *
         * @param {Object} evtObj Event callback object.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _onLoadedData: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onLoadedData', evtObj);
            this._checkForLiveCaptions();
        },

        /**
         * Check for captions.
         *
         * @param {Object} evtObj Event callback object.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _onTimeUpdate: function (evtObj) {
            !this.hasDispatchedCaptionsReady && !!this._getActiveTrack() && this._dispatchCaptionsReady();
            this._setActiveCueProps(evtObj);
        },

        /**
         * CONTROL_LOAD_CAPTIONS callback.
         *
         * @param {Object} evtObj Event payload data.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _onControlLoadCaptions: function (evtObj) {
            var url;

            if (evtObj.target !== this._containerId) {
                return;
            }

            url = evtObj.payload.url;

            if (!_.isString(url)) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_onControlLoadCaptions', evtObj.target);

            this._loadCaptionsUrl(url);
        },

        /**
         * CONTENT_FACADE_CREATED callback.
         *
         * @param {Object} evtObj Event payload data.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _onContentFacadeCreated: function (evtObj) {
            if (evtObj.target !== this._containerId) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_onContentFacadeCreated', evtObj.target);

            if (this._cviModel.contentVideoState.isFlash) {
                this._disabled = true;
                this._removeEventListeners();
                this._removeVideoProgressHandler();
                this._dispatchCaptionsReady();
            }
            else {
                this._disabled = false;
                this._loadOrDeferCaptions(this._captionsUrl);
            }
        },

        /**
         * XHR success handler.
         * @param {Object} xhr - request object
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined} Undefined
         */
        _onLoadComplete: function (xhr) {
            var text = xhr.responseText;

            this.debug && uvpjs.log(this.DEBUG_ID, '_onLoadComplete xhr', xhr);

            try {
                // Remove leading line feeds from xml file, traps CBSNews
                // malformed xml case and leaves well-formed xml alone.
                text = text.replace(/\n/g, '');
                text = text.substr(text.indexOf('<?xml'));

                var parser = new DOMParser();
                var xml = parser.parseFromString(text, 'text/xml');

                this._xmlToCues(xml);
            } catch (error) {
                var msg = 'Error parsing closed captions XML.';
                this._dispatchCaptionsError(msg);
                this.debug && uvpjs.error(this.DEBUG_ID, msg, error);
            }
        },

        /**
         * XHR error handler.
         * @param {Object} xhr - request obejct
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined} Undefined
         */
        _onLoadError: function (xhr) {
            var status = xhr.status,
                msg = 'Unknown error';

            switch (status) {
                case 404:
                    msg = 'File not found';
                    break;
                case 500:
                    msg = 'Server error';
                    break;
                case 0:
                    msg = 'Request aborted';
                    break;
            }

            msg += ' ' + status;

            this._dispatchCaptionsError(msg);
            this.debug && uvpjs.error(this.DEBUG_ID, 'onLoadError', msg);
        },

        /**
         * Check for captions on add track.
         *
         * @param {TrackEvent} e
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _onAddTrack: function (e) {
            var track = e.track;

            this.debug && uvpjs.log(this.DEBUG_ID, '_onAddTrack', e);

            track.id = this._trackId;
            track.mode = this._trackMode;

            if (track.kind === "captions") {
                this._finalizeTrackElement();
                this._finalizeLiveCaptions();
            }
        },

        /**
         * Check for live captions on video progress.
         * @param {Object} e Event callback object.
         * @memberof uvpjs.CaptionsManager
         */
        _onVideoProgress: function (e) {
            var q, i;

            if (e.target !== this._containerId) return;

            if (!this._hasCaptions()) {
                // If captions were previously initialized, dispatch a
                // captions unavailable event.
                if (this._liveCaptionsInitalized) {
                    this._dispatchCaptionsUnavailable();
                    this._liveCaptionsInitalized = false;
                }

                return;
            }

            if (!this._liveCaptionsInitalized) {
                this._checkForLiveCaptions();

                return;
            }

            var tt = this._getActiveTrack();

            if (tt && tt.activeCues && (i = tt.activeCues.length)) {
                this.ccDisplayRequested  && this.showCcContainer(true);
                while (i--) {
                    if (e.payload.currentTime - tt.activeCues[i].endTime > 1) {
                        // lingering cue (should be edge case)
                        this.showCcContainer(false);
                    }
                }
            }
            else  {
                // no active cues - hide the cc element
                this.showCcContainer(false);
            }
        },

        /**
         * Executed when live captions are created.
         * @memberof uvpjs.CaptionsManager#
         */
        _finalizeLiveCaptions: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, '_finalizeLiveCaptions.');
            this._finalizeCaptions(true);
        },

        /**
         * Finalize captions.
         *
         * @param {Boolean} isLive  Is live-streaming captions.
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _finalizeCaptions: function (isLive) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_finalizeCaptions');

            // Calculate the video position to prevent fullscreen top margin
            // bug with cbs.com (no refresh on fullscreen). -Andi, 1/9/17
            this._setRect();

            if (isLive && this._liveCaptionsInitalized) {
                return;
            }

            // Attempt to add style captions using the ::cue CSS property.
            // Styling shouldn't prevent captions from being displayed.
            try {
                !isLive && this._applyCueStyles();
                this._finalizeStyles();
                this._applyStyles();
                this._checkBottomPosition();
            } catch (e) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'Error applying cue styling.', e);
                this._dispatchCaptionsError(e);
            }

            isLive && (this._liveCaptionsInitalized = true);

            !!this._getActiveTrack() && this._dispatchCaptionsReady();
        },

        /**
         * Finalize the <track> element.
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _finalizeTrackElement: function () {
            var track = this._getActiveTrack(),
                func = this._onTimeUpdate;

            this.debug && uvpjs.log(this.DEBUG_ID, '_finalizeTrackElement');

            // Not all Firefox versions support `oncuechange`.
            track && (track.oncuechange = func) || this._videoEl.addEventListener('timeupdate', func);
        },

        /**
         * Create merged styles object in order of precedence.
         *
         *    1. Page/skin API requests.
         *    2. Config closed caption module styles.
         *    3. Relevant in-line caption styles.
         *    4. Default caption settings.
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _finalizeStyles: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, '_finalizeStyles');

            // TODO: Not using for now per CX (11/14/16).
            // this._updateStylesObject(this._inlineStyles);

            this._updateStylesObject(this._configStyles);
            this._updateStylesObject(this._pageStyles);

            this._applyStyles();
        },


        /////////////////////
        // CSS styles

        /**
         * Apply CSS styles to dynamically created cues.
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _applyCueStyles: function () {
            // Apply styles.
            var style = _.get(this._captionsJson, 'tt.head.styling.style');

            // Could have multiple <style> tags; grab first.
            style = _.isArray(style) ? style[0] : style;

            this.debug && uvpjs.log(this.DEBUG_ID, '_applyCueStyles style', style);

            if (!style) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'No styling found in XML file.');
                return;
            }

            this._inlineStyles = {
                backgroundColor: style['tts:backgroundColor'],
                color: style['tts:color'],
                fontFamily: style['tts:fontFamily'],
                fontSize: style['tts:fontSize'],
                fontStyle: style['tts:fontStyle'],
                fontWeight: style['tts:fontWeight'],
                textAlign: style['tts:textAlign'],
                textDecoration: style['tts:textDecoration']
            };
        },

        /**
         * Create CSS ::cue classes and add to DOM.
         *
         * @memberof uvpjs.CaptionsManager
         */
        _applyStyles: function () {
            var u = uvpjs.util,
                styles = this.styles,
                selector = this._styleSelector,
                rules = [],
                skipUpdate, key, value;

            this.debug && uvpjs.log(this.DEBUG_ID, '_applyStyles styles', styles);

            // Convert main CSS style object into key-value pairs.
            for (key in styles) {
                value = styles[key];
                skipUpdate = false;

                switch (key) {
                    case 'background-opacity':
                    case 'font-opacity':
                        skipUpdate = true;
                        break;

                    case 'text-position':
                        skipUpdate = true;
                        this._setPosition(value);
                        break;

                    case 'background-color':
                        value = getColor(value, styles['background-opacity']);
                        break;

                    case 'color':
                    case 'font-color':
                        key = 'color';
                        value = getColor(value, styles['font-opacity']);
                        break;

                    case 'text-edge-style':
                        key = 'text-shadow';
                        value = toTextShadow(value);
                        break;
                }

                // No CSS to apply.
                if (skipUpdate) {
                    continue;
                }

                if (!isValidCSS(key, value)) {
                    this.debug && uvpjs.warn(this.DEBUG_ID, 'Invalid CSS.', key, value);
                    continue;
                }

                rules.push({ name: key, value: value });
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_applyStyles selector, rules', selector, rules);

            u.addCSSRules(this._styleEl, selector, rules);
        },

        /**
         * Update the main style object.
         *
         * @param {Array} styles Array of styles to update.
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _updateStylesObject: function (styles) {
            var key, value, name;

            for (key in styles) {
                value = styles[key];

                if (!value || !key) {
                    return;
                }

                name = toKebabCase(key);

                if (!(name in this.styles)) {
                    this.debug && uvpjs.warn(this.DEBUG_ID, 'Unsupported captions style property.', name);
                    continue;
                }

                // Verify and normalize values being added to styles object.
                //
                // TODO: Should consider further verifications.
                switch (name) {
                    case 'font-size':
                        value = getFontSizePercent(value);
                        break;
                }

                this.styles[name] = value;
            }

            // this.debug && uvpjs.log(this.DEBUG_ID, 'Updated styles.\n' + JSON.stringify(this.styles, null, 2));
        },


        ////////////////////
        // Utils

        /**
         * Whether a captions track exists.
         * @memberof uvpjs.CaptionsManager
         * @returns {Boolean}
         */
        _hasCaptions: function () {
            return isCaptionsTrack(this._getActiveTrack());
        },

        /**
         * Force the captions button to be displayed by firing CAPTIONS_READY. Return
         * and don't load captions immediately, wait until captions are displayed to
         * load, when _deferLoadingCaptions is true.
         *
         * @param {String} url - Captions file url.
         *
         * @memberof uvpjs.CaptionsManager
         *
         * @private
         */
        _loadOrDeferCaptions: function (url) {
            if (this._deferLoadingCaptions) {
                this._dispatchCaptionsReady();
            } else {
                this._loadCaptionsUrl(url);
            }
        },

        /**
         * Load captions by url
         * @param {Object} url - Captions file url.
         * @memberof uvpjs.CaptionsManager
         * @returns {Undefined}
         */
        _loadCaptionsUrl: function (url) {
            var isStr = uvpjs.util.isDefinedString(url),
                isVttFile = isStr && url.substr(-4) === '.vtt',
                codeLoader;

            if (!isStr || this._cviModel.contentVideoState.isFlash)  return;

            this.debug && uvpjs.log(this.DEBUG_ID, '_loadCaptionsUrl');

            this._videoEl = document.getElementById(this._videoId);

            // Load to <track> tag directly.
            if (isVttFile) {
                this._createTrackElement(url);
                return;
            }

            codeLoader = new uvpjs.CodeLoader();
            codeLoader.loadXHR(url, this._onLoadComplete.bind(this), this._onLoadError.bind(this));
        },

        /**
         * Check for captions.
         * @param {Object} evtObj Event callback object.
         * @memberof uvpjs.CaptionsManager#
         */
        _checkForLiveCaptions: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, '_checkForLiveCaptions');

            // Exit if there's no track to work with.
            if (!this._hasCaptions()) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'No captions track to finalize.');
                return;
            }

            this._finalizeTrackElement();
            this._finalizeLiveCaptions();
        },

        /**
         * Clears the track of existing cues
         * @private
         * @memberof uvpjs.CaptionsManager#
         */
        _clearAllCaptionTracks: function() {
            var ccEl = this._ccEl,
                tracks = this._getTextTracks(),
                i = (tracks && tracks.length) || 0;

            this.debug && uvpjs.log(this.DEBUG_ID, '_clearAllCaptionTracks', tracks);

            while (i--) {
                this._clearCaptionTrack(tracks[i]);
            }

            // VTG-282 Clear non-native captions element, if created.
            ccEl && (ccEl.innerHTML = '');
        },

        /**
         * Clears the track of existing cues
         * @private
         * @memberof uvpjs.CaptionsManager#
         */
        _clearCaptionTrack: function (track) {
            var cues, i;

            // VTG-372 Only work on captions track
            if (!isCaptionsTrack(track)) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_clearCaptionTrack', track);

            cues = track && track.cues;
            i = (cues && cues.length) || 0;

            while (i--) {
                track.removeCue(cues[i]);
            }

            track.cues = null;
        },

        /**
         * API for showing tracks.
         *
         * @param {Object} evtObj   UVPJS event object.
         * @param {String} mode     'hidden' or 'showing'.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _toggleVisibility: function (e, mode) {
            var track = this._getActiveTrack(),
                ccEl = this._ccEl;

            if (e.target !== this._containerId || !this._hasCaptions()) return;

            this.debug && uvpjs.log(this.DEBUG_ID, '_toggleVisibility', mode);

            this.showCcContainer(mode !== 'hidden');
        },

        /**
         * @private
         *
         * @param {Boolean} flag
         */
        showCcContainer: function (flag) {
            this._ccEl && (this._ccEl.style.display = flag === false ? 'none' : 'block');
        },

        ////////////////////
        // Getters

        /**
         * Get the `textTracks'.`
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @returns {HTMLElement}
         *
         * @private
         */
        _getTextTracks: function () {
            return this._videoEl && this._videoEl.textTracks;
        },

        /**
         * Get the active <track> tag.
         *
         * @memberof uvpjs.CaptionsManager
         *
         * @returns {HTMLElement}
         */
        _getActiveTrack: function () {
            var tt = this._getTextTracks(),
                n = (tt && tt.length) || 0,
                track, cues, i;

            for (i = 0; i < n; i++) {
                track = tt[i];
                cues = track && track.cues;

                // VTG-372 Only work on captions track
                if (cues && cues.length && isCaptionsTrack(track)) {
                    return track;
                }
            }
        },

        /*
           enableCaptionsTracks() is called when captions should be available,
           but no activeTrack is found.  This can happen if an iOS user in
           in (native) fullscreen mode elects to turn captions 'OFF'; which
           changes caption TextTrack mode to 'disabled'.

           In this state, if the caption track mode is changed from 'disabled'
           to 'hidden', as is done here, native caption tracks will again be
           visible along with custom captions, requiring that we set
           video.webkitClosedCaptionsVisible = false.
        */
        /**
         * @private
         */
        enableCaptionsTracks: function() {
            var tt = this._getTextTracks(),
                i = (tt && tt.length) || 0,
                track;

            while (i--) {
                track = tt[i];
                isCaptionsTrack(track) && (track.mode = 'hidden');
            }
            this._videoEl.webkitClosedCaptionsVisible = false;
        },

        /**
         * Get track by id.
         *
         * TODO: Not currently used; placeholder for future optimization.
         *
         * @param {String} id   Track id.
         *
         * @memberof uvpjs.CaptionsManager
         *
         * @returns {HTMLElement}
         */
        _getTrackById: function (id) {
            var tt = this._getTextTracks();

            return tt && tt.getTrackById(id || this._trackId);
        },

        /**
         * Get active cues.
         *
         * @memberof uvpjs.CaptionsManager
         *
         * @returns {Array} Array of cues.
         *
         * @private
         */
        _getActiveCues: function () {
            var tt = this._getActiveTrack();

            return tt && tt.activeCues;
        },

        /**
         * Get all cues.
         *
         * @memberof uvpjs.CaptionsManager
         *
         * @returns {Array} Array of cues.
         *
         * @private
         */
        _getAllCues: function () {
            var tt = this._getActiveTrack();

            return tt && tt.cues;
        },

        /**
         * Get main CSS selector.
         *
         * @memberof uvpjs.CaptionsManager
         */
        _getStyleSelector: function () {
            return '#' + this._captionsId + ' .' + this.CAPTIONS_TEXT_CLASSNAME;
        },


        ////////////////////
        // Setters

        /**
         * Checks for CDO params. Overrides XML-level properties.
         *
         * @memberof uvpjs.CaptionsManager
         å*/
        _setCDOParams: function () {
            var module = this._cviModel.getModule(this.CONFIG_MODULE_NAME),
                styles = {},
                key, value, name;

            this.debug && uvpjs.log(this.DEBUG_ID, '_setCDOParams module', module);

            if (!module) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_setCDOParams No config module found.');
                return;
            }

            if (module.enabled !== true) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_setCDOParams Config module not enabled.');
                return;
            }

            if (_.isEmpty(module.params)) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_setCDOParams Config module params array empty.');
                return;
            }

            _.each(module.params, function (param) {
                key = param.name;
                value = param.value;

                if (!key || !value) {
                    return;
                }

                name = toKebabCase(key);

                styles[key] = value;
            });

            this.debug && uvpjs.log(this.DEBUG_ID, 'Config module styles. ' + JSON.stringify(styles, null, 2));
            this._configStyles = styles;
        },

        /**
         * Proxy for setting the CC position.
         *
         * @param {String} s Known slot name.
         *
         * @memberof uvpjs.CaptionsManager
         */
        _setPosition: function (s) {
            var opts = [
                    'top-left',
                    'top-center',
                    'top-right',
                    'middle-left',
                    'middle-center',
                    'middle-right',
                    'bottom-left',
                    'bottom-center',
                    'bottom-right',
                    'bottom-left-floated',
                    'bottom-center-floated',
                    'bottom-right-floated'
                ],
                name = opts.indexOf(s) > -1 ? s : 'bottom-center-floated';

            this._setPositionCSS(name);
        },

        /**
         * Set the position on the cc <div> container.
         *
         * @param {String} name
         *
         * @memberof uvpjs.CaptionsManager
         */
        _setPositionCSS: function (name) {
            var u = uvpjs.util,
                styleEl = this._styleEl,
                ccEl = this._ccEl,
                cbh = parseInt(this.BASE_CONTROLS_HEIGHT),
                offset = 10, // Offset from bottom of video frame
                styles, prts, xpos, ypos, top, bottom, mb, btm;

            if (!styleEl || !ccEl) {
                return;
            }

            prts = name.split('-');
            ypos = prts[0];
            xpos = prts[1];

            mb = parseInt(ccEl.style.marginBottom);
            btm = mb > cbh ? offset : cbh - mb;

            top = { top: '0', middle: '50%', bottom: 'auto' }[ypos];
            bottom = { top: 'auto', middle: 'auto', bottom: btm + 'px' }[ypos];

            styles =  {
              'top': top,
              'bottom': bottom,
              'text-align': xpos,
              'transform': 'initial'
            };

            ypos === 'middle' && (styles['transform'] = 'translateY(-50%)');

            // this.debug && uvpjs.log(this.DEBUG_ID, '_setPositionCSS', name, styles, styleEl);

            // Container styles.
            u.addCSSObject(styleEl, ccEl, styles, '.' + this.CAPTIONS_CONTAINER_CLASSNAME);
        },

        /**
         * Check whether bottom padding is needed for control bar.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _checkBottomPosition: function () {
            var styles = this.styles;

            // this.debug && uvpjs.log(this.DEBUG_ID, '_checkBottomPosition', styles);

            styles && this._setPosition(styles['text-position']);
        },

        /**
         * Calculates the position.
         *
         * @private
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _setRect: function () {
            var videoEl = this._videoEl,
                ccEl = this._ccEl,
                contentEl = videoEl && videoEl.parentNode,
                cRect, vRect, rectH, rectW, cRatio, rRatio,
                vRatio, videoH, videoW, styles, margin,
                calcH, calcW, diffW, diffH, fullW, fullH;


            if (!videoEl || !contentEl) {
                return;
            }

            videoH = videoEl.videoHeight;
            videoW = videoEl.videoWidth;

            // Occurs if called before <video> element has size information.
            if (!videoW || !videoH) {
                return;
            }

            vRect = videoEl.getBoundingClientRect();
            cRect = contentEl.getBoundingClientRect();

            //** Calculate video dimensions.

            rectH = vRect.height;
            rectW = vRect.width;

            vRatio = videoH / videoW;
            rRatio = rectH / rectW;
            cRatio = rRatio / vRatio;

            diffH = cRect.height - vRect.height;
            diffW = cRect.width - vRect.width;

            fullW = cRatio > 1 || (diffW === 0 && diffH !== 0);
            fullH = cRatio < 1 || (diffW !== 0 && diffH === 0);

            //** Apply the correct height and width styles.

            // Video is full width.
            if (fullW) {
                styles = {
                    'height': 'auto',
                    'max-height': '100%',
                    'width': '100%',
                    'margin': 0,
                };
            }
            // Video is full height.
            else if (fullH) {
                styles = {
                    'height': '100%',
                    'max-width': '100%',
                    'width': 'auto',
                    'margin': 0,
                };
            // Video is full height and width.
            } else {
                styles = {
                    'height': '100%',
                    'width': '100%',
                    'margin': 0,
                };
            }

            // Apply styles.
            styles && _applyStyles.call(this);

            //** Now calculate margin based on new height and width settings.

            vRect = videoEl.getBoundingClientRect();
            cRect = contentEl.getBoundingClientRect();

            diffH = cRect.height - vRect.height;
            diffW = cRect.width - vRect.width;

            if (fullW) {
                margin = (diffH / 2) + 'px';
                styles = {
                    'margin': 'inherit',
                    'margin-top': margin,
                    'margin-bottom': margin,
                };
            }
            else if (fullH) {
                margin = (diffW / 2) + 'px';
                styles = {
                    'margin': 'inherit',
                    'margin-left': margin,
                    'margin-right': margin,
                };
            }

            // Scale font-size to video with.
            ccEl && (styles['font-size'] = this._calculateFontSize(vRect.width));

            // Apply styles.
            styles && _applyStyles.call(this);

            // this.debug && uvpjs.log(this.DEBUG_ID, '_setRect', styles);

            function _applyStyles() {
                _.assign(videoEl.style, styles);

                // VTG-282 Apply the same styles to the captions container to
                //         keep the non-native captions in-frame.
                if (ccEl) {
                    _.assign(ccEl.style, styles);
                    this._checkBottomPosition();
                }
            }
        },

        /**
         * Set the font-size based on video width.
         *
         * @param {Number} vw   Video container width
         *
         * @private
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _calculateFontSize: function (vw) {
            var size;

            try {
                size = (vw / parseInt(this.BASE_VIDEO_WIDTH)) * parseInt(this.BASE_FONT_SIZE);
                size = Math.max(size, parseInt(this.MIN_FONT_SIZE));
            } catch(e) {
                console.error(e);
            }

            // this.debug && uvpjs.log(this.DEBUG_ID, '_calculateFontSize', vw, size);

            return (size && size + 'px') || this.BASE_FONT_SIZE;
        },

        /**
         * Set the properties of each active cue.
         *
         * @private
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _setActiveCueProps: function (e) {
            var tg = e && e.target,
                cues = (tg && tg.activeCues) || this._getActiveCues();

            // this.debug && uvpjs.log(this.DEBUG_ID, '_setActiveCueProps');

            this._setCueProps(cues);
        },

        /**
         * Set the properties of each cue.
         *
         * @private
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _setAllCueProps: function () {
            var cues = this._getAllCues();

            this._setCueProps(cues);
        },

        /**
         * Set the properties of each cue.
         *
         * @param {Array} cues Array of cues.
         *
         * @private
         *
         * @memberof uvpjs.CaptionsManager#
         */
        _setCueProps: function (cues) {
            // this.debug && uvpjs.log(this.DEBUG_ID, '_setCueProps');

            // VTG-282 Support for non-native captions.
            // VTG-407 Use non-native captions only.
            this._addCuesToCaptionsElement(cues);
        },


        /////////////////
        // Converters

        /**
         * Convert XML cues to VTTCue objects and add to <track>.
         *
         * @param {Object} xml - XML data.
         *
         * @memberof uvpjs.CaptionsManager
         */
        _xmlToCues: function (xml) {
            var json = xmlToJson(xml),
                Cue, cues, newCue, nextItem, track, text, item, i, j, n, lc;

            this._captionsJson = json;

            this.debug && uvpjs.log(this.DEBUG_ID, '_xmlToCues json =', json);

            if (_.isEmpty(json) || !_.isPlainObject(json)) {
                return;
            }

            cues = _.get(json, 'tt.body.div.p');

            this.debug && uvpjs.log(this.DEBUG_ID, '_xmlToCues cues', cues);

            if (_.isUndefined(cues) || _.isEmpty(cues)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'No cues found in XML file.');
                return;
            }

            Cue = this._supportsVTTCue ? window.VTTCue : window.TextTrackCue;

            if (!Cue) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'Browser does not support dynamic captions.');
                return;
            }

            track = this._videoEl.addTextTrack('captions', 'English', 'en');
            track.id = this._trackId;

            // Apply cue settings. Read more here:
            // https://developer.mozilla.org/en-US/docs/Web/API/Web_Video_Text_Tracks_Format#Cue_Settings
            n = cues.length;
            for (i = 0; i < n; i++) {
                j = i + 1;
                item = cues[i];
                nextItem = cues[j];
                text = item.text;

                // Don't show empty-string captions (small black box).
                if (_.isEmpty(text)) {
                    continue;
                }

                // Convert old <span> tags.
                //
                // OPTIMIZE?
                text = text.replace(/(.*)<span.*tts:fontStyle="italic">(.*)<\/span>(.*)/g, '$1<i>$2</i>$3');
                text = text.replace(/(.*)<span.*tts:fontWeight="bold">(.*)<\/span>(.*)/g, '$1<b>$2</b>$3');
                text = text.replace(/(.*)<span.*tts:textDecoration="under">(.*)<\/span>(.*)/g, '$1<u>$2</u>$3');

                // Count lines for positioning.
                lc = getNumLines(text);
                item._lineCountPrev = item._lineCountPrev || 0;
                item._lineCountNext = item._lineCountNext || 0;

                // Determine number of lines for each start time.
                while ((nextItem && nextItem.begin) === item.begin) {
                    nextItem._lineCountPrev = lc + item._lineCountNext;
                    item._lineCountNext += getNumLines(nextItem.text);
                    nextItem = cues[++j];
                }

                newCue = new Cue(getTime(item.begin), getTime(item.end), text);

                newCue._lineCount = lc;
                newCue._lineCountPrev = item._lineCountPrev;
                newCue._lineCountNext = item._lineCountNext;

                // Attempt to convert ccrow and cccol to position, line, and align.
                newCue._metadata = item.metadata;
                newCue = metadataToPosition.call(this, newCue);

                track.addCue(newCue);
            }

            this._finalizeCaptions();
        },

        // VTG-282 Support for non-native captions.
        /**
         * Convert VTTCues to native DOM elements.
         *
         * @param {Array} cues
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _addCuesToCaptionsElement: function (cues) {
            var u = uvpjs.util,
                ccEl = this._ccEl,
                html = '<div class="{{cntrClass}}">{{spans}}</div>',
                spans = '',
                n = cues && cues.length,
                i, cue, text;

            if (!n) return;

            for (i = 0; i < n; i++) {
                cue = cues[i];
                text = cue.text;

                if (!u.isDefinedString(text)) {
                    continue;
                }

                text = text.replace(/(\r\n|\n|\r)/g, '<br/>');
                spans += '<span class="{{txtClass}}">'+ text +'</span>';
                (i + 1 !== n) && (spans += '<br/>'); // Add break if not last line of text
            }

            html = html.replace('{{spans}}', spans);
            html = html.replace('{{cntrClass}}', this.CAPTIONS_CONTAINER_CLASSNAME);
            html = html.replace(/{{txtClass}}/g, this.CAPTIONS_TEXT_CLASSNAME);

            ccEl && (ccEl.innerHTML = html);
        },

    });


    ////////////////////
    // Helpers

    /**
     * Get alpha channel from color string.
     *
     * NOTE: Not currently used, but may be useful in future.
     *
     * @param {String} s Color.
     *
     * @return {Number} Alpha channel value.
     */
    getAlpha = function (s) {
        return s.indexOf('rgba') > -1 ? s.split(',')[3].replace(')', '') : 1;
    };

    /**
     * Trys to convert to an RGBA string.
     *
     * @param {String} color Color string.
     * @param {String} alpha Alpha value.
     *
     * @returns {Object} RGB object.
     */
    getColor = function (color, alpha) {
        var rgb = rgbaToRgb(color) || hexToRgb(color) || hexToRgb(nameToHex(color));

        if (!rgb || !alpha) {
            return color;
        }

        return toRgba(rgb.r, rgb.g, rgb.b, alpha);
    };

    /**
     * Get default CSS styles.
     *
     * @return {Object} Style key-value pairs.
     */
    getDefaultStyles = function () {
        return {
            'background-opacity': '1',
            'background-color': '#000000',
            'font-color': '#FFFFFF',
            'font-family': 'Arial, sans-serif',
            'font-opacity': '1',
            'font-size': '100%',
            'font-weight': 'normal',
            'line-height': '1',
            'text-position': 'default',
            'text-decoration': 'none',
            'text-edge-style': 'none'
        };
    };

    /**
     * Normalize the font-size as percentage.
     *
     * NOTE: Sould include 'em' and 'rem' in the future.
     *
     * @param {String} size Font-size.
     *
     * @returns {String} Font-size.
     */
    getFontSizePercent = function (size) {
        var output = '100%';

        if (size.indexOf('px') > -1) {
            output = size.replace('px', '');
            output = output / 18; // 18px is base font-size.
            output = output * 100 + '%';
        }
        else if (size.indexOf('%') > -1) {
            output = size;
        }

        return output;
    };

    /**
     * Return number of lines in text.
     *
     * @param {String} text
     *
     * @returns {Integer} Number of lines.
     */
    getNumLines = function (text) {
        return text && ((text.match(/\n/g) || []).length + 1);
    };

    /**
     * Convert XML timestamp to number (e.g. 00:00:33.93 into 33.93).
     *
     * @param {String} time - Timestamp to convert.
     *
     * @returns {Number|Undefined} Number in seconds or undefined.
     */
    getTime = function (time) {
        var h, m, s, inSecs, segs, rnd;

        if (_.isNull(time) || _.isUndefined(time)) {
            return undefined;
        }

        rnd = function (num, len) {
            return Math.round(num * Math.pow(10, len)) / Math.pow(10, len);
        };

        segs = time.split(':');
        h = Number(segs[0]) * 60 * 60;
        m = Number(segs[1]) * 60;
        s = Number(segs[2]);
        inSecs = h + m + s;

        return rnd(inSecs, 2);
    };

    /**
     * Converts hex colors to rgb.
     *
     * @param {String} hex Class name.
     *
     * @returns {Object} RGB object.
     */
    hexToRgb = function (hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
            return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    };

    // VTG-372 Only work on captions track
    /**
     * Whether the `TextTrack` is a captions track.
     *
     * @param {HTMLTrackElement} track CSS property name.
     *
     * @returns {Boolean}
     */
    isCaptionsTrack = function (track) {
        return track instanceof window.TextTrack && track.kind === 'captions';
    };

    /**
     * Validates the CSS proeprty name and value.
     *
     * @param name CSS property name.
     * @param value CSS property value.
     *
     * @returns {Boolean}
     */
    isValidCSS = function (name, value) {

        if (!name || !value) {
            return;
        }

        // Test if browser supports the window.CSS.supports method.
        if (_.get(window, 'CSS.supports')) {
            return window.CSS.supports(name, value);
        }

        // Primitive fallback polyfill which is sufficient for our purposes
        // since browsers will largely ignore incorrect CSS properties.
        return typeof document.createElement('div').style[name] === 'string';
    };

    /**
     * Convert `ccrow` and `cccol` into cue position.
     *
     * @returns {HTMLElement} cue Cue element.
     *
     * @returns {HTMLElement}
     */
    metadataToPosition = function (cue) {
        var metadata = cue._metadata,
            xpos;


        // TODO: This should be normalized with _setPosition.


        if (metadata) {
            cue.snapToLines = true; // Ensures lines don't overlap.

            // NOTE: `cccol` has a max of 35.
            xpos = Math.round(metadata.cccol / 35 * 100);
            cue.position = xpos;
            cue.align = xpos < 45 ? 'start' : xpos > 55 ? 'end' : this._lineAlign;
            cue.positionAlign = xpos < 45 ? 'line-left' : xpos > 55 ? 'line-right' : 'center';

            // NOTE: This jumps around less, not sure which to use.
            // cue.position = xpos < 33 ? 5 : xpos > 66 ? 95 : 50;
            // cue.align = xpos < 33 ? 'start' : xpos > 66 ? 'end' : 'middle';
            // cue.positionAlign = xpos < 33 ? 'line-left' : xpos > 66 ? 'line-right' : 'center';

            // NOTE: `ccrow` has a max of 15. Subtract 2 lines to bring text
            //       above control bar. Negative numbers indicate bottom
            //       up, where -1 is absolute bottom.
            cue.line = metadata.ccrow - 17 + this._lineOffset;

            cue._defaults = {
                line: cue.line,
                position: cue.position,
                align: cue.align,
                positionAlign: cue.positionAlign
            };
        }

        return cue;
    };

    /**
     * Converts known color names into hex.
     *
     * @param {String} name Color name.
     *
     * @returns {String} Hex string.
     */
    nameToHex = function (name) {
        return {
            'white': '#ffffff',
            'yellow': '#ffff00',
            'green': '#008000',
            'cyan': '#00ffff',
            'blue': '#0000ff',
            'magenta': '#ff00ff',
            'red': '#ff0000',
            'black': '#000000',
        }[name.toLowerCase()];
    };

    /**
     * Convert RGBA to RGB.
     *
     * @param {String} s RGBA.
     *
     * @return {Object} RGB object.
     */
    rgbaToRgb = function (s) {
        var parts;

        if (s.indexOf('rgba') === -1) {
            return;
        }

        parts = s.substr(5, s.length).split(',');

        return {
            r: parts[0],
            g: parts[1],
            b: parts[2]
        };
    };

    /**
     * Convert CSS names to kebab case (e.g. fontSize to font-size).
     *
     * @param xml XML document
     *
     * @returns {Object}
     */
    toKebabCase = function (text) {
        if (!_.isString(text) || _.isEmpty(text)) {
            return;
        }

        // First, insert a hyphen before all caps, then lowercase string.
        return text.replace(/([A-Z])/g, '-$1').toLowerCase();
    };

    /**
     * Creates an RGBA string from color and alpha values.
     *
     * @param {String} red
     * @param {String} green
     * @param {String} blue
     * @param {String} alpha
     *
     * @return {string} - RGBA CSS String
     */
    toRgba = function (red, green, blue, alpha) {
        return 'rgba(' + [red, green, blue, alpha].join(',') + ')';
    };

    /**
     * Convert name to CSS text-shadow.
     *
     * @param name
     *
     * @returns {String}
     */
    toTextShadow = function (name) {
        return {
            'drop-shadow': '2px 2px 3px #000',
            'outline': '-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000',
            'raised': '-1px -1px 1px #FFF, 1px 1px 1px #000'
        }[name] || 'none';
    };

    /**
     * Convert XML to JSON. Adapted from http://davidwalsh.name/convert-xml-json
     * @param xml - XML document
     * @returns {Object}
     */
    xmlToJson = function (xml) {
        var obj = {};

        // Node types:
        //   1: ELEMENT_NODE
        //   3: TEXT_NODE

        // Elements and attributes.
        if (xml.nodeType === 1 && xml.attributes.length > 0) {
            for (var j = 0, k = xml.attributes.length; j < k; j++) {
                var attribute = xml.attributes.item(j);
                obj[attribute.nodeName] = attribute.nodeValue;
            }
        }
        // #text elements.
        else if (xml.nodeType === 3) {
            obj = xml.nodeValue;
        }

        // Special caption <p> elements.
        if (xml.nodeName === 'p') {
            obj.text = '';
            _.each(xml.childNodes, function (node) {

                // Skip <metadata> tags.
                if (node.nodeName === 'metadata') {
                    return;
                }

                var text = (new XMLSerializer()).serializeToString(node);

                // Element nodes.
                if (node.nodeType === 1) {
                    // Line breaks get ignored by the VTTCue object, so we
                    // convert them here to newline characters.
                    obj.text += node.tagName === 'br' ? '\n' : text;
                }

                // Text nodes.
                if (node.nodeType === 3) {
                    obj.text += text;
                }
            });
        }

        // Child nodes.
        if (xml.hasChildNodes()) {
            for (var i = 0, h = xml.childNodes.length; i < h; i++) {
                var item = xml.childNodes.item(i),
                    nodeName = item.nodeName;

                if (typeof obj[nodeName] === 'undefined') {
                    obj[nodeName] = xmlToJson(item);
                    continue;
                }

                // If more than one child, create an array
                if (typeof obj[nodeName].push === 'undefined') {
                    var old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }

                obj[nodeName].push(xmlToJson(item));
            }
        }

        return obj;
    };

}(uvpjs.register('uvpjs')));
(function (obj) {
    'use strict';

    var _ = obj._;


    obj.ConfigDataObject = uvpjs.Class.subClass({

        debug: true,

        sessionOptions: {
            // Application State
            adBlockerCallback:null,
            cms: '',
            id3OwnerIds: null,
            ftag: '',
            mapp: '',
            netwk: '',
            partner: '',
            uvpc: '',
            ursuid: '',
            usesIMA: false,
            usesTealium: false,
            //** NOTE: skinConfig object properties are now properties of the root sessionOptions object. 8/9/16
            skin: true,
            enableUnmutedAutoplay: false,
            enableMutedAutoplay: false,
            customCSS: null,
            enableReplay: false,
            previewImage: null,
            themeName: 'default',
            //**
            // Session State
            allowConcurrentPlayback: false,
            browserVer: '',
            contsess:'',
            deviceCPU: '',
            deviceScreenSize: '',
            deviceType: '',
            deviceVers: '',
            host: '',
            maxDynamicSwitchingIndex: '',
            minDynamicSwitchingIndex: '',
            mso: '',
            pageUrl: '',
            playerCoords: '',
            playerId: '',
            playerVersion: '',
            playsInline: false,
            preloadContent: false,
            preventFlashPlayback: false,
            referrer: '',
            resumeBeaconInterval: 10,
            sessionId: '',
            useDynamicSwitching: true,
            enableNativeMobileAutoplay: false,
            userCountry: '',
            userISP: '',
            userId: '',
            userPPID: '',
            userStatus: '',
            isEmbedded: false,
            deferLoadingCaptions: false,
            capLevelToPlayerSize: null,
            enableDashJSFastSwitchABR:null,
            trackingConfigOverrides: null,
            userConnectionType: 'unknown'
        },

        /**
         * @constructor uvpjs.ConfigDataObject
         * @memberof uvpjs.ConfigManager
         *
         * Application and session level metadata passed into the `initialize()` method of an instance of the Video Manager. See example below.
         * @example
         * // Session options with example values.
         * var sessionOptions = {
         *     cms: 'platform',
         *     partner: 'cbs',
         *     netwk: 'can',
         *     ursuid: '123456',
         *     uvpc: 'http://vtstage.cbsinteractive.com/config/can.xml',
         *     usesIMA: true,
         *     usesTealium: true,
         *     skin: true,
         *     autoPlay: false
         * };
         * @param {Object} sessionOptions session options
         * @param {String} sessionOptions.adBlockerCallback - Bound callback provided to UVPJS by the page that returns true if there is an ad blocker operating in the page.
         * @param {String} sessionOptions.cms - Identifies the content management system providing meta data for the content video(s) during the current player session. Currently the only valid value is uvpjs.mediaCapabilities.PLATFORM (when using thePlatform) or empty string `''`.
         * @param {String} sessionOptions.id3OwnerIds - Comma-delimited list of ID3 private frame owner id values. These must be supplied if you require access to ID3 data embedded in media via viideoCuepoint events
         * @param {String} sessionOptions.ftag - Used to identify the tracking origin of the embedded SmartTag.
         * @param {String} sessionOptions.mapp - Allows the skin to add a unique identifier to the mapp tag that is passed to DW tracking. This value is used by business units to uniquely identify a skin if the business unit deploys multiple skins. The value is arbitrarily determined by the business unit.
         * @param {String} sessionOptions.netwk - Identifies if this instance of the player is part of the CBS Audience Network (CAN). Currently the only valid value is `CAN` or an empty string `''`.
         * @param {String} sessionOptions.partner - The unique ID for the business unit embedding the player. Example values currently in use are `gamespot`, `cnettv`, `cbssports`.  Coordinate with VideoTech and DW groups to ensure a unique value for a given business unit. This is a required data point.
         * @param {Array|Object|String} sessionOptions.uvpc - The configuration settings that may contain partner-level overrides to the default UVPJS configuration settings. Accepts fully-qualified urls (XML or JSON), JSON or JavaScript objects, or an array of any combination of urls and objects. The XML or JSON files can live on a server hosted by the business-unit or it can be hosted on Video Tech servers. {@link https://sites.google.com/a/cbsinteractive.com/video-technology/home/developer/uvpjs-home/startup-configuration Click here for more information.}
         * @param {String} sessionOptions.ursuid - The CBSi internal authenticated user ID.
         * @param {skinConfig} sessionOptions.skinConfig - DEPRECATED: The properties of the skinConfig object are now apart of the root sessionOptions object.
         * @param {Boolean} sessionOptions.skin - Enable or disable the default custom skin. When `false`, the UVPJS default custom skin is completely disabled and the default browser controls are restored. Default is `true`.
         * @param {Boolean} sessionOptions.enableUnmutedAutoplay - Enable automatic playback with sound
         * @param {Boolean} sessionOptions.enableMutedAutoplay - Enable muted automatic playback of video
         * @param {String} sessionOptions.customCSS - Url of a custom CSS file to override the UVPJS default. Optional.
         * @param {String} sessionOptions.previewImage - Url of a preview image to display before video start when autoplay is disabled. Optional.
         * @param {Boolean} sessionOptions.enableReplay - Instructs the default skin to display a replay button after video end. Optional.
         * @param {String} sessionOptions.themeName - Skin theme name for CSS namespacing.
         * @param {Boolean} sessionOptions.usesIMA - Signals UVPJS to setup the `ad` container and wait for the Google IMA script to finish loading.
         * @param {Boolean} sessionOptions.usesTealium - Indicates that UVPJS should wait for the existence of the AppMeasurement "s" object on the page while initializing Adobe Heartbeat tracking.
         * @param {String} sessionOptions.allowConcurrentPlayback - Allows more than one video to play at time when true. When false only one video instance at a time can play on a page. Starting a paused player will cause the currently playing instance to pause.
         * @param {String} sessionOptions.browserVer -
         * @param {String} sessionOptions.contsess - previous session ID used for continuous session tracking.
         * @param {String} sessionOptions.deviceCPU -
         * @param {String} sessionOptions.deviceScreenSize -
         * @param {String} sessionOptions.deviceType -
         * @param {String} sessionOptions.deviceVers -
         * @param {Boolean} sessionOptions.enableNativeMobileAutoplay - If TRUE, video auto playback will be managed by the mobile browser
         * @param {String} sessionOptions.host -
         * @param {String} sessionOptions.maxDynamicSwitchingIndex -
         * @param {String} sessionOptions.minDynamicSwitchingIndex -
         * @param {String} sessionOptions.mso - Multiple System Operator also known as a cable TV company. For example: Comcast or Time Warner.
         * @param {String} sessionOptions.pageUrl -
         * @param {String} sessionOptions.playerCoords -
         * @param {String} sessionOptions.playerId -
         * @param {String} sessionOptions.playerVersion -
         * @param {String} sessionOptions.preloadContent - Boolean, if true start preloading content video after the third quartile of the last pre-roll or mid-roll ad.
         * @param {Boolean} sessionOptions.preventFlashPlayback - If true, Flash will not be used as a fallback for HLS playback
         * @param {String} sessionOptions.referrer -
         * @param {String} sessionOptions.resumeBeaconInterval - Interval in seconds for sending out DW Global Resume beacons.
         * @param {String} sessionOptions.sessionId -
         * @param {String} sessionOptions.useDynamicSwitching - Boolean
         * @param {String} sessionOptions.userCountry -
         * @param {String} sessionOptions.userISP -
         * @param {String} sessionOptions.userId -
         * @param {String} sessionOptions.userPPID -
         * @param {String} sessionOptions.userStatus - CBS.com All Access user status. For example: reg;sub;pay.
         * @param {String} sessionOptions.deferLoadingCaptions - If loading of closed captions should be delayed until they are displayed
         * @param {Boolean} sessionOptions.capLevelToPlayerSize - Flag to control if hls.js's capLevelToPlayerSize setting to limit rendition by window size should be enabled
         * @param {Boolean} sessionOptions.enableDashJSFastSwitchABR - Flag to control if dash.js' enableFastSwitch setting to allow buffer overlapping (may increase segments downloaded and thus CDN cost - but should improve QOE metrics).
         * @param {Array} sessionOptions.trackingConfigOverrides - Config array of the format [{name: "agent_name", enabled: boolean}] used to override instantiation of tracking agents
         * @param {String} sessionOptions.userConnectionType - User provided value to track the connection type. For example: 'wifi'. It defaults to 'unknown'.
         */
        init: function(sessionOptions) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.CONFIG_MANAGER;

            this.modules =  [];
            this.classes = [];

            if(window.top !== window.self) {
                this.sessionOptions.isEmbedded = true;
                this.sessionOptions.referrer = document.referrer;
            }

            this.initialize(sessionOptions);
        },

        /**
         * @memberof uvpjs.ConfigDataObject
         * @param options
         */
        initialize: function(options) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'ConfigDataObject initialize options = ', options);
            }
            // Video Manager error traps missing or mistyped options
            this.overrideSessionOptions(options);
        },

        /**
         * Destroy instance
         * @memberof uvpjs.ConfigDataObject
         */
        destroy: function() {
            this.modules = null;
            this.classes = null;
        },

        /**
         * Used at CDO initialization and for dynamic overrides
         * @param {object} options - object with session properties and new values ex: {ursuid:"LarryDoyle", userStatus:"stayinAlive"}
         * @memberof uvpjs.ConfigDataObject
         * @returns {Undefined} Undefined
         */
        overrideSessionOptions: function(options) {
            var sessionOptions = this.getSessionOptions(options);

            if (!sessionOptions || !_.isPlainObject(sessionOptions)) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'ConfigDataObject overrideSessionOptions options undefined or not the correct type.');
                }
                return;
            }

            this.sessionOptions = sessionOptions;
        },

        getSessionOption: function(key) {
            return this.sessionOptions[key] || null;
        },

        /**
         * Returns a copy of the sessionOptions object. Merges incoming `options` values, if needed.
         * Used by the VideoManager to create playerOptions without updating the global sessionOptions.
         * @param {Object} options - Object with session properties and new values.
         * @memberof uvpjs.ConfigDataObject
         * @returns {Object} Returns the sessionOptions object; merged, if needed.
         */
        getSessionOptions: function(options) {
            var sessionOptions, skinConfig, key;

            // uvpjs.log(this.DEBUG_ID, 'ConfigDataObject getSessionOptions options = ' + options);

            sessionOptions = _.clone(this.sessionOptions);

            // Video Manager error traps missing or mistyped options
            if (!options || !_.isPlainObject(options)) {
                return sessionOptions;
            }

            skinConfig = options.skinConfig;

            //** NOTE: skinConfig object properties are now properties of the root sessionOptions object.
            //**       For backwards compatibility, we'll look for a skinConfig object here and copy the
            //**       the properties to the root sessionOptions object, if needed.  8/9/16
            if (skinConfig && !_.isEmpty(skinConfig)) {
                uvpjs.warn(this.DEBUG_ID,
                    'DEPRECATION NOTICE: The `skinConfig` session option parameter no longer exists. ' +
                    'Please relocate the properties to the `sessionOption` object.'
                );

                for (key in skinConfig) {
                    if (sessionOptions.hasOwnProperty(key)) {
                        sessionOptions[key] = skinConfig[key];
                    }
                }
            }

            for (key in sessionOptions) {
                if (options.hasOwnProperty(key)) {
                    sessionOptions[key] = options[key];
                }
            }
            return sessionOptions;

            // todo add this Chrome Cast knowledge pulled from Hi5:
            // 4/14/2015 ChromeCast hack to allow ursuid to be dynamically set after initialization and after DW.params are checked.
            // iow the tracker and DW have been created
            //if (this.tracker && this.tracker.dw){
            //   this.tracker.dw._ursuid = this.sessOpts.ursuid;
            // }
        },

        /**
         * Get a module by name.
         * @param {String} name - the name of the module
         * @memberof uvpjs.ConfigDataObject
         * @returns {Object}
         */
        getModule: function(name) {
            return _findItemByName(this.modules, name);
        },

        /**
         * Returns the config object's modules arrays.
         * @memberof uvpjs.ConfigDataObject
         * @returns {Array}
         */
        getModules: function() {
            return this.modules;
        },

        /**
         * Returns a module's parameter value by name.
         * @param {String} moduleName - the name of the module
         * @param {String} paramName - the name of the param
         * @memberof uvpjs.ConfigDataObject
         * @returns {Array}
         */
        getModuleParam: function(moduleName, paramName) {
            var module = _findItemByName(this.modules, moduleName),
                param = _findItemByName(module.params, paramName);

            if (!param || !param.hasOwnProperty('value')) {
                return;
            }

            return param.value;
        },

        /**
         * Creates a module.
         * @param {Object} module - new module object
         * @memberof uvpjs.ConfigDataObject
         * @returns {Undefined} Undefined
         */
        setModule: function(module) {
            _addItemToArray(this.modules, module, 'name', this.DEBUG_ID);
        },

        /**
         * Check if a module is enabled.
         * @param {String} name - the name of the module
         * @memberof uvpjs.ConfigDataObject
         * @returns {Boolean}
         */
        isModuleEnabled: function(name) {
            var module = this.getModule(name);

            if (!module) {
                var message = 'ConfigDataObject isModuleEnabled module not found: ' +  name;

                if (this.debug) {
                    uvpjs.log(this.DEBUG_ID, message);
                }
                //this.eventsManager.dispatchEvent(this.eventsMgr.eventTypes.UVPJS_WARNING, {msg: message}, this);

                return false;
            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'ConfigDataObject isModuleEnabled '+ name +':', module.enabled);
            }
            return module.enabled;
        },

        /**
         * Check if a module exists in the config
         * @param {String} name - the name of the module
         * @memberof uvpjs.ConfigDataObject
         * @returns {Boolean}
         */
        isModuleSet: function(name) {
           return !!this.getModule(name);
        },

        /**
         * Get a class by name.
         * @param {String} name - the name of the class
         * @memberof uvpjs.ConfigDataObject
         * @returns {Object}
         */
        getClass: function(name) {
            return _findItemByName(this.classes, name);
        },

        /**
         * Returns the config object's classes arrays
         * @memberof uvpjs.ConfigDataObject
         * @returns {Array}
         */
        getClasses: function() {
            return this.classes;
        },

        /**
         * Get a class property by name.
         * @param {String} name - the name of the class
         * @param {String} propertyName - the name of the property
         * @memberof uvpjs.ConfigDataObject
         * @returns {String}
         */
        getClassProperty: function(name, propertyName) {
            var classItem = _findItemByName(this.classes, name),
                propertiesArray = _getItemProperty.call(this, classItem, 'properties', this.DEBUG_ID),
                propertyItem = _findItemByName(propertiesArray, propertyName);

            return _getItemProperty.call(this, propertyItem, 'value', this.DEBUG_ID);
        },

        /**
         * Get a class' list array.
         * @param {String} name - the name of the class
         * @memberof uvpjs.ConfigDataObject
         * @returns {Array}
         */
        getClassListItems: function(name) {
            var listItem = _findItemByName(this.classes, name);

            return _getItemProperty.call(this, listItem, 'list', this.DEBUG_ID);
        },

        /**
         * Get a property from a class' list item.
         * @param {String} name - the name of the class
         * @param {String} listItemId - the id of the list item
         * @param {String} propertyName - the name of the property
         * @memberof uvpjs.ConfigDataObject
         * @returns {String}
         */
        getClassListItemProperty: function(name, listItemId, propertyName) {
            var listItemsArray = this.getClassListItems(name),
                listItem = _findItemById(listItemsArray, listItemId),
                propertiesArray = _getItemProperty.call(this, listItem, 'properties', this.DEBUG_ID),
                propertyItem = _findItemByName(propertiesArray, propertyName);

            return _getItemProperty.call(this, propertyItem, 'value', this.DEBUG_ID);
        },

        /**
         * Creates a class.
         * @param {Object} cls - new class object
         * @memberof uvpjs.ConfigDataObject
         * @returns {Undefined} Undefined
         */
        setClass: function(cls) {
            _addItemToArray(this.classes, cls, 'name', this.DEBUG_ID);
        },

        /**
         * Determines if network is CAN.
         * @memberof uvpjs.ConfigDataObject
         * @returns {Boolean}
         */
        isCAN: function() {
            return _.isString(this.sessionOptions.netwk) && this.sessionOptions.netwk.toLowerCase() == 'can';
        },
    });

    // OPTIMIZE? -  these are good candidates to reside in a shared util object
    /**
     * Helper functions
     */

    /**
     * Find an array item.
     * @param {Array} array - the array to search through
     * @param {String} key - name of the item
     * @param {String} value - value of the item
     * @returns {Object}
     */
    var _findItemInArray = function(array, key, value) {
        for (var i in array) {
            if (array[i][key] == value) {
                return array[i];
            }
        }
        return false;
    };

    /**
     * Find an array item by name.
     * @param {Array} array - the array to search through
     * @param {String} name - name of the item
     * @returns {Object}
     */
    var _findItemByName = function(array, name) {
        return _findItemInArray(array, 'name', name);
    };

    /**
     * Find an array item by id.
     * @param {Array} array - the array to search through
     * @param {String} id - id of the item
     * @returns {Object}
     */
    var _findItemById = function(array, id) {
        return _findItemInArray(array, 'id', id);
    };

    /**
     * Find a property of an item.
     * @param {Array} item - the item to search through
     * @param {String} property - the name of the item's property
     * @param {String} dbugId - debug identifier
     *
     * @returns {Array|String}
     */
    var _getItemProperty = function(item, property, dbugId) {
        if (!item) {
            if (this.debug) {
                uvpjs.warn(dbugId, 'ConfigDataObject findItemProperty item not found:', item);
            }
            return false;
        }

        if (!item.hasOwnProperty(property)) {
            if (this.debug) {
                uvpjs.warn(dbugId, 'ConfigDataObject findItemProperty no item property:', item, property);
            }
            return false;
        }

        return item[property];
    };

    /**
     * Add or update an array with item.
     * @param {Array} array - the array to search through
     * @param {String} item - the item to add to the array
     * @param {String} key - the key name to search against
     * @param {String} dbugId - debug identifier
     *
     * @returns {Undefined} Undefined
     */
    var _addItemToArray = function(array, item, key, dbugId) {
        // See if the item already exists
        for (var i in array) {
            if (array[i][key] == item[key]) {
                if (this.debug) {
                    uvpjs.log(dbugId, 'ConfigDataObject _addItemToArray updating existing item', item);
                }
                array[i] = item;
                return;
            }
        }

        if (this.debug) {
            uvpjs.log(dbugId, 'ConfigDataObject _addItemToArray creating item', item);
        }
        array.push(item);
    };

}(uvpjs.register('uvpjs')));

/* CBSi uvpjs: client-side JS */
'use strict';

(function (obj) {

    var _ = obj._,
        secret = Math.random();


    obj.ConfigManager = uvpjs.Class.subClass({

        /**
         * @constructor uvpjs.ConfigManager
         *
         * @description <span class="class-desc">Exists on UVPJS level stores frontend config metadata as
         * “appState” and “sessionState”; “appState” and “sessionState” are passed to each CVI during CVI.initialization
         * Loads backend config creates and initializes configDataObject with backend config file data
         * (aka Modules and Classes, or similar) dynamically load UVPJS classes or tells someone else to (phase 2)/span>
         *
         * @memberof uvpjs.ConfigManager
         * @param {Number} singletonKey - used for Singleton creation
         * @param {Object} sessionOptions session options
         * @param {String} sessionOptions.cms - Identifies the content management system providing meta data for the content video(s) during the current player session. Currently the only valid value is uvpjs.mediaCapabilities.PLATFORM (when using thePlatform) or empty string `''`.
         * @param {String} sessionOptions.ftag - Used to identify the tracking origin of the embedded SmartTag.
         * @param {String} sessionOptions.mapp - Allows the skin to add a unique identifier to the mapp tag that is passed to DW tracking. This value is used by business units to uniquely identify a skin if the business unit deploys multiple skins. The value is arbitrarily determined by the business unit.
         * @param {String} sessionOptions.netwk - Identifies if this instance of the player is part of the CBS Audience Network (CAN). Currently the only valid value is `CAN` or an empty string `''`.
         * @param {String} sessionOptions.partner - The unique ID for the business unit embedding the player. Example values currently in use are `gamespot`, `cnettv`, `cbssports`.  Coordinate with VideoTech and DW groups to ensure a unique value for a given business unit. This is a required data point.
         * @param {Array|Object|String} sessionOptions.uvpc - The configuration settings that may contain partner-level overrides to the default UVPJS configuration settings. Accepts fully-qualified urls (XML or JSON), JSON or JavaScript objects, or an array of any combination of urls and objects. The XML or JSON files can live on a server hosted by the business-unit or it can be hosted on Video Tech servers. {@link https://sites.google.com/a/cbsinteractive.com/video-technology/home/developer/uvpjs-home/startup-configuration Click here for more information.}
         * @param {String} sessionOptions.ursuid - The CBSi internal authenticated user ID.
         * @param {skinConfig} sessionOptions.skinConfig - Configuration that controls the UVPJS default skin.
         * @param {Boolean} sessionOptions.usesIMA - Signals UVPJS to setup the `ad` container and wait for the Google IMA script to finish loading.
         * @param {Boolean} sessionOptions.usesTealium - Indicates that UVPJS should wait for the existence of the AppMeasurement "s" object on the page while initializing Adobe Heartbeat tracking.
         * @param {String} sessionOptions.allowConcurrentPlayback - Allows more than one video to play at time when true. When false only one video instance at a time can play on a page. Starting a paused player will cause the currently playing instance to pause.
         * @param {String} sessionOptions.browserVer -
         * @param {String} sessionOptions.deviceCPU -
         * @param {String} sessionOptions.deviceScreenSize -
         * @param {String} sessionOptions.deviceType -
         * @param {String} sessionOptions.deviceVers -
         * @param {String} sessionOptions.host -
         * @param {String} sessionOptions.maxDynamicSwitchingIndex -
         * @param {String} sessionOptions.minDynamicSwitchingIndex -
         * @param {String} sessionOptions.mso - Multiple System Operator also known as a cable TV company. For example: Comcast or Time Warner.
         * @param {String} sessionOptions.pageUrl -
         * @param {String} sessionOptions.playerCoords -
         * @param {String} sessionOptions.playerId -
         * @param {String} sessionOptions.playerVersion -
         * @param {String} sessionOptions.referrer -
         * @param {String} sessionOptions.sessionId -
         * @param {String} sessionOptions.useAutoDynamicSwitching -
         * @param {String} sessionOptions.userCountry -
         * @param {String} sessionOptions.userISP -
         * @param {String} sessionOptions.userId -
         * @param {String} sessionOptions.userPPID -
         * @param {String} sessionOptions.userStatus - CBS.com All Access user status. For example: reg;sub;pay.
         * @param {String} sessionOptions.deferLoadingCaptions - If loading of closed captions should be delayed until they are displayed
         *
         * @param {Function} callback: callback function
         *
         */
        init: function(singletonKey, sessionOptions, callback) {
            this.debug = uvpjs.debug;

            if (!singletonKey || singletonKey !== secret) {
                if (this.debug) {
                    uvpjs.error(this.DEBUG_ID, 'ERROR: ', 'ConfigManager is a Singleton; obtain instance via ConfigManager.getInstance().');
                }
                return;
            }

            this.initCallback = callback;

            this.DEBUG_ID = uvpjs.DebugManager.configParams.CONFIG_MANAGER;

            // VideoManager error traps missing or mistyped sessionOptions
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'init sessionOptions =', sessionOptions);
            }

            this.CDO = new uvpjs.ConfigDataObject(sessionOptions);
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'init CDO =',  this.CDO);
            }

            this.configSources = [];
            this.configSources.push(this.CDO.sessionOptions.uvpc);

            if (this.CDO.isCAN()) {
                this.configSources.push(uvpjs.ConfigManager.CAN_CONFIG_PATH);
            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'init configSources =',  this.configSources);
            }

            this.loadConfig();
        },

        /**
         * @memberof uvpjs.ConfigManager
         */
        initialize: function() {
            // no impl
        },

        /**
         * Destroy instance
         * @memberof uvpjs.ConfigManager
         */
        destroy: function() {
            this.initCallback = null;
            this.CDO.destroy();
            this.CDO = null;

            uvpjs.ConfigManager.destroyInstance();
        },

        /**
         * Load configuration files.
         * @memberof uvpjs.ConfigManager
         */
        loadConfig: function() {

            if (!this.configSources.length) {
                // uvpjs.log(this.DEBUG_ID, 'loadConfig configSources array empty');

                if (_.isFunction(this.initCallback)) {
                    // uvpjs.log(this.DEBUG_ID, 'loadConfig initCallback called');
                    this.initCallback(this.CDO);
                }

                return;
            }

            var source = this.configSources.shift();

            // uvpjs.log(this.DEBUG_ID, ' loadConfig source', source);

            if (source !== null && source !== undefined) {
                // `source.constructor` allows us to distinguish between an object and an array
                // `typeof` considers them both objects
                switch (source.constructor) {
                    case String:
                        if (source === '') {
                            break;
                        }

                        var codeLoader = new uvpjs.CodeLoader();
                        codeLoader.loadXHR(source, this.onLoadComplete.bind(this), this.onLoadError.bind(this));
                        return; // onLoadComplete and onLoadError call loadConfig so we exit the function

                    case Array:
                        this.configSources = source.concat(this.configSources);
                        break;

                    case Object:
                        this.updateCDO(source);
                        break;
                }
            }

            this.loadConfig();
        },

        /**
         * Handles JSON configuration files
         * @param {Object} xhr - request object
         * @memberof uvpjs.ConfigManager
         */
        onLoadComplete: function(xhr) {
            var text = xhr.responseText,
                type = xhr.getResponseHeader('Content-Type'),
                parser, xml, json;

            // JSON
            if (type.indexOf('application/json') > -1) {
                json = JSON.parse(text);
            // XML
            } else if (type.indexOf('text/xml') > -1 || type.indexOf('application/xml') > -1) {
                parser = new DOMParser();
                xml = parser.parseFromString(text, 'text/xml');
                json = this.xmlToCDO(xml);
            // Unknown
            } else {
                this.debug && uvpjs.error(this.DEBUG_ID, 'Unknwon content-type.', type);
            }

            json && this.updateCDO(json);
            this.loadConfig();
        },

        /**
         * XHR error handler
         * @param {Object} xhr - request obejct
         * @memberof uvpjs.ConfigManager
         */
        onLoadError: function(xhr) {
            var message = 'unknown error';

            switch (xhr.status) {
                case 0:
                    message = 'request timeout';
                    break;
            }

            if (this.debug) {
                uvpjs.error(this.DEBUG_ID, 'onLoadError error =', message, xhr);
            }

            this.loadConfig();
        },

        /**
         * Update config object with new config object
         * @param {Object} newObj - new config object
         * @memberof uvpjs.ConfigManager
         */
        updateCDO: function(newObj) {
            if (_.isEmpty(newObj)) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'updateCDO newObj is empty');
                }
                return;
            }

            ['classes', 'modules'].map(function(item) {
                // Skip if the object doesn't contain the array
                if (!newObj.hasOwnProperty(item)) {
                    return;
                }
                this.CDO[item] = _mergeArrays(this.CDO[item], newObj[item]);
            }, this);
        },

        /**
         * Convert XML to native config object
         * @param xml - XML document
         * @memberof uvpjs.ConfigManager
         * @returns {Object}
         */
        xmlToCDO: function(xml) {
            var obj = {};

            var isBoolean = function (value) {
                return value === 'y' || value === 'n';
            };

            var isTruthy = function(value) {
                return value === 'y';
            };

            var json = _xmlToJSON(xml);

            // We don't need the parent object wrapper
            if (json.hasOwnProperty('player-config')) {
                json = json['player-config'];
            }

            // uvpjs.log(this.DEBUG_ID, '_toConfigObject json =', json);

            obj.modules = (function() {
                var moduleArray, output = [];

                if (!json.modules) {
                    return;
                }

                moduleArray = _ensureArray(json.modules.module);

                for (var m in moduleArray) {
                    var thisModule = moduleArray[m];

                    var module = {
                        name: thisModule.name,
                        category: thisModule.category,
                        enabled: isTruthy(thisModule.enabled),
                        params: [],
                    };

                    // Not all XML modules have params
                    if (moduleArray[m].hasOwnProperty('params')) {
                        var paramArray = _ensureArray(thisModule.params.param);

                        for (var p in paramArray) {
                            var thisParam = paramArray[p];

                            // Make sure it's a well-formed parameter
                            if (!thisParam.name) {
                                continue;
                            }

                            // Convert "y" / "n" values to boolean
                            if (isBoolean(thisParam.value)) {
                                thisParam.value = isTruthy(thisParam.value);
                            }

                            module.params.push(thisParam);
                        }
                    }

                    var category = thisModule.category || 'unknown';

                    output.push(module);
                }

                return output;
            })(obj);

            obj.classes = (function() {
                var classArray = _ensureArray(json.classes),
                    output = [];

                for (var c in classArray) {
                    var thisClass = classArray[c];

                    // Check if "class" item has a "classDef" parent object
                    if (thisClass.hasOwnProperty('classDef')) {
                        thisClass = thisClass.classDef;
                    }

                    if (!thisClass.name) {
                        continue;
                    }

                    var cls = {
                        name: thisClass.name,
                        className: thisClass.className,
                        properties: [],
                        list: [],
                    };

                    // Not all XML classes have a list
                    if (thisClass.hasOwnProperty('list')) {
                        var listArray = _ensureArray(thisClass.list.listitem);

                        for (var l in listArray) {
                            var thisItem = listArray[l];

                            // Make sure it's a well-formed list item
                            if (!thisItem.id) {
                                continue;
                            }

                            if (thisItem.hasOwnProperty('properties')) {
                                thisItem.properties = thisItem.properties.property;
                            }

                            cls.list.push(thisItem);
                        }
                    }

                    if (thisClass.hasOwnProperty('properties')) {
                        cls.properties = thisClass.properties.property;
                    }

                    output.push(cls);
                }

                return output;
            })();

            // uvpjs.log(this.DEBUG_ID, '_toConfigObject obj =', obj);

            return obj;
        },

        /**
         * getCDO() - get current config object
         *
         * @memberof uvpjs.ConfigManager
         *
         * @returns {Object}
         */
        getCDO: function() {
            return this.CDO;
        },

    });

    // OPTIMIZE - consider moving strings like this to a central config to avoid having
    // them scattered about the codebase
    /**
     * @memberof uvpjs.ConfigManager
     * @alias uvpjs.ConfigManager.CAN_CONFIG_PATH
     */
    obj.ConfigManager.CAN_CONFIG_PATH = '//can.cbs.com/thunder/player/chrome/smart_tag/config.php?url=http://can.cbs.com/thunder/player/chromeless/uvp/can.xml';


    // Singleton pattern
    obj.ConfigManager._instance = null;

    obj.ConfigManager.destroyInstance = function() {
        this._instance = null;
    };

    obj.ConfigManager.getInstance = function(sessionOptions, callback) {
        if (!this._instance) {
            // note use of private "secret" for singletonKey
            this._instance = new uvpjs.ConfigManager(secret, sessionOptions, callback);
        }

        return this._instance;
    };


    ///////////////
    // PRIVATE
    /**
     * Helper functions
     */

    // OPTIMIZE? - move to a dedicated util obj
    /**
     * Merge two arrays
     * @description Merge two arrays together. array1 takes precedence over array2.
     * @param array1 - existing array to be updated by new array
     * @param array2 - new array to merge into existing array
     * @returns {Array}
     */
    var _mergeArrays = function(array1, array2) {
        for (var i in array2) {
            var exists = false;

            for (var j in array1) {
                if (array1[j].name === array2[i].name) {
                    exists = true;
                    break;
                }
            }

            if (!exists) {
                array1.push(array2[i]);
            }
        }

        return array1;
    };

    // OPTIMIZE? -  xmlToJSON conversion also occurs in CaptionsManager, albeit with some special handling
    /**
     * Convert XML to JSON.
     * Adapted from http://davidwalsh.name/convert-xml-json
     * @param xml - XML document
     * @returns {Object}
     */
    var _xmlToJSON = function(xml) {
        var obj = {}, n;

        // Elements and attributes
        if (xml.nodeType === 1 && xml.attributes.length > 0) {
            n = xml.attributes.length;

            for (var j = 0; j < n; j++) {
                var attribute = xml.attributes.item(j);
                obj[attribute.nodeName] = attribute.nodeValue;
            }
        }

        // Children
        if (xml.hasChildNodes()) {
            n = xml.childNodes.length;

            for (var i = 0; i < n; i++) {
                var item = xml.childNodes.item(i),
                    nodeName = item.nodeName;

                // Skip text elements
                if (item.nodeType === 3) {
                    continue;
                }

                if (typeof obj[nodeName] === 'undefined') {
                    obj[nodeName] = _xmlToJSON(item);
                    continue;
                }

                // If more than one child, create an array
                if (typeof obj[nodeName].push === 'undefined') {
                    var old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }

                obj[nodeName].push(_xmlToJSON(item));
            }
        }

        return obj;
    };

    /**
     * Ensures the item passed is an array
     * @description The _xmlToJson function creates arrays only when there are
     *              more than one child element being iterated over (it creates
     *              the array on the second pass). This function ensures the
     *              single-item elements are arrays to correctly iterate over.
     * @param item - either an object or an array
     * @returns {Array}
     */
    var _ensureArray = function(item) {
        if (typeof item === 'undefined' || item.constructor === String) {
            return;
        }

        if (item.constructor === Object) {
            item = [item];
        }

        return item;
    }

}(uvpjs.register('uvpjs')));


/**
 * Created by ldoyle on 8/11/15.
 */

(function (obj) {
    'use strict';

    var Watermark = null,
        Kaleidoscope360 = null,
        _ = obj._;

    /**
     * Events - passes them to Resource Provider for filtering and Dispatching<br>
     * subclass for each low level video player context HTML5, SWF, DASH MSE, IMA, Stallone.<br>
     * @constructor uvpjs.VideoPlayerFacade
     * @extends uvpjs.VideoPlayerFacade
     */

    obj.VideoPlayerFacade = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.VIDEO_PLAYER_FACADE,

        WARNINGS: {
            ABR_NOT_SUPPORTED: 'Adaptive Bitrate Streaming not supported.',
            FACADE_MUST_BE_INITIALIZED: 'Facade must be initialized before you call this method',
            ABR_INDEX_OUT_OF_RANGE: 'ABR Index is out of range',
            ARG_MUST_BE_BOOLEAN: 'The argument must be (boolean) true or false',
            STARTING_BITRATE_BELOW_MIN_ALLOWED: 'Unable to set start bitrate below minimum bitrate allowed threshold, upping to min threshold'
        },

        MEDIA_TYPES: {
            VIDEO:'video',
            AUDIO:'audio',
            TEXT:'text'
        },
        // HTML5 SPECIFIC EVENT TYPE CONSTANTS // todo ld move into Facade to allow sharing by HLS and other classes
        eventTypes: {
            /**
             * list of standard HTML5 / Flash fallback event names for easy reference.
             * @type {object}
             */
            HTML5: {
                ABORT: 'abort',            // Sent when playback is aborted; ex: if the media is playing and is restarted from the beginning.
                CAN_PLAY: 'canplay',          // Sent when enough data is available that the media can be played, at least a couple of frames.
                CAN_PLAY_THROUGH: 'canplaythrough',   // the entire media can be played without interruption, more comments below in handleEvent
                CLICK: 'click',            // sent when a click event is detected, more comments below in handleEvent
                DURATION_CHANGE: 'durationchange',   // The metadata has loaded or changed, indicating a change in duration of the media, more comments below in handleEvent
                ENDED: 'ended',            // Sent when playback completes, more comments below in handleEvent
                EMPTIED: 'emptied',          // The media has become empty; ex: sent if the media has already been loaded (or partially loaded)
                ERROR: 'error',            // Sent when an error occurs, more comments below in handleEvent and error methods
                LOAD_START: 'loadstart',        // Sent when loading of the media begins, more comments below in handleEvent
                LOADED_DATA: 'loadeddata',       // The first frame of the media has finished loading, more comments below in handleEvent
                LOADED_METADATA: 'loadedmetadata',   // The media's metadata has finished loading, more comments below in handleEvent
                PAUSE: 'pause',            // Sent when playback is paused, more comments below in handleEvent
                PLAY: 'play',             // Sent when playback of the media starts after having been paused, more comments below in handleEvent
                PLAYING: 'playing',          // Sent when the media begins to play, more comments below in handleEvent
                PROGRESS: 'progress',         // Sent periodically to inform the progress of downloading the media, more comments below in handleEvent
                RATE_CHANGE: 'ratechanged',      // Sent when the playback speed changes, more comments below in handleEvent
                SEEKED: 'seeked',           // Sent when a seek operation completes, more comments below in handleEvent
                SEEKING: 'seeking',          // Sent when a seek operation begins, more comments below in handleEvent
                TIME_UPDATE: 'timeupdate',       // The time indicated by the element's currentTime attribute has changed, more comments below in handleEvent
                VOL_CHANGE: 'volumechange',     // Sent when the audio volume changes, more comments below in handleEvent
                STALLED: 'stalled',          // Sent when the user agent is trying to fetch media data, more comments below in handleEvent
                SUSPEND: 'suspend',          // Sent when loading of the media is suspended, more comments below in handleEvent
                TOUCH_END: 'touchend',         // Sent when the touck event has ended, more comments below in handleEvent
                WAITING: 'waiting',           // when the requested operation (such as playback) is delayed pending, more comments below in handleEvent
                ADD_TRACK: 'addtrack',        // Sent when a new text track is added to a video element
                CUE_CHANGE: 'cuechange',       // Sent when active cues are added or removed on a text track
                WEBKIT_NEED_KEY: 'webkitneedkey' // Sent when Safari has proccessed an HLS manifest using FairPlay and needs to acquire a license key

            },

            readyState: {
                HAVE_NOTHING: 0,                            // no data
                HAVE_METADATA: 1,                           // Duration, width, height and other metadata of the video have been fetched.
                HAVE_CURRENT_DATA: 2,                       // There has not been sufficiently data loaded in order to start or continue playback.
                HAVE_FUTURE_DATA: 3,                        // Enough data to start playback
                HAVE_ENOUGH_DATA: 4                         // It should be possible to play the media stream without interruption till the end.
            },
            networkState: {
                NETWORK_EMPTY: 0,                           // not yet initialized
                NETWORK_IDLE: 1,                            // source chosen; not in fetching state
                NETWORK_LOADING: 2,                         // actively fetches the source
                NETWORK_NO_SOURCE: 3                        // no source in a supported format can be spotted
            },
            errors: {
                MEDIA_ERROR_ABORTED: 1,	                    // the user has aborted fetching the video
                MEDIA_ERROR_NETWORK: 2, 	                // network error
                MEDIA_ERR_DECODE: 3,                        // error at decodation time
                MEDIA_ERR_SRC_NOT_SUPPORTED: 4              // media format not supported
            }
        },

        // DOM ELEMENT NAME PREFIXES
        PREFIX_CONTENT: 'content_',                         // html element for content prefix within videoContainer_object
        PREFIX_ADS: 'ad_',                                  // html element for ad prefix within videoContainer_object
        CONTROLS: 'controls',                               // video tag controls attribute

        // ERROR CONSTANTS
        errors: {
            DATA_LOADING_ERROR_STATE: 130                 // an error occured while loading data
        },

        // JAVASCRIPT OBJECT TYPE CONSTANTS
        SOURCE: 'source',           // the source string name constant
        OBJECT: 'object',           // the object constant string
        POSTER: 'poster',           // the poster attribute name
        VIDEO: 'video',            // video object type, video element

        init: function () {
            this.debug = uvpjs.debug;
            this.debug && uvpjs.log(this.DEBUG_ID, 'init');

            this.playbackState = uvpjs.mediaCapabilities.EMPTY;   // EMPTY:-2, LOADING:-1, STOPPED:0, PLAYING:1, PAUSED:2, BUFFERING:3

            // TODO? should this.videoTagRef default to null

            this.videoTagRef = null;            // videoTagRef - the video element
            this.supportsTouchEvents = false;   // needs to come from a config object. temporary
            this.resourceProvider = {};         // the resource provider responsible for this video facade
            this.vidContId = '';

            // VTG-79; vidContentId not used (set in initialize, not read); intent?
            this.vidContentId = '';
            this.internalNS = '';
            this.facadeState = {};
            this.hasPlaybackStarted = false;
        },

        /**
         *
         * @param {Object}                  options
         * @param {Number}                  options.abrStartIndex
         * @param {String}                  options.assetURL
         * @param {Boolean}                 options.isMuted
         * @param {uvpjs.ResourceProvider}  options.resourceProvider
         * @param {Boolean}                 options.useDynamicSwitching
         * @param {Number}                  options.volume
         * @param {Boolean}                 options.suppressCreatedEvent
         * @param {Boolean}                 options.deferLoadingCaptions
         *
         * @memberof uvpjs.VideoPlayerFacade#
         */
        initialize: function (options) {
            var rp = options.resourceProvider,
                containerId = rp.vidContId;

            this.resourceProvider = rp;
            this.eventsMgr = this.resourceProvider.eventsMgr;
            this.vidContId = containerId;
            this.assetURL = options.assetURL;
            this.vidContentId = this.PREFIX_CONTENT + containerId;
            this.internalNS = '.' + containerId + '.' + 'facade';
            this.videoTagRef = document.getElementById(this.VIDEO + '_' + containerId);
            this.deferLoadingCaptions = options.deferLoadingCaptions;

            this._updateVolumeSettings(options);

            // Create CBS watermark.
            if (rp.createWatermark() && !options.suppressWatermark) {
                Watermark = new uvpjs.Watermark({
                    containerId: containerId,
                    eventsMgr: this.eventsMgr,
                    videoEl: this.videoTagRef
                });
            }

            if(rp.is360() && !options.suppress360) {
                Kaleidoscope360 = new uvpjs.Kaleidoscope360({
                    containerId: containerId,
                    eventsMgr: this.eventsMgr,
                    videoEl: this.videoTagRef
                });
            }

            options.suppressCreatedEvent !== true && this.dispatchCreated();
        },


        /**
         * @memberof uvpjs.VideoPlayerFacade#
         * @protected
         */
        dispatchCreated: function () {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTENT_FACADE_CREATED, {}, this.vidContId);
        },

        // VTG-216 All calls to `facade.cleanUp` now call `facade.destroy`; `destroy` not
        //         called properly before and low-level facades never fully cleaned-up.

        /**
         * Cleans up the HTML5 video player facade, removing video tag, making
         * sure video is stopped. Be careful to garbage correct properly.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         */
        destroy: function () {

            if (_.isEmpty(this.resourceProvider)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'VideoPlayerFacade cleanUp this.resourceProvider is empty; facade already destroyed.')
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade cleanUp this.resourceProvider.rco.id = ', this.resourceProvider.rco.id)

            // Remove events.
            this.removeEvents();

            // Destroy CBS watermark.
            if (Watermark) {
                Watermark.destroy();
                Watermark = null;
            }

            // Destroy Kalediscope canvas
            if (Kaleidoscope360) {
                Kaleidoscope360.destroy();
                Kaleidoscope360 = null;
            }


            this.resourceProvider = null;
            this.vidContId = null;

            this.videoTagRef = null;
            this.vidContId = null;
            this.vidContentId = null;
            this.internalNS = null;
            this.supportsTouchEvents = null;
            this.hasPlaybackStarted = false;
        },

        /////////////////////
        // Private

        /**
         * Setup the HTML5 video tag volume and mute.
         *
         * @param {Object}  options
         * @param {Boolean} options.isMuted Muted state.
         * @param {Number}  options.volume  Video volume.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @private
         */

        _updateVolumeSettings: function (options) {
            var options = options || {},
                volume = options.volume,
                isMuted = options.isMuted === true,
                vidEl = this.videoTagRef;

            this.debug && uvpjs.log(this.DEBUG_ID, '_updateVolumeSettings', options);

            if (uvpjs.util.inRange(volume, 0, 1)) {
                vidEl.volume !== volume && (vidEl.volume = volume);
            }

            if ('isMuted' in options && vidEl.muted !== isMuted) {
                this.muteVideo(isMuted);
            }
        },

        /**
         * Add HTML5 media events.
         *
         * @todo it appears this.supportsTouchEvents never gets evaluated; always false.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         */
        _addHTML5Events: function () {
            var types = this.eventTypes.HTML5,
                gesture = !!this.supportsTouchEvents ? 'TOUCH_END' : 'CLICK',
                evt;

            this.debug && uvpjs.log(this.DEBUG_ID, '_addHTML5Events');

            for (evt in types) {
                if (evt === 'CLICK' || evt === 'TOUCH_END') {
                    continue;
                }
                this.videoTagRef.addEventListener(types[evt], this, false);
            }

            // Special condition for click or touchend.
            this.videoTagRef.addEventListener(types[gesture], this, false);
        },

        /**
         * Remove facade specific events.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        _removeHTML5Events: function () {
            var types = this.eventTypes.HTML5,
                gesture = !!this.supportsTouchEvents ? 'TOUCH_END' : 'CLICK',
                evt;

            this.debug && uvpjs.log(this.DEBUG_ID, '_removeHTML5Events');

            for (evt in types) {
                if (evt === 'CLICK' || evt === 'TOUCH_END') {
                    continue;
                }
                this.videoTagRef.removeEventListener(types[evt], this, false);
            }

            // Special condition for click or touchend.
            this.videoTagRef.removeEventListener(types[gesture], this, false);
        },

        /**
         * Main HTML5 media event trapping loop.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @param {event} event object returned from low-level HTML5 video.
         */
        handleEvent: function (event) {
            var types = this.eventTypes.HTML5;

            if (!this.videoTagRef) return;

            switch (event.type) {
                case types.ABORT:
                    // Sent when playback is aborted; ex: if the media is playing and is restarted from the beginning.
                    break;

                case types.CAN_PLAY:
                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent CAN_PLAY');
                    }
                    // Sent when enough data is available that the media can be played, at least a couple of frames.
                    // This corresponds to the HAVE_ENOUGH_DATA readyState.

                    // don't need the can play event listenter once it has fired for a particular video.
                    this.videoTagRef.removeEventListener(types.CAN_PLAY, this, false);

                    break;

                case types.CAN_PLAY_THROUGH:
                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent CAN_PLAY_THROUGH');
                    }
                    // Sent when ready state changes to CAN_PLAY_THROUGH,
                    // means the entire media can be played without interruption,
                    // assuming the download rate remains at least at the current level.
                    // Note: Manually setting the currentTime will eventually fire a canplaythrough event in firefox.
                    // Other browsers might not fire this event.

                    // don't need the can play through event listenter once it has fired for a particular video.
                    this.videoTagRef.removeEventListener(types.CAN_PLAY_THROUGH, this, false);

                    // iPad, iPhone, iPod cases
                    // VTG-147: could improve semnatics here?
                    if (uvpjs.mediaCapabilities.isIOS()) {
                        if (this.debug) {
                            uvpjs.warn(this.DEBUG_ID, 'VideoPlayerFacade handleEvent  CAN_PLAY_THROUGH iDevice CASE    CALL this.resourceProvider.facadeDisplayReady()');
                        }
                        this.resourceProvider.facadeDisplayReady();
                    }

                    break;

                case types.CLICK:
                    // sent when a click event is detected.
                    break;

                case types.DURATION_CHANGE:
                    break;

                case types.EMPTIED:
                    // The media has become empty; ex: sent if the media has already been loaded (or partially loaded),
                    // and the load() method is called to reload it.
                    this.playbackStateChange(uvpjs.mediaCapabilities.EMPTY);

                    break;


                case types.ENDED:
                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent ENDED');
                    }
                    // Sent when playback completes.
                    this.videoDone();
                    break;

                case types.ERROR:
                    // Sent when an error occurs.  The element's error attribute contains more information.

                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent ERROR');
                    }

                    this.error(event.target.error);

                    break;

                // 3/25/2016 DEV NOTE: typical startup event order (confirm for all types)  LOAD_START then LOADED_METADATA  then LOADED_DATA.

                case types.LOAD_START:
                    // anything but iPad, iPod, or iPhone.
                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent LOAD_START');
                    }

                    if (_.isEmpty(this.resourceProvider)) {
                        if (this.debug) {
                            uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade  handleEvent LOAD_START  this.resourceProvider === {}   RETURN !!!!!');
                        }
                        return;
                    }

                    // VTG-147: could improve semnatics here?
                    if (uvpjs.mediaCapabilities.isIOS()) {
                        if (this.debug) {
                            uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade  handleEvent LOAD_START  uvpjs.mediaCapabilities.isIOS()  RETURN !!!!!');
                        }
                        return;
                    }
                    //uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade  handleEvent LOAD_START  CALL this.resourceProvider.facadeDisplayReady()');
                    //
                    //this.resourceProvider.facadeDisplayReady();
                    break;

                case types.LOADED_METADATA:
                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent LOADED_METADATA');
                    }
                    // The media's metadata has finished loading, all attributes now contain as much useful information as they're going to.

                    // Non-iDevice case, not iPad, iPhone, iPod
                    // VTG-147: could improve semnatics here?
                    if (!uvpjs.mediaCapabilities.isIOS()) {
                        if (this.debug) {
                            uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade  handleEvent LOAD_START NON-iDEVICE CASE CALL this.resourceProvider.facadeDisplayReady()');
                        }
                        this.resourceProvider.facadeDisplayReady();
                    }

                    break;

                case types.LOADED_DATA:
                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent LOADED_DATA');
                    }
                    // The first frame of the media has finished loading.
                    // DO WE STILL NEED TO DO SOMETHING HERE FOR CHROMECAST? OR OTHER DEVICE?

                    break;

                case types.PAUSE:
                    // Sent when playback is paused.
                    if (this.debug) {
                        uvpjs.log(this.DEBUG_ID, '>>>>>>> playbackstate changed in fascade: PAUSE ENCOUNTERED');
                    }
                    if (this.getPlaybackState() === uvpjs.mediaCapabilities.PLAYING) {
                        if (this.debug) {
                            uvpjs.log(this.DEBUG_ID, '>>>>>>> playbackstate changed in fascade: PAUSE is new playback state, dispatch new state');
                        }
                        this.playbackStateChange(uvpjs.mediaCapabilities.PAUSED);
                        //logWindow('uvp_video.js video pause at time : ' + this.video.currentTime );
                    }

                    //this.resourceProvider.handleFacadeEvent('onVideoPause');
                    break;

                case types.PLAY:
                    // The media has started playing. Sent when playback of the media starts after having been paused. (when playback is resumed after a prior pause event).
                    break;

                case types.PLAYING:
                    // Sent when the media begins to play (either for the first time, after having been paused, or after ending and then restarting).
                    this.hasPlaybackStarted = true;
                    this.playbackStateChange(uvpjs.mediaCapabilities.PLAYING);
                    break;

                case types.PROGRESS:
                    // Sent periodically to inform the progress of downloading the media.
                    // data about the current amount of downloaded media
                    // is in the media element's buffered attribute.
                    // don't rely on TIME_UPDATE,  VIDEO_PROGRESS timer events.
                    this.videoLoading();
                    break;

                case types.RATE_CHANGE:
                    // Sent when the playback speed changes.
                    // NOT IMPLEMENTED
                    break;

                case types.SEEKING:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent SEEKING', event);
                    break;

                case types.SEEKED:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade handleEvent SEEKED', event);
                    // Sent when a seek operation completes.
                    this.seeked(event.target.currentTime);
                    break;

                case types.STALLED:
                    // Sent when the user agent is trying to fetch media data,
                    // but data is unexpectedly not forthcoming.

                    // Not suitable for setting 'buffering'
                    break;

                case types.SUSPEND:
                    // Sent when loading of the media is suspended;
                    // this may happen either because the download has completed
                    // or because it has been paused for any other reason.

                    break;

                case types.TIME_UPDATE:
                    // don't rely on TIME_UPDATE,  VIDEO_PROGRESS timer events.
                    // The time indicated by the element's currentTime attribute has changed.
                    this.timeUpdated();
                    break;

                case types.VOL_CHANGE:
                    // Sent when the audio volume changes
                    this.volumeChanged();
                    break;

                case types.WAITING:
                    // Sent when the requested operation (such as playback) is delayed pending
                    // the completion of another operation (such as a seek).

                    // Not suitable for setting 'buffering'
                    break;
            }
        },

        /**
         * HTML5 `seeked` video event.
         *
         * @param {Number} currentTime
         *
         * @memberof uvpjs.VideoPlayerFacade#
         */
        seeked: function (currentTime) {
            var paused = this.videoTagRef.paused,
                mc = uvpjs.mediaCapabilities;

            this.playbackStateChange(paused ? mc.PAUSED : mc.PLAYING);

            this.debug && uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade seeked ' + JSON.stringify({
                currentTime: currentTime,
                paused: paused,
                playbackState: this.playbackState
            }, null, 2));

            this.resourceProvider.facadeSeeked({ seekToTime: currentTime });
        },

        /**
         * Called off the PROGRESS HTML5 video event.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        videoLoading: function () {
            var amountLoaded;
            // todo try catches are processor intensive, is there an alternative?

            // VTG-79; would knowing the readyState help here?
            try {
                amountLoaded = this.videoTagRef.buffered.end(0) || 0;
            } catch (e) {
                amountLoaded = 0;
                //amountLoaded = (this.global.isTouch()) ? this.video.duration() : 0;
            }

            var dataObj = {
                bufferLength: amountLoaded,
                duration: this.videoTagRef.duration
            };
            // call the rP method for processing media download events
            this.resourceProvider.facadeLoading(dataObj);
        },

        /**
         * Passes low-level video tag volume changes to the Resource Provider. Called off the VOLUMECHANGED HTML5 video event.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        volumeChanged: function () {
            //update controller so subsequent videos keep the same setting
            var videoVol = this.videoTagRef.volume;
            if (!_.isNumber(videoVol) || videoVol < 0) {
                videoVol = 0;
            } else if (videoVol > 1) {
                videoVol = 1;
            }
            this.resourceProvider.facadeVolumeChange(videoVol);
        },


        /**
         * Passes low-level video tag currentTime to the Resource Provider.
         * Called off the `timeupdate` HTML5 video event.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         */
        timeUpdated: function () {
            var ct = this.videoTagRef.currentTime;

            (typeof ct === 'number') && this.resourceProvider.facadeTimeUpdate(ct);
        },

        /**
         * error() - method that is called off of the ERROR HTML5 video event.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @param {Object} err - error object.
         */
        error: function (err) {
            var msgs = uvpjs.ErrorInfo.messages,
                codes = uvpjs.ErrorInfo.errorCodes,
                msg = msgs.UNSPECIFIED_VIDEO_PLAYBACK_ERROR,
                code = codes.UNSPECIFIED_VIDEO_PLAYBACK_ERROR,
                isFatal = true;

            /*
                From: MDN https://developer.mozilla.org/en-US/docs/Web/API/MediaError
                MEDIA_ERR_ABORTED            1   The fetching of the associated resource has been aborted by the user
                MEDIA_ERR_NETWORK            2   A network error caused the resource to stop being fetched.
                MEDIA_ERR_DECODE             3   A decoding error caused the resource to stop being fetched.
                MEDIA_ERR_SRC_NOT_SUPPORTED  4   The associated resource has been detected to be not suitable.
            */

            // assume fatal if not known
            if (err) {
                switch (err.code) {
                    case err.MEDIA_ERR_ABORTED:
                        isFatal = false;
                        msg = msgs.MEDIA_ERR_ABORTED;
                        code = codes.MEDIA_ERR_ABORTED;
                        break;

                    case err.MEDIA_ERR_NETWORK:
                        msg = msgs.MEDIA_ERR_NETWORK;
                        code = codes.MEDIA_ERR_NETWORK;
                        break;

                    case err.MEDIA_ERR_DECODE:
                        msg = msgs.MEDIA_ERR_DECODE;
                        code = codes.MEDIA_ERR_DECODE;
                        break;

                    case err.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        msg = msgs.MEDIA_ERR_SRC_NOT_SUPPORTED;
                        code = codes.MEDIA_ERR_SRC_NOT_SUPPORTED;
                        break;

                    default: break;
                }
            }

            this.debug && uvpjs.error(this.DEBUG_ID, "VideoPlayerFacade Error: " + msg);

            if (_.isEmpty(this.resourceProvider)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade error(); no RP - early return.');
                return;
            }

            // notify RP of error
            this.resourceProvider.facadeError(new uvpjs.ErrorInfo({
                errorCode: code,
                message: msg,
                isFatal: isFatal
            }));
        },

        /**
         * Hides the video (does not remove from layout)
         * @memberof uvpjs.VideoPlayerFacade#
         */
        hideVideo: function () {
            this.videoTagRef && (this.videoTagRef.style.visibility = "hidden");
        },

        /**
         * Shows video hidden via facade.hideVideo()
         * @memberof uvpjs.VideoPlayerFacade#
         */
        showVideo: function () {
            this.videoTagRef && (this.videoTagRef.style.visibility = "visible");
        },

        // VTG-79; stopVideo doesn't seem to be used
        /**
         * Stops the currently playing video.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        stopVideo: function () {
            if (this.videoTagRef) {
                this.videoTagRef.pause();
                this.playbackStateChange(uvpjs.mediaCapabilities.STOPPED);
                //send a stopped event.
            }
        },

        /**
         * Plays a currently paused video.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        playVideo: function () {
            var promise;

            if (this.videoTagRef) {
                this.debug &&  uvpjs.log(this.DEBUG_ID, 'playVideo');

                promise = this.videoTagRef.play();

                if (promise !== undefined) {
                    promise
                        .then(Function.prototype)
                        .catch(this.handlePlayPromiseRejection.bind(this));
                }
            }
        },

        /**
         * If browser returns a Promise, handle a rejection
         * @private
         *
         * @param {Object} err
         */
        handlePlayPromiseRejection: function (err) {
            this.debug && uvpjs.log(this.DEBUG_ID, "Browser appears to be preventing autoplay: " + err.message)
            this.resourceProvider && this.resourceProvider.facadeBrowserPlayFailure(err.message);
        },

        /**
         * Pauses the currently playing video.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        pauseVideo: function () {
            if (this.videoTagRef) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'pauseVideo');
                this.videoTagRef.pause();
            }
        },

        /**
         * Seeks to the time (seekToTime) in seconds.
         * @param {Number} seekToTime - time in seconds to seek to.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {undefined} undefined
         */
        seekTo: function (seekToTime) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'seekTo', seekToTime);

            if (isNaN(seekToTime)) {
                return;
            }

            if (this.videoTagRef && seekToTime >= 0 && seekToTime < this.videoTagRef.duration) {
                this.videoTagRef.currentTime = seekToTime;
            }
        },

        // VTG-151: SeekToLive Phase 1
        /**
         * Seeks to the live point time.
         * Note: Should be extended by those facades which accept live streams.
         * @memberOf uvpjs.VideoPlayerFacade
         */
        seekToLive: function () {
            if (!this.isHDStreamLive()) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'seekToLive attempted on non-Live Stream');
            }

            if (!this.videoTagRef) return;

            var seekPt = this.videoTagRef.seekable &&
                         this.videoTagRef.seekable.length > 0 &&
                         this.videoTagRef.seekable.end(0);

            if (!isNaN(seekPt) && seekPt > this.videoTagRef.currentTime) {
                this.videoTagRef.currentTime = seekPt;
            }
        },

        /**
         * Toggle between muted and unmuted audio.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        toggleMute: function () {
            var state;

            if (!this.videoTagRef) { return; }

            state = !this.videoTagRef.muted;

            this.muteVideo(state);
        },

        /**
         * @memberof uvpjs.VideoPlayerFacade#
         * @param state
         */
        setFullscreenState: function (state) {
            // noop in base class
        },


        /**
         * Loads the video - WHAT NEEDS TO GO HERE?
         * @memberof uvpjs.VideoPlayerFacade#
         */
        loadVideo: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'loadVideo');
            this.videoTagRef.addEventListener(this.eventTypes.HTML5.CAN_PLAY, this, false);
            this.videoTagRef.addEventListener(this.eventTypes.HTML5.CAN_PLAY_THROUGH, this, false);
            this.videoTagRef.load();
        },

        /**
         * Mutes the currently playing video.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @param {Boolean} flag  optional state flag; pass FALSE to un-mute.
         */
        muteVideo: function (flag) {
            var state = flag !== false;

            if (!this.videoTagRef) { return; }

            this.videoTagRef.muted = state;

            if (state && !this.videoTagRef.getAttribute("muted")) {
                this.videoTagRef.setAttribute("muted", "muted");
            }

            !state && this.videoTagRef.removeAttribute("muted");
        },

        /**
         * Unmutes the currently playing video.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        unMuteVideo: function () {
            this.muteVideo(false);
        },

        // VTG-79; getVolume does not seem to be in use
        /**
         * Returns the video volume.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Number} - returns current volume.
         */
        getVolume: function () {
            return this.videoTagRef && this.videoTagRef.volume || 0;
        },

        /**
         * Sets the video volume.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @param {Number} newVolume - the volume to set to.
         */
        setVolume: function (newVolume) {
            if (this.videoTagRef && newVolume >= 0 && newVolume <= 1) {
                this.videoTagRef.volume = newVolume;
            }
        },

        /**
         * Returns the current duration of the video.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Number} - returns the current video duration.
         */
        getDuration: function () {
            var duration = 0;
            if (this.videoTagRef) {
                duration = this.videoTagRef.duration;
                //check if video tag duration is Infinity (Safari) - if so, set duration to seekable end value.
                if (duration ===  Number.POSITIVE_INFINITY && this.videoTagRef.seekable !== null && this.videoTagRef.seekable.length > 0) {
                    duration = this.videoTagRef.seekable.end(0);
                }
            }
            return duration;
        },

        /**
         * Returns the current time.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Number} - returns the current time in the video.
         */
        getCurrentTime: function () {
            return (this.hasPlaybackStarted && this.videoTagRef && this.videoTagRef.currentTime) || 0;
        },

        /////////////////////
        // Live

        /**
         * Returns if the stream is playing at the live point.
         * Note: Should default to false and be extended by other facades.
         * @memberOf uvpjs.VideoPlayerFacade#
         * @return {boolean}
         */
        isPlayingLive: function () {
            return false;
        },

        /**
         * Returns if the stream in question is a LIVE stream.
         * Note: Should default to false and be extended by other facades.
         * @memberOf uvpjs.VideoPlayerFacade#
         * @return {boolean}
         */
        isHDStreamLive: function () {
            return false;
        },


        /////////////////////
        // ABR

        /**
         * Determine whether or not adaptive bitrate streaming is supported.
         * Normalized between HLS/DASH
         * Defaults to false for non advanced facades
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return Boolean
         */
        isAbrStreamingSupported: function () {
            return false;
        },

        /**
         * Determine whether or not to use dynamic switching.
         * Normalized between HLS/DASH
         * Defaults to false for non advanced facades
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @param {Boolean} useDynamic
         *
         */
        useDynamicSwitching: function (useDynamic) {
            (!this.isAbrStreamingSupported() || typeof useDynamic !== 'boolean' ) && this.debug && uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
        },

        /**
         * Switch up the ABR index.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        switchUp: function () {
            !this.isAbrStreamingSupported() && this.debug && uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
        },

        /**
         * Switch down the ABR index.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        switchDown: function () {
            !this.isAbrStreamingSupported() && this.debug && uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
        },

        /**
         * Switch to a particular ABR bitrate.
         *
         * @param {Number} bitrate - Preferred ABR Bitrate
         *
         * @memberof uvpjs.VideoPlayerFacade#
         */
        switchToBitrate: function (kbps) {
            !this.isAbrStreamingSupported() && this.debug && uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
            return -1;
        },

        /**
         * Returns the minimum Bitrate value from manifest. Returns -1 if unknown / unset.
         *
         * @param bitrate
         * @return {number}
         */
        getMinBitrate: function () {
            return -1;
        },

        /**
         * Returns a maximum ABR Bitrate value from manifest. Returns -1 if unknown / unset.
         *
         * @param bitrate
         * @return {number}
         */
        getMaxBitrate: function () {
            return -1;
        },

        /**
         * Returns the minimum Bitrate value allowed by ABR. Lower Threshold. Returns -1 if unknown / unset.
         *
         * @param bitrate
         * @return {number}
         */
        getMinBitrateAllowed: function () {
            return -1;
        },

        /**
         * Returns the maximum Bitrate value allowed by ABR. Upper Threshold. Returns -1 if unknown / unset.
         *
         * @param bitrate
         * @return {number}
         */
        getMaxBitrateAllowed: function () {
            return -1;
        },

        /**
         * Sets a minimum bitrate threshold. Returns -1 if unable to be set.
         * @param {number} kbps
         */
        setMinBitrateAllowed: function (kbps) {
            !this.isAbrStreamingSupported() && this.debug && uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
            return -1;
        },

        /**
         * Sets a maximum bitrate threshold. Returns -1 if unable to be set.
         * @param {number} kbps
         */
        setMaxBitrateAllowed: function (kbps) {
            !this.isAbrStreamingSupported() && this.debug && uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
            return -1;
        },

        /**
         * Sets a maximum bitrate threshold. Returns -1 if unable to be set.
         * @param {array} list of bitrates to check
         * @param {number} bitrate to find index for
         * @param {boolean} true for finding minBitrateAllowed.
         */
        getIndexForBitrate: function (list, bitrate, isMin) {
            /*
            * | --400--- | --800--- | --1000--- | --1500--- | --2500--- |    MIN should result in 1000
            *                     <----  900 is bitrate ------->
            * | --400--- | --800--- | --1000--- | --1500--- | --2500--- |    MAX should result in 800
            */
            var index = 0;
            var i = 0;
            var len = list.length - 1;
            if (isMin) {
                while (i < len) {
                    if (bitrate <= list[i].bitrate) {
                        index = i;
                        break;
                    }
                    i++;
                }
            } else {
                i = len;
                while (i > 0) {
                    if (bitrate >= list[i].bitrate) {
                        index = i;
                        break;
                    }
                    i--;
                }
            }
            return index;
        },

        /////////////////////
        // Video

        /**
         * Event that dispatches when the video ends.  // Resource Provider facadeDone() is the CONTENT_END dispatcher. ResourceProvider calls this.cleanUp(); on the facade.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        videoDone: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade    videoDone     uvpjs.mediaCapabilities.STOPPED   this.resourceProvider.facadeDone()   ');
            this.playbackStateChange(uvpjs.mediaCapabilities.STOPPED);
            this.resourceProvider.facadeDone(); // AD_END dispatcher or CONTENT_END dispatcher then VIDEO_DONE dispatcher. ResourceProvider calls this.cleanUp(); on the facade.
        },

        /**
         * Clears the video tag of the source and any metadata that represents a particular video.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        clearVideo: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade    clearVideo     call -> this.cleanUp();');
            this.cleanUp(); // todo review this...
        },

        /**
         * @memberof uvpjs.VideoPlayerFacade#
         * @abstract
         */
        removeEvents: function () {
            // noop;
            // VTG-79; this method is called in 'cleanup' below, but is only impl'd by subclasses.
            // If subclasses _must_ implement, consider making this an abstract method (throws error if invoked)
        },

        // VTG-79; intent to use?
        /**
         * Sets the width and the height of the html5 video element?
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @param {Number} width - width in pixels to set video to.
         * @param {Number} height - height in pixels to set video to.
         */
        setSize: function (width, height) {
            // not implemented yet.
        },

        /**
         * Returns the buffering amount of HTML5 video eleemnt.
         * @memberof uvpjs.VideoPlayerFacade#
         * @return {Object} HTML5 video element buffered object
         */
        getBuffered: function () {
            var vidEl = this.videoTagRef,
                buffered = vidEl && vidEl.buffered && vidEl.buffered.length,
                start = 0,
                end = 0,
                delta;

            if (buffered) {
                start = buffered.start && buffered.start(0);
                end = buffered.end && buffered.end(0);
            }

            delta = end - start;

            return (delta > 0 && delta) || 0;
        },

        // VTG-79; getCurrentSrc not used
        /**
         * Returns the current source for the html5 video element
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {String} HTML5 video element source URL
         */
        getCurrentSrc: function () {
            if (this.videoTagRef) {
                return this.videoTagRef.src;
            }
        },

        // VTG-79;  getError not used
        /**
         * Returns the current source for the html5 video element
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Object} HTML5 video element error object.
         */
        getError: function () {
            if (this.videoTagRef) {
                return this.videoTagRef.error;
            }
        },

        // VTG-79; getReadyState not used
        /**
         * Returns the ready state for the HTML5 video element.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {STRING} HTML5 video element ready state: see contants above.
         */
        getReadyState: function () {
            if (this.videoTagRef) {
                return this.videoTagRef.readyState;
            }
        },

        // VTG-79; getNetworkState not used
        /**
         * Returns the network state for the HTML5 video element.
         * @memberof uvpjs.VideoPlayerFacade#
         * @return {Object} HTML5 video element network state: see constants above.
         */
        getNetworkState: function () {
            if (this.videoTagRef) {
                return this.videoTagRef.networkState;
            }
        },

        /**
         * Turn HTML5 video tag native controls on/off.
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @param {boolean} onOff - turns native controls of video tag on or off.
         */
        manageNativeControls: function (onOff) {
            if (!this.videoTagRef) {
                return;
            }

            var hasControls = this.videoTagRef.hasAttribute(this.CONTROLS);

            if (onOff && !hasControls) {
                this.videoTagRef.setAttribute('controls', this.CONTROLS);
            } else if (!onOff && hasControls) {
                this.videoTagRef.removeAttribute(this.CONTROLS);
            }
        },

        /**
         * Passes playback state changes to the Resource Provider.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        playbackStateChange: function (newState) {
            if (newState !== this.playbackState) {
                this.playbackState = newState;
                this.debug && uvpjs.log(this.DEBUG_ID, 'playbackStateChange this.vidContId = ' + this.vidContId + ' newState = ' + newState);

                if (_.isEmpty(this.resourceProvider)) {
                    this.debug && uvpjs.warn(this.DEBUG_ID, 'playbackStateChange  this.resourceProvider === {}   RETURN !!!!!');// TODO remove when confident Facade cleanup is working correctly.
                    return;
                }

                this.resourceProvider.facadePlaybackStateChange(newState);
            }
        },

        /**
         * Returns the low-level media playback state.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        getPlaybackState: function () {
            return this.playbackState;
        },

        /**
         * Get playback framerate in frames per second.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Number} Frames per second..
         */
        getPlaybackFramerate: function () {
            return -1;
        },

        /**
         * Get current bandwidth.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Number}
         */
        getCurrentBandwidth: function () {
            return -1;
        },

        /**
         * Get current max bandwidth.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Number}
         */
        getCurrentMaxBandwidth: function () {
            return -1;
        },

        /**
         * Get total number of dropped frames.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Number}
         */
        getDroppedFramesCount: function () {
            return -1;
        },

        /**
         * Get average number of dropped frames per second.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {Number}
         */
        getAverageDroppedFPS: function () {
            return -1;
        },

        /**
         * Returns the low-level media playback state.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        getFacadeState: function () {
            return this.facadeState;
        },

        /**
         * Returns the stream type
         *
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @return {String} Steam type.
         */
        getStreamType: function () {
            return '';
        },

        /**
         * Gets the asset URL. Determines if CAN dyanmic variant service in use.
         * @memberof uvpjs.VideoPlayerFacade#
         */
        getAssetURL: function () {
            // First, attempt to get a CAN dynamic variant playlist.
            var assetURL = this.resourceProvider.getAltURL();

            this.usingDynamicVariantPlaylist = !_.isUndefined(assetURL);

            // If there's a manifest parsing error, or there's no altURL, grab the assetURL.
            if (this.hasManifestParsingError || !this.usingDynamicVariantPlaylist) {
                this.usingDynamicVariantPlaylist = false;
                assetURL = this.resourceProvider.getAssetURL();
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'VideoPlayerFacade getAssetURL assetURL', assetURL);

            return assetURL;
        },

    });
}(uvpjs.register('uvpjs')));



(function (obj) {

    'use strict';

    var nielsenOwnerName = 'www.nielsen.com';

    obj.VPF_Flash = uvpjs.VideoPlayerFacade.subClass({

        /**
         * @constructor uvpjs.VPF_Flash
         */
        init: function() {
            this._super();

            this.debug && uvpjs.log(this.DEBUG_ID, 'Playback will use UVP Flash.');
            this.player = null;
            this.isPaused = false;
            this.isReady = false;
            this.swfService = null;

            this.id3Options = null;

            this.initOptions = {};
            this.currFlashVideoState = {
                averageDroppedFPS: -1,
                bufferLength: -1,
                videoFramerate: -1,
                curMaxBandwidth: -1,
                isHDStreamLive: false,
                isPlayingLive: false,
                isSeekable: false
            };
            this.hasCaptions = false;
            this.hasSetStartBitrate = false;
            this.captionsUrl = null;
            this.windowLabels = {};
            this.bitrateInfo = {
                bitrates: null,
                abrInfo: null,
                min: null, // requested minimum
                max: null, // requested maximum
            };
            this.pendingSwitchMode = null;
            this.facadeType = uvpjs.mediaCapabilities.FLASH_HLS;
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         */
        initialize: function(options) {
            for (var q in options) {
                this.initOptions[q] = options[q];
            }

            //options.suppressWatermark = true;
            options.suppress360 = true;
            options.suppressCreatedEvent = true;

            this._super(options);

            this.swfService = options.swfService;
            this.player = this.swfService.getSwf();

            this.initializeCaptionStyles();
            this.addUvpFlashEventListeners();

            this.dispatchCreated();
        },

        /**
         * @override
         */
        destroy: function () {
            var q;

            for (q in this.windowLabels) {
                window[this.windowLabels[q]] = null;
            }
            this.player && this.player.stopVideo();
            this.player && this.player.clearVideo();
            this.player = null;

            this.swfService = null;

            this._super();
        },

        /**
         * @override
         */
        pauseVideo: function() {
            this.isPaused = true;
            this.player.pauseVideo();
        },

        /**
         * @override
         */
        playVideo: function() {
            if (!this.hasPlaybackStarted) {
                this.loadVideo();
            }
            else {
                this.isPaused && this.player.playVideo();
            }
            this.isPaused = false;
        },

        /**
         * @override
         */
        muteVideo: function () {
            this.player && this.player.mute();
        },

        /**
         * @override
         */
        unMuteVideo: function () {
            this.player && this.player.unMute();
        },

        /**
         * @override
         */
        getVolume: function () {
            return this.player && this.player.getVolume();
        },

        /**
         * @override
         */
        setVolume: function(val){
            this.player && this.player.setVolume(val);
        },

        /**
         * @override
         */
        seekTo: function(seconds) {
            this.player && this.player.seekTo(seconds);
        },

        /**
         * @override
         */
        seekToLive: function () {
            // uvp flash automatically seeks to live on resume from pause
        },

        /**
         * @override
         */
        hideVideo: function () {
            if (!this.player) return;
            this.player.style.visibility = 'hidden';
            this.player.mute();
        },

        /**
         * @override
         */
        showVideo: function () {
            if (!this.player) return;
            this.player.style.visibility = 'visible';
            this.player.unMute();
        },

        /**
         * @override
         */
        setFullscreenState: function (state) {
            this.swfService.resetSize();
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         *
         * @param {String} url
         */
        loadCaptions: function (url) {
            this.captionsUrl = !uvpjs.util.isEmpty(url) ? url : null;

            if (!this.captionsUrl) return;

            if (!this.deferLoadingCaptions)  {
                this.hasCaptions = true;
                this.player.loadCaptions(url);
            }
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         */
        showCaptions: function () {
            if (!this.hasCaptions && this.captionsUrl) {
                this.player.loadCaptions(this.captionsUrl);
                this.hasCaptions = true;
                this.player.showCaptions();
            }
            else {
                this.player.showCaptions();
            }
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         */
        hideCaptions: function () {
            this.player.hideCaptions();
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         *
         * @param {Array} propArr
         */
        setCaptionStyle: function(propArr) {
            var i = (Array.isArray(propArr) && propArr.length) || 0,
                u = uvpjs.util, pi, p, v,
                tx = uvpjs.VPF_Flash.styleTransform;

            while(i--) {
                pi = propArr[i];
                p = this.dashToCamel(pi.name);
                v = tx[p] ? tx[p](pi.value) : pi.value;

                !u.isEmpty(pi.value) && this.player.setStyleAttribute(p, v);
            }
        },

        /**
         *
         * @param opts
         *
         * @param opts.ownerIdList
         * @param opts.findNielsen
         * @param opts.dataCallback
         */
        setId3Options: function (opts) {
            this.id3Options = opts;
        },

        ////////////
        // metadata

        /**
         * Returns ABR info array with bitrates
         *
         * @return {Array|null}
         */
        getAbrInfo: function () {
            return this.bitrateInfo.abrInfo || null;
        },

        /**
         * @override
         */
        getStreamType: function () {
            return 'HLS';
        },

        /**
         * @override
         */
        getBuffered: function () {
            return this.currFlashVideoState.bufferLength || -1;
        },

        /**
         * @override
         */
        getAverageDroppedFPS: function () {
            return this.currFlashVideoState.averageDroppedFPS || -1;
        },

        /**
         * @override
         */
        getPlaybackFramerate: function () {
            return this.currFlashVideoState.videoFramerate || -1;
        },

        /**
         * @override
         */
        getDuration: function () {
            return this.player && this.player.getDuration();
        },

        /**
         * @override
         */
        getCurrentTime: function() {
            return this.player && this.player.getCurrentTime();
        },

        /**
         * @override
         */
        getCurrentMaxBandwidth: function () {
            return this.currFlashVideoState.curMaxBandwidth || -1;
        },

        /**
         * @override
         */
        isHDStreamLive: function () {
            return this.currFlashVideoState.isHDStreamLive || false;
        },

        /**
         * @override
         */
        isPlayingLive: function () {
            return this.currFlashVideoState.isPlayingLive || false;
        },

        /**
         * @override
         */
        getDroppedFramesCount: function () {
            return -1;
        },

        /**
         * @override
         */
        getCurrentBandwidth: function () {
            return -1;
        },

        /**
         * @override
         */
        getFacadeState: function () {
            return {
                currentBitrate: this.currFlashVideoState.sourceBitrate,
                abrInfo: this.bitrateInfo.abrInfo
            };
        },

        //////////////////////////////
        // ABR methods

        /**
         * @override
         */
        isAbrStreamingSupported: function () {
            return true;
        },

        /**
         * @override
         */
        useDynamicSwitching: function (onOff) {
            var boolStr = onOff === false ? 'false' : 'true';

            this.player.enableDynamicStreaming(boolStr);
        },

        /**
         * @override
         */
        switchToBitrate: function (bitrate) {
            var obj = this.findClosestBitrate(bitrate);

            obj.index !== -1 && this.player.switchStreamingIndex(obj.index);
        },

        /**
         * @override
         */
        setMinBitrateAllowed: function (kbps) {
            var obj = this.findClosestBitrate(kbps);

            if (obj.index !== -1) {
                this.bitrateInfo.min = obj.bitrate;
                this.player.setMinimumStreamingIndex(obj.index);
            }
        },

        /**
         * @override
         */
        setMaxBitrateAllowed: function (kbps) {
            var obj = this.findClosestBitrate(kbps);

            if (obj.index !== -1) {
                this.bitrateInfo.max = obj.bitrate;
                this.player.setMaximumStreamingIndex(obj.index);
            }
        },

        /**
         * @override
         */
        switchUp: function () {
            var curr = this.currFlashVideoState.playbackBitrate,
                obj = this.findClosestBitrate(curr),
                brlen = obj.index !== -1 && this.bitrateInfo.bitrates.length;

            if (obj.index !== -1 && obj.index < (brlen - 1)) {
                this.player.switchStreamingIndex(obj.index + 1);
            }
        },

        /**
         * @override
         */
        switchDown: function () {
            var curr = this.currFlashVideoState.playbackBitrate,
                obj = this.findClosestBitrate(curr);

            if (obj.index !== -1 && obj.index > 0) {
                this.player.switchStreamingIndex(obj.index - 1);
            }
        },

        /**
         * @override
         */
        getMinBitrateAllowed: function () {
            return this.bitrateInfo.min || -1;
        },

        /**
         * @override
         */
        getMaxBitrateAllowed: function () {
            return this.bitrateInfo.max || -1;
        },

        /**
         * @override
         */
        getMinBitrate: function () {
            return this.bitrateInfo.bitrates ? this.bitrateInfo.bitrates[0] : -1;
        },

        /**
         * @override
         */
        getMaxBitrate: function () {
            var len = this.bitrateInfo.bitrates && this.bitrateInfo.bitrates.length;
            return len ? this.bitrateInfo.bitrates[len-1] : -1;
        },

        /**
         * @override
         */
        getStartBitrate: function () {
            return this.currFlashVideoState.defaultBitrate || -1;
        },

        /**
         * @override
         */
        getCurrentBitrate: function () {
            return this.currFlashVideoState.sourceBitrate || -1;
        },

        /**
         *
         * @param br
         */
        findClosestBitrate: function(br) {
            var list = this.bitrateInfo.bitrates,
                i = list ? list.length : 0,
                d, out = {bitrate: 0, delta: Infinity, index: -1};

            while (i--) {
                d = Math.abs(br - list[i]);
                if (d < out.delta) {
                    out.bitrate = list[i];
                    out.index = i;
                    out.delta = d;
                }
            }

            return out;
        },

        ////////////////////
        // Event handling

        // Event handlers are pre-supplied with event type via partial application.
        // These methods map to unique identifiers in the global namespace (see addUvpFlashEventListeners)

        /**
         * @memberOf uvpjs.VPF_Flash#
         *
         * @param {String} type event type
         */
        hContentEvent: function(type) {
            var evt = uvpjs.VPF_Flash.uvpFlashEvent.content;

            switch(type) {
                case evt.CONTENT_START:
                    if (!this.isReady) {
                        this.isReady = true;
                        this.hasPlaybackStarted = true;
                        this.initOptions.isMuted && this.muteVideo();
                        this.resourceProvider.facadeDisplayReady();
                    }
                    break;

                case evt.CONTENT_END:

                    break;
            }
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         *
         * @param {String} type event type
         * @param {*}      payload (technically, an argument sent to callback)
         */
        hPlaybackEvent: function(type, payload) {
            var evt = uvpjs.VPF_Flash.uvpFlashEvent.playback, p;

            switch(type) {
                case evt.VIDEO_STATE_CHANGE:
                    this.isReady && this.playbackStateChange(+payload);
                    break;

                case evt.VIDEO_PROGRESS:
                    this.processCvioPayload(payload);
                    break;

                case evt.VIDEO_CUEPOINT:
                    this.id3Options && this.processCuepointPayload(payload);
                    break;

                case evt.VIDEO_ERROR:
                    this.processCvioPayload(payload);
                    this.dispatchError();

                    break;

                case evt.VIDEO_DONE:
                    this.processCvioPayload(payload);
                    // currFlashVideoState.errorInfo will be populated in above method
                    // if 'done' results from a playback error.
                    if (!uvpjs.util.isEmpty(this.currFlashVideoState.errorInfo)) {
                        this.dispatchError();
                    }
                    else {
                        this.videoDone();
                    }

                    break;

                case evt.VIDEO_TRANSITION_COMPLETE:
                    p = this.parsePayload(payload);

                    this.resourceProvider.facadeVideoTransitionComplete(p.newRate.rate, this.pendingSwitchMode);
                    this.pendingSwitchMode = null;
                    break;

                case evt.VIDEO_TRANSITION_START:
                    p = this.parsePayload(payload);

                    this.pendingSwitchMode = p.reason.toLowerCase().indexOf('manual') >= 0 ? 'manual' : 'auto';

                    this.resourceProvider.facadeVideoTransitionStart(p.newRate.rate, this.pendingSwitchMode);

                    break;
            }
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         * @private
         */
        dispatchError: function () {
            this.resourceProvider.facadeError(new uvpjs.ErrorInfo({
                eventType: uvpjs.EventType.VIDEO_PLAYBACK_ERROR,
                errorCode: uvpjs.ErrorInfo.errorCodes.FLASH_PLAYBACK_ERROR,
                message: "Error from UVP Flash: " + this.currFlashVideoState.errorInfo || null,
                isFatal: true
            }));
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         * @private
         *
         * @param {String} infoJson
         */
        processCvioPayload: function (infoJson) {
            var obj = this.parsePayload(infoJson, 'ContentVIO'),
                q, cvio;

            if (!obj) return;

            cvio = obj.ContentVIO;

            for (q in cvio) {
                this.currFlashVideoState[q] = this.getCvioValue(cvio[q]);
            }

            this.bitrateInfo.bitrates === null && cvio.currentTime > 0 && this.captureBitrateInfo();
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         *
         * @private
         */
        setStartBitrate: function() {
            var pbr;

            this.hasSetStartBitrate = true;
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         * @private
         */
        captureBitrateInfo: function() {
            var arr = [],
                abri = [],
                br = this.player.getContentBitrateInfo(),
                brspl = typeof br === 'string' && br.split(','),
                i = Array.isArray(brspl) ? brspl.length : 0;

            while (i--) {
                arr[i] = +brspl[i];
                abri[i] = {bitrate: +brspl[i]};
            }
            this.bitrateInfo.bitrates = arr;
            this.bitrateInfo.abrInfo = abri;
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         * @private
         *
         * @param {String} infoJson
         */
        processCuepointPayload: function (infoJson) {
            var obj = this.parsePayload(infoJson, 'Cuepoint'),
                iopts = this.id3Options,
                out = {pts: null};

            if (!obj || !iopts.dataCallback || (obj.text.indexOf('syncbak.cc') >= 0)) return;

            out.name = iopts.findNielsen && obj.text.indexOf(nielsenOwnerName) > -1 ? nielsenOwnerName : obj.name;
            out.data = obj.text;

            iopts.dataCallback(out);
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         * @private
         *
         * @param {*} val
         */
        getCvioValue: function (val) {
            var mt, tbool, fbool, num, v;

            if (typeof val === 'boolean' || typeof val === 'number') {
                return val;
            }

            if (typeof val === 'string') {
                mt = val === 'NaN' || val === 'null' || val === '';
                tbool = !mt && val.toLowerCase() === 'true';
                fbool = !mt && !tbool && val.toLowerCase() === 'false';
                num = !mt && !tbool && !fbool && parseInt(val);
                v = isNaN(num) ? val : num;

                return mt ? -1 : (tbool ? true : (fbool ? false : v) );
            }
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         * @private
         */
        parsePayload: function (p, name) {
            var obj = null;

            if (p.indexOf('{') === 0 || p.indexOf('[') === 0) {
                try {
                    obj = JSON.parse(p);
                }
                catch(e) {
                    this.debug && uvpjs.warn(this.DEBUG_ID, 'Unable to parse ' + name + 'as JSON; ' + e.message);

                    return null;
                }

                return obj;
            }

            return p;
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         * @private
         */
        addUvpFlashEventListeners: function() {
            var evt = uvpjs.VPF_Flash.uvpFlashEvent,
                map = {},
                getM = function(scope, n, evt) {
                    var uc = n.charAt(0).toUpperCase() + n.substr(1);
                    return scope['h' + uc + 'Event'].bind(scope, evt);
                },
                lbls, cat, q, ename, e;

            // one handler per event category: caption, playback, etc.
            for (q in evt) {
                cat = evt[q];
                for (e in cat) {
                    ename = cat[e];
                    map[ename] = getM(this, q, ename);
                }
            }

            lbls = this.windowLabels = uvpjs.UvpSwfService.setWindowMethods(map);

            for (q in lbls) {
                this.player.addEventJSCallback(q, lbls[q]);
            }
        },

        /**
         * @memberOf uvpjs.VPF_Flash#
         * @private
         */
        loadVideo: function() {
            var opts = {
                cdn: uvpjs.UvpSwfService.constant.CDN,
                fileType: 'm3u8'
            };

            this.initOptions.startTime && (opts.startTime = this.initOptions.startTime);

            this.player.loadVideoByUrl(this.assetURL, opts);
        },


        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        initializeCaptionStyles: function () {
            var s = {
                fontSize: 14,
                fontColor: "0xffff00",
                backgroundOpacity: "75",
                backgroundDisplayWidth: "auto",
                padding: "10",
                yOffset: "40"
            }, q;

            for (q in s) {
                this.player.setStyleAttribute(q, s[q]);
            }
        },


        // util
        dashToCamel: function(s) {
            return s.replace(/(-\w)/g, function(m) {
                return m[1].toUpperCase();
            });
        }
    });

    /**
     * @memberof uvbpjs.VPF_Flash
     * @static
     *
     */
    obj.VPF_Flash.uvpFlashEvent = {
        content: {
            CONTENT_END: 'onContentEnd_cbsi',
            CONTENT_START: 'onContentStart_cbsi'
        },
        playback: {
            VIDEO_CUEPOINT: 'onVideoCuePoint',
            VIDEO_DONE: 'onVideoDone',
            VIDEO_ERROR: 'onVideoError',
            VIDEO_PROGRESS: 'onVideoProgress',
            VIDEO_STATE_CHANGE: 'onStateChange_cbsi',
            VIDEO_TRANSITION_COMPLETE: 'onVideoTransitionComplete',
            VIDEO_TRANSITION_START: 'onVideoTransitionStart'
        }
    };

    obj.VPF_Flash.styleTransform = {
        _opacity: function(v) {
            return (+v) * 100;
        },
        backgroundOpacity: function(v) {
            return uvpjs.VPF_Flash.styleTransform._opacity(v);
        },
        fontOpacity: function(v) {
            return uvpjs.VPF_Flash.styleTransform._opacity(v);
        },
        fontSize: function(v) {
            var pctStr = v.substr(0, v.indexOf('%')),
                pct = (+pctStr) * 0.01;

            return Math.round(pct * 14);
        }
    }


}(uvpjs.register('uvpjs')));

/**
 * Created by brlewis on 8/27/15.
 */
'use strict';

(function (obj) {

    var _ = obj._;

    obj.VPF_HTML5 = uvpjs.VideoPlayerFacade.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.VPF_HTML5,

        /**
         * @constructor uvpjs.VPF_HTML5
         * @description An HTML5 video player facade; passes events to Resource Provider for filtering and Dispatching.
         * @extends uvpjs.VideoPlayerFacade
         */
        init: function () {
            this.debug = uvpjs.debug;
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'VPF_HTML5 Init');
            }

            // facadeType set to false if the facade is a base HTML5 video facade; true if uses MSE or other library
            this.facadeType = uvpjs.mediaCapabilities.HTML5;
            this.onStalledEvent = this.onStalledEvent.bind(this);
            this.fairplayDRM = null;
            this.startTime = null;

            this.hCueChange = this.onCueChange.bind(this);
            this.hTextTrackAdded = this.onAddTextTrack.bind(this);

            this.activeMetadataTrack = null;

            this._super();
        },

        destroy: function() {
            // VTG-499 - this destroy path is tricky.

            this.fairplayDRM && this.fairplayDRM.destroy();
            this.fairplayDRM = null;

            // Setting src to an emtpy string can cause a MEDIA_ERR_SRC_NOT_SUPPORTED error
            // Use removeAttribute instead, https://github.com/w3c/media-source/issues/53
            this.videoTagRef.removeAttribute('src');

            // For all browsers to cleaning unload the src we need to call load() here
            // https://www.w3.org/TR/html5/embedded-content-0.html#best-practices-for-authors-using-media-elements
            this.videoTagRef.load();

            this._super();

            this.activeMetadataTrack = null;
            this.hCueChange = Function.prototype;
            this.hTextTrackAdded = Function.prototype;
        },

        /**
         * @memberof uvpjs.VPF_HTML5
         *
         * @param {Object} options
         */
        initialize: function (options) {

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'VPF_HTML5 initialize resourceProvider.rco.id = ', options.resourceProvider.rco.id);
                uvpjs.log(this.DEBUG_ID, 'VPF_HTML5 initialize this.options = ', options);
            }

            this._super(options);

            if (options.drm.enabled) {
                this.fairplayDRM = new uvpjs.FairPlayDRM({
                    drm: options.drm,
                    videoTagRef: this.videoTagRef,
                    eventTypes: this.eventTypes,
                    errorCallback: this.handleFairPlayError.bind(this)
                });
            }

            //
            // NOTE: Volume and mute handled in superclass.
            //

            !uvpjs.util.isEmpty(options.startTime) && (this.startTime = Math.floor(options.startTime));
            this.addEvents();
            this.setSource();

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'VPF_HTML5  initialize  COMPLETE   this.options = ', options);
            }
        },

        /**
         * @override
         * @param {} event
         */
        handleEvent: function (event) {
            var types = this.eventTypes.HTML5;

            if (!this.videoTagRef)  return;

            this._super(event);

            // VTG-398; support a content resume time
            if (event.type === types.LOADED_METADATA && this.startTime) {
                this.videoTagRef.currentTime = this.startTime;
                this.startTime = null;
            }
        },

        /**
         * Handles errors from the FairPlayDRM class and calls facadeError
         * All errors are treated as fatal errors
         * @memberof uvpjs.VPF_HTML5
         *
         * @param {Number} errorCode Error code to use in the ErrorInfo
         * @param {String} errorMessage Error message to use in the ErrorInfo
         */
        handleFairPlayError: function(errorCode, errorMessage) {
            this.resourceProvider.facadeError(new uvpjs.ErrorInfo({
                errorCode: errorCode,
                message: errorMessage,
                isFatal: true
            }));
        },

        /**
         * Sets the source based on the type of facade this class is.
         * @memberof uvpjs.VPF_HTML5
         */
        setSource: function () {
            try {
                this.videoTagRef.src = this.assetURL;
            }
            catch(e) {
                console.log("Error caught at setSource: ", e);
            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'VPF_HTML5 setSource this.videoTagRef.src', this.videoTagRef.src);
            }
        },

        /**
         * Add HTML5 media events.
         * @memberof uvpjs.VPF_HTML5
         */
        addEvents: function () {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'VPF_HTML5 addEvents');
            }
            this._addHTML5Events();
            this.videoTagRef.addEventListener(this.eventTypes.HTML5.STALLED, this.onStalledEvent, false);
            this.videoTagRef.textTracks.addEventListener(this.eventTypes.HTML5.ADD_TRACK, this.hTextTrackAdded, false);
        },


        onAddTextTrack: function(event) {
            if (event.track && event.track.kind === 'metadata') {
                event.track.addEventListener(this.eventTypes.HTML5.CUE_CHANGE, this.hCueChange, false);
                event.track.mode = 'hidden';
                this.activeMetadataTrack = event.track;
            }
        },

        onCueChange: function(event) {
            if (event && event.target && event.target.activeCues && event.target.activeCues.length >= 1) {
                this.resourceProvider.facadeId3Data(event.target.activeCues);
            }
        },

        /**
         * Remove facade specific events.
         * @memberof uvpjs.VPF_HTML5
         */
        removeEvents: function () {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'VPF_HTML5 removeEvents');
            }
            this._removeHTML5Events();
            this.videoTagRef.removeEventListener(this.eventTypes.HTML5.STALLED, this.onStalledEvent, false);

            if (this.videoTagRef.textTracks) {
                this.videoTagRef.textTracks.removeEventListener(this.eventTypes.HTML5.ADD_TRACK, this.hTextTrackAdded, false);
            }

            if (this.activeMetadataTrack) {
                this.activeMetadataTrack.removeEventListener(this.eventTypes.HTML5.CUE_CHANGE, this.hCueChange, false);
            }
        },

        /**
         * return the facade stade data when requested. The facade state is critical data from the facade
         * data that is not also included in the Mobel and is usually low-level debugging supportive information.
         * @memberof uvpjs.VPF_HTML5
         *
         * @returns {Object} - returns the facade state object
         */
        getFacadeState: function () {
            return this.facadeState || {};
        },

        /**
         * Get stream type.
         *
         * @memberof uvpjs.VPF_HTML5#
         *
         * @returns {String} Steam type.
         */
        getStreamType: function () {
            return uvpjs.mediaCapabilities.isSafari() ? 'HLS' : 'MP4';
        },

        /**
         * Handle HTML5 STALLED event.
         * @memberof uvpjs.VPF_HTML5
         */
        onStalledEvent: function (event) {

            // trap null or empty resourceProvider
            if(_.isEmpty(this.resourceProvider) || _.isEmpty(this.resourceProvider.cviModel)) {
                if (this.debug) {
                    uvpjs.log(this.DEBUG_ID, 'VPF_HTML5 onStalledEvent event,(_.isEmpty(this.resourceProvider) || _.isEmpty(this.resourceProvider.cviModel) RETURN event = ', event);
                }
                return;
            }

            var hasPlaybackStarted = this.resourceProvider.cviModel.contentPlaybackState.playbackStarted;

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'VPF_HTML5 onStalledEvent event, hasPlaybackStarted', event, hasPlaybackStarted);
            }
        },
    });
}(uvpjs.register('uvpjs')));

/**
 * Notes: HLS.JS API Information can be found at:
 * https://github.com/video-dev/hls.js/blob/master/docs/API.md
 *
 * GitHub Project
 * https://github.com/video-dev/hls.js/
 */

'use strict';

(function (obj) {

    obj.VPF_HLSJS = uvpjs.VideoPlayerFacade.subClass({

        debug: uvpjs.Configuration.env !== 'production',

        DEBUG_ID: uvpjs.DebugManager.configParams.VPF_HLSJS,
        LIB_DEBUG_ID: uvpjs.DebugManager.configParams.HLSJS_LIB,
        LEVEL_DEBUG_ID: uvpjs.DebugManager.configParams.HLSJS_LEVEL,
        FRAG_DEBUG_ID: uvpjs.DebugManager.configParams.HLSJS_FRAG,
        FRAME_DROP_DEBUG_ID: uvpjs.DebugManager.configParams.HLSJS_FRAME_DROP,

        LIVE_POINT_GRACE_SECONDS: 11,

        /**
         * @constructor uvpjs.VPF_HLSJS
         * @extends uvpjs.VideoPlayerFacade
         */
        init: function () {
            this.debug = uvpjs.debug;
            this._super();

            uvpjs.log(this.DEBUG_ID, "HLS.js version: " + Hls.version);

            this._currentBandwidth = null;
            this._currentMaxBandwidth = null;
            this._playbackFramerate = null;
            this._isLiveStreamKnown = false;
            this._isHdStreamLive = false;
            this._isPlayingLive = false;
            this.id3HandlingEnabled = false;
            this.mc = uvpjs.mediaCapabilities;
            this.facadeType = this.mc.HLSJS;
            this.withCredentials = false;
            this.startTime = -1;
            this.maxBitrate = -1;
            this.minBitrate = -1;
            this.startBitrate = -1;
            // this.useDynamicSwitchingAtStart = true;
            this.bitrateList = null;

            // VTG-396: Note - The 'loader' property of Hlsjs config can NOT be NULL or UNDEFINED
            // when supplied to the Hlsjs constructor. Hlsjs won't fall back to its default XXHR-based loader.
            // Playback will fail due to an internal Hlsjs exception.
            this.libConfig = {
                debug: uvpjs.DebugManager.isParamEnabled(this.LIB_DEBUG_ID),
                enableWorker: true,
                autoStartLoad: false,
                enableCEA708Captions: true,
                initialLiveManifestSize: 1,
                liveSyncDurationCount: 3,
                capLevelToPlayerSize: false,
                xhrSetup: (function (xhr, url) {

                    // Only set `withCredentials` for Akamai Streampack (CSMIL) requests. Setting
                    // `withCredentials` forces the browser to send the `hdntl` Akamai cookie.
                    //
                    // NOTE: This setting must persist the life of the video and subsequent requests.
                    this.withCredentials = this.withCredentials || (url.indexOf('akamaihd') > -1 && url.indexOf('csmil') > -1);

                    if (this.debug && this.withCredentials) {
                        // Moving to FRAG DEBUG because this fires per segment request.
                        uvpjs.log(this.FRAG_DEBUG_ID, 'init xhrSetup withCredentials', this.withCredentials);
                    }

                    // Do send cookies for HTTPS urls.
                    xhr.withCredentials = this.withCredentials;

                    // If a non-segment request then register another callback to report if the encoding is complete.
                    // NOTE: There are many ways to check this. String.indexOf for presence/absence of the HLS
                    // End List Tag (EXT-X-ENDLIST) is by far the fastest. Especially considering object iteration of
                    // the loaded tags can get progressively worse in longer live streams (thus larger manifests).
                    if (url.indexOf('.m3u8') !== -1) {
                        xhr.addEventListener('readystatechange', (function () { //TODO Check if this is needed anymore there
                            if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
                                // This basically says 'if i am a playlist manifest and have no end tag' than I am live.
                                this._isHdStreamLive = (xhr.responseText.indexOf('STREAM-INF') === -1) && (xhr.responseText.indexOf('EXT-X-ENDLIST') === -1);
                                // Single check once a live stream detected to set is Playing Live true on start up
                                // User action wrt seeking will set value moving forward
                                if(!this._isLiveStreamKnown && this._isHdStreamLive) {
                                    this._isPlayingLive = true;
                                    this._isLiveStreamKnown = true;
                                }
                            }
                        }).bind(this));
                    }

                }).bind(this)
            };

            this.onLibraryEvent = this.onLibraryEvent.bind(this);
            this.onLevelEvent = this.onLevelEvent.bind(this);
            this.onFragmentEvent = this.onFragmentEvent.bind(this);
            this.onID3Event = this.onID3Event.bind(this);
            this.onError = this.onError.bind(this);
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         */
        destroy: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'destroy');

            this.player.destroy();
            this._super();

            this._currentBandwidth = null;
            this._currentMaxBandwidth = null;
            this._playbackFramerate = null;
            this.bitrateList = null;
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         *
         * @param {Object} options
         */
        initialize: function (options) {

            this._super(options);
            this.id3HandlingEnabled = options.enableId3Handling;


            // HLS Player Creation Config.
            // edge of live delay, expressed in multiple of EXT-X-TARGETDURATION. if set to 3, playback will start from fragment N-3,
            // N being the last fragment of the live playlist. decreasing this value is likely to cause playback stalls.
            // HLS Specification default: 3
            typeof options.liveSyncDurationCount === 'number' && options.liveSyncDurationCount > 0 && (this.libConfig.liveSyncDurationCount = options.liveSyncDurationCount);
            // if set to true, the adaptive algorithm with limit levels usable in auto-quality by the HTML video element dimensions (width and height).
            // If dimensions between multiple levels are equal, the cap is chosen as the level with the greatest bandwidth.
            options.capLevelToPlayerSize === true && (this.libConfig.capLevelToPlayerSize = options.capLevelToPlayerSize);

            if (!uvpjs.util.isEmpty(options.hlsjsLoader)) {
                // only set 'loader' if one has been supplied
                this.debug && uvpjs.log(this.DEBUG_ID, "Hlsjs using custom loader.");
                this.libConfig.loader = options.hlsjsLoader;
            }

            // Create
            this.player = new Hls(this.libConfig);
            this.addEvents();

            // NOTE: Options must be stored locally until manifest is parsed so we can use bitratelist to set properties.
            typeof options.startBitrate === 'number' && options.startBitrate > -1 && (this.startBitrate = options.startBitrate);
            typeof options.maxBitrate === 'number' && options.maxBitrate > -1 && (this.maxBitrate = options.maxBitrate);
            typeof options.minBitrate === 'number' && options.minBitrate > - 1 && (this.minBitrate = options.minBitrate);
            //typeof options.useDynamicSwitching === 'boolean' && (this.useDynamicSwitchingAtStart = options.useDynamicSwitching)
            options.startTime && (this.startTime = Math.round(options.startTime)); // 1/11/17 decimal values crash HLSJS, so round to integer.
            this.resourceProvider.rco.withCredentials && (this.withCredentials = this.resourceProvider.rco.withCredentials);

            this.player.loadSource(this.assetURL);
            this.player.attachMedia(this.videoTagRef);
        },

        /**
         * @inheritDoc
         */
        seekToLive: function () {
            var player = this.player;
            var liveSyncPosition = this.player.liveSyncPosition;
            var isHDStreamLive = this.isHDStreamLive();

            if (isHDStreamLive && player && liveSyncPosition) {
                this.seekTo(liveSyncPosition);
            }
            else {
                uvpjs.warn(this.DEBUG_ID, 'Unable to seekToLive - isHDStreamLive? ' + isHDStreamLive);
            }
        },

        seekTo: function(position) {
            var player = this.player;
            var liveSyncPosition = this.player.liveSyncPosition;
            var isHDStreamLive = this.isHDStreamLive();
            // Determin is playing live
            this._isPlayingLive = (player && isHDStreamLive && liveSyncPosition && position === liveSyncPosition);
            // Seek via superclass
            this._super(position);
        },

        /**
         * @inheritdoc
         */
        isAbrStreamingSupported: function () {
            return this.bitrateList ? this.bitrateList.length > 0 : this._super();
        },

        /**
         * @inheritdoc
         *
         */
        useDynamicSwitching: function (useDynamic) {
            this._super();
            if (this.player) {
                this.player.nextLevel = useDynamic ? -1 : this.player.currentLevel;
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.FACADE_MUST_BE_INITIALIZED);
            }
        },

        /**
         * @inheritdoc
         * @memberof @memberof uvpjs.VPF_HLSJS#
         */
        switchUp: function () {
            if (this.player) {
                this.switchToIndex(this.player.nextLoadLevel + 1);
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.FACADE_MUST_BE_INITIALIZED);
            }
        },

        /**
         * @inheritdoc
         * @memberof @memberof uvpjs.VPF_HLSJS#
         */
        switchDown: function () {
            if (this.player) {
                this.switchToIndex(this.player.nextLoadLevel - 1);
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.FACADE_MUST_BE_INITIALIZED);
            }
        },

        /**
         * @inheritdoc
         * @memberof @memberof uvpjs.VPF_HLSJS#
         */
        switchToBitrate: function (bitrate) {
            this.switchToIndex(this.getIndexForBitrate(this.bitrateList, bitrate, false));
        },

        /**
         * intenal
         * @memberof @memberof uvpjs.VPF_HLSJS#
         */
        switchToIndex: function (index) {
            if (this.isAbrStreamingSupported()) {
                //clear min and max (only if no capping)
                this.getMinBitrateAllowed() > 0 && this.setMinBitrateAllowed(0);
                !this.player.config.capLevelToPlayerSize && this.getMaxBitrateAllowed() > 0 && this.setMaxBitrateAllowed(-1);
                //Never ignore Player Size Capping in Manual mode!
                var cappedIndex = this.player.autoLevelCapping !== -1 ? this.getIndexForBitrate(this.bitrateList, this.getMaxBitrateAllowed(), false) : NaN;
                var maxIndex = !isNaN(cappedIndex) ? cappedIndex : this.bitrateList.length - 1;
                if (index >= 0 && index <= maxIndex) {
                    this.player.nextLevel = index;
                } else {
                    uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_INDEX_OUT_OF_RANGE, 'Range=', 0, "-", maxIndex, ' : Index=', index);
                }

            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
            }
        },

        /**
         * Gets the starting bitrate.
         * Note: This is not necessarily the value requested. This is the reported bitrate
         * from the manifest which is closest to the original value requested.
         *
         * @memberof @memberof uvpjs.VPF_HLSJS#
         * @return Integer - -1 if unknown / not originally set
         */
        getStartBitrate: function () { //TODO check for correct logic with new changes.
            var player = this.player;
            return this.startBitrate || this.minBitrate || (player && player.levels && player.levels[0] && player.levels[0].bitrate) || -1;
        },

        /**
         * @memberof @memberof uvpjs.VPF_HLSJS#
         */
        setStartBitrate: function (bitrate) {
            if (this.player) {
                if (bitrate < this.getMinBitrateAllowed()) {
                    bitrate = this.getMinBitrateAllowed();
                    this.debug && uvpjs.warn(this.DEBUG_ID, this.WARNINGS.STARTING_BITRATE_BELOW_MIN_ALLOWED);
                }
                this.player.config.startLevel = this.getIndexForBitrate(this.bitrateList, bitrate, false);
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.FACADE_MUST_BE_INITIALIZED);
            }
        },

        /**
         * @inheritdoc
         * @return Integer - -1 if unknown
         */
        getMinBitrateAllowed: function () {
            if (this.player) {
                var level = this.player.minAutoLevel;
                return this.bitrateList ? this.bitrateList[level].bitrate : this._super();
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.FACADE_MUST_BE_INITIALIZED);
                return this._super();
            }
        },

        /**
         * @inheritDoc
         * @memberof uvpjs.VPF_HLSJS#
         */
        setMinBitrateAllowed: function (bitrate) {
            if (this.player) {
                this.player.config.minAutoBitrate = bitrate - 1; //We are subtracting  -1 here due to Bug in HLS.js should be >= but is >....
                var index = this.getIndexForBitrate(this.bitrateList, bitrate, true); //enforce rule if current level is lower then new min set.
                if (this.player.currentLevel < index) {
                    this.player.nextAutoLevel = index;
                }
                uvpjs.warn(this.DEBUG_ID, 'setMinBitrateAllowed', bitrate);
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.FACADE_MUST_BE_INITIALIZED);
            }
        },

        /**
         * @inheritdoc
         * @return Integer - -1 if unknown
         */
        getMaxBitrateAllowed: function () {
            if (this.player) {
                var level = this.player.maxAutoLevel;
                return level !== undefined ? this.bitrateList[level].bitrate : this._super();
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.FACADE_MUST_BE_INITIALIZED);
                return this._super();
            }
        },

        /**
         * @inheritDoc
         * @memberof uvpjs.VPF_HLSJS#
         */
        setMaxBitrateAllowed: function (bitrate) {
            if (this.player) {
                this.player.autoLevelCapping = bitrate === -1 ? bitrate : this.getIndexForBitrate(this.bitrateList, bitrate, false); // -1 turns off capping for MAX.
                uvpjs.warn(this.DEBUG_ID, 'setMaxBitrateAllowed', bitrate);
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.FACADE_MUST_BE_INITIALIZED);
                return this._super();
            }
        },

        /**
         * @inheritdoc
         * @memberof uvpjs.VPF_HLSJS#
         */
        getMinBitrate: function () {
            if (this.isAbrStreamingSupported()) {
                return this.bitrateList[0].bitrate;
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
                return this._super();
            }
        },

        /**
         * @inheritdoc
         * @memberof uvpjs.VPF_HLSJS#
         */
        getMaxBitrate: function () {
            if (this.isAbrStreamingSupported()) {
                return this.bitrateList[this.bitrateList.length - 1].bitrate;
            } else {
                uvpjs.warn(this.DEBUG_ID, this.WARNINGS.ABR_NOT_SUPPORTED);
                return this._super();
            }
        },

        /**
         * Gets the current bitrate.
         * Note: This is the manifest value of the bitrate associated with the current rendition.
         *
         * @return Integer - -1 if unknown
         * @memberof @memberof uvpjs.VPF_HLSJS#
         */
        getCurrentBitrate: function () {
            var bitrate = -1;
            if (this.bitrateList && this.bitrateList[this.player.currentLevel]) {
                bitrate = this.bitrateList[this.player.currentLevel].bitrate;
            }
            return bitrate;
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         * @return {Number}
         */
        getPlaybackFramerate: function () {
            return this._playbackFramerate || 0;
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         *
         * @return {Number}
         */
        getCurrentBandwidth: function () {
            return this._currentBandwidth || 0;
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         *
         * @return {Number}
         */
        getCurrentMaxBandwidth: function () {
            return this._currentMaxBandwidth || 0;
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         *
         * @return {Number}
         */
        getDroppedFramesCount: function () {
            var player = this.player, v, vq, df;

            if (!player) {
                return;
            }

            v = this.player.media;
            vq = v.getVideoPlaybackQuality;

            if (vq && typeof vq === 'function') {
                return vq.call(v).droppedVideoFrames;
            }

            df = v.webkitDroppedFrameCount;

            if (df) {
                return df;
            }

            return 0;
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         *
         * @return {Number}
         */
        getAverageDroppedFPS: function () {
            return this.getDroppedFramesCount() / this.getDuration();
        },

        getCappedAbrInfo: function () {
            var maxIndex = this.getIndexForBitrate(this.bitrateList, this.getMaxBitrateAllowed(), false) + 1;
            var minIndex = this.getIndexForBitrate(this.bitrateList, this.getMinBitrateAllowed(), true);
            return this.bitrateList.slice(minIndex, maxIndex);
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         *
         * @return {Object}
         */
        getFacadeState: function () {
            var fs = {
                startBitrate: -1,
                currentBitrate: -1,
                minBitrate: -1,
                maxBitrate: -1,
                droppedFrames: this.getDroppedFramesCount(),
                droppedFPS: this.getAverageDroppedFPS(),
                playbackFramerate: this.getPlaybackFramerate(),
                abrInfo: [],
                currentAbr: {
                    bitrate: 0,
                    // TODO: Remove after 1.7.1 hotpatch (12/21/16).
                    levelId: {},
                    info: {},
                    detail: {},
                    stats: {},
                    updated: false,
                }
            };

            if (this.player && this.bitrateList) {
                fs.player = this.player;
                fs.abrInfo = this.bitrateList
                fs.currentAbr =  this.bitrateList[this.player.currentLevel];
                fs.cappedAbrInfo = this.getCappedAbrInfo();
                fs.startBitrate = this.getStartBitrate();
                fs.currentBitrate = this.getCurrentBitrate();
                fs.minBitrate = this.getMinBitrateAllowed();
                fs.maxBitrate = this.getMaxBitrateAllowed();
            }

            return fs;
        },

        /**
         * Get stream type.
         *
         * @memberof uvpjs.VPF_HLSJS#
         *
         * @return {String} Steam type.
         */
        getStreamType: function () {
            return 'HLS';
        },

        /**
         * Sugar for 'is this the live point of a live stream'
         * This has been refactored to a boolean condition.
         * ** Starts true if a live stream initially detected.
         * ** Turns false when a user seeks to the not live sync position.
         * ** Returns to true when a user uses this.seekToLive.
         * @extends uvpjs.VideoPlayerFacade
         *
         * @return {boolean} isPlayingLive;
         */
        isPlayingLive: function () {
            return this._isPlayingLive;
        },

        /**
         * @extends uvpjs.VideoPlayerFacade
         */
        isHDStreamLive: function () {
            return this._isHdStreamLive;
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         */
        addEvents: function () {
            this._addHTML5Events();

            var hlsEvts = Hls.Events,
                hLibEvt = this.onLibraryEvent,
                hLvlEvt = this.onLevelEvent,
                hFrgEvt = this.onFragmentEvent;

            // Lib
            this.player.on(hlsEvts.MEDIA_ATTACHING, hLibEvt, false);
            this.player.on(hlsEvts.MEDIA_ATTACHED, hLibEvt, false);
            this.player.on(hlsEvts.MEDIA_DETACHING, hLibEvt, false);
            this.player.on(hlsEvts.MANIFEST_PARSED, hLibEvt, false);
            this.player.on(hlsEvts.MANIFEST_LOADED, hLibEvt, false);
            this.player.on(hlsEvts.MANIFEST_LOADING, hLibEvt, false);
            this.player.on(hlsEvts.FPS_DROP, hLibEvt, false);
            // Level
            this.player.on(hlsEvts.LEVEL_SWITCHING, hLvlEvt, false);
            this.player.on(hlsEvts.LEVEL_SWITCHED, hLvlEvt, false);
            this.player.on(hlsEvts.LEVEL_LOADING, hLvlEvt, false);
            this.player.on(hlsEvts.LEVEL_LOADED, hLvlEvt, false);
            this.player.on(hlsEvts.LEVEL_UPDATED, hLvlEvt, false);
            this.player.on(hlsEvts.LEVEL_PTS_UPDATED, hLvlEvt, false);
            // Frag
            this.player.on(hlsEvts.FRAG_LOADING, hFrgEvt, false);
            this.player.on(hlsEvts.FRAG_LOAD_PROGRESS, hFrgEvt, false);
            this.player.on(hlsEvts.FRAG_LOADED, hFrgEvt, false);
            this.player.on(hlsEvts.FRAG_PARSED, hFrgEvt, false);
            this.player.on(hlsEvts.FRAG_BUFFERED, hFrgEvt, false);
            this.player.on(hlsEvts.FRAG_CHANGED, hFrgEvt, false);
            this.player.on(hlsEvts.FRAG_PARSING_DATA, hFrgEvt, false);
            // handling ID3 metadata is expensive; only do so if requested
            this.id3HandlingEnabled && this.player.on(hlsEvts.FRAG_PARSING_METADATA, this.onID3Event, false);
            // Error
            this.player.on(hlsEvts.ERROR, this.onError, false);
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         */
        removeEvents: function () {
            this._removeHTML5Events();

            var hlsEvts = Hls.Events,
                hLibEvt = this.onLibraryEvent,
                hLvlEvt = this.onLevelEvent,
                hFrgEvt = this.onFragmentEvent;

            // Lib
            this.player.off(hlsEvts.MEDIA_ATTACHING, hLibEvt);
            this.player.off(hlsEvts.MEDIA_ATTACHED, hLibEvt);
            this.player.off(hlsEvts.MEDIA_DETACHING, hLibEvt);
            this.player.off(hlsEvts.MANIFEST_PARSED, hLibEvt);
            this.player.off(hlsEvts.MANIFEST_LOADED, hLibEvt);
            this.player.off(hlsEvts.MANIFEST_LOADING, hLibEvt);
            this.player.off(hlsEvts.FPS_DROP, hLibEvt);
            // Level
            this.player.off(hlsEvts.LEVEL_SWITCHING, hLvlEvt);
            this.player.off(hlsEvts.LEVEL_SWITCHED, hLvlEvt);
            this.player.off(hlsEvts.LEVEL_LOADING, hLvlEvt);
            this.player.off(hlsEvts.LEVEL_LOADED, hLvlEvt);
            this.player.off(hlsEvts.LEVEL_UPDATED, hLvlEvt);
            this.player.off(hlsEvts.LEVEL_PTS_UPDATED, hLvlEvt);
            // Frag
            this.player.off(hlsEvts.FRAG_LOADING, hFrgEvt);
            this.player.off(hlsEvts.FRAG_LOAD_PROGRESS, hFrgEvt);
            this.player.off(hlsEvts.FRAG_LOADED, hFrgEvt);
            this.player.off(hlsEvts.FRAG_PARSED, hFrgEvt);
            this.player.off(hlsEvts.FRAG_BUFFERED, hFrgEvt);
            this.player.off(hlsEvts.FRAG_CHANGED, hFrgEvt);
            this.player.off(hlsEvts.FRAG_PARSING_DATA, hFrgEvt);
            this.id3HandlingEnabled && this.player.off(hlsEvts.FRAG_PARSING_METADATA, this.onID3Event);
            // Error
            this.player.off(hlsEvts.ERROR, this.onError);
        },

        /**
         * Handles data available after manifest is parsed
         * @param data
         */
        handleManifestData: function (data) {
            this.bitrateList = this.player.levels;

            var lvls = data.levels,
                i = lvls.length,
                infoArr = [], lvl;

            while (i--) {
                lvl = lvls[i];
                infoArr.unshift({
                    name: lvl.name || null,
                    rate: lvl.bitrate,
                    width: lvl.width,
                    height: lvl.height
                });
            }
            //TODo HLS.js will return info sorted in levels call... mapping value is fine but do we need to sort?
            // ensure sorted lowest-highest bitrate
            infoArr.sort(function (a, b) {
                var ar = a.rate, br = b.rate;
                return ar < br ? -1 : (ar > br ? 1 : 0);
            });
            //console.log("xxx" , infoArr, this.bitrateList);
            this.resourceProvider.facadeMetadataParsed({
                abrInfo: infoArr
            });

        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         * @private
         *
         * @param {Object} event
         * @param {Object} data
         */
        onLibraryEvent: function (event, data) {
            if (this.debug) {
                uvpjs.log(this.LIB_DEBUG_ID, event, data);
            }

            var hlsEvts = Hls.Events;

            switch (event) {
                case hlsEvts.MEDIA_ATTACHING:
                case hlsEvts.MEDIA_ATTACHED:
                case hlsEvts.MEDIA_DETACHING:
                case hlsEvts.MANIFEST_LOADING:
                    break;

                case hlsEvts.MANIFEST_PARSED:
                    this.handleManifestData(data);
                    break;

                // TODO: Haven't seen this event triggered.
                case hlsEvts.FPS_DROP:
                    // uvpjs.log(this.LIB_DEBUG_ID, event, data.totalDroppedFrames);
                    break;

                case hlsEvts.MANIFEST_LOADED:
                    // Set Max to value.. need to wait until manifest loaded so we can have access to bitrate list.
                    if (this.maxBitrate > -1) {
                        this.setMaxBitrateAllowed(this.maxBitrate);
                        this.resourceProvider.facadeMaximumBitrateAllowedChanged(this.maxBitrate);
                    }
                    // Set Max to value.. need to wait until manifest loaded so we can have access to bitrate list.
                    if (this.minBitrate > -1) {
                        this.setMinBitrateAllowed(this.minBitrate);
                        this.resourceProvider.facadeMinimumBitrateAllowedChanged(this.minBitrate);
                    }
                    // Set Start to value hls.js internally honors min valueif start is less
                    if (this.startBitrate > -1) {
                        this.setStartBitrate(this.startBitrate);
                    }
                    if (!this.player.autoStartLoad) {
                        this.player.startLoad(this.startTime);
                    }

                    //TODO fix HLS.js does not catch this in time race.  Works in LEVLEUPDATED but do not like it here. Does not work in uvpjs as of v2.8.2
                    // if (!this.useDynamicSwitchingAtStart) {
                    //     this.useDynamicSwitching(false);
                    // }

                break;

                default:
                    break;
            }
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         * @private
         *
         * @param {Object} event
         * @param {Object} data
         */
        onLevelEvent: function (event, data) {
            this.debug && uvpjs.log(this.LEVEL_DEBUG_ID, event, data);
            var hlsEvts = Hls.Events;

            switch (event) {
                case hlsEvts.LEVEL_LOADED:
                    this.resourceProvider.facadeVideoLevelLoaded(data.details);
                    break;

                case hlsEvts.LEVEL_LOADING:
                case hlsEvts.LEVEL_UPDATED:
                case hlsEvts.LEVEL_PTS_UPDATED:
                    break;

                case hlsEvts.LEVEL_SWITCHING:
                    this.resourceProvider.facadeVideoTransitionStart(this.bitrateList[data.level].bitrate);
                    break;

                case hlsEvts.LEVEL_SWITCHED:
                    this.resourceProvider.facadeVideoTransitionComplete(this.bitrateList[data.level].bitrate);
                    break;

                default:
                    break;
            }
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         * @private
         *
         * @param {Object} event
         * @param {Object} data
         */
        onFragmentEvent: function (event, data) {
            var hlsEvts = Hls.Events,
                bw, st;

            // this.debug && uvpjs.log(this.FRAG_DEBUG_ID, event, data.dropped, dropped);

            switch (event) {
                case hlsEvts.FRAG_LOAD_PROGRESS:
                    break;

                case hlsEvts.FRAG_PARSING_DATA:
                    if (data.type === 'video') {
                        this._playbackFramerate = data.nb / (data.endPTS - data.startPTS);
                    }
                    break;

                case hlsEvts.FRAG_LOADED:
                    st = data.stats;
                    bw = (st.loaded * 8000) / Number(window.performance.now() - st.trequest);
                    this._currentBandwidth = bw;
                    this._currentMaxBandwidth = Math.max(bw, this._currentMaxBandwidth);
                    break;

                case hlsEvts.FRAG_CHANGED:
                    break;

                default:
                    break;
            }
        },

        /**
         * Handler for hlsjs FRAG_PARSING_METADATA event (ID3 data event).
         * @memberof uvpjs.VPF_HLSJS#
         * @private
         *
         * @param {String} eventType
         * @param {Object} data
         */
        onID3Event: function (eventType, data) {
            this.resourceProvider.facadeId3Data(data.samples);
        },

        /**
         * @memberof uvpjs.VPF_HLSJS#
         * @private
         *
         * @param {Object} event
         * @param {Object} data
         */
        onError: function (event, data) {
            var ei = uvpjs.ErrorInfo,
                ed = Hls.ErrorDetails,
                et = Hls.ErrorTypes,
                details = data.details || 'Details N/A.',
                fatal = data.fatal,
                type = data.type,
                recoverable = false,
                overrideErrs = [
                    ed.MANIFEST_LOAD_ERROR,
                    ed.MANIFEST_PARSING_ERROR
                ];

            this.debug && uvpjs.error(this.LEVEL_DEBUG_ID, event, type, details, fatal);

            // Fatal error.
            if (fatal) {

                switch (type) {
                    case et.NETWORK_ERROR:
                        // Recover if not an override asset url issue.
                        if (overrideErrs.indexOf(details) === -1) {
                            recoverable = true;
                            this.player.startLoad(this.startTime);
                        }
                        break;

                    case et.MEDIA_ERROR:
                        // *should not* recover - can cause issues when performing a seek
                        break;

                    default:
                        // cannot recover
                        break;
                }

            }
            // Special case when exception is raised during buffer appending.
            // Firefox corner case for older MP4s delivered via Streampack.
            else if (details === ed.BUFFER_APPENDING_ERROR) {

                if (this.mc.isFirefox() && (parseInt(this.mc.getBrowserMajorVersion()) < 49)) {
                    this.debug && uvpjs.log(this.DEBUG_ID, 'Handling Firefox buffer appending error.');

                    recoverable = true;
                    this.player.recoverMediaError();

                    setTimeout(function () {
                        this.player.startLoad();
                        this.player.media.play();
                    }.bind(this), 100);
                }

            }


            if (recoverable) {
                return;
            }

            this.resourceProvider.facadeError(this._getErrorInfoForType(type, details, fatal));
        },

        /**
         * Builds an ErrorInfo object for a particular hls.js error type
         * @memberof uvpjs.VPF_HLSJS#
         * @private
         *
         * @param {String} type hls.js error type
         * @param {String} details error details/description
         * @param {Boolean} fatal indicates if the error is fatal
         * @returns {uvpjs.ErrorInfo} ErrorInfo object for current error state
         */
        _getErrorInfoForType: function(type, details, fatal) {
            var ei = uvpjs.ErrorInfo,
                et = Hls.ErrorTypes,
                ec = uvpjs.ErrorInfo.errorCodes;
            switch(type) {
                case et.NETWORK_ERROR:
                    return new ei({
                        errorCode: ec.HLSJS_PLAYBACK_ERROR,
                        hlsjsErrorCode: ec.HLSJS_NETWORK_ERROR,
                        message: ei.messages.HLSJS_NETWORK_ERROR.replace('{INFO}', details),
                        isFatal: fatal
                    });
                case et.MEDIA_ERROR:
                    return new ei({
                        errorCode: ec.HLSJS_PLAYBACK_ERROR,
                        hlsjsErrorCode: ec.HLSJS_MEDIA_ERROR,
                        message: ei.messages.HLSJS_MEDIA_ERROR.replace('{INFO}', details),
                        isFatal: fatal
                    });
                case et.MUX_ERROR:
                    return new ei({
                        errorCode: ec.HLSJS_PLAYBACK_ERROR,
                        hlsjsErrorCode: ec.HLSJS_MUX_ERROR,
                        message: ei.messages.HLSJS_MUX_ERROR.replace('{INFO}', details),
                        isFatal: fatal
                    });
                case et.OTHER_ERROR:
                    return new ei({
                        errorCode: ec.HLSJS_PLAYBACK_ERROR,
                        hlsjsErrorCode: ec.HLSJS_OTHER_ERROR,
                        message: ei.messages.HLSJS_OTHER_ERROR.replace('{INFO}', details),
                        isFatal: fatal
                    });
            }
        },
    });

}(uvpjs.register('uvpjs')));

(function (obj) {
    'use strict';

    obj.Diagnostic = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.VIDEO_PLAYER_FACADE,

        PREFIX:   'diagnostic_',

        /**
         * Constructor function.
         *
         * @param {Object}               options
         * @param {uvpjs.EventsManager}  options.eventsMgr    Instance of EventsManager.
         * @param {HTMLElement}          options.containerEl  Main outer container element.
         * @param {HTMLElement}          options.videoEl      Video element.
         *
         * @constructor uvpjs.Diagnostic
         * @extends uvpjs
         */
        init: function (options) {
            var cfg = uvpjs.Configuration,
                videoEl;

            this.debug = uvpjs.debug;

            this.debug && uvpjs.log(this.DEBUG_ID, 'Diagnostic: Create diagnostic window.');

            if (!options) {
                return;
            }

            videoEl = options.videoEl;

            this._videoEl = videoEl;
            this._containerEl = options.containerEl;
            this._eventsMgr = options.eventsMgr;

            this._containerId = this._containerEl.id;
            this._diagnosticId = this.PREFIX + this._containerId;
            this._contentEl = videoEl.parentNode;
            this._namespace = '.' + this._containerId + '.' + 'diagnostic';

            this._menuEl = null;
            this._diagEl = null;
            this._styleEl = null;
            this._diagTableEl = null;

            this._showDiagBtn = null;
            this._hideDiagBtn = null;

            // NOTE: Controls the display order in the panel.
            this._params = {
                'player version': cfg.version,
                'stream type': null,
                'playback state': null,

                'duration': null,
                'current time': null,
                'buffer length': null,

                'total dropped frames': null,
                'average dropped (fps)': null,
                'playback framerate (fps)': null,

                'switching mode': null,
                'available indexes': null,
                'transition state': null,

                'start index bitrate (B/s)': null,
                'current index bitrate (B/s)': null,
                'current bandwidth (B/s)': null,
            };

            uvpjs.util.createStyleSheet(this._finalize.bind(this));
        },

        /**
         * Destroy instance
         *
         * @memberof uvpjs.Diagnostics
         */
        destroy: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'Diagnostic: Removing diagnostic window.');

            if (!this._diagEl || !this._contentEl) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Diagnostic: unable to remove window.');
                return;
            }

            this._removeEventListeners();
            this._removeDiag();

            this._eventsMgr = null;
            this._containerEl = null;
            this._diagnosticId = null;
            this._contentEl = null;
            this._videoEl = null;
            this._diagEl = null;
            this._menuEl = null;
            this._styleEl = null;
            this._diagTableEl = null;
            this._showDiagBtn = null;
            this._hideDiagBtn = null;
            this._namespace = null;
            this._params = null;
        },

        /**
         * Hide window.
         *
         * @memberof uvpjs.Diagnostic#
         */
        show: function () {
            this._showDiag();
        },

        /**
         * Show window.
         *
         * @memberof uvpjs.Diagnostic#
         */
        hide: function () {
            this._hideDiag();
        },

        //////////////////
        // Private

        /**
         * Finalize after stylesheet added.
         *
         * @param {HTMLElement} styleEl <style> element.
         *
         * @memberof uvpjs.CaptionsManager#
         *
         * @private
         */
        _finalize: function (styleEl) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'Diagnostic: _finalize');
            this._styleEl = styleEl;
            this._createDiag();
            this._addEventListeners();
        },

        /**
         * Creates diagnostic window.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _createDiag: function () {
            var u = uvpjs.util,
                styleEl = this._styleEl,
                contentEl = this._contentEl,
                tmpl = this._template,
                params = this._params,
                key, value, diagEl, diagTblEl, hideBtn;

            if (!contentEl) {
                return;
            }

            diagEl = document.createElement('div');
            diagEl.id = this._diagnosticId;
            contentEl.insertBefore(diagEl, contentEl.firstChild);

            hideBtn = uvpjs.util.htmlToElement('<span>x</span>');
            hideBtn.addEventListener('click', this._handleCloseButton.bind(this), true);
            diagEl.appendChild(hideBtn);

            diagTblEl = document.createElement('table');
            diagEl.appendChild(diagTblEl);

            u.addCSSObject(styleEl, diagEl, {
              'background': 'rgba(28, 28, 28, 0.7)',
              'border': 0,
              'border-radius': '4px',
              'color': 'white',
              'display': 'none',
              'font-family': 'Arial, Tahoma, Geneva, sans-serif',
              'font-size': '12px',
              'left': '5px',
              'line-height': '1',
              'padding': '5px',
              'position': 'absolute',
              'top': '5px',
              'z-index': 10
            });

            u.addCSSObject(styleEl, diagEl, {
              'color': '#777',
              'cursor': 'pointer',
              'float': 'right',
              'font-size': '14px',
              'line-height': '1',
              // Increase clickable area
              'margin': '-15px -10px',
              'padding': '10px'
            }, 'span');

            u.addCSSObject(styleEl, diagEl, {
              'color': '#fff'
            }, 'span:hover');

            u.addCSSObject(styleEl, diagEl, {
              'border-spacing': 'auto',
              'margin-right': '20px',
              'border': 0,
              'padding': 0,
              'margin': 0
            }, 'table');

            u.addCSSObject(styleEl, diagEl, {
                'background': 'transparent',
            }, 'table td');

            u.addCSSObject(styleEl, diagEl, {
                'color': '#c9c9c9',
                'padding': '0 5px'
            }, 'table td:first-child');

            u.addCSSObject(styleEl, diagEl, {
                'width': '60px',
            }, 'table td:last-child');

            this._diagEl = diagEl;
            this._diagTableEl = diagTblEl;
            this._hideDiagBtn = hideBtn;
        },

        /**
         * Remove diagnostic window from DOM.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _removeDiag: function () {
            var el = this._diagEl,
                btn = this._hideDiagBtn;

            btn && btn.removeEventListener('click', this._handleCloseButton.bind(this));
            el && el.remove();
        },

        /**
         * Hide window.
         *
         * @memberof uvpjs.Diagnostic#
         */
        _hideDiag: function () {
            var el = this._diagEl,
                em = this._eventsMgr;

            el && (el.style.display = 'none');
            em.dispatchEvent(em.eventTypes.DIAGNOSTIC_WINDOW_CLOSED, {}, this._containerId);
        },

        /**
         * Show window.
         *
         * @memberof uvpjs.Diagnostic#
         */
        _showDiag: function () {
            var el = this._diagEl;
            el && (el.style.display = 'block');
        },

        /**
         * Toggle window.
         *
         * @memberof uvpjs.Diagnostic#
         */
        _toggleDiag: function () {
            var el = this._diagEl;

            if (!el) {
                return;
            }

            if (el.style.display === 'block') {
                this._hideDiag();
                return;
            }

            this._showDiag();
        },

        /**
         * When diagnostic window close button is clicked.
         *
         * @memberof uvpjs.Diagnostic#
         */
        _handleCloseButton: function () {
            var em = this._eventsMgr;

            this.debug && uvpjs.log(this.DEBUG_ID, '_handleCloseButton');

            this._hideDiag();

            em.dispatchEvent(em.eventTypes.DIAGNOSTIC_WINDOW_CLOSE_BUTTON, {}, this._containerId);
        },

        /**
         * Add event listeners.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _addEventListeners: function () {
            var ns = this._namespace,
                em = this._eventsMgr,
                et = em.eventTypes,
                cn = this._containerEl;

            if (!em || !ns) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Diagnsotic: unable to add event listeners.');
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'Diagnostic: Adding event listeners.');

            em.addEventListener(et.VIDEO_PROGRESS + ns, this. _onVideoProgress.bind(this));
            em.addEventListener(et.VIDEO_STATE_CHANGE + ns, this. _onVideoStateChange.bind(this));
            em.addEventListener(et.VIDEO_TRANSITION_START + ns, this. _onVideoTransitionStart.bind(this));
            em.addEventListener(et.VIDEO_TRANSITION_COMPLETE + ns, this. _onVideoTransitionComplete.bind(this));
        },

        /**
         * Remove event listeners.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _removeEventListeners: function () {
            var ns = this._namespace,
                em = this._eventsMgr,
                et = em.eventTypes,
                cn = this._containerEl;

            if (!em || !ns) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Diagnsotic: unable to remove event listeners.');
                return;
            }

            em.removeEventListener(et.VIDEO_PROGRESS + ns);
            em.removeEventListener(et.VIDEO_STATE_CHANGE + ns);
            em.removeEventListener(et.VIDEO_TRANSITION_START + ns);
            em.removeEventListener(et.VIDEO_TRANSITION_COMPLETE + ns);
        },

        /**
         * Update diagnostic HTML table.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _updateTableHtml: function () {
            var rows = '',
                pm = this._params,
                tr, html, k, v;

            for (k in pm) {
                v = pm[k];

                if (v === null || v === undefined) {
                    continue;
                }

                rows += '<tr><td>'+ k +'</td><td>'+ v +'</td></tr>';
            }

            this._diagTableEl.innerHTML = rows;
        },

        /**
         * VIDEO_PROGRESS callback.
         *
         * @param {Object} evtObj Event object.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _onVideoProgress: function (evtObj) {
            var ps = evtObj.payload,
                fs = ps.facadeState,
                pm = this._params,
                mn = fs.minABRLevel,
                mx = fs.maxABRLevel;

            if (evtObj.target !== this._containerId) {
                return;
            }

            // this.debug && uvpjs.log(this.DEBUG_ID, 'Diagnostic: _onVideoProgress', ps, fs);

            pm['stream type'] = ps.streamType;
            pm['duration'] = ps.duration;
            pm['current time'] = ps.currentTime.toFixed(2);
            pm['buffer length'] = ps.bufferLength.toFixed(2);

            pm['total dropped frames'] = ps.droppedFrames >= 0 && ps.droppedFrames || null;
            pm['average dropped (fps)'] = ps.averageDroppedFPS >= 0 && ps.averageDroppedFPS.toFixed(2)  || null;
            pm['playback framerate (fps)'] = ps.playbackFramerate >= 0  && ps.playbackFramerate.toFixed(2)  || null;
            pm['current bandwidth (B/s)'] = ps.currentBandwidth >= 0 && toBytes(ps.currentBandwidth) || null;

            pm['switching mode'] = ps.switchingMode;
            pm['current index bitrate (B/s)'] = toBytes(fs.currentAbr && fs.currentAbr.bitrate);
            pm['start index bitrate (B/s)'] = toBytes(fs.startBitrate);

            if (mn !== undefined && mx !== undefined) {
                pm['available indexes'] = mn + ' to ' + mx;
            }

            this._updateTableHtml();
        },

        /**
         * VIDEO_STATE_CHANGE callback.
         *
         * @param {Object} evtObj Event object.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _onVideoStateChange: function (evtObj) {
            var ps = evtObj.payload,
                pm = this._params;

            if (evtObj.target !== this._containerId) {
                return;
            }

            // this.debug && uvpjs.log(this.DEBUG_ID, 'Diagnostic: _onVideoStateChange', ps);

            pm['playback state'] = ps.newState;

            this._updateTableHtml();
        },

        /**
         * VIDEO_TRANSITION_START callback.
         *
         * @param {Object} evtObj Event object.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _onVideoTransitionStart: function (evtObj) {
            var ps = evtObj.payload,
                pm = this._params;

            if (evtObj.target !== this._containerId) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'Diagnostic: _onVideoTransitionStart', ps);

            pm['transition state'] = 'start';

            this._updateTableHtml();
        },

        /**
         * VIDEO_TRANSITION_COMPLETE callback.
         *
         * @param {Object} evtObj Event object.
         *
         * @private
         *
         * @memberof uvpjs.Diagnostic#
         */
        _onVideoTransitionComplete: function (evtObj) {
            var ps = evtObj.payload,
                pm = this._params;

            if (evtObj.target !== this._containerId) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'Diagnostic: _onVideoTransitionComplete', ps);

            pm['transition state'] = 'complete';

            this._updateTableHtml();
        },
    });

    function toBytes(bytes) {
        if (isNaN(bytes)) {
            return;
        }

        if (bytes < 1048576) {
            return (bytes / 1024).toFixed(2) + 'k';
        }

        if (bytes < 1073741824) {
            return(bytes / 1048576).toFixed(2) + 'M';
        }

        return (bytes / 1073741824).toFixed(2) + 'G';
    }

}(uvpjs.register('uvpjs')));

(function (obj) {
    'use strict';

    obj.Watermark = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.VIDEO_PLAYER_FACADE,

        IMAGE:    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJIAAAAqCAYAAABY4gKWAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNTVGM0ZGMTBGN0IxMUUzOEQxQ0UwRUY4QzJFQzczMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNTVGM0ZGMjBGN0IxMUUzOEQxQ0UwRUY4QzJFQzczMyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1NUYzRkVGMEY3QjExRTM4RDFDRTBFRjhDMkVDNzMzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1NUYzRkYwMEY3QjExRTM4RDFDRTBFRjhDMkVDNzMzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+PHDLXgAACblJREFUeNrsXAdz2zoMBjU8Yzuz+f//7rWNM7yn9Ky7DxHCUhIoS26aC+94SRuJAoEPk8OkaUrf7bud26JvFnzZFpx659S7px5D1gY9awn6/tR3p7499UPdj5lvi/TlWgacK/wMAZwyITOwjgDVCj25FJAiIL6D3wNBFIF4RvwWPfXQpKZbCmYdlXRUtVDMPwbdJAQn589af2wRQL1TH4OeQNDghQf0zDItTn2uHcMXSBnzBiC6g3+TAvEpiNuc+hJMLWrZuI8tMTuBMHfQuk2NMfrggUbjjaVUO3xz1SCoMtBMTn2I35MGxmRAZcr/ip+NACkjcARiozPRnoCRbwXMzID0o0XNNUL4KzBKI9TM6lxDicyZPMi+t4bG78+YS8arG4A6aYlXKWQ1PxdIfTAwrsm8ImBmDHxxWIW2geSi46lCoAMILGxY448Q0LwGXzPw3EGxkwvwaQalqwWkCfwuNQQgF9pf4O7+BpCYSZnL+VUgkMwK37bEA/7+BkLaeYDoXsRCl+JTIZiCkhdvAaS0JWJTgOkWGv+3WgLwjktcB7UosARWv+eR5Nx5gsiUdB86x8gI1XWkG7zQtsmUYDp4aGQbdAyRqRwE868V6XMTmr6EtmsAcatwZ0b8PIqeWM+E+H6ojPsS8GRvB+AuIF0hsPYBkXEwXBuQMphu4F58tMwHKFV/D2EZ5iKd7ireLZu7JqPlWFHTRqArUdSEtgjot2J+gSUXLoXEmHtXlDLKvnFtyyoqyEx8hJkIgg94l2tBfYxZxdAUkxhb8VJZ2yqFHIGJmjlFVmykKeZxKUHOPcK8O0Lbi3jwoswaI/AnKQHQHoqwxnMG4BsIINl1vi3eeRXufATZuebPshpJKxo5gmtNLUKmhcsCRqzxIc76QkW9petR23kmXUmf6yxXCjAHFgCrQJTNcVoxrxiCHFguKQD/Nh7WyCWbAHx4A6BT4VnGVrkmddQFh6BtJQL+Keie4G/2uynGf5d9ZGUCfSWIDvjYTuEyVnjuXpQQbLewE5oUeVhDbZD4Isx2FZh47EDx/ZVivJ2YHws3EIqmDbCHDtkYxHWyJmdEjJtWyFMCZAhrxHLlsgiXPgLLXTNNMztru1IIh4O3356B8QFEHQV4AoH+n0B3m8H9UTG3pCTuKUrDfb7/hthiDXBrQ4i+JSsj3OKzNTeZKPkkCQnAcW8p8wo07xyukd3f+x8CZWCZQvB1VokPMJ1cen8CgcsL1UJCxTM7h6aWMT4T2IOIQbSx3S/yq2j3LWuZgH8Lh/s7J9tmS3NrGZU9jMdaYIaD9Ei6tq4iIA1A+PYMYa5hfbYNAEMLvgDuJK6IZfYiXklFNlnlunroR5EWH/D7oQEl4cVxSc/UEVvxMta530swn4GV+CT47r3IHAP8vpdA0jBt2YDwtw1ZmBtlPBejV9Vd5uIZXmSOPADNTO0LIHJtbCviDt8WW7J5KQjQr6i55RIOpu0YkMH0IBQzw848EsRq0tymQNBE63lqWVVB0HYTK8ulaAWQWiDoCHfDtZ016Vf/QxGzzUqUuU/NhQgp5Vtkto5YL4vLfoii5ru/CxWavafP1VKPXlZInIMx5ADS3rPw6aIxEUDuIf54hBsyHkDaIVgveiaiZmNNI2qArljyDfgJyKqbnJv1/Gttg3itKHviBeWmwZ9A8DfQ6kgBpBSJSloBtksmKAvw0BtIX21PbiDijzKwPZP/AqcWULzTIVZ4g03FM20AyShiZkOKoludAuC/0jIh3sHNlG3tXSL1PdCf24mbAFRI+Wp+0TNxRUzY5g6NMjwM+ZlAEYz61GH+pSatwkOFVWA3yLspmwQUB7bjkpCCF0rLwo42gFQWzgxFGeAdSEfFZD/b0SXj2csyutBRhHM9NwOgpsi8uLYTnOleUtRtgoLvMtgmJQI/tGAt9yUliYlMJBgch4o6kkwHd58ESNpVc94e0iuZX0L5MZ65QkuX6HySJBY/ZbqudTmsqF0AVLaDGGcM/q8LrGa3IcvEcdmuILa8E0nAh0XbDRXsfLMGGDYApLihUsKG9Es1C1icYYWyDPCsVhhHUReSKTNXo7si/tKM2XGAZG+9m83jyVHfWUCGTWy/NQV8MABRh/LK9k66Ns2Zq4TyFeK6rYfg9o78CopNBP8zql4Jjwtc+KgihpJj8P6kV7jB3xC6hl6Xa+PqOFu4QAjTBvWsAfcWgN6lg9+39HGHSMLZpIyRdqRb/b+tGXgHlG9dHSDAfQBhl2iJiGl8inADzPmhJvg3IuurK+QNfdwcF1K+WCzbHAAIzlBOrlynVnhwTx+3shgB8g8fXCg1LqY/txpoQHRP+eIj9x4Y8gimtFli6FD1wrS9DykUQSUL77qGIlXtC6KK7Hlt/U1aponFt2dYRN/MMgCI7KNZPdS67L1qRrrhwEL9RoHmVBTShgpimRDXIT6Zgt+jGw/h+MRl18ox5bj2eT4OeB8hwFj5/ZFQorJWFPPxmXzjoHUC/vbE/z/BtSYKQBkBil8i9soMxQ2UJ3KA6CiNj21V3ki3WSsVKfOYivdsD8R4VTsLDPmdj9eu/jMt2tMgB+HSXLsSE2GpRpRXnXnbiNxK21FkjHLcskRmTu5jW7IWtsFzG8oXeEeitGAc727FO4yJK8y96EAoB+PvsnIdkBwphWQjWmqtIb+LDDjd/ImJPCrfoQatF2vZf/j9kXSHBlzzJ08eGBFLlbWJcLVlPGFwr0XsG9LHNTl5RCmkfAtMh8pPFLOsPhwojQqQH5N+p53NKFPh74vGeFEEw3Vdm1YhtqDbZc5950+eyqjZ6zWj/AKPtIQnXNca0Z/n2uT+qVB0Cfoqul/tZ6KSYl8Ak9jmPmrWZldd5NIthRIFdNkqPu+HWilp5L1AQUVNLBUJQ6gYN1HS+kqOBeSyhcIp/GDTC5W25k6VTGxbmDO4gQQuZtPi3OV3d1RyOUNB4D31sN5192u5aF1QwcmXQIH+KeULlU0ykFPN5V8EkCH3kekDwCQznzZAxIcgfPd6bTzB1AStC3JvACwMtl2NT3n2RQBa924gPuv2VpDuXuI2Ep9rZWLKT57Wnbv93QTgfTszdOghMYqpvfuROG4utZq+N7bFlG8fiJUptRFavqXqkyht3tjGAbCkRbteF1F+W11MutvqJA98bq3zaSHqXYOGkxC+O+qV3IvEZwFJMiYWTLVvTJUBHDNvqzThAZ2/DlcFosOZ4/BKvX1/pqtgaN+j2VbyMqD82FVdQElLvfKxmE3eamss7WsjRf/M7TPM38AFD0l/xycJd8tKv/BVtu/rkb9uY6vZLbCa8oQLX5K6qwv+/wUYAJgTliFeAJfvAAAAAElFTkSuQmCC',
        PREFIX:   'watermark_',
        OFFSET:   10,     // Controls default bottom and right position offset.
        SIZE:     0.1,    // Controls watermark's width as percentage of video (e.g. 0.1 is 10%)
        RATIO:    42/146, // Ratio of image dimensions (height / width).


        /**
         * Constructor function.
         *
         * @param {Object}               options
         * @param {String}               options.containerId  Main outer container id.
         * @param {uvpjs.EventsManager}  options.eventsMgr    Instance of EventsManager.
         * @param {HTMLElement}          options.videoEl      Video element.
         *
         * @constructor uvpjs.Watermark
         * @extends uvpjs
         */
        init: function (options) {
            var videoEl;

            this.debug = uvpjs.debug;

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'Create CBS watermark.');
            }

            if (!options) {
                return;
            }

            videoEl = options.videoEl;

            this._videoEl = videoEl;
            this._eventsMgr = options.eventsMgr;
            this._containerId = options.containerId;
            this._watermarkId = this.PREFIX + this._containerId;

            this._contentEl = videoEl.parentNode;
            this._namespace = '.' + this._containerId + '.' + 'waterkmark';
            this._imgEl = null;

            this._createImage();
            this._addEventListeners();
        },

        /**
         * Destroy instance
         *
         * @memberof uvpjs.Watermark
         */
        destroy: function () {

            if (!this._imgEl || !this._contentEl) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG, 'Unable to remove watermark.');
                }
                return;
            }

            this._removeEventListeners();
            this._removeImage();

            this._eventsMgr = null;
            this._containerId = null;
            this._watermarkId = null;
            this._contentEl = null;
            this._videoEl = null;
            this._namespace = null;
            this._imgEl = null;
        },


        //////////////////
        // Private

        /**
         * Create CBS watermark <img> element and add to DOM.
         *
         * @private
         *
         * @memberof uvpjs.Watermark#
         */
        _createImage: function () {
            var imgEl;

            if (!this._contentEl) {
                return;
            }

            imgEl = document.createElement('img');
            imgEl.id = this._watermarkId;
            imgEl.src = this.IMAGE;
            imgEl.style.position = 'absolute';
            imgEl.style.display = 'none';

            this._imgEl = imgEl;

            this._contentEl.appendChild(imgEl);
        },

        /**
         * Remove CBS watermark <img> element from DOM.
         *
         * @private
         *
         * @memberof uvpjs.Watermark#
         */
        _removeImage: function () {
            var imgEl = this._imgEl;

            if (!imgEl || !imgEl.parentNode) {
                return;
            }

            imgEl.parentNode.removeChild(imgEl);
        },

        /**
         * Handle interval timer to check for the CBS watermark to ensure it's
         * not removed from the DOM.
         *
         * @private
         *
         * @memberof uvpjs.Watermark#
         */
        _ensureImage: function () {
            var imgEl = document.getElementById(this._watermarkId);

            // Leave if <img> already in DOM.
            if (imgEl) {
                return;
            }

            this._createImage();
            this._setPosition();
            this._showImage();
        },

        /**
         * Hide watermark.
         *
         * @memberof uvpjs.Watermark#
         */
        _hideImage: function () {
            var imgEl = this._imgEl;

            if (!imgEl) {
                return;
            }

            imgEl.style.display = 'none';
        },

        /**
         * Show watermark.
         *
         * @memberof uvpjs.Watermark#
         */
        _showImage: function () {
            var imgEl = this._imgEl;

            if (!imgEl) {
                return;
            }

            imgEl.style.display = 'block';
        },

        /**
         * Add event listeners.
         *
         * @private
         *
         * @memberof uvpjs.Watermark#
         */
        _addEventListeners: function() {
            var ns = this._namespace,
                em = this._eventsMgr,
                et = em.eventTypes;

            if (!em || !ns) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'Unable to add event listeners.');
                }
                return;
            }

            // UVPJS events.
            em.addEventListener(et.AD_START + ns, this._hideImage.bind(this));
            em.addEventListener(et.CONTENT_START + ns, this._showImage.bind(this));
            em.addEventListener(et.CONTENT_END + ns, this._hideImage.bind(this));
            em.addEventListener(et.CONTAINER_RESIZE + ns, this._onContainerResize.bind(this));

            // Earliest point the <video> element has width and height information.
            this._videoEl.addEventListener('canplay', this._onCanPlay.bind(this));

            // Set interval to ensure image doesn't get removed from DOM.
            em.addTimedEventCallback(em.HALF_SECOND, ns, this._ensureImage.bind(this));
        },

        /**
         * Remove event listeners.
         *
         * @private
         *
         * @memberof uvpjs.Watermark#
         */
        _removeEventListeners: function() {
            var ns = this._namespace,
                em = this._eventsMgr,
                et = em.eventTypes;

            if (!em || !ns) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'Unable to remove event listeners.');
                }
                return;
            }

            em.removeEventListener(et.AD_START + ns);
            em.removeEventListener(et.CONTENT_START + ns);
            em.removeEventListener(et.CONTENT_END + ns);
            em.removeEventListener(et.CONTAINER_RESIZE + ns);

            em.removeTimedEventCallback(this.TIMER_INTERVAL, ns);

            this._videoEl.removeEventListener(this.HTML5_CAN_PLAY, this._onCanPlay.bind(this));
        },

        /**
         * HTML5_CAN_PLAY callback.
         *
         * NOTE: First time <video> element has height and width information.
         *
         * @memberof uvpjs.Watermark#
         */
        _onCanPlay: function () {
            this._setPosition();
            this._showImage();
        },

        /**
         * CONTAINER_RESIZE callback.
         *
         * @param {Object} evtObj Event object.
         *
         * @private
         *
         * @memberof uvpjs.Watermark#
         */
        _onContainerResize: function (evtObj) {
            if (evtObj.target !== this._containerId) {
                return;
            }

            this._setPosition();
        },

        /**
         * Calculates the CBS watermark position.
         *
         * @private
         *
         * @memberof uvpjs.Watermark#
         */
        _setPosition: function () {
            var imgEl, contentEl, videoEl, calcH, calcW, offset, vRect, rectH,
                rectW, size, cRatio, rRatio, vRatio, videoH, videoW, cRect,
                diffB, diffR, diffH, diffW, imgH, imgW;

            contentEl = this._contentEl;
            videoEl = this._videoEl;
            imgEl = this._imgEl;

            if (!imgEl || !videoEl || !contentEl) {
                return;
            }

            videoH = videoEl.videoHeight;
            videoW = videoEl.videoWidth;

            // Occurs if called before <video> element has size information.
            if (!videoW || !videoH) {
                return;
            }

            offset = this.OFFSET;
            size = this.SIZE;

            vRect = videoEl.getBoundingClientRect();
            cRect = contentEl.getBoundingClientRect();

            //** Calculate video dimensions.

            rectH = vRect.height;
            rectW = vRect.width;

            vRatio = videoH / videoW;
            rRatio = rectH / rectW;
            cRatio = rRatio / vRatio;

            //** Determine difference between content and video containers.

            calcH = rectW * vRatio;
            calcW = rectH / vRatio;

            diffB = cRect.bottom - vRect.bottom;
            diffR = cRect.right - vRect.right;

            //** Determine size of the image (original dimensions: 146x42).

            // Video is taking up full width.
            if (cRatio > 1) {
                diffH = (rectH - calcH) / 2;
                diffW = 0;
                imgW = (rectW * size) + 'px';
                imgH = 'auto';
            // Video is taking up full height.
            } else {
                diffH = 0;
                diffW = (rectW - calcW) / 2;
                imgW = 'auto';
                imgH = (rectH * size * (this.RATIO / vRatio)) + 'px';
            }

            //** Apply calulcated size and position to <img> element.

            imgEl.style.width = imgW;
            imgEl.style.height = imgH;
            imgEl.style.bottom = diffH + diffB + offset + 'px';
            imgEl.style.right = diffW + diffR + offset + 'px';
        }
    });

}(uvpjs.register('uvpjs')));
(function (obj) {
    'use strict';

    obj.Kaleidoscope360 = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.VIDEO_PLAYER_FACADE,

        PREFIX:   '360_',
        // kaleidoscope library path
        KALEIDOSCOPE_SDK_PATH: uvpjs.Configuration.path + 'lib/kaleidoscope.min.js',

        /**
         * Constructor function.
         *
         * @param {Object}               options
         * @param {String}               options.containerId  Main outer container id.
         * @param {uvpjs.EventsManager}  options.eventsMgr    Instance of EventsManager.
         * @param {HTMLElement}          options.videoEl      Video element.
         *
         * @constructor uvpjs.Kaleidoscope360
         * @extends uvpjs
         */
        init: function (options) {
            var videoEl;

            this.debug = uvpjs.debug;

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'Setup Kaleidoscope for 360 playback');
            }

            if (!options) {
                return;
            }

            videoEl = options.videoEl;

            this._videoEl = videoEl;
            this._eventsMgr = options.eventsMgr;
            this._containerId = options.containerId;
            this._360Id = this.PREFIX + this._containerId;
            this._360El = null;

            this._contentEl = videoEl.parentNode;
            this._namespace = '.' + this._containerId + '.' + 'kaleidoscope360';

            this._kaleidoscopeViewer = null;

            this._loadKaleidoscope(this._setupKaleidoscope.bind(this));
            this._addEventListeners();
        },

        /**
         * Destroy instance
         *
         * @memberof uvpjs.Kaleidoscope360
         */
        destroy: function () {

            if (!this._360El || !this._kaleidoscopeViewer) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG, 'Unable to remove Kaleidoscope360.');
                }
                return;
            }

            this._removeEventListeners();
            if (this._kaleidoscopeViewer) {
                this._kaleidoscopeViewer.destroy();
            }
            this._remove360Dom();

            this._eventsMgr = null;
            this._containerId = null;
            this._contentEl = null;
            this._videoEl = null;
            this._namespace = null;
            this._kaleidoscopeViewer = null;
            this._360El = null;
        },


        //////////////////
        // Private

        /**
         * Load the Kaleidoscope library, if it has not already been loaded.
         * Then calls the callback function
         *
         * @private
         *
         * @param {Function} callback function.
         *
         * @memberof uvpjs.Kaleidoscope360#
         */
        _loadKaleidoscope: function(callback) {
            if (typeof callback !== 'function') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'VideoPlayerFacade _loadKaleidoscope: no callback supplied.');

                return;
            }

            this.pluginLoadedCB = function () {
                this.isPluginLoaded = true;
                callback();
            }.bind(this);

            // Load if SDK not loaded
            if (!window.Kaleidoscope || !window.Kaleidoscope.Video) {
                this.codeLoader = new uvpjs.CodeLoader();
                this.codeLoader.loadScript(this.KALEIDOSCOPE_SDK_PATH, this.pluginLoadedCB);

                return;
            }

            this.pluginLoadedCB();
        },

        /**
         * Setup of DOM and create a Kaleidoscope Video player instance
         *
         * @private
         *
         *
         * @memberof uvpjs.Kaleidoscope360#
         */
        _setupKaleidoscope: function() {
            if (this._kaleidoscopeViewer) {
                return;
            }

            this._create360Dom();

            this._kaleidoscopeViewer = new window.Kaleidoscope.Video({
                source: this._videoEl,
                container: this._360El,
                height: this._contentEl.clientHeight,
                width: this._contentEl.clientWidth
            });
        },

        /**
         * Creates the <div> element to use for Kaleidoscope to render its WebGL <canvas> in.
         * Appends the new div under the content_ div
         * Sets a style so this div will also be on-top and accept the click events
         *
         * @private
         *
         *
         * @memberof uvpjs.Kaleidoscope360#
         */
        _create360Dom: function() {
            this._360El = document.createElement('div');
            this._360El.id = this._360Id;
            this._360El.style.position = 'absolute';
            this._360El.style.zIndex = '1';
            this._contentEl.appendChild(this._360El);
        },

        /**
         * Removes the <div> created for the Kaleidoscope WebGL <canvas>
         *
         * @private
         *
         *
         * @memberof uvpjs.Kaleidoscope360#
         */
        _remove360Dom: function() {
            if (this._360El) {
                this._360El.remove();
            }
        },

        /**
         * Calls render method on the Kaleidoscope player
         * This should we triggered from the CONTENT_START event
         * Calling too early can result in a LOT of WebGL warnings
         *
         * @private
         *
         *
         * @memberof uvpjs.Kaleidoscope360#
         */
        _startKaleidoscopeRender: function() {
            if (this._kaleidoscopeViewer) {
                this._kaleidoscopeViewer.render();
            }
        },

        /**
         * Updates the size of the Kaleidoscope WebGL <canvas>.
         * Matches the size of the content_ element.
         * This should be called from CONTAINER_RESIZE event.
         *
         * @private
         *
         *
         * @memberof uvpjs.Kaleidoscope360#
         */
        _handleContainerResize: function() {
            if (!this._kaleidoscopeViewer || !this._contentEl) {
                return;
            }
            // Resize the Kaleidoscope canvas when video is loaded
            this._kaleidoscopeViewer.setSize({height: this._contentEl.clientHeight, width: this._contentEl.clientWidth});
        },

        /**
         * Add event listeners.
         *
         * @private
         *
         * @memberof uvpjs.Kaleidoscope360#
         */
        _addEventListeners: function() {
            var ns = this._namespace,
                em = this._eventsMgr,
                et = em.eventTypes;

            if (!em || !ns) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'Unable to add event listeners.');
                }
                return;
            }

            // UVPJS events.
            em.addEventListener(et.CONTAINER_RESIZE + ns, this._handleContainerResize.bind(this));
            // To handle WebGL errors in Kaleidoscope before video has started,
            // wait for CONTENT_START before calling render.
            em.addEventListener(et.CONTENT_START + ns, this._startKaleidoscopeRender.bind(this));
        },

        /**
         * Remove event listeners.
         *
         * @private
         *
         * @memberof uvpjs.Kaleidoscope360#
         */
        _removeEventListeners: function() {
            var ns = this._namespace,
                em = this._eventsMgr,
                et = em.eventTypes;

            if (!em || !ns) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'Unable to remove event listeners.');
                }
                return;
            }

            em.removeEventListener(et.CONTAINER_RESIZE + ns);
            em.removeEventListener(et.CONTENT_START + ns);
        }
    });

}(uvpjs.register('uvpjs')));
/**
 * Created by ldoyle on 8/13/15.
 */
'use strict';

(function (obj) {

    /**
     * Resource Config Object Parent<br>
     * 1) Holds resource config data.<br>
     * 2) Vets resource config initialization data based on resource config type.<br>
     * 3) Used by Core Video Instance Manager to make resource add/load requests<br>
     * 4) Created by Page/App as the payload in play video API calls.<br>
     * 5) Loaded into the CVI_Model when the resource becomes the currently playing video.<br>
     * 6) Preserved in the Resource Provider that was initialized with it.<br>
     *
     * Allowable Resource Provider types:
     * RP_URL:'rp_url',
     * RP_DAI: 'rp_dai'
     * RP_IMA:'rp_ima',
     * RP_MDIALOG:'rp_mDialog',
     * RP_PLATFORM:'rp_platform'.
     *
     */

    obj.ResourceConfigObject = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_CONFIG_OBJECT,

        /**
         * @constructor uvpjs.ResourceConfigObject
         *
         * @param rcObj
         * @param id - arbitrary identifier
         * @param vidContId - id of video tag container
         */
        init: function(rcObj, id, vidContId) {
            this.debug = uvpjs.debug;
            this.validationInfo = null;
            this.id = id;
            this.vidContId = vidContId
            this.rcoSeed = {};

            this.initialize(rcObj);
        },

        /**
         * @memberof uvpjs.ResourceConfigObject#
         *
         * @param {Object} rcInitObj - Resource Config Object initialization values
         */
        initialize: function(rcInitObj) {
            this.validationInfo = this.validateUserRco(rcInitObj);

            if (!this.validationInfo) { return; }

            this.rcoSeed = rcInitObj;
            this.populateSelf(rcInitObj);
        },

        /**
         * @memberof uvpjs.ResourceConfigObject#
         */
        getContextMetadata: function () {
            return this.contextMetadata || null;
        },

        /**
         * @memberof uvpjs.ResourceConfigObject#
         * @protected
         */
        populateSelf: function(obj) {
            var p;

            for (p in obj) {
                if (obj.hasOwnProperty(p)) {
                    this[p] = obj[p];
                }
            }
        },

        /**
         * Returns true if a valid property with the supplied name exists
         *
         * @param {String} name
         *
         * @returns {Boolean}
         */
        has: function(name) {
            return !uvpjs.util.isEmpty(this[name]);
        },

        /**
         * Returns an object with an error property - if true, a validation error has occurred
         * @memberof uvpjs.ResourceConfigObject#
         *
         * @returns {Boolean}
         */
        getValidationInfo: function() {
            return this.validationInfo;
        },

        /**
         * Validates the supplied config object
         *
         * @memberof uvpjs.ResourceConfigObject#
         * @protected
         *
         * @param {Object} rco
         *
         * @returns {Boolean}
         */
        validateUserRco: function(rco) {
            return {
                error: false,
                message: ''
            }
        }
    });
}(uvpjs.register('uvpjs')));

/**
 * Created by ldoyle on 11/18/15.
 */
'use strict';

(function (obj) {

    obj.RCO_URL = uvpjs.ResourceConfigObject.subClass({

        /**
         * @constructor uvpjs.ResourceConfigObject.RCO_URL
         *
         * @param {Object} rco
         */
        init: function(rco, id, vidContId) {
            this._super(rco, id, vidContId);
        },

        /**
         * @override
         */
        validateUserRco: function(rco) {
            var sup = this._super(rco),
                oku = uvpjs.util.isDefinedString(rco.assetURL);

            return {
                error: sup.error || !oku,
                message: sup.error ? sup.message : "Invalid assetURL"
            }
        }

    });

}(uvpjs.register('uvpjs')));

(function (obj) {

    obj.DaiRco = uvpjs.ResourceConfigObject.subClass({

        /**
         * @constructor uvpjs.DaiRco
         *
         * @param {Object} rco
         */
        init: function(rco, id, vidContId) {
            this.daiParams = {
                adTagParameters: null,
                contentSourceId: null,
                daiVideoId: null,
                assetKey: null,
                apiKey: null,
                useSsb: false
            };
            this._super(rco, id, vidContId);
        },

        useSsb: function () {
            return this.daiParams.useSsb;
        },

        /**
         * Sets the videoId/cmsRefGuid
         * @memberof uvpjs.DaiRco#
         *
         * @param val
         */
        setCmsRefGuid: function (val) {
            this.cmsRefGuid = val;
            this.daiParams.daiVideoId = val;
        },

        /**
         * Returns true if sufficient data for a metadata call to be made
         * @memberof uvpjs.DaiRco#
         *
         * @param {String} globalUrl the url value, if any, obtained from uvpc module
         */
        canMakePlatformCall: function(globalUrl) {
            var validGlobal = uvpjs.util.isDefinedString(globalUrl),
                u = (this.has('selectorCall') && this.selectorCall) || (validGlobal && globalUrl);

            if (!u) return false;

            if (u.indexOf('$PID$') > -1) {
                return this.has('pid');
            }
            else if (u.indexOf('$GUID$') > -1) {
                return this.has('cmsRefGuid');
            }
            else {
                return true;
            }
        },

        /**
         * Returns ad call parameters parsed from selector call
         * @memberof uvpjs.DaiRco#
         */
        getAdTagParameters: function() {
            return this.daiParams.adTagParameters;
        },

        /**
         * Returns video id for stream request (VOD)
         * @memberof uvpjs.DaiRco#
         */
        getVideoId: function() {
            return this.has('cmsRefGuid') ? this.cmsRefGuid : null;
        },

        /**
         * Returns the DAI-specific 'cms id'
         * @memberof uvpjs.DaiRco#
         */
        getContentSourceId: function() {
            return this.daiParams.contentSourceId;
        },

        /**
         * Returns key for a live stream
         * @memberof uvpjs.DaiRco#
         */
        getAssetKey: function() {
            return this.daiParams.assetKey;
        },

        /**
         * Returns key for locked content
         * @memberof uvpjs.DaiRco#
         */
        getApiKey: function() {
            return this.daiParams.apiKey;
        },

        ////////////
        // protected
        /**
         * @override
         */
        validateUserRco: function(rco) {
            var hasSdk = window.google && google.ima && google.ima.dai,
                hasMinDaiReqs = this.validateDaiConfig(rco),
                sup = this._super(rco),
                ok = (rco.useSsb || hasSdk) && hasMinDaiReqs && !sup.error,
                msg = !hasSdk ? "DAI SDK is missing." : (!hasMinDaiReqs ? "Supplied RCO is not valid for rp_dai" : '');

            return {
                error: !ok,
                missingSDK: !hasSdk,
                message: sup.error ? sup.message : msg
            }
        },

        /**
         * @override
         */
        populateSelf: function(rcInitObj) {
            var p, own;

            for (p in rcInitObj) {
                own = rcInitObj.hasOwnProperty(p);

                if (own && this.daiParams[p] !== undefined) {
                    this.daiParams[p] = rcInitObj[p];
                }
                else if (own) {
                    this[p] = rcInitObj[p];
                }
            }

            if (this.daiParams.daiVideoId && !this.cmsRefGuid) {
                this.cmsRefGuid = this.daiParams.daiVideoId;
            }

            this.checkCustomAdTagParams();
        },

        ///////////
        // private
        /**
         * Validates user-supplied rco for required params
         * @private
         *
         * @param {Object} obj
         *
         * @return {Boolean}
         */
        validateDaiConfig: function (obj) {
            var u = uvpjs.util,
                ap = !u.isEmpty(obj.adTagParameters),
                cs = !u.isEmpty(obj.contentSourceId);

            // minimal validation here; still need a videoId, but that
            // could get picked up later if a platform call is to be made
            if (!obj.useSsb && (!ap || !cs)) {
                this.debug && uvpjs.error("DaiRco: missing contentSourceId or adTagParameters.");
                return ap && cs;
            }
            if (obj.useSsb) {
                return !u.isEmpty(obj.assetURL);
            }

            return ap && cs;
        },

        /**
         * Transforms cust_params of adTagParameters from obj to str, if necessary
         * @private
         */
        checkCustomAdTagParams: function () {
            var u = uvpjs.util,
                cp = this.daiParams.adTagParameters ? this.daiParams.adTagParameters.cust_params : null,
                str;

            if (!cp || typeof cp === 'string') return;

            if (u.isPlainObject(cp)) {
                str = u.queryStrFromObj(cp);
                this.daiParams.adTagParameters.cust_params = encodeURIComponent(str);
            }
        }

    });

}(uvpjs.register('uvpjs')));

/**
 * Created by ldoyle on 12/8/15.
 */
'use strict';

(function (obj) {

    obj.RCO_IMA = uvpjs.ResourceConfigObject.subClass({

        /**
         * @constructor uvpjs.ResourceConfigObject.RCO_IMA
         *
         * @param {Object} rco
         */
        init: function(rco, id, vidContId) {
            this._super(rco, id, vidContId);
        },

        /**
         * @override
         */
        validateUserRco: function(rco) {
            var hasSdk = window.google && google.ima,
                sup = this._super(rco),
                ok = hasSdk && !sup.error;

            return {
                error: !ok,
                missingSDK: !hasSdk,
                message: sup.error ? sup.message : "IMA SDK is missing."
            }
        }

    });

}(uvpjs.register('uvpjs')));

/**
 * Created by ldoyle on 12/8/15.
 */
'use strict';

(function (obj) {

    obj.RCO_Mdialog = uvpjs.ResourceConfigObject.subClass({

        /**
         * @constructor uvpjs.ResourceConfigObject.RCO_Mdialog
         *
         * @param {Object} rco
         */
        init: function(rco, id, vidContId) {
            this._super(rco, id, vidContId);
        },

        /**
         * @override
         */
        validateUserRco: function(rco) {
            var sup = this._super(rco);

            return {
                error: sup.error || !uvpjs.util.isDefinedString(rco.assetURL),
                message: sup.err ? sup.message : "Invalid assetURL"
            }
        }

    });

}(uvpjs.register('uvpjs')));


/**
 * Created by ldoyle on 12/8/15.
 */
'use strict';

(function (obj) {

    obj.RCO_Platform = uvpjs.ResourceConfigObject.subClass({

        /**
         * @constructor uvpjs.RCO_Platform
         *
         * @param {Object} rco
         */
        init: function(rco, id, vidContId) {
            this._super(rco, id, vidContId);
        },

        /**
         * @override
         */
        validateUserRco: function(rco) {
            var u = uvpjs.util,
                usesPid = u.isDefinedString(rco.pid),
                mayUseGuid = !usesPid && (u.isDefinedString(rco.cmsRefGuid) && !u.isDefinedString(rco.assetURL)),
                sup = this._super(rco),
                ok = !sup.error && (usesPid || mayUseGuid || u.isDefinedString(rco.selectorCall));

            return {
                error: !ok,
                message: sup.error ? sup.message : "Supplied RCO is not valid for type rp_platform"
            }
        }
    });

}(uvpjs.register('uvpjs')));

(function (obj) {

    'use strict';

    obj.UvpSwfService = uvpjs.Class.subClass({

        /**
         *
         * @param {Object}    options
         * @param {String}    options.debugId
         * @param {Function}  options.readyCallback
         * @param {Element}   options.contentVideoDom
         * @param {Element}   options.playerDom
         * @param {String}    options.containerId
         * @param {String}    options.id3OwnerIds
         * @param {Boolean}   options.capLevelToPlayerSize
         */
        init: function (options) {
            this.debugId = options.debugId;

            this.debug = uvpjs.debug;

            this.containerId = options.containerId;
            this.dom = options.contentVideoDom;
            this.playerDom = options.playerDom;
            this.callback = options.readyCallback;
            this.id3OwnerIds = options.id3OwnerIds || '';
            this.capLevelToPlayerSize = options.capLevelToPlayerSize;

            this.swf = null;
            this.swfName = this.containerId + "UvpSwf";

            this.windowLabels = null;
            this.initTimeoutHandle = null;
            this.svcC = uvpjs.UvpSwfService;

            this.resizeTimeoutHandle = null;

            setTimeout(this.initialize.bind(this), 1);
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @public
         */
        destroy: function() {
            var q;

            this.dom && this.swf && this.dom.removeChild(this.swf);
            this.dom = null;
            this.swf = null;

            this.callback = Function.prototype;

            for (q in this.windowLabels) {
                window[this.windowLabels[q]] = null;
            }
            this.windowLabels = null;
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @return {Object}
         */
        getSwf: function() {
            return this.swf;
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         *
         * @return {ClientRect}
         */
        getContainerSize: function() {
            return this.dom.getBoundingClientRect();
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         */
        resetSize: function () {
            clearTimeout(this.resizeTimeoutHandle);

            this.resizeTimeoutHandle = setTimeout(
                this.setSize.bind(this),
                40
            );
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        setSize: function() {
            var s = this.getContainerSize(),
                w = s.width, h = s.height;

            this.swf && this.swf.setSize(w, h, 0, 0);
        },


        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        playerReadyHandler: function () {
            clearTimeout(this.initTimeoutHandle);

            this.swf = navigator.appName.indexOf("Microsoft") !== -1 ? window[this.swfName] : document[this.swfName];

            this.startTimer();

            this.swf.addEventJSCallback(this.svcC.constant.PLAYER_LOADED_EVENT, this.windowLabels.playerLoaded);
            this.swf.addEventJSCallback(this.svcC.constant.PLUGINS_AVAILABLE, this.windowLabels.pluginsAvailable);
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        playerLoadedHandler: function() {
            this.debug && uvpjs.log(this.debugId, "UvpSwfService: playerLoaded event rec'd from SWF.");

            clearTimeout(this.initTimeoutHandle);

            this.callback(this.swf);
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        pluginsAvailableHandler: function(info) {
            // is empty at present
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        startTimer: function() {
            this.initTimeoutHandle = setTimeout(function() {
                this.callback(null, this.svcC.error.PLAYER_INIT_TIMEOUT)
            }.bind(this), this.svcC.constant.INIT_TIMEOUT);
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        embedCompleteHandler: function (info) {
            if (!info.success) {
                this.callback(null, this.svcC.error.EMBED_FAILED);

                return;
            }
            this.startTimer();
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        embed: function (target) {
            var lbls = this.windowLabels;

            this.svcC.swfobject.embedSWF(
                this.svcC.constant.SWF_URL,
                target,
                '100%',
                '100%',
                "10.3.0",
                false,
                {   /*flashVars*/
                    cfg: 'false',
                    clts: this.capLevelToPlayerSize ? 'true' : 'false',
                    smode: 'fit',
                    jsReady: lbls.jsReady,
                    playerReady: lbls.playerReady,
                    oid: this.id3OwnerIds || ''
                },
                {   /*params*/
                    allowScriptAccess: 'always',
                    allowFullScreen: 'true',
                    scale: 'noscale',
                    salign: 'lt',
                    wmode: 'opaque'
                },
                false, // attrs
                this.embedCompleteHandler.bind(this)
            );
        },

        /**
         * @memberof uvpjs.UvpSwfService#
         * @private
         */
        initialize: function () {
            var dom = this.dom,
                div, v;

            if (!this.svcC.hasFlash()) {
                this.callback(null, this.svcC.error.FLASH_NOT_DETECTED);

                return;
            }

            this.windowLabels = this.svcC.setWindowMethods({
                jsReady: function(){return true;},
                playerReady: this.playerReadyHandler.bind(this),
                playerLoaded:  this.playerLoadedHandler.bind(this),
                pluginsAvailable: this.pluginsAvailableHandler.bind(this)
            });

            // create target in content video dom
            div = document.createElement('div');
            div.id = this.swfName;

            v = dom.querySelector('video');
            v.style.display = 'none';

            dom.style.height = '100%';
            this.playerDom.style.height = '100%';

            dom.insertBefore(div, v);

            this.embed(div);
        }

    });

    obj.UvpSwfService.constant = {
        PLAYER_LOADED_EVENT: 'onPlayerLoaded_cbsi',
        PLUGINS_AVAILABLE: 'pluginsAvailable',
        SWF_URL: '//vidtech.cbsinteractive.com/uvpjs/uvpjsf/js_falback.swf',
        INIT_TIMEOUT: 30000,
        CDN: 'akamai_hd'
    };

    obj.UvpSwfService.error = {
        FLASH_NOT_DETECTED: 'Unable to use Flash; Flash Player not available.',
        EMBED_FAILED: 'Embed of UVP Flash via swfobject failed.',
        PLAYER_INIT_TIMEOUT: 'Player failed to initialize before timeout of 30 sec.'
    };

    /**
     * @memberof uvpjs.UvpSwfService
     * @static
     *
     * @return {boolean}
     */
    obj.UvpSwfService.hasFlash = function() {
        var flashVer = this.swfobject.getFlashPlayerVersion().major;

        return !uvpjs.util.isEmpty(flashVer) && parseInt(flashVer) > 0;
    };

    /**
     * Supplied with an object of names mapped to functions, this method
     * will put those functions in the global scope under random identifiers,
     * which replace the functions in the map returned
     *
     * @example
     * passing in: {
     *      myFoo: function(){console.log('foo');}
     * }
     *
     * will return something like {
     *    myFoo: "f_8fb873a1"
     * }
     *
     * where "f_38735119" is the name of the function in the global scope
     * and can be passed to UVP when registering callbacks, e.g.
     *
     * @memberof uvpjs.UvpSwfService
     * @static
     *
     * @return {Object}
     */
    obj.UvpSwfService.setWindowMethods = function(map) {
        var pre = 'f_',
            u = uvpjs.util,
            q, fn, name;

        // put callback functions in global scope
        for (q in map) {
            fn = map[q];
            name = pre + u.uid8();
            window[name] = fn;
            map[q] = name;
        }

        return map;
    };


    /*
      SWFObject v2.3.20130521 http://github.com/swfobject/swfobject
      Released under the MIT License http://www.opensource.org/licenses/mit-license
    */
    obj.UvpSwfService.swfobject = (function(){
        var D="undefined",r="object",T="Shockwave Flash",Z="ShockwaveFlash.ShockwaveFlash",q="application/x-shockwave-flash",S="SWFObjectExprInst",x="onreadystatechange",Q=window,h=document,t=navigator,V=false,X=[],o=[],P=[],K=[],I,p,E,B,L=false,a=false,m,G,j=true,l=false,O=function(){var ad=typeof h.getElementById!=D&&typeof h.getElementsByTagName!=D&&typeof h.createElement!=D,ak=t.userAgent.toLowerCase(),ab=t.platform.toLowerCase(),ah=ab?/win/.test(ab):/win/.test(ak),af=ab?/mac/.test(ab):/mac/.test(ak),ai=/webkit/.test(ak)?parseFloat(ak.replace(/^.*webkit\/(\d+(\.\d+)?).*$/,"$1")):false,aa=t.appName==="Microsoft Internet Explorer",aj=[0,0,0],ae=null;if(typeof t.plugins!=D&&typeof t.plugins[T]==r){ae=t.plugins[T].description;if(ae&&(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&t.mimeTypes[q].enabledPlugin)){V=true;aa=false;ae=ae.replace(/^.*\s+(\S+\s+\S+$)/,"$1");aj[0]=n(ae.replace(/^(.*)\..*$/,"$1"));aj[1]=n(ae.replace(/^.*\.(.*)\s.*$/,"$1"));aj[2]=/[a-zA-Z]/.test(ae)?n(ae.replace(/^.*[a-zA-Z]+(.*)$/,"$1")):0}}else{if(typeof Q.ActiveXObject!=D){try{var ag=new ActiveXObject(Z);if(ag){ae=ag.GetVariable("$version");if(ae){aa=true;ae=ae.split(" ")[1].split(",");aj=[n(ae[0]),n(ae[1]),n(ae[2])]}}}catch(ac){}}}return{w3:ad,pv:aj,wk:ai,ie:aa,win:ah,mac:af}}(),i=function(){if(!O.w3){return}if((typeof h.readyState!=D&&(h.readyState==="complete"||h.readyState==="interactive"))||(typeof h.readyState==D&&(h.getElementsByTagName("body")[0]||h.body))){f()}if(!L){if(typeof h.addEventListener!=D){h.addEventListener("DOMContentLoaded",f,false)}if(O.ie){h.attachEvent(x,function aa(){if(h.readyState=="complete"){h.detachEvent(x,aa);f()}});if(Q==top){(function ac(){if(L){return}try{h.documentElement.doScroll("left")}catch(ad){setTimeout(ac,0);return}f()}())}}if(O.wk){(function ab(){if(L){return}if(!/loaded|complete/.test(h.readyState)){setTimeout(ab,0);return}f()}())}}}();function f(){if(L||!document.getElementsByTagName("body")[0]){return}try{var ac,ad=C("span");ad.style.display="none";ac=h.getElementsByTagName("body")[0].appendChild(ad);ac.parentNode.removeChild(ac);ac=null;ad=null}catch(ae){return}L=true;var aa=X.length;for(var ab=0;ab<aa;ab++){X[ab]()}}function M(aa){if(L){aa()}else{X[X.length]=aa}}function s(ab){if(typeof Q.addEventListener!=D){Q.addEventListener("load",ab,false)}else{if(typeof h.addEventListener!=D){h.addEventListener("load",ab,false)}else{if(typeof Q.attachEvent!=D){g(Q,"onload",ab)}else{if(typeof Q.onload=="function"){var aa=Q.onload;Q.onload=function(){aa();ab()}}else{Q.onload=ab}}}}}function Y(){var aa=h.getElementsByTagName("body")[0];var ae=C(r);ae.setAttribute("style","visibility: hidden;");ae.setAttribute("type",q);var ad=aa.appendChild(ae);if(ad){var ac=0;(function ab(){if(typeof ad.GetVariable!=D){try{var ag=ad.GetVariable("$version");if(ag){ag=ag.split(" ")[1].split(",");O.pv=[n(ag[0]),n(ag[1]),n(ag[2])]}}catch(af){O.pv=[8,0,0]}}else{if(ac<10){ac++;setTimeout(ab,10);return}}aa.removeChild(ae);ad=null;H()}())}else{H()}}function H(){var aj=o.length;if(aj>0){for(var ai=0;ai<aj;ai++){var ab=o[ai].id;var ae=o[ai].callbackFn;var ad={success:false,id:ab};if(O.pv[0]>0){var ah=c(ab);if(ah){if(F(o[ai].swfVersion)&&!(O.wk&&O.wk<312)){w(ab,true);if(ae){ad.success=true;ad.ref=z(ab);ad.id=ab;ae(ad)}}else{if(o[ai].expressInstall&&A()){var al={};al.data=o[ai].expressInstall;al.width=ah.getAttribute("width")||"0";al.height=ah.getAttribute("height")||"0";if(ah.getAttribute("class")){al.styleclass=ah.getAttribute("class")}if(ah.getAttribute("align")){al.align=ah.getAttribute("align")}var ak={};var aa=ah.getElementsByTagName("param");var af=aa.length;for(var ag=0;ag<af;ag++){if(aa[ag].getAttribute("name").toLowerCase()!="movie"){ak[aa[ag].getAttribute("name")]=aa[ag].getAttribute("value")}}R(al,ak,ab,ae)}else{b(ah);if(ae){ae(ad)}}}}}else{w(ab,true);if(ae){var ac=z(ab);if(ac&&typeof ac.SetVariable!=D){ad.success=true;ad.ref=ac;ad.id=ac.id}ae(ad)}}}}}X[0]=function(){if(V){Y()}else{H()}};function z(ac){var aa=null,ab=c(ac);if(ab&&ab.nodeName.toUpperCase()==="OBJECT"){if(typeof ab.SetVariable!==D){aa=ab}else{aa=ab.getElementsByTagName(r)[0]||ab}}return aa}function A(){return !a&&F("6.0.65")&&(O.win||O.mac)&&!(O.wk&&O.wk<312)}function R(ad,ae,aa,ac){var ah=c(aa);aa=W(aa);a=true;E=ac||null;B={success:false,id:aa};if(ah){if(ah.nodeName.toUpperCase()=="OBJECT"){I=J(ah);p=null}else{I=ah;p=aa}ad.id=S;if(typeof ad.width==D||(!/%$/.test(ad.width)&&n(ad.width)<310)){ad.width="310"}if(typeof ad.height==D||(!/%$/.test(ad.height)&&n(ad.height)<137)){ad.height="137"}var ag=O.ie?"ActiveX":"PlugIn",af="MMredirectURL="+encodeURIComponent(Q.location.toString().replace(/&/g,"%26"))+"&MMplayerType="+ag+"&MMdoctitle="+encodeURIComponent(h.title.slice(0,47)+" - Flash Player Installation");if(typeof ae.flashvars!=D){ae.flashvars+="&"+af}else{ae.flashvars=af}if(O.ie&&ah.readyState!=4){var ab=C("div");
            aa+="SWFObjectNew";ab.setAttribute("id",aa);ah.parentNode.insertBefore(ab,ah);ah.style.display="none";y(ah)}u(ad,ae,aa)}}function b(ab){if(O.ie&&ab.readyState!=4){ab.style.display="none";var aa=C("div");ab.parentNode.insertBefore(aa,ab);aa.parentNode.replaceChild(J(ab),aa);y(ab)}else{ab.parentNode.replaceChild(J(ab),ab)}}function J(af){var ae=C("div");if(O.win&&O.ie){ae.innerHTML=af.innerHTML}else{var ab=af.getElementsByTagName(r)[0];if(ab){var ag=ab.childNodes;if(ag){var aa=ag.length;for(var ad=0;ad<aa;ad++){if(!(ag[ad].nodeType==1&&ag[ad].nodeName=="PARAM")&&!(ag[ad].nodeType==8)){ae.appendChild(ag[ad].cloneNode(true))}}}}}return ae}function k(aa,ab){var ac=C("div");ac.innerHTML="<object classid='clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'><param name='movie' value='"+aa+"'>"+ab+"</object>";return ac.firstChild}function u(ai,ag,ab){var aa,ad=c(ab);ab=W(ab);if(O.wk&&O.wk<312){return aa}if(ad){var ac=(O.ie)?C("div"):C(r),af,ah,ae;if(typeof ai.id==D){ai.id=ab}for(ae in ag){if(ag.hasOwnProperty(ae)&&ae.toLowerCase()!=="movie"){e(ac,ae,ag[ae])}}if(O.ie){ac=k(ai.data,ac.innerHTML)}for(af in ai){if(ai.hasOwnProperty(af)){ah=af.toLowerCase();if(ah==="styleclass"){ac.setAttribute("class",ai[af])}else{if(ah!=="classid"&&ah!=="data"){ac.setAttribute(af,ai[af])}}}}if(O.ie){P[P.length]=ai.id}else{ac.setAttribute("type",q);ac.setAttribute("data",ai.data)}ad.parentNode.replaceChild(ac,ad);aa=ac}return aa}function e(ac,aa,ab){var ad=C("param");ad.setAttribute("name",aa);ad.setAttribute("value",ab);ac.appendChild(ad)}function y(ac){var ab=c(ac);if(ab&&ab.nodeName.toUpperCase()=="OBJECT"){if(O.ie){ab.style.display="none";(function aa(){if(ab.readyState==4){for(var ad in ab){if(typeof ab[ad]=="function"){ab[ad]=null}}ab.parentNode.removeChild(ab)}else{setTimeout(aa,10)}}())}else{ab.parentNode.removeChild(ab)}}}function U(aa){return(aa&&aa.nodeType&&aa.nodeType===1)}function W(aa){return(U(aa))?aa.id:aa}function c(ac){if(U(ac)){return ac}var aa=null;try{aa=h.getElementById(ac)}catch(ab){}return aa}function C(aa){return h.createElement(aa)}function n(aa){return parseInt(aa,10)}function g(ac,aa,ab){ac.attachEvent(aa,ab);K[K.length]=[ac,aa,ab]}function F(ac){ac+="";var ab=O.pv,aa=ac.split(".");aa[0]=n(aa[0]);aa[1]=n(aa[1])||0;aa[2]=n(aa[2])||0;return(ab[0]>aa[0]||(ab[0]==aa[0]&&ab[1]>aa[1])||(ab[0]==aa[0]&&ab[1]==aa[1]&&ab[2]>=aa[2]))?true:false}function v(af,ab,ag,ae){var ad=h.getElementsByTagName("head")[0];if(!ad){return}var aa=(typeof ag=="string")?ag:"screen";if(ae){m=null;G=null}if(!m||G!=aa){var ac=C("style");ac.setAttribute("type","text/css");ac.setAttribute("media",aa);m=ad.appendChild(ac);if(O.ie&&typeof h.styleSheets!=D&&h.styleSheets.length>0){m=h.styleSheets[h.styleSheets.length-1]}G=aa}if(m){if(typeof m.addRule!=D){m.addRule(af,ab)}else{if(typeof h.createTextNode!=D){m.appendChild(h.createTextNode(af+" {"+ab+"}"))}}}}function w(ad,aa){if(!j){return}var ab=aa?"visible":"hidden",ac=c(ad);if(L&&ac){ac.style.visibility=ab}else{if(typeof ad==="string"){v("#"+ad,"visibility:"+ab)}}}function N(ab){var ac=/[\\\"<>\.;]/;var aa=ac.exec(ab)!=null;return aa&&typeof encodeURIComponent!=D?encodeURIComponent(ab):ab}var d=function(){if(O.ie){window.attachEvent("onunload",function(){var af=K.length;for(var ae=0;ae<af;ae++){K[ae][0].detachEvent(K[ae][1],K[ae][2])}var ac=P.length;for(var ad=0;ad<ac;ad++){y(P[ad])}for(var ab in O){O[ab]=null}O=null;for(var aa in swfobject){swfobject[aa]=null}swfobject=null})}}();return{registerObject:function(ae,aa,ad,ac){if(O.w3&&ae&&aa){var ab={};ab.id=ae;ab.swfVersion=aa;ab.expressInstall=ad;ab.callbackFn=ac;o[o.length]=ab;w(ae,false)}else{if(ac){ac({success:false,id:ae})}}},getObjectById:function(aa){if(O.w3){return z(aa)}},embedSWF:function(af,al,ai,ak,ab,ae,ad,ah,aj,ag){var ac=W(al),aa={success:false,id:ac};if(O.w3&&!(O.wk&&O.wk<312)&&af&&al&&ai&&ak&&ab){w(ac,false);M(function(){ai+="";ak+="";var an={};if(aj&&typeof aj===r){for(var aq in aj){an[aq]=aj[aq]}}an.data=af;an.width=ai;an.height=ak;var ar={};if(ah&&typeof ah===r){for(var ao in ah){ar[ao]=ah[ao]}}if(ad&&typeof ad===r){for(var am in ad){if(ad.hasOwnProperty(am)){var ap=(l)?encodeURIComponent(am):am,at=(l)?encodeURIComponent(ad[am]):ad[am];if(typeof ar.flashvars!=D){ar.flashvars+="&"+ap+"="+at}else{ar.flashvars=ap+"="+at}}}}if(F(ab)){var au=u(an,ar,al);if(an.id==ac){w(ac,true)}aa.success=true;aa.ref=au;aa.id=au.id}else{if(ae&&A()){an.data=ae;R(an,ar,al,ag);return}else{w(ac,true)}}if(ag){ag(aa)}})}else{if(ag){ag(aa)}}},switchOffAutoHideShow:function(){j=false},enableUriEncoding:function(aa){l=(typeof aa===D)?true:aa},ua:O,getFlashPlayerVersion:function(){return{major:O.pv[0],minor:O.pv[1],release:O.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(ac,ab,aa){if(O.w3){return u(ac,ab,aa)}else{return undefined}},showExpressInstall:function(ac,ad,aa,ab){if(O.w3&&A()){R(ac,ad,aa,ab)}},removeSWF:function(aa){if(O.w3){y(aa)}},createCSS:function(ad,ac,ab,aa){if(O.w3){v(ad,ac,ab,aa)}},addDomLoadEvent:M,addLoadEvent:s,getQueryParamValue:function(ad){var ac=h.location.search||h.location.hash;
            if(ac){if(/\?/.test(ac)){ac=ac.split("?")[1]}if(ad==null){return N(ac)}var ab=ac.split("&");for(var aa=0;aa<ab.length;aa++){if(ab[aa].substring(0,ab[aa].indexOf("="))==ad){return N(ab[aa].substring((ab[aa].indexOf("=")+1)))}}}return""},expressInstallCallback:function(){if(a){var aa=c(S);if(aa&&I){aa.parentNode.replaceChild(I,aa);if(p){w(p,true);if(O.ie){I.style.display="block"}}if(E){E(B)}}a=false}},version:"2.3"}
    }());

}(uvpjs.register('uvpjs')));

/**
 * Created by ldoyle on 8/11/15.
 */
'use strict';

(function (obj) {

    var _ = obj._;

    /*
     * 'RESOURCE PROVIDERS MANAGE AND DISPATCH LIFECYCLE EVENTS'<br>
     *
     * Resource Provider will be subclassed to service specific use cases: RP_URL RP_mDialog, RP_IMA, PR_Platform, etc.<br>
     - RP_URL =  “rp_url”<br>
     - RP_PLATFORM = “rp_platform”<br>
     - RP_IMA = “rp_ima”<br>
     - RP_MDIALOG = “rp_mDialog”<br>
     - state:UNPLAYED, PLAYING, PLAYED<br>

     Resource Providers activate in two stages:<br>
     1) load data and notify RPM dataloadedCallback when done <br>
     2) RPM tells RP to loadAndPlayVideo.<br>
     This allows Resource Providers to spin up their own child RP to gather data. ie RP_IMA creates an RP_PLATFORM to collect SMIL metatdata.<br>
     <br>
     Resource Provider manages the low level 'LowLife tm' video player(s) required playing the video bits.
     LowLife candidates include HTML5, SWF! (ads and live streams), DASH MSE,<br>

     Resource Provider 'RP', its job is to gather Video State and Playback State.<br>
     - Gathers video state, hold it temporarily, then when playback is about to begin initializes the Model with the new Video State.<br>
     - The Model can access state via method calls, including the case where the RP dispatches an event and the Model callback for that event uses the RP ref in the event.data to update state.<br>
     - Ensures correct metadata is maintained for video playback.<br>
     - Has Facade callbacks for low-level video events: play, pause, buffer, stop, done, seek, videotime, ID3 tags?<br>
     - manages ad pod objects<br>
     - Tells Resource Playlist Manager when a resource starts and ends so the Resource Playlist Manager can dispatch RESOURCE_START and RESOURCE_END events.<br>
     <br>
     1) CONTENT_START - playback event time marker (ACTUALLY segment start, should include segment number)-<br>
     - dispatch at the begining of the content video, after an ad pod ends and content restarts<br>
     - But not resuming after a pause or seek unless resuming after playing an ad pod encountered during the seek.<br>

     2) CONTENT_END -<br>

     3) AD_START - data contains new ad video metadata for Model to pick up.<br>

     4) new event AD_POD_START .data is currAdPod object with:<br>
     - number of ads, pod duration, pod position, pod start time aka chapter time, podType pre, mid, post<br>
     - model will capture this info<br>
     - AD_PLUGIN_CONTENT_PAUSE_REQUEST new event... be aware<br>

     5) AD_POD_END - (send on IMA Content Resume Request) NEW EVENT!<br>

     6) AD_PLUGIN_CONTENT_RESUME_REQUEST new event...<br>
     */

    obj.ResourceProvider = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PROVIDER,

        /**
         * @constructor uvpjs.ResourceProvider
         * @description Resource providers manage and dispatch lifecycle events
         *
         *
         * @param {Object} options
         * @param {Object} options.rco
         * @param {uvpjs.CoreVideoInstanceManager} options.cviMgr
         * @param {String} options.vidContId
         * @param {uvpjs.P2pClient} options.p2pClient
         * @param {Object} options.containers  holds playerDom and contentVideoDom
         * @param {Object} options.multiCdnClient
         * @param {Boolean} options.deferLoadingCaptions
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            this.vidContId = '';
            this.containers = options.containers;
            this.internalNS = '';
            this.rco = {};
            this.contentDataProxy = null;

            this.cviMgr = {};
            this.eventsMgr = {};
            this.cviModel = {};

            this.RPM = {};
            this.metadata = {};
            this.facade = {};
            this.dataLoadedCB = Function.prototype;
            this.dataLoadErrorCB = Function.prototype;
            this.errorInfo =  null;
            this.contentStartOpen = false;

            this.uvpSwfService = null;

            this._previousLocalStorageTime = 0;
            this._previousResumeBeaconTime = 0;
            this._localStorageInterval = 3000;   // milliseconds 3000 = 3 second interval;
            this.preloadContent = false;
            this.bufferingDetected = null;
            this.bufferingCheckInterval = 1000;
            this.bufferingCheckOffset = 1/this.bufferingCheckInterval;
            this.bufferingCheckLastTime = 0;

            this.deferLoadingCaptions = options.deferLoadingCaptions;

            this.id3HandlingEnabled = false;
            this.id3Parser = null;
            this.id3EventQueue = null;

            this.p2pClient = options.p2pClient;
            this.multiCdnClient = options.multiCdnClient;

            this.suppressFacadePlay = false;
            this._overrideAssetUrlFailure = false;

            this.mc = uvpjs.mediaCapabilities;

            this.providerType = '';

            this._seekToTime = null;
            this._seekFromTime = null;

            this.initialize(options.rco, options.cviMgr, options.vidContId);
        },

        /**
         * @param {Object} rcObj - Validated Resource Config Object.
         * @param {uvpjs.CoreVideoInstanceManager} cviMgr - Validated Core Video Instance Manager.
         * @param {String} vidContId - Validated Video Container Tag Element ID.
         */
        initialize: function (rcObj, cviMgr, vidContId) {
            var cvs;

            this.debug && uvpjs.log(this.DEBUG_ID, 'initialize rcObj = ', rcObj);

            this.rco = rcObj;
            this.vidContId = vidContId;
            this.cviMgr = cviMgr;
            this.eventsMgr = this.cviMgr.getEventsMgr();
            this.cviModel = this.cviMgr.getModelRef();
            this.RPM = this.cviMgr.RPM;
            this.internalNS = '.' + this.vidContId + '.rp';

            cvs = this.cviModel.contentVideoState;

            // Global and Local Resume cbs.com
            cvs.sendResumeEvent = false;
            cvs.startTime = 0;
            cvs.elapsedTime = 0;
            cvs.showPreroll = true; // ? TODO (djl) - why is this initialized to TRUE in this base class?
            cvs.playedChapterTime = 0;
            cvs.previousSessionId = '';

            // create data proxy (populated with contentVideoState defaults)
            this.contentDataProxy = new uvpjs.ContentDataProxy({
                defaults: this.cviModel.contentVideoStateDefaults,
                eventsManager: this.eventsMgr
            });

            if (!_.isUndefined(this.cviModel.sessionOptions.resumeBeaconInterval)) {
                // sessionOptions.resumeBeaconInterval is in seconds, convert to milliseconds.
                this._resumeBeaconInterval = this.cviModel.sessionOptions.resumeBeaconInterval * 1000;
            }
            else {
                this._resumeBeaconInterval = 10000; // default 10 second intervals
            }

            this.id3HandlingEnabled = this.cviModel.isId3HandlingRequired();
        },

        /**
         * Returns the type of this provider
         * @memberof uvpjs.ResourceProvider#
         *
         * @returns {String}
         */
        getProviderType: function() {
            return this.providerType;
        },

        /**
         * Add a timer callback to trigger VIDEO_PROGRESS events.
         * @memberof uvpjs.ResourceProvider#
         */
        _addVideoProgressTimerCallback: function () {
            var em = this.eventsMgr;

            this._removeTimers();

            em.addTimedEventCallback(em.TENTH_SECOND, this.internalNS, this.onUVPJSTimerTick.bind(this));
            em.addTimedEventCallback(this.bufferingCheckInterval, this.internalNS, this.checkBuffering.bind(this));
        },

        /**
         * @memberof uvpjs.ResourcePlaylistManager#
         * @param {array} propArr
         */
        setCaptionStyle: function(propArr) {
            // hack for flash
            this._hasFacade() && this.facade.setCaptionStyle && this.facade.setCaptionStyle(propArr);
        },

        /**
         * Remove a timer callback for VIDEO_PROGRESS events.
         * @memberof uvpjs.ResourceProvider#
         */
        _removeTimers: function () {
            var em = this.eventsMgr;

            em.removeTimedEventCallback(em.TENTH_SECOND, this.internalNS);
            em.removeTimedEventCallback(this.bufferingCheckInterval, this.internalNS);
        },

        /**
         * Cleans up Resource Provider.
         *
         * @memberof uvpjs.ResourceProvider
         */
        cleanUp: function () {
            var seed = this.rco && this.rco.rcoSeed;

            this.debug && uvpjs.log(this.DEBUG_ID, 'cleanUp dispatches CONTENT_END', this.rco ? this.rco.id : "No current RCO.");

            this.dispatchVideoDone();

            this.id3Parser && this.id3Parser.destroy();
            this.id3Parser = null;

            if (this.contentStartOpen) {
                this.contentStartOpen = false;
                this.dispatchContentEnd();
            }

            this.p2pClient && this.p2pClient.destroy();
            this.multiCdnClient && this.multiCdnClient.destroy();

            this.p2pClient = null;
            this.multiCdnClient = null;

            this._removeTimers();
            this._removeUVPEventListeners();

            this.destroyFacade();

            this.cleanUpObjects();
            this.killDataProxy();

            this.RPM.resourceEnd(seed);
        },

        /**
         * @memberof uvpjs.ResourceProvider
         */
        cleanUpObjects: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'cleanUpObjects');

            this.removeCaptionEventListeners();

            if (this.uvpSwfService) {
                this.eventsMgr.removeEventListener(this.eventsMgr.eventTypes.CONTAINER_RESIZE + this.internalNS);
                this.uvpSwfService && this.uvpSwfService.destroy();
                this.uvpSwfService = null;
            }

            this.vidContId = null;
            this.internalNS = null;
            this.rco = null;
            this.cviMgr = null;
            this.eventsMgr = null;
            this.cviModel = null;
            this.metadata = null;
            this.facade = {};
            this.dataLoadedCB = Function.prototype;
            this.dataLoadErrorCB = Function.prototype;
            this.errorInfo = null;
            this._overrideAssetUrlFailure = false;
            this._seekToTime = null;
            this._seekFromTime = null;
        },

        /**
         * Kills the ContentDataProxy isntance
         * @memberof uvpjs.ResourceProvider
         */
        killDataProxy: function() {
            this.contentDataProxy && this.contentDataProxy.destroy();
            this.contentDataProxy = null;
        },

        /**
         * Create, initialize, and play a Video Facade only after loading the
         * metadata and in this method resetting the CVI_Model.
         *
         * IMPORTANT: Use CVI_Model for Video State and Playback State.
         *
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Boolean} suppressFacadePlay - if true, facade.playVideo will not be invoked.  (This is to support
         * native iOS autplay behavior)
         */
        loadVideoAndBeginPlayback: function (suppressFacadePlay) {
            var mdl = this.cviModel;

            this.debug && uvpjs.log(this.DEBUG_ID, 'loadVideoAndBeginPlayback vidContId, rco', this.vidContId, this.rco);

            // 1) overwrite with content model (that may be derived from thePlatform data)
            // 2) overwrite CVI Content Video with RCO values.
            // 3) merge Config Data Object (CDO) data into the content state and ad state objects.
            mdl.setNonDefaultContentVideoStateItems(this.contentDataProxy.getModel()); // 1
            mdl.setContentVideoStateItems(this.rco); // 2
            this.setModelRcoOverrides(); // 2
            mdl.mergeCDOData(); // 3
            this.killDataProxy(); // no longer needed
            this.suppressFacadePlay = suppressFacadePlay;

            if (this.multiCdnClient) {
                this.multiCdnClient.getDecision(this.handleCdnDecision.bind(this, null));
            }
            else {
                this.doFlashCheck(null);
            }
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @protected
         *
         * @param {*} xtra pre-supplied arg, if applicable
         */
        doFlashCheck: function(xtra) {
            if (!this.shouldUseFlash()) {
                this.finishLoadVideoAndBeginPlayback(xtra);
            }
            else {
                this.cviModel.contentVideoState.isFlash = true;
                this.cviModel.contentVideoState.cdn = uvpjs.UvpSwfService.constant.CDN;
                this.prepForCaptionEvents();

                this.uvpSwfService = new uvpjs.UvpSwfService({
                    capLevelToPlayerSize: this.rco.capLevelToPlayerSize === true,
                    debugId: this.DEBUG_ID,
                    containerId: this.vidContId,
                    id3OwnerIds: this.cviModel.getConfiguredId3OwnerIds(),
                    contentVideoDom: this.containers.contentVideoDom,
                    playerDom: this.containers.playerDom,
                    readyCallback: this.handleUvpFlashPlayerLoaded.bind(this, xtra)
                });

                this.eventsMgr.addEventListener(
                    this.eventsMgr.eventTypes.CONTAINER_RESIZE + this.internalNS,
                    this.handleContainerResizeForFlash.bind(this)
                );
            }
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @private
         */
        handleContainerResizeForFlash: function() {
            this.uvpSwfService.resetSize();
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @protected
         *
         * @param {*} xtra  an optinal pre-supplied argument
         * @param {Object} swf reference to UVP Flash swf
         * @param {Number} error
         */
        handleUvpFlashPlayerLoaded: function(xtra, swf, error) {
            var ei = uvpjs.ErrorInfo, e;

            if (error) {
                e = new ei({
                    errorCode: ei.errorCodes.FLASH_RELATED_ERROR,
                    message: 'Unable to use Flash: ' + error,
                    isFatal: true
                });

                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.PLAYER_START_ERROR,
                    { errorInfo: e},
                    this.vidContId
                );

                return;
            }

            setTimeout(this.finishLoadVideoAndBeginPlayback.bind(this, xtra), 2);
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @protected
         * @param {*}       xtra       pre-supplied arg, if applicable
         * @param {Object} decisionObj
         */
        handleCdnDecision: function(xtra, decisionObj) {
            this.setNewAssetUrlAndCdn(decisionObj);
            this.doFlashCheck(xtra);
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @private
         */
        shouldUseFlash: function() {
            var si = this.mc.systemInfo,
                prevented = this.cviModel.getSessionOption('preventFlashPlayback'),
                canUseHls = si.supportsNativeHls || si.isHlsjsEligible,
                canUseFlash = !prevented && si.isDesktop && uvpjs.UvpSwfService.hasFlash(),
                isHls = this.mc.isHlsUrl(this._getAssetUrl()),
                env = uvpjs.Configuration.env;

            if ((env === 'local' || env === 'dev' || env === 'stage') &&
                window.forceFlash && canUseFlash) {
                return true;
            }

            return isHls && !canUseHls && canUseFlash;
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @private
         */
        prepForCaptionEvents: function () {
            var et = this.eventsMgr.eventTypes,
                list = [et.CONTROL_HIDE_CAPTIONS, et.CONTROL_SHOW_CAPTIONS, et.CAPTIONS_READY],
                i = list.length;

            while (i--) {
                this.eventsMgr.addEventListener(list[i] + this.internalNS, this.hCaptionEventForUvpFlash.bind(this));
            }
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @private
         */
        removeCaptionEventListeners: function() {
            var et = this.eventsMgr.eventTypes,
                list = [et.CONTROL_HIDE_CAPTIONS, et.CONTROL_SHOW_CAPTIONS, et.CAPTIONS_READY],
                i = list.length;

            while (i--) {
                this.eventsMgr.removeEventListener(list[i] + this.internalNS);
            }
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @private
         *
         * @param {Object} e
         */
        hCaptionEventForUvpFlash: function (e) {
            var et = this.eventsMgr.eventTypes;

            if (!this._hasFacade() || e.target !== this.vidContId) return;

            switch (e.type) {
                case et.CAPTIONS_READY:
                    this.facade.loadCaptions(this.cviModel.contentVideoState.closedCaptionPath);
                    break;

                case et.CONTROL_SHOW_CAPTIONS:
                    this.facade.showCaptions();
                    break;

                case et.CONTROL_HIDE_CAPTIONS:
                    this.facade.hideCaptions();
                    break;

                default: break;
            }
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @protected
         *
         * @param {*}  xtra
         */
        finishLoadVideoAndBeginPlayback: function (xtra) {
            var mdl = this.cviModel,
                type;

            this.cviMgr.setPlaybackInfoOnModel();
            this.cviMgr.setContextMetadata(this.rco.getContextMetadata());

            this.dispatchContentDataLoaded();
            this.RPM.resourceStart(this.rco.rcoSeed);
            this._addUVPEventListeners();

            mdl.incrementMedNum();

            this.createFacade();

            type = this.facade.facadeType;
            this.id3HandlingEnabled && this.createId3Parser(type);

            if (this.suppressFacadePlay !== true) {
                this.facade.showVideo();
                this.facade.playVideo();
            }

            if (type === this.mc.FLASH_HLS) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.CAPTIONS_READY,
                    { vidState: this.cviModel.getContentVideoState()},
                    this.vidContId
                );
            }
        },

        /**
         * @memberof uvpjs.RP_Platform#
         */
        dispatchContentDataLoaded: function () {
            this.eventsMgr.dispatchEvent(
                this.eventsMgr.eventTypes.CONTENT_DATA_LOADED,
                { vidState: this.cviModel.getContentVideoState()},
                this.vidContId
            );
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @protected
         */
        setNewAssetUrlAndCdn: function(decisionObj) {
            var plist = (decisionObj && decisionObj.providers) || null,
                p = plist && plist[0] ? plist[0] : null,
                host = (p && p.host) || null,
                cdn = (p && p.provider) || null,
                assetUrl, uinfo, newUrl;

            if (host) {
                assetUrl = this._getAssetUrl();
                uinfo = uvpjs.util.parseUrl(assetUrl);

                if (host !== uinfo.host) {
                    newUrl = uinfo.protocol + '//' + host + uinfo.pathname + uinfo.search;
                    this.cviModel.contentVideoState.assetURL = newUrl;
                }
            }
            if (cdn) {
                this.cviModel.contentVideoState.cdn = cdn;
            }
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @private
         */
        setModelRcoOverrides: function() {

            var mdl = this.cviModel,
                soStart = Number(mdl.getSessionOption('startBitrate')) || -1,
                soMin = Number(mdl.getSessionOption('minBitrate')) || -1,
                soMax = Number(mdl.getSessionOption('maxBitrate')) || -1,
                soLiveSync = Number(mdl.getSessionOption('liveSyncDurationCount')) || -1,
                soCap = !!mdl.getSessionOption('capLevelToPlayerSize'),
                soFastSwitch = !!mdl.getSessionOption('enableDashJSFastSwitchABR'),
                soAutoABR = mdl.getSessionOption("useDynamicSwitching"),
                rcStart = Number(this.rco.startBitrate) || -1,
                rcMin = Number(this.rco.minBitrate) || -1,
                rcMax = Number(this.rco.maxBitrate) || -1,
                rcLiveSync = Number(this.rco.liveSyncDurationCount) || -1,
                rcCap = this.rco.capLevelToPlayerSize,
                rcFastSwitch = this.rco.enableDashJSFastSwitchABR,
                rcAutoABR = this.rco.useDynamicSwitching;

            // else clauses do 'reset' to session option value
            if(rcStart > -1) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Override Start Bitrate w RCO Value:', rcStart);
                mdl.setStartBitrate(rcStart);
            }
            else {
                mdl.setStartBitrate(soStart);
            }

            if(rcMin > -1) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Override Min Bitrate w RCO Value:', rcMin);
                mdl.setMinBitrate(rcMin);
            }
            else {
                mdl.setMinBitrate(soMin);
            }

            if(rcMax > -1) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Override Max Bitrate w RCO Value:', rcMax);
                mdl.setMaxBitrate(rcMax);
            }
            else {
                mdl.setMaxBitrate(soMax);
            }

            if(rcLiveSync > -1) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Override Live Sync Duration Count w RCO Value:', rcLiveSync);
                mdl.setLiveSyncDurationCount(rcLiveSync);
            }
            else {
                mdl.setLiveSyncDurationCount(soLiveSync);
            }

            if(typeof rcCap === 'boolean') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Override Cap Level To Player Size w RCO Value:', rcCap);
                mdl.setCapLevelToPlayerSize(rcCap);
            }
            else {
                mdl.setCapLevelToPlayerSize(soCap);
            }

            if(typeof rcFastSwitch === 'boolean') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Override FastSwitch ABR value w RCO Value:', rcFastSwitch);
                mdl.setDashJSFastSwitchABR(rcFastSwitch);
            }
            else {
                mdl.setDashJSFastSwitchABR(soFastSwitch);
            }

            if(typeof rcAutoABR === 'boolean') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Override useDynamicABR value w RCO Value:', rcAutoABR);
                mdl.setUseDynamicSwitching(rcAutoABR);
            }
            else {
                mdl.setUseDynamicSwitching(soAutoABR);
            }
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @private
         *
         * @param {String} facadeType facade.facadeType
         */
        createId3Parser: function(facadeType) {
            // Parsers may need to vary according to facade type.
            this.id3EventQueue = [];
            var id3ParserOptions = {
                ownerIdList: this.cviModel.getConfiguredId3OwnerIds(),
                findNielsen: this.cviModel.isNielsenTrackingEnabled(),
                dataCallback: this.handleId3Metadata.bind(this)
            };

            switch (facadeType) {

                case this.mc.HLSJS:
                    this.id3Parser = new uvpjs.FrameId3Parser(id3ParserOptions);
                    break;

                case this.mc.HTML5:
                    this.id3Parser = new uvpjs.TrackId3Parser(id3ParserOptions);
                    break;

                case this.mc.FLASH_HLS:
                    id3ParserOptions.dataCallback = this.dispatchCuepointEvent.bind(this);
                    this.facade.setId3Options(id3ParserOptions);
                    break;
            }

        },


        /**
         * Data callback with ID3 data from id3Parser
         * @param {Object} data
         */
        handleId3Metadata: function(data) {
            // these objects are queued because they're received in advance
            // of when the segment with the data actually plays back. See also checkId3Events() below.
            this.id3EventQueue && this.id3EventQueue.push(data);
        },

        /**
         * Checks video current time (supplied as an arg) against id3 tag time (pts) values in queued data
         * If PTS is <= current video time, cuepoint event is dispatched
         * @param {Number} time
         */
        checkId3Events: function(time) {
            var q = this.id3EventQueue,
                i = (q && q.length) || 0, data;

            while (i--) {
                data = q[i];
                if (time >= data.pts) {
                    this.dispatchCuepointEvent(data);
                    this.id3EventQueue.splice(i, 1);
                }
            }
        },

        /**
         *
         * @param {Object} data
         * @param {Object} data.name
         * @param {Object} data.data
         */
        dispatchCuepointEvent: function (data) {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.VIDEO_CUEPOINT, data, this.vidContId);
        },

        /**
         * Create and initialize facade.
         *
         * @memberof uvpjs.ResourceProvider#
         *
         */
        createFacade: function () {
            var mdl = this.cviModel,
                vs = mdl.getContentVideoState(),
                assetURL = this._getAssetUrl(),
                options = {
                    enableId3Handling: this.id3HandlingEnabled,
                    assetURL: assetURL,
                    isMuted: mdl.isMuted,
                    resourceProvider: this,
                    startTime: vs.startTime,
                    startBitrate: mdl.startBitrate,
                    maxBitrate: mdl.maxBitrate,
                    minBitrate: mdl.minBitrate,
                    useDynamicSwitching: mdl.useDynamicSwitching,
                    liveSyncDurationCount: mdl.liveSyncDurationCount,
                    volume: mdl.volume,
                    capLevelToPlayerSize: mdl.capLevelToPlayerSize,
                    enableDashJSFastSwitchABR: mdl.enableDashJSFastSwitchABR,
                    deferLoadingCaptions: this.deferLoadingCaptions,
                    drm: vs.drm
                };

            this.debug && uvpjs.log(this.DEBUG_ID, 'createFacade', options);

            this.facade = this.getFacade(assetURL);

            if (this.facade.facadeType === this.mc.HLSJS && this.p2pClient) {
                options.hlsjsLoader = this.p2pClient.getHlsjsLoader();
            }

            if (this.facade.facadeType === this.mc.FLASH_HLS) {
                options.swfService = this.uvpSwfService;
            }

            this.facade.initialize(options);

            this.facade.manageNativeControls(mdl.nativeControls);
        },

        /**
         * Destroy facade instance.
         *
         * @memberof uvpjs.ResourceProvider#
         *
         */
        destroyFacade: function () {
            var destroyable = this._hasFacade() && typeof this.facade.destroy === 'function';

            this.debug && uvpjs.log(this.DEBUG_ID, 'destroyFacade');

            if (!destroyable) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Facade already cleaned up.');
                return;
            }

            this.facade.destroy();
            this.facade = {};
        },

        /**
         * Mutes video while ad is playing separately
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Boolean} flag
         */
        muteContentForAdPlay: function (flag) {
            var mdl = this.cviModel,
                facade = this.facade;

            if (!this._hasFacade()) {
                return;
            }

            if (flag !== false) {
                facade.muteVideo();
            }
            else if (!mdl.isMuted) {
                facade.unMuteVideo();
            }
        },

        /**
         * Returns a config module if exists
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {String} moduleName
         *
         * @returns {Object}
         */
        getModule: function (moduleName) {
            return this.cviModel.getModule(moduleName);
        },

        /**
         * Returns value of a config module param, if exists
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {String} moduleName
         * @param {String} param
         *
         * @returns {*}
         */
        getModuleParam: function (moduleName, param) {
            return this.cviModel.getModuleParam(moduleName, param);
        },

        /**
         * Returns whether to create a watermark.
         *
         * @memberof uvpjs.ResourceProvider#
         *
         * @returns {Boolean}
         */
        createWatermark: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'createWatermark');

            return this.cviModel.contentVideoState.useWatermark;
        },

        /**
         * Returns whether the current video should be displayed as 360
         *
         * @memberof uvpjs.ResourceProvider#
         *
         * @returns {Boolean}
         */
        is360: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'is360');

            return this.cviModel.contentVideoState.is360;
        },

        /**
         * Starts the Video Progress event timer.
         * @memberof uvpjs.ResourceProvider#
         */
        startVideoProgressTimer: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'startVideoProgressTimer');

            // fires the first content VIDEO_PROGRESS event so the CVI_Model
            // Content Video State is properly populated when CONTENT_START is dispatched.
            this.onUVPJSTimerTick();

            this._addVideoProgressTimerCallback();
        },

        /**
         * Dispatches a CONTENT_START event with payload {contentData: ContentVideoState()}.
         * @memberof uvpjs.ResourceProvider#
         */
        dispatchContentStart: function () {
            var state = this.cviModel.getContentVideoState();
            this.debug && uvpjs.log(this.DEBUG_ID, 'CONTENT_START; state = ', state);

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTENT_START, {contentData: state}, this.vidContId);
        },

        /**
         * Dispatches a CONTENT_END event with payload {contentData: ContentVideoState()}.
         * @memberof uvpjs.ResourceProvider#
         */
        dispatchContentEnd: function () {
            var state = this.cviModel.getContentVideoState();
            this.debug && uvpjs.log(this.DEBUG_ID, 'CONTENT_END; state = ', state);

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTENT_END, {contentData: state}, this.vidContId);
        },

        /**
         * Dispatch SEEK_DONE event.
         *
         * @memberof uvpjs.ResourceProvider#
         */
        dispatchSeekDone: function () {
            var em = this.eventsMgr;

            em.dispatchEvent(em.eventTypes.SEEK_DONE, {
                seekFromTime: this._seekFromTime,
                seekToTime: this._seekToTime
            }, this.vidContId);

            this._seekToTime = null;
            this._seekFromTime = null;

        },

        /**
         * Dispatches VIDEO_DONE event.
         * @memberof uvpjs.ResourceProvider#
         */
        dispatchVideoDone: function () {
            var isFatalError = this.cviModel && this.cviModel.contentPlaybackState.fatalError,
                xtraMsg = isFatalError ? 'Fatal ERROR encountered' : '';

            this.debug && uvpjs.log(this.DEBUG_ID, 'About to dispatch Video Done. ' + xtraMsg);

            !isFatalError && this.clearLocalStorageItems();
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.VIDEO_DONE, {}, this.vidContId);
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @param {Number} newState
         */
        dispatchVideoStateChange: function (newState) {
            if (!isNaN(newState)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.VIDEO_STATE_CHANGE, {
                    newState: newState,
                    isAd: false
                }, this.vidContId);
            }
        },

        /////////////////////
        // Facade interface

        /**
         * Called if the promise returned by videoEl.play() encounters an error (i.e., if a promise is returned).
         * @memberof uvpjs.ResourceProvider#
         */
        facadeBrowserPlayFailure: function(msg) {
            this.eventsMgr.dispatchEvent(
                this.eventsMgr.eventTypes.VIDEO_START_ERROR,
                {
                    errorInfo: new uvpjs.ErrorInfo({
                        eventType: this.eventsMgr.eventTypes.VIDEO_START_ERROR,
                        errorCode: uvpjs.ErrorInfo.errorCodes.USER_GESTURE_REQUIRED,
                        message: "Browser autoplay policy may be preventing video play: " + msg,
                        isFatal: false
                    })
                },
                this.vidContId
            );
        },

        /**
         * Called by a Facade. Dispatches a UVPJS event CONTENT_START.<br>
         * Prime the CVI with the latest Video State, then start the Video State Progress timer callbacks, then call CONTENT_START.<br>
         * For the IMA Mobile case facadeDisplayReady must be called from  the 'lodedmetadata' HTML5 Video tag event handler.
         *
         * @memberof uvpjs.ResourceProvider#
         */
        facadeDisplayReady: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'facadeDisplayReady  this.rco.id = ' + this.rco.id);

            this.startVideoProgressTimer();
            this.contentStartOpen = true;
            this.dispatchContentStart();
        },

        /**
         * Handles metadata from a facade; intended for population of model
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} data
         */
        facadeMetadataParsed: function (data) {
            data && data.abrInfo && this.cviModel.setAbrInfo(data.abrInfo);
        },

        /**
         * Called by a Facade. Updates CVI_Model current time and duration on Facade progress events (if the Facade has low level progress events).
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} data - playbackStateObj: {duration: this._videoTagRef.duration, currentTime: this._videoTagRef.currentTime}
         *
         * Note This is never called by any facade but overridden in DAIResourceProvider.
         */
        facadeProgress: function (data) {
            if (uvpjs.util.isEmpty(data) || typeof data !== 'object' || !data.currentTime || !data.duration) {
                return;
            }

            this.cviModel.setContentPlaybackStateItems({currentTime: data.currentTime});

            // update duration if the Facade exposes a valid new value.
            this.setModelDuration(parseInt(data.duration));
        },

        /**
         * Called by a Facade. Updates CVI_Model current time and duration when the Facade determines
         * the time or duration have changed, ex: sent when the media has loaded enough that the duration is known.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} data - playbackStateObj: {duration: this._videoTagRef.duration}
         */
        facadeDurationChanged: function (data) {
            if (uvpjs.util.isEmpty(data) || typeof data !== 'object' || !data.duration) {
                return;
            }
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @param {Number} dur
         */
        setModelDuration: function (dur) {
            if (dur > 0 && this.cviModel.contentVideoState.duration !== dur) {
                this.cviModel.setContentVideoStateItems({duration: dur});
                // it is very useful to keep the duration in the playback state
                this.cviModel.setContentPlaybackStateItems({duration: dur});
            }
        },

        /**
         * Called by a Facade, calls this.dispatchContentEnd() to dispatch CONTENT_END.
         * @memberof uvpjs.ResourceProvider#
         */
        facadeDone: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'facadeDone; this.rco.id = ' + this.rco.id);
            this.cleanUp();
        },

        /**
         * Called by facade.
         *
         * @param {Object} dataObj
         * @param {Number} dataObj.seekToTime
         *
         * @memberof uvpjs.ResourceProvider#
         */
        facadeSeeked: function (dataObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'facadeSeeked', dataObj);

            if (!this._seekFromTime) {
                this.debug && uvpjs.log(this.DEBUG_ID, "Facade seek doesn't appear to be user generated. Not dispatching SEEK_DONE.");
                return;
            }

            this._seekToTime = dataObj.seekToTime;

            // VTG-232 TODO QUESTION Do we want to send SEEK_DONE if paused?
            this.dispatchSeekDone();
        },

        /**
         * Called by a Facade. Dispatches a UVPJS event VIDEO_ERROR with data payload.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {uvpjs.ErrorInfo} errorInfo - descriptive error string.
         */
        facadeError: function (errorInfo) {
            var u = uvpjs.util,
                currRP = this.RPM && this.RPM.currRP,
                em = this.eventsMgr,
                mdl = this.cviModel,
                hasMdl = !u.isEmpty(mdl),
                isFatal = errorInfo.isFatal,
                cvs, playbackStarted, usingOverride, evt;

            this.debug && uvpjs.log(this.DEBUG_ID, 'facadeError; vc id= ' + this.vidContId + ';' + errorInfo.message);

            // check availability of override
            if (hasMdl && isFatal) {
                cvs = this.cviModel.getContentVideoState();

                playbackStarted = cvs.playbackStarted;
                usingOverride = u.isDefinedString(cvs.overrideAssetURL);

                if (!playbackStarted && usingOverride && !this._overrideAssetUrlFailure) {
                    this._handleOverrideAssetURLError(errorInfo);
                    return;
                }
            }

            if (!hasMdl) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'facadeError; RP has no cviModel **');
            }

            if (!u.isEmpty(em)) {
                evt = errorInfo.eventType || em.eventTypes.VIDEO_PLAYBACK_ERROR;
                errorInfo.eventType = evt;
                em.dispatchEvent(evt, { errorInfo: errorInfo }, this.vidContId);
            }
            else {
                this.debug && uvpjs.log(this.DEBUG_ID, 'facadeError; RP has no events mgr **');
            }

            // if fatal, clean up
            if (isFatal) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'facadeError fatal error.');

                hasMdl && (mdl.contentPlaybackState.fatalError = true);

                // ? -  currRP should === 'this'
                if (currRP && currRP.rco && currRP.rco.type === uvpjs.mediaCapabilities.RP_IMA) {
                    currRP.imaContentComplete();
                    return;
                }

                this.debug && uvpjs.log(this.DEBUG_ID, 'facadeError; RP; RPM.currRP is null');

                this.cleanUp();
            }
        },

        /**
         * Called by a Facade. Dispatches VIDEO_STATE_CHANGE events with the playback state value of the video.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Number} newState - enum  EMPTY:-2, LOADING:-1, STOPPED:0, PLAYING:1, PAUSED:2, BUFFERING:3
         */
        facadePlaybackStateChange: function (newState) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'facadePlaybackStateChange id = ' + this.rco.id + ' newState = ' + newState);

            this.dispatchVideoStateChange(newState);
        },

        /**
         * Called by a Facade. Dispatches LEVEL_LOADED when a level load is completed.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} details - the details associated with the HLS level change.
         */
        facadeVideoLevelLoaded: function (details) {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.LEVEL_LOADED, {details: details}, this.vidContId);
        },

        /**
         * Called by a Facade. Dispatches VIDEO_TRANSITION_START when a level switch is started.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Number} bitrate - the bitrate associated with the HLS level change.
         * @param {String} switchMode - 'auto' or 'manual'
         */
        facadeVideoTransitionStart: function (bitrate, switchMode) {
            var switchingMode = switchMode || (this.cviModel.useDynamicSwitching ? 'auto' : 'manual');

            uvpjs.log(this.DEBUG_ID, 'facadeVideoTransitionStart id = ' + this.rco.id + ' bitrate = ' + bitrate + ' mode = ' + switchingMode);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.VIDEO_TRANSITION_START, {bitrate: bitrate, mode:switchingMode}, this.vidContId);
        },

        /**
         * Called by a Facade. Dispatches VIDEO_TRANSITION_COMPLETE when a level switch is complete.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Number} bitrate - the bitrate associated with the HLS level change.
         * @param {String} switchMode - 'auto' or 'manual'
         */
        facadeVideoTransitionComplete: function (bitrate, switchMode) {
            var switchingMode = switchMode || (this.cviModel.useDynamicSwitching ? 'auto' : 'manual');

            uvpjs.log(this.DEBUG_ID, 'facadeVideoTransitionComplete id = ' + this.rco.id + ' bitrate = ' + bitrate + ' mode = ' + switchingMode);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.VIDEO_TRANSITION_COMPLETE, {bitrate: bitrate, mode:switchingMode}, this.vidContId);
        },

        /**
         * Handles ID3 data from ID3-aware facades
         *
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} data
         */
        facadeId3Data: function(data) {
            this.id3Parser && this.id3Parser.parse(data);
        },

        /**
         * Called by a Facade. Dispatches MINIMUM_BITRATE_ALLOWED when the lower bitrate threshold is moved.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Number} bitrate - the bitrate associated with the lower threshold.
         */
        facadeMinimumBitrateAllowedChanged: function (bitrate) {
            this.cviModel.setMinBitrate(bitrate);
        },

        /**
         * Called by a Facade. Dispatches MAXIMUM_BITRATE_ALLOWED when the upper bitrate threshold is moved.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Number} bitrate - the bitrate associated with the upper threshold.
         */
        facadeMaximumBitrateAllowedChanged: function (bitrate) {
            this.cviModel.setMaxBitrate(bitrate);
        },

        // END of FACADE INTERFACE METHODS

        /**
         * Get the Video Player Facade (VPF).
         *
         * @param {String} assetURL
         *
         * @memberof uvpjs.ResourceProvider#
         *
         * @returns {Object} A Video Playback Facade object reference.
         */
        getFacade: function (assetURL) {
            var streaming = this.mc.STREAMING,
                assetURL = assetURL || this._getAssetUrl(),
                isHlsStream = this.mc.isHlsUrl(assetURL),
                isDashStream = this.mc.isDashUrl(assetURL),
                isFlash = this.cviModel.contentVideoState.isFlash,
                facade;

            this.debug && uvpjs.log(this.DEBUG_ID, 'getFacade');

            (isFlash || isHlsStream || isDashStream) && this._setDeliveryType(streaming);

            // Hls
            if (!isFlash && isHlsStream) {
                this.mc.canPlayHLSJS() && (facade = new uvpjs.VPF_HLSJS());
            }
            // Dash
            else if (!isFlash && isDashStream) {
                if (!uvpjs.VPF_DASHJS) {
                    this.debug && uvpjs.warn(this.DEBUG_ID, 'Unable to create facade; DASHJS not available.');
                    return;
                }
                facade = new uvpjs.VPF_DASHJS();
            }
            else if (isFlash) {
                facade = new uvpjs.VPF_Flash();
            }

            return facade || new uvpjs.VPF_HTML5(); // Default to HTML5
        },

        /**
         * Core Video Interface (CVI) Events which the Resource Provider needs to mediate for the facade.<br>
         *
         * @memberof uvpjs.ResourceProvider#
         */
        _addUVPEventListeners: function () {
            var em = this.eventsMgr,
                et = em.eventTypes,
                ns = this.internalNS,
                id = this.rco && this.rco.id;

            this.debug && uvpjs.log(this.DEBUG_ID, '_addUVPEventListeners this.rco.id = ', id);

            if (this._uvpEventListenersAdded) {return;}
            this._uvpEventListenersAdded = true;

            em.addEventListener(et.CONTROL_SEEK + ns, this.onVideoSeekTo.bind(this));
            em.addEventListener(et.CONTROL_SEEK_TO_LIVE_POINT + ns, this.onVideoSeekToLive.bind(this));
            em.addEventListener(et.CONTROL_PAUSE + ns, this.onPauseVideo.bind(this));
            em.addEventListener(et.CONTROL_PLAY + ns, this.onPlayVideo.bind(this));
            em.addEventListener(et.CONTROL_MUTE + ns, this.onMuteVideo.bind(this));
            em.addEventListener(et.CONTROL_UNMUTE + ns, this.onUnMuteVideo.bind(this));
            em.addEventListener(et.CONTROL_VOLUME_SET + ns, this.onChangeVideoVolume.bind(this));
            em.addEventListener(et.CONTROL_FULLSCREEN + ns, this.onFullscreen.bind(this));
            em.addEventListener(et.SWITCH_REQUEST + ns, this.onSwitchRequest.bind(this));
            em.addEventListener(et.USE_DYNAMIC_SWITCHING + ns, this.onUseDynamicSwitching.bind(this));
            em.addEventListener(et.MAXIMUM_BITRATE_ALLOWED + ns, this.onMaximumBitrateAllowed.bind(this));
            em.addEventListener(et.MINIMUM_BITRATE_ALLOWED + ns, this.onMinimumBitrateAllowed.bind(this));
        },

        /**
         * Core Video Interface (CVI) Events which the Resource Provider needs to mediate for the facade.<br>
         *
         * @memberof uvpjs.ResourceProvider#
         */
        _removeUVPEventListeners: function () {

            var em = this.eventsMgr,
                et = em.eventTypes,
                ns = this.internalNS,
                id = this.rco && this.rco.id;

            this.debug && uvpjs.log(this.DEBUG_ID, '_removeUVPEventListeners this.rco.id = ', id);

            em.removeEventListener(et.CONTROL_SEEK + ns);
            em.removeEventListener(et.CONTROL_SEEK_TO_LIVE_POINT + ns);
            em.removeEventListener(et.CONTROL_PAUSE + ns);
            em.removeEventListener(et.CONTROL_PLAY + ns);
            em.removeEventListener(et.CONTROL_MUTE + ns);
            em.removeEventListener(et.CONTROL_UNMUTE + ns);
            em.removeEventListener(et.CONTROL_VOLUME_SET + ns);
            em.removeEventListener(et.SWITCH_REQUEST + ns);
            em.removeEventListener(et.USE_DYNAMIC_SWITCHING + ns);
            em.removeEventListener(et.MAXIMUM_BITRATE_ALLOWED + ns);
            em.removeEventListener(et.MINIMUM_BITRATE_ALLOWED + ns);

            em.removeEventListener(et.CONTROL_SHOW_CAPTIONS + ns);
            em.removeEventListener(et.CONTROL_HIDE_CAPTIONS + ns);
            em.removeEventListener(et.CONTROL_LOAD_CAPTIONS + ns);
        },

        /**
         * Returns asset URL. Determines if CAN dyanmic variant service in use.
         *
         * @memberof uvpjs.VideoPlayerFacade#
         *
         * @param {Object} rco Optional RCO object.
         *
         * @private
         */
        _getAssetUrl: function (rco) {
            var u = uvpjs.util,
                state = rco || this.cviModel.getContentVideoState(),
                overrideAssetURL = state.overrideAssetURL,
                useOverride = u.isDefinedString(overrideAssetURL) && !this._overrideAssetUrlFailure,
                url = useOverride ? overrideAssetURL : state.assetURL;

            this.debug && uvpjs.log(this.DEBUG_ID, '_getAssetUrl (using override: '+ useOverride +')', url);

            return url;
        },

        /**
         * Set internal `deliveryType` to "streaming" and update model.
         *
         * @param {String} type uvpjs.mediaCapabilities delivery type constant
         *
         * @memberof uvpjs.ResourceProvider#
         *
         * @private
         */
        _setDeliveryType: function (type) {
            this.cviModel.setContentVideoStateItems({ deliveryType: type });
        },

        /**
         * Error parsing dynamic variant manifest using `overrideAssetURL`. Try `assetURL`.
         *
         * @param {uvpjs.ErrorInfo} errorInfo - descriptive error string.
         *
         * @memberof uvpjs.ResourceProvider#
         *
         * @private
         */
        _handleOverrideAssetURLError: function (errorInfo) {
            var ei = uvpjs.ErrorInfo,
                em = this.eventsMgr,
                evt = em.eventTypes.VIDEO_START_ERROR,
                msg = ei.messages.DYNAMIC_VARIANT_MANIFEST_PARSE_ERROR;

            this.debug && uvpjs.warn(this.DEBUG_ID, msg + " Error using overrideAssetURL; will use assetURL.");

            errorInfo.eventType = evt;
            errorInfo.message = msg;
            errorInfo.isFatal = false;
            errorInfo.errorCode = ei.errorCodes.DYNAMIC_VARIANT_MANIFEST_PARSE_ERROR;

            em.dispatchEvent(evt, { errorInfo: errorInfo }, this.vidContId);

            this._overrideAssetUrlFailure = true;

            // Destroy old and create new facade.
            this.destroyFacade();
            this.createFacade();

            this.facade.showVideo();
            this.facade.playVideo();
        },

        /**
         * Event handler to manage switch event.
         *
         * @param {Object} evtObj Event object with payload of `bitrate`, which is in KBPS and mapped to the closest
         * level, or the string `up` or `down` to switch one level in that direction.
         *
         * @memberof uvpjs.ResourceProvider#
         */
        onSwitchRequest: function (evtObj) {
            var target = evtObj && evtObj.target,
                payload = evtObj && evtObj.payload,
                bitrate = payload && payload.bitrate,
                mdl = this.cviModel,
                facade = this.facade;

            if (target !== this.vidContId || !bitrate || !this._hasFacade()) {
                return;
            }

            switch (typeof bitrate) {

                case 'string':
                    if (bitrate === 'up') {
                        mdl.setUseDynamicSwitching(false);
                        facade.switchUp()
                    }
                    else if (bitrate === 'down') {
                        mdl.setUseDynamicSwitching(false);
                        facade.switchDown();
                    }
                    else {
                        bitrate = Number(bitrate);
                        if (isNaN(bitrate)) {
                            return;
                        }
                        mdl.setUseDynamicSwitching(false);
                        facade.switchToBitrate(bitrate);
                    }
                    break;

                case 'number':
                    mdl.setUseDynamicSwitching(false);
                    facade.switchToBitrate(bitrate);
                    break;

                default:
                    this.debug && uvpjs.warn(this.DEBUG_ID, 'Unable to switch to a selected bitrate.', bitrate);
                    break;
            }
        },

        /**
         * Switches dynamic switching on or off for manual or auto mode.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} evtObj -  payload.data boolean turns dynamic switching on or off (false is manual mode; true is auto switching).
         */
        onUseDynamicSwitching: function (evtObj) {

            if (!evtObj || evtObj.target !== this.vidContId || !evtObj.payload) {
                return;
            }

            var useDynamic = evtObj.payload.data;
            this.cviModel.setUseDynamicSwitching(useDynamic);

            if (this._hasFacade()) {
                this.facade.useDynamicSwitching(useDynamic);
                if (useDynamic) { //going back to useDynamic so setting cvi min and max in case when cleared in manual mode.
                    this.facade.setMinBitrateAllowed(this.cviModel.minBitrate);
                    this.facade.setMaxBitrateAllowed(this.cviModel.maxBitrate);
                }
            }
            this.debug && uvpjs.log(this.DEBUG_ID, 'facadeDynamicSwitchingChange  this.rco.id = ' + this.rco.id + ' useDynamic = ', useDynamic);
        },

        /**
         * Sets minimum bitrate allowed.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} evtObj - the data object. payload.bitrate is numeric value of the closest bitrate requested.
         */
        onMinimumBitrateAllowed: function (evtObj) {
            var payload = evtObj.payload,
                bitrate = payload && payload.bitrate,
                facade = this.facade;

            if (evtObj.target !== this.vidContId) {
                return;
            }

            if (!bitrate || typeof bitrate !== 'number') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Unable to set minimum bitrate to ' + bitrate, typeof bitrate);
                return;
            }

            this.cviModel.setMinBitrate(bitrate);
            this._hasFacade() && facade.setMinBitrateAllowed(bitrate);
        },

        /**
         * sets maximum bitrate allowed.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} evtObj - the data object. payload.bitrate is numeric value of the closest bitrate requested.
         */
        onMaximumBitrateAllowed: function (evtObj) {
            var payload = evtObj.payload,
                bitrate = payload && payload.bitrate,
                facade = this.facade;

            if (evtObj.target !== this.vidContId) {
                return;
            }

            if (!bitrate || typeof bitrate !== 'number') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Unable to set minimum bitrate to ' + bitrate, typeof bitrate);
                return;
            }

            this.cviModel.setMaxBitrate(bitrate);
            this._hasFacade() && facade.setMaxBitrateAllowed(bitrate);
        },

        /**
         * CONTROL_SEEK callback. Call the facade seekTo() method with a time in seconds.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {object} evtObj - Events Manager event dispatch object with.
         */
        onVideoSeekTo: function (evtObj) {
            var target = evtObj && evtObj.target,
                payload = evtObj && evtObj.payload,
                seekTime = payload && payload.seekTime,
                duration = this.cviModel.contentVideoState.duration,
                currentTime = this.cviModel.contentPlaybackState.currentTime,
                facade = this.facade;

            if (typeof seekTime !== 'number' || target !== this.vidContId) {
                return;
            }

            if (seekTime < 0 || seekTime > duration) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'onVideoSeekTo out of range seekTime = ' + seekTime);
                return;
            }

            // VTG-232 Track seek from time for dispatching SEEK_DONE.
            this._seekFromTime = this._seekFromTime || currentTime;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onVideoSeekTo ' + JSON.stringify({
                seekTime: seekTime,
                seekFromTime: this._seekFromTime
            }, null, 2));

            this._hasFacade() && facade.seekTo(seekTime);
        },

        /**
         * CONTROL_SEEK_TO_LIVE_POINT callback. Call the facade seekToLive() method.
         * @memberof uvpjs.ResourceProvider#
         */
        onVideoSeekToLive: function () {
            var facade = this.facade;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onVideoSeekToLive');

            this._hasFacade() && facade.seekToLive();
        },

        /**
         * Dispatches a CONTROL_VOLUME_CHANGE with volume it receives from the low-level video tag volume changes from the facade.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {number} newVolume - the new volume between 0 and 1.
         */
        facadeVolumeChange: function (newVolume) {
            if (_.isNaN(newVolume) || !_.isNumber(newVolume)) {
                return;
            }

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.CONTROL_VOLUME_CHANGE, {vol: newVolume}, this.vidContId);
        },

        /**
         * facadeLoading(dataObj) - called when facade downloads more of the media file on approx second intervals.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {object} dataObj = {bufferLength: amountLoaded, duration: this.videoTagRef.duration}
         */
        facadeLoading: function (dataObj) {
            var payload = {data: dataObj};
            if (dataObj && (dataObj.bufferLength || dataObj.loaded)) {
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.VIDEO_LOADING, payload, this.vidContId);
            }
        },

        /**
         * Video tag `currentTime` updated.
         *
         * @param {Number} updatedTime
         *
         * @memberof uvpjs.ResourceProvider#
         */
        facadeTimeUpdate: function (updatedTime) {
            this.cviModel.setContentPlaybackStateItems({ currentTime: updatedTime });
        },

        /**
         * fullscreen change
         *
         * @param {Object} e
         *
         * @memberof uvpjs.ResourceProvider#
         */
        onFullscreen: function (e) {
            this.facade && this.facade.facadeType === this.mc.FLASH_HLS && this.facade.setFullscreenState(e.payload.isFs);
        },

        /**
         * CONTROL_PAUSE event callback.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {Object} evtObj - event object with .name, .target:'video Container ID' is a
         * dom element ID string, payload: {} is an empty object.
         */
        onPauseVideo: function (evtObj) {
            var target = evtObj && evtObj.target,
                facade = this.facade;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onPauseVideo this.vidContId = ', this.vidContId, ' evtObj.target = ', target);

            (target === this.vidContId) && this._hasFacade() && facade.pauseVideo();
        },

        /**
         * CONTROL_PLAY event callback. CONTROL_PLAY is dispatched by the Video Control Interface in the API method
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {object} evtObj - event object with .name, .target:'video Container ID' is a
         * dom element ID string, payload: {} is an empty object.
         */
        onPlayVideo: function (evtObj) {
            var target = evtObj && evtObj.target,
                facade = this.facade;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onPauseVideo this.vidContId = ', this.vidContId, ' evtObj.target = ', target);

            (target === this.vidContId) && this._hasFacade() && facade.playVideo();
        },

        /**
         * CONTROL_VOLUME_SET event callback.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {object} evtObj - event object with .name, .target:'video Container ID' is a
         * dom element ID string, payload: {vol: a Number bewteen 0 and 1}.
         */
        onChangeVideoVolume: function (evtObj) {
            var target = evtObj && evtObj.target,
                payload = evtObj && evtObj.payload,
                volume = payload && payload.vol,
                inRange = uvpjs.util.inRange(volume, 0, 1),
                isMuted = this.cviModel.isMuted,
                facade = this.facade;

            (target === this.vidContId) && inRange && !isMuted && this._hasFacade() && facade.setVolume(volume);
        },

        /**
         * CONTROL_MUTE event callback.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {object} evtObj - event object with .name, .target:'video Container ID' is a
         * dom element ID string, payload: {} is an empty object.
         */
        onMuteVideo: function (evtObj) {
            var target = evtObj && evtObj.target,
                facade = this.facade;

            (target === this.vidContId) && this._hasFacade() && facade.muteVideo();
        },

        /**
         * CONTROL_UNMUTE event callback.
         * @memberof uvpjs.ResourceProvider#
         *
         * @param {object} evtObj - event object with .name, .target:'video Container ID' is a
         * dom element ID string, payload: {} is an empty object.
         */
        onUnMuteVideo: function (evtObj) {
            var target = evtObj && evtObj.target,
                facade = this.facade;

            (target === this.vidContId) && this._hasFacade() && facade.unMuteVideo();
        },

        /**
         * Dispatches a VIDEO_PROGRESS event with Video Progress Payload object.
         * @memberof uvpjs.ResourceProvider#
         */
        onUVPJSTimerTick: function () {
            if (!this._hasFacade() || this.facade.getPlaybackState() !== this.mc.PLAYING) {
                return;
            }

            var state = {};

            if (this.cviModel.contentVideoState.episodeFlag) {
                // Local Resume
                if (((Date.now() - this._previousLocalStorageTime) > this._localStorageInterval)) {
                    this._previousLocalStorageTime = Date.now();
                    this.setLocalStorageItems();
                }

                // Global Resume
                state = this.cviModel.getContentVideoState();

                if (!_.isEmpty(this.cviModel.sessionOptions.userId) &&
                    ((Date.now() - this._previousResumeBeaconTime) > (this._resumeBeaconInterval))) {
                    this._previousResumeBeaconTime = Date.now();
                    this.eventsMgr.dispatchEvent(
                        this.eventsMgr.eventTypes.PLAYBACK_DURATION_RESUME,
                        {contentData: state},
                        this.vidContId
                    );
                }

            }

            if (this.cviModel.contentVideoState.sendResumeEvent) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.VIDEO_RESUME,
                    {contentTime: this.cviModel.contentVideoState.startTime},
                    this.vidContId
                );
                this.cviModel.contentVideoState.sendResumeEvent = false;
            }

            var payload = this.getVideoProgressPayload();
            this.setModelDuration(payload.duration);
            this.id3HandlingEnabled && this.checkId3Events(payload.currentTime);

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.VIDEO_PROGRESS, payload, this.vidContId);
        },

        /**
         * This method is called at intervals and checks the play position to determine if buffering is occurring.
         * 'Buffering' play state is set if the playhead has not advanced sufficiently over the given time interval.
         *
         * Adapted from
         * http://stackoverflow.com/questions/21399872/how-to-detect-whether-html5-video-has-paused-for-buffering
         *
         * @memberof uvpjs.ResourceProvider#
         * @private
         *
         * @param {Number} time - an optional time to override the use of state.currentTime
         */
        checkBuffering: function (time) {
            var state = this.cviModel ? this.cviModel.contentPlaybackState : null,
                currentTime;

            if (
                !state || !state.playbackStarted || state.playbackState === this.mc.PAUSED ||
                !this._hasFacade() || this.facade.facadeType === this.mc.FLASH_HLS
            ) {
                return;
            }

            currentTime = time || state.currentTime || 0;

            if (!this.bufferingDetected && currentTime < (this.bufferingCheckLastTime + this.bufferingCheckOffset)) {
                this.bufferingDetected = true;
                this.facade.playbackStateChange(this.mc.BUFFERING);
            }
            else if (this.bufferingDetected && currentTime >= (this.bufferingCheckLastTime + this.bufferingCheckOffset)) {
                this.bufferingDetected = false;
                this.facade.playbackStateChange(this.mc.PLAYING);
            }

            this.bufferingCheckLastTime = currentTime;
        },

        /**
         * Creates the payload object used in VIDEO_PROGRESS events.
         * @memberof uvpjs.ResourceProvider#
         */
        getVideoProgressPayload: function () {
            // Content Playback State //
            var vs = this.cviModel.getCurrentVideoState(),
                duration = this.facade.getDuration();

            var payload = {
                averageDroppedFPS: 0,
                bufferLength: 0,
                currentBandwidth: 0,
                currentContentSegment: 1,
                currentMaxBandwidth: 0,
                currentTime: 0,
                droppedFrames: 0,
                duration: duration,
                errorInfo: '',
                facadeState: {},
                isAd: false,
                isHDStreamLive: false,  // isHDStreamLive = true for live stream.
                                        // isHDStreamLive: false for dvr stream.
                                        // is user at the 'true' live point of a live stream or are
                                        // they watching 'behind' the live point
                isPlayingLive: false,   // isPlayingLive - is the duration of a live stream increasing or is the
                                        // live stream being played as an archive
                                        // currently unimplemented in mobile web true -> video is playing at the
                                        // live point of live stream; false = video 'behind' live point. default = true
                isSeeking: false,
                lastPercentageCompleted: 0,
                lastSecondCompleted: 0,
                playbackState: this.mc.EMPTY,   // default value
                playbackBitrate: 0,
                playbackComplete: false,
                playbackFramerate: 0,
                playbackStarted: true,
                sourceBitrate: 0,
                streamType: null,
                switchingMode: 'auto',
                videoFramerate: 0
            };

            this.setFacadeStateOnProgressPayload(payload);
            return payload;
        },

        /**
         * @memberof uvpjs.ResourceProvider#
         * @protected
         *
         * @param p
         * @returns {*}
         */
        setFacadeStateOnProgressPayload: function(p) {
            var facade = this.facade,
                fs = this._hasFacade() && facade.getFacadeState();

            if (!fs) return p;

            p.facadeState = fs;
            p.averageDroppedFPS = facade.getAverageDroppedFPS();
            p.bufferLength = facade.getBuffered() || 0;
            p.currentTime = facade.getCurrentTime() || 0;
            p.currentBandwidth = facade.getCurrentBandwidth();
            p.currentMaxBandwidth = facade.getCurrentMaxBandwidth();
            p.droppedFrames = facade.getDroppedFramesCount();
            p.playbackFramerate = facade.getPlaybackFramerate();
            p.playbackState = facade.getPlaybackState();
            p.streamType = facade.getStreamType();
            p.isHDStreamLive = facade.isHDStreamLive();
            p.isPlayingLive = facade.isPlayingLive();
            p.switchingMode = (this.cviModel.useDynamicSwitching) ? 'auto' : 'manual';
        },

        /**
         * Sets the local storage items which contains resume data. This system only works in a single player scenario.
         * @memberof uvpjs.ResourceProvider#
         */
        setLocalStorageItems: function () {
            if (!uvpjs.util.supportsLocalStorage()) {return;}

            localStorage.setItem('UVPJS.resumePid', this.rco.pid);
            localStorage.setItem('UVPJS.resumeContentTime', this.cviModel.contentPlaybackState.currentTime);
            localStorage.setItem('UVPJS.resumeEpochTime', Date.now());
            localStorage.setItem('UVPJS.resumeSessionId', this.cviModel.sessionId);
        },

        /**
         * Retrieves the local storage items and sets their values in the Model.
         * @memberof uvpjs.ResourceProvider#
         */
        populateContentVideoStateFromLocalStorage: function () {
            var cvs = this.cviModel.contentVideoState,
                resumePid = localStorage.getItem('UVPJS.resumePid') || null,
                resumeCtime = localStorage.getItem('UVPJS.resumeContentTime') || null,
                resumeEtime = localStorage.getItem('UVPJS.resumeEpochTime') || null,
                resumeSid = localStorage.getItem('UVPJS.resumeSessionId') || null;

            if (!uvpjs.util.supportsLocalStorage()) {return;}

            resumePid && (cvs.resumePid = resumePid);
            resumeCtime && (cvs.resumeContentTime = resumeCtime);
            resumeEtime && (cvs.resumeEpochTime = resumeEtime);
            resumeSid && (cvs.resumeSessionId = resumeSid);
        },

        /**
         * Clears the local storage items.
         * @memberof uvpjs.ResourceProvider#
         */
        clearLocalStorageItems: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'clearLocalStorageItems');
            if (!uvpjs.util.supportsLocalStorage()) {return;}

            localStorage.setItem('UVPJS.resumePid', '');
            localStorage.setItem('UVPJS.resumeContentTime', 0);
            localStorage.setItem('UVPJS.resumeEpochTime', 0);
            localStorage.setItem('UVPJS.resumeSessionId', '');
        },

        /**
         * Reset model state.
         *
         * @memberof uvpjs.ResourceProvider#
         */
        resetModelState: function () {
            var mdl = this.cviModel;

            if (!mdl) { return; }

            mdl.resetAdVideoState();
            mdl.resetContentVideoState();
        },


        /////////////////
        // Helpers

        /**
         * Checks if facade is defined.
         *
         * @memberof uvpjs.ResourceProvider#
         */
        _hasFacade: function () {
            return !uvpjs.util.isEmpty(this.facade);
        }
    });

}(uvpjs.register('uvpjs')));

(function (obj) {

    var _ = obj._,
        adCallIdentifiers = {
            DOUBLECLICK_IMA: 'pubads.g.doubleclick.net',
            DOUBLECLICK: 'ad.doubleclick.net',
            PHP: 'request.php',
            JSP: 'Request.jsp',
        };

    obj.ContentDataProxy = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.CONTENT_DATA_PROXY,

        /**
         * @constructor uvpjs.ContentDataProxy
         *
         * @param {Object} options
         * @param {Function} options.successCallback,
         * @param {Function} options.errorCallback,
         * @param {uvpjs.EventsManager} options.eventsManager
         * @param {String} options.url
         * @param {String} options.pid
         * @param {String} options.cmsRefGuid
         * @param {String} options.defaults default values for model
         * @param {Object} options.queryParams
         */
        init: function(options) {
            this.debug = uvpjs.debug;

            this.mdl = {};

            this.retryLimit = 3;
            this.callAttempts = 0;
            this.selectorCall = null;
            this.callDelays = [0, 20, 1000];

            this.opts = options || {};
            this.startErrorName = uvpjs.EventType.VIDEO_START_ERROR;

            this.opts.defaults && this.populateDefaults(this.opts.defaults);
            this.eventsMgr = this.opts.eventsManager;

            delete this.opts.defaults;

            this.opts.url && this.loadData(this.opts.url, this.opts.queryParams);
        },

        //////////////////
        // PUBLIC

        /**
         * @memberof uvpjs.ContentDataProxy#
         */
        destroy: function() {
            this.mdl = null;
            this.opts && delete this.opts.errorCallback;
            this.opts && delete this.opts.successCallback;
            this.opts = null;
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {Object} options same options that may be passed to constructor (q.v.)
         */
        setOptions: function(opts) {
            var q;

            for (q in opts) {
                this.opts[q] = opts[q];
            }
        },

        // getModel and get/setProperty are provisional - for compatibility with curr code. Ideally, this proxy would serve
        // as contentVideoState model, with value read/write via accessor properties (see defineProperties() below).
        /**
         * Returns Platform data model
         * @memberof uvpjs.ContentDataProxy#
         *
         * @returns {Object}
         */
        getModel: function() {
            return this.mdl;
        },

        /**
         * Returns a model property
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {String} name
         *
         * @returns {*}
         */
        getProperty: function(name) {
            return this.mdl[name];
        },

        /**
         * Override or add a model property
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {String} name
         * @param {*} value
         */
        setProperty: function(name, value) {
            this.mdl[name] = value;
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {String} url
         * @param {Object} queryParams optional object of name:value pairs to populate query string
         */
        loadData: function(url, queryParams) {
            var cbParam = 'callback=uvpHandleJsonpResult',
                qp = queryParams || this.opts.queryParams,
                leadAmp = false,
                hasParams = !uvpjs.util.isEmpty(qp),
                p;

            this.opts.url = url;
            this.opts.queryParams = queryParams;

            if (hasParams) {
                url += url.indexOf('?') < 0 ? '?' : '&';
                for (p in qp) {
                    url += (!leadAmp ? '' : '&') + p + '=' + qp[p];
                    leadAmp = true;
                }
            }

            if (url.indexOf(cbParam) < 0) {
                url += (url.indexOf('?') < 0 ? '?' : '&') + cbParam;
            }

            this.selectorCall = url;


            this.tz = Date.now();
            this.makeSelectorCall();
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         * @param {uvpjs.ErrorInfo} errorInfo
         */
        makeSelectorCall: function() {
            var xhrSvc = new uvpjs.CodeLoader();

            this.callAttempts++;

            this.debug && uvpjs.log(this.DEBUG_ID, 'ContentDataProxy making selector call: ' + this.selectorCall);

            xhrSvc.loadXHR(this.selectorCall, this.handleData.bind(this), this.handleError.bind(this));
        },


        ///////////////////
        // PRIVATE

        /**
         * @memberof uvpjs.ContentDataProxy#
         * @param {uvpjs.ErrorInfo} errorInfo
         */
        signalError: function(errorInfo) {
            typeof this.opts.errorCallback === 'function' && this.opts.errorCallback(errorInfo);
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         */
        signalSuccess: function() {
            typeof this.opts.successCallback === 'function' && this.opts.successCallback();
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {Document} smilXml
         *
         * @returns {Object}
         */
        parseSmilXML: function (smilXml) {
            var refs = smilXml.getElementsByTagName('ref'),
                contentNode = null,
                firstRefNode = refs[0],
                foundAd = false,
                mdl = this.mdl,
                platformError = firstRefNode && this.checkForPlatformError(firstRefNode),
                switches, videos, i, n, refNode,
                videoNode, url, paramNodes, params;

            this.debug && uvpjs.log(this.DEBUG_ID, 'ContentDataProxy.parseSmilXML; SMIL document:', smilXml);

            if (platformError && platformError.error) {
                return platformError;
            }

            switches = smilXml.getElementsByTagName('switch');
            videos = switches[0] ? switches[0].getElementsByTagName('video') : smilXml.getElementsByTagName('video');

            if (videos[0] === null) {
                return {
                    error: true,
                    errorInfo: new uvpjs.ErrorInfo({
                        eventType: this.startErrorName,
                        errorCode: uvpjs.ErrorInfo.errorCodes.RESOURCE_UNAVAILABLE,
                        message: uvpjs.ErrorInfo.messages.UNEXPECTED_ABSENCE_OF_VIDEO,
                        isFatal: true
                    })
                }
            }

            // init chapeterTimeStr; populated (if applicable) in one of the blocks (if/for) below
            mdl.chapterTimesString = '';

            if (firstRefNode) {
                for (i = 0, n = refs.length; i < n; i++) {
                    refNode = refs[i];
                    url = refNode.attributes['src'].nodeValue;

                    if (this.isAdCallURL(url)) {
                        !foundAd && (mdl.imaAdCall = url);
                        foundAd = true;
                    }
                    else {
                        if (!contentNode) {
                            contentNode = refNode;
                            mdl.assetURL = contentNode.getAttribute('src'); // assetUrl
                            paramNodes = refNode.getElementsByTagName('param');
                        }
                    }

                    if (refNode.getAttribute('clipEnd') !== null){
                        mdl.chapterTimesString += (refNode.getAttribute('clipEnd') + ',');
                    }
                }
            }

            for (i = 0, n = videos.length; i < n; i++) {
                videoNode = videos[i];
                url = videoNode.attributes['src'].nodeValue;

                // If no content node at this point, video node has info and src url points to single manifest file
                if(!contentNode){
                    contentNode = videoNode;
                    mdl.assetURL = contentNode.getAttribute('src');
                    paramNodes = videoNode.getElementsByTagName('param');

                    if (videoNode.getAttribute('clipEnd') === null) {
                        break; // No clip end if short form video
                    }
                }

                if (videoNode.getAttribute('clipEnd') !== null){
                    mdl.chapterTimesString += (videoNode.getAttribute('clipEnd') + ',');
                }
            }

            params = (paramNodes && this.extractParams(paramNodes)) || {};
            this.populateModelFromContentNodeAndParams(contentNode, params);

            return { error: false };
        },

        /**
         * Populates model with platform data
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param cnode
         * @param {Object} p params object
         * @param {String} p.excludeNielsenTracking
         * @param {String} p.EpisodeNumber
         * @param {String} p.Embeddable
         * @param {Object} p.IsLive
         * @param {String} p.IsLiveCDN
         * @param {String} p.PrimaryCategoryName
         * @param {String} p.SeasonNumber
         * @param {Object} p.EpisodeFlag
         * @param {String} p.VTAG
         * @param {String} p.ClosedCaptionURL
         * @param {String} p.WatermarkPlayback
         * @param {Object} p.SeriesTitle
         */
        populateModelFromContentNodeAndParams: function(cnode, p) {
            var mdl = this.mdl,
                mc = uvpjs.mediaCapabilities,
                attrMap = {
                    episodeAbstract: 'abstract',
                    copyright: 'copyright',
                    sourceHeight: 'height',
                    keywords: 'keywords',
                    videoTitle: 'title',
                    sourceWidth: 'width'
                },
                pMap = {
                    contentType: 'contentType',
                    excludeNielsenTracking: 'excludeNielsenTracking',
                    episodeNumber: 'EpisodeNumber',
                    cdn: 'IsLiveCDN',
                    category: 'PrimaryCategoryName',
                    seasonNumber: 'SeasonNumber',
                    VTAG: 'VTAG',
                    closedCaptionPath: 'ClosedCaptionURL',
                    seriesTitle: 'SeriesTitle'
                },
                t = 'true', cts, lidx;

            // simple assignments in these loops
            for (q in attrMap) {
                mdl[q] = cnode.getAttribute(attrMap[q]) || '';
            }

            for (q in pMap) {
                mdl[q] = p[pMap[q]] || '';
            }

            // not-so-simple assignments
            mdl.mediaId = this.getMediaId(p);
            mdl.duration = this.getDuration(cnode);
            mdl.sourceOwner = this.getSourceOwner(p);

            mdl.cmsRefGuid = cnode.getAttribute('guid') || cnode.getAttribute('vid') || '';

            mdl.isEmbedable = p.Embeddable  === t;
            mdl.isLive = p.IsLive  === t;
            mdl.episodeFlag = p.EpisodeFlag  === t;
            mdl.useWatermark = p.WatermarkPlayback === t;

            if (mdl.chapterTimesString.length > 0) {
                cts = mdl.chapterTimesString;
                lidx = cts.length - 1;
                cts.lastIndexOf(',') === lidx && (mdl.chapterTimesString = cts.substring(0, lidx));
                mdl.chapterStartTimes = this.convertChapterTimesToSeconds(mdl.chapterTimesString);
            }
            else {
                mdl.chapterStartTimes = [];
            }

            if (mdl.assetURL.indexOf(mc.M3U) > -1) {
                mdl.cdn = 'akamai_hd';
                mdl.fileType = mc.M3U;
            }
            else if (mdl.assetURL.indexOf(mc.MP3) > -1) {
                mdl.fileType = mc.MP3;
            }
            else {
                mdl.fileType = mc.MP4
            }
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {Object} xhr - request object
         *
         * @returns {undefined} undefined
         */
        handleData: function(xhr) {
            var text = xhr.responseText,
                util = uvpjs.util,
                smiltext = text.substring(text.indexOf('{'), text.lastIndexOf('}') + 1),
                smilObj = (this.isValidJsonStr(smiltext) && JSON.parse(smiltext)) || null,
                smil = !util.isEmpty(smilObj) ? smilObj.metafile : null,
                parser = smil && new DOMParser(),
                smilXmlDoc = parser && parser.parseFromString(smil, 'application/xml'),
                parseResult = smilXmlDoc && this.parseSmilXML(smilXmlDoc);

            this.callAttempts = 0;

            if (parseResult) {
                if (parseResult.error) {
                    this.debug && uvpjs.error(this.DEBUG_ID, 'ContentDataProxy Error: ' + parseResult.errorInfo.message);
                    this.signalError(parseResult.errorInfo);

                    return;
                }

                this.defineProperties();
                this.signalSuccess();
            }
            else {
                this.debug && uvpjs.error(this.DEBUG_ID, 'ContentDataProxy Error: Invalid response');

                this.signalError(this.createInvalidResourceFormatError());
            }
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {String} str - a string to be tested
         *
         * @return {Boolean}
         */
        isValidJsonStr: function(str) {
            return typeof str === 'string' && (
                (str.charAt(0) === '{' && str.charAt(str.length - 1) === '}') ||
                (str.charAt(0) === '[' && str.charAt(str.length - 1) === ']')
            );
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         * @param {Object} xhr - request object
         */
        handleError: function(xhr) {
            var message = 'ContentDataProxy Error: Unable to load url ' +
                          uvpjs.util.getErrorMessageForXHRStatus(xhr.status),
                callDelay;

            this.debug && uvpjs.error(this.DEBUG_ID, message, this.selectorCall);

            if (this.shouldRetryCall(xhr)) {

                // possible values for 'callAttempts' are 1, 2
                callDelay = this.callDelays[this.callAttempts];

                if (this.callAttempts >= 1) {
                    this.eventsMgr.dispatchEvent(this.startErrorName, {
                        errorInfo: new uvpjs.ErrorInfo({
                            eventType: this.startErrorName,
                            errorCode: uvpjs.ErrorInfo.errorCodes.UNEXPECTED_CONDITION,
                            message: "Selector call failed; now on retry " + this.callAttempts + "; dly = " + callDelay,
                            isFatal: false
                        })
                    });
                }

                setTimeout(this.makeSelectorCall.bind(this), callDelay);
            }
            else {
                this.callAttempts = 0;
                this.signalError(new uvpjs.ErrorInfo({
                    eventType: this.startErrorName,
                    errorCode: uvpjs.ErrorInfo.errorCodes.RESOURCE_UNAVAILABLE,
                    message: message + ' URL: ' + this.selectorCall,
                    isFatal: true,
                    serverCode: xhr.status
                }));
            }
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {String} str - a string to be tested
         *
         * @return {Boolean}
         */
        shouldRetryCall: function (xhr) {
            var s = xhr.status,
                isPfm = this.selectorCall.indexOf('link.theplatform') > -1;

            return isPfm && (this.callAttempts < this.retryLimit) && s !== 500 && s !== 404 && s !== 403 && s !== 0;
        },


        //////////////////
        // private util

        /**
         * @memberof uvpjs.ContentDataProxy#
         */
        defineProperties: function() {
            // skip this for now - for future use
        },

        /**
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param node
         * @returns {*}
         */
        checkForPlatformError: function (node) {
            var errObj = node && this.parseSmilRefNodeForException(node);

            if (errObj) {
                return {
                    error: true,
                    errorInfo: new uvpjs.ErrorInfo({
                        eventType: this.startErrorName,
                        errorCode: uvpjs.ErrorInfo.errorCodes.RESOURCE_UNAVAILABLE,
                        message: this.composePlatformErrorMessage(errObj),
                        serverCode: errObj.responseCode,
                        isFatal: true
                    })
                }
            }

            return {error: false};
        },

        /**
         * Creates an ErrorInfo object for a non-specific invalid format error
         * @memberof uvpjs.ContentDataProxy#
         *
         * @returns {uvpjs.ErrorInfo}
         */
        createInvalidResourceFormatError: function () {
            return new uvpjs.ErrorInfo({
                eventType: this.startErrorName,
                errorCode: uvpjs.ErrorInfo.errorCodes.INVALID_RESOURCE_FORMAT,
                message: uvpjs.ErrorInfo.messages.INVALID_RESOURCE_FORMAT,
                isFatal: true
            });
        },

        /**
         * Creates a message from Platform error properties (error object is local only; not related to ErrorInfo)
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {Object} errObj
         * @param {Number} errObj.responseCode
         * @param {String} errObj.abstract
         * @param {String} errObj.exception
         *
         * @return {String}
         */
        composePlatformErrorMessage: function (errObj) {
            var code = errObj.responseCode || "n/a",
                pid = '; PID: ' + (this.opts.pid || 'n/a') + '; ',
                guid = this.opts && (this.opts.cmsRefGuid + '; ') || '',
                details = errObj.abstract ? errObj.abstract  + ' ' : '',
                msg1 = errObj.exception || 'Resource Unavailable.';

            return 'Platform Error; code: ' + code + pid + guid + msg1 + ' ' + details;
        },

        /**
         * Populates default model properties
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param defaultsObj
         */
        populateDefaults: function(defaultsObj) {
            !uvpjs.util.isEmpty(defaultsObj) && _.assign(this.mdl, defaultsObj);
        },

        /**
         * Parses a node for Platform exceptions
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {Node} node
         *
         * @return {Object}
         */
        parseSmilRefNodeForException: function(node) {
            var paramNodes = node.getElementsByTagName('param'),
                out = {}, i;

            if (paramNodes && paramNodes.length) {
                i = paramNodes.length;

                while (i--) {
                    out[paramNodes[i].getAttribute('name')] = paramNodes[i].getAttribute('value');
                }

                if (out.isException === 'true') {
                    out.abstract = node.getAttribute('abstract') || '';

                    return out;
                }
            }

            return null;
        },

        /**
         * Extracts data from parameter nodes
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {String} paramNodes - SMIL xml parameter nodes

         * @return Object - params table created from the parameter nodes
         */
        extractParams: function(paramNodes){
            var params = {},
                node, n, v, i;

            if (uvpjs.util.isEmpty(paramNodes)) {
                return params;
            }

            i = paramNodes.length;
            while (i--) {
                node = paramNodes[i];
                n = node.getAttribute('name');
                v = node.getAttribute('value');
                (n && v) && (params[n] = v);
            }

            return params;
        },

        /**
         * Returns true if url contains any strings characteristic of an ad call
         * @memberof uvpjs.ContentDataProxy#
         *
         * @private
         * @param {String} url
         *
         * @returns {boolean}
         */
        isAdCallURL: function(url) {
            // TODO (djl) - is there a better way?
            // inspect tags attribute for ad-related values? e.g., tags="preroll" appears in ref node

            return url.indexOf(adCallIdentifiers.DOUBLECLICK) > -1 ||
                   url.indexOf(adCallIdentifiers.DOUBLECLICK_IMA) > -1 ||
                   url.indexOf(adCallIdentifiers.PHP) > -1 ||
                   url.indexOf(adCallIdentifiers.JSP) > -1;
        },

        /**
         * Returns media id
         * @memberof uvpjs.ContentDataProxy#
         * @private
         *
         * @param {Object} params
         *
         * @return {String}
         */
        getMediaId: function(params){
            var mediaId = '',
                tdata = params.trackingData,
                qosp, i, n;

            if (uvpjs.util.isEmpty(tdata)) { return ''; }

            qosp = tdata.split('|');

            for (i = 0, n = qosp.length; i < n; i++) {
                if (qosp[i].indexOf('cid=') > -1) {
                    mediaId = qosp[i].split('=')[1];
                }
            }

            return mediaId;
        },

        /**
         * Returns the source owner.
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {Object} params
         *
         * @returns {String}
         */
        getSourceOwner: function(params) {
            var src = params.Source;

            return uvpjs.util.isEmpty(src) && params.WatermarkPlayback === 'true' ? 'Entertainment' : src || '';
        },

        /**
         * Returns video duration
         * @memberof uvpjs.ContentDataProxy#
         *
         * @param {Node} node
         *
         * @return {Number} Content Duration in seconds or 0.
         */
        getDuration: function(node) {
            var contentDuration = parseInt(node.getAttribute('dur')) || 0;

            return contentDuration > 0 ? contentDuration * 0.001 : contentDuration;
        },

        /**
         * Creates array of chapter times (in seconds)
         * @memberof uvpjs.ContentDataProxy#
         *
         * @return {Array}
         */
        convertChapterTimesToSeconds: function (str) {
            var ret = [],
                list = str.split(','),
                i = list.length,
                toSec = function(t) {
                    var pi = parseInt, n;

                    t = list[i].split(':');
                    n = t.length;
                    switch (n) {
                        case 1:
                            return pi(t[0]);

                        case 2:
                            return (pi(t[0]) * 60) + pi(t[1]);

                        case 3:
                            return (pi(t[0]) * 3600) + (pi(t[1]) * 60) + pi(t[2]);
                    }
                };

            while (i--) {
                ret.unshift(toSec(list[i]));
            }

            return ret;
        }
    });

}(uvpjs.register('uvpjs')));
/**
 * Created by ldoyle on 8/13/15.
 */
'use strict';

(function (obj) {

    var _ = obj._;

    obj.RP_URL = uvpjs.ResourceProvider.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PROVIDER,

        // VTG-79; this class doesn't seem to do much; consider a refactor that puts a "loadData" method
        // on ResourceProvider, with a default impl that invokes the dataLoaded callback as is done here.
        // That would eliminate the need for this class, with perhaps a tweak somewhere to account for the
        // only unique bit of work done here (set this.cviModel.isCurrVideoAd = false;).

        /**
         * @constructor uvpjs.ResourceProvider.RP_URL
         * @extends uvpjs.ResourceProvider
         *
         * @param {Object} options
         */
        init: function(options) {
            this._super(options);
            this.providerType = uvpjs.mediaCapabilities.RP_URL;
        },

        /**
         * @memberof uvpjs.ResourceProvider.RP_URL
         *
         * @param {object} rcObj - Validated Resource Config Object.
         * @param {object} cviMgr - Validated Core Video Instance Manager.
         * @param {string} vidContId - Validated Video Container Tag Element ID.
         */
        initialize: function(rcObj, cviMgr, vidContId) {
            this._super(rcObj, cviMgr, vidContId);
        },

        /**
         * Load any additional metadata, ex: Platform SMIL file, and call dataLoadedCallback() when done.
         * @memberof uvpjs.RP_URL
         * @override
         *
         * @param {function} dataLoadedCallback - RPM or RP callback invoked after data is sucessfully loaded.
         * @param {function} errorCallback - RPM or RP callback invoked if there is data load error.
         */
        loadData: function(dataLoadedCallback, errorCallback) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_URL loadData');

            if (!_.isFunction(dataLoadedCallback) || !_.isFunction(errorCallback)) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.UVPJS_WARNING,
                    {msg:'RP_URL loadData Callbacks missing or invalid RETURN WITHOUT LOADING DATA'},
                    this.internalNS
                );
                return;
            }

            this.dispatchVideoStateChange(this.mc.LOADING);

            this.dataLoadedCB = dataLoadedCallback;
            this.dataLoadErrorCB = errorCallback;

            this.dataLoadedCB();
        },

        /**
         * See superclass, lay a video only after loading the metadata and in this method resetting the CVI_Model.
         * @override
         *
         * @memberof uvpjs.RP_URL
         * @returns {undefined} undefined
         */

        loadVideoAndBeginPlayback: function(suppressFacadePlay) {
            this.debug &&  uvpjs.log(this.DEBUG_ID, 'RP_URL loadVideoAndBeginPlayback this.rco = ', this.rco);
            this.resetModelState();

            this.cviModel.isCurrVideoAd = false;
            this._super(suppressFacadePlay);
        }

    });

}(uvpjs.register('uvpjs')));

/**
 * Created by ldoyle on 12/16/15.
 */

'use strict';

(function (obj) {

    obj.RP_Platform = uvpjs.ResourceProvider.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PROVIDER,
        ONE_HOUR_MS: 3600000,

        /**
         * @constructor uvpjs.ResourceProvider.RP_Platform
         * @extends uvpjs.ResourceProvider
         *
         * @param {Object} options
         */
        init: function(options) {
            this._super(options);
            this.providerType = uvpjs.mediaCapabilities.RP_PLATFORM;
        },

        ////////////////
        // PUBLIC
        /**
         * Called by RPM Resource Playlist Manager. Load any additional metadata, ex: Platform SMIL file,
         * and call dataLoadedCallback() when done.
         * @memberof uvpjs.RP_Platform#
         *
         * @param {Function} dataLoadedCallback - RPM or RP callback invoked after data is sucessfully loaded.
         * @param {Function} errorCallback - RPM or RP callback invoked if there is data load error.
         */
        loadData: function(dataLoadedCallback, errorCallback) {
            var resultObj = this.getSelectorCall(),
                url = resultObj.url || null,
                qp = null;

            if (resultObj.error) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'RP_Platform ERROR: ' + resultObj.message);

                if (typeof errorCallback === "function") {
                    errorCallback(new uvpjs.ErrorInfo({
                        eventType: this.eventsMgr.eventTypes.PLAYER_START_ERROR,
                        errorCode: uvpjs.ErrorInfo.errorCodes.SELECTOR_CALL_ERROR,
                        message: uvpjs.ErrorInfo.messages.SELECTOR_CALL_ERROR + " " + resultObj.message,
                        isFatal: true
                    }));
                }

                return;
            }

            this.dispatchVideoStateChange(this.mc.LOADING);

            this.dataLoadedCB = dataLoadedCallback;

            if (uvpjs.util.isDefinedString(this.rco.sig)) {
                qp = {sig: this.rco.sig}
            }

            this.contentDataProxy.setOptions({
                pid: this.rco.pid || null,
                cmsRefGuid: this.rco.cmsRefGuid || null,
                successCallback: this.onDataProxyComplete.bind(this),
                errorCallback: errorCallback
            });

            this.contentDataProxy.loadData(url, qp);
        },

        /**
         * Create, initialize, and play a Video Facade only after loading the metadata and in
         * this method resetting the CVI_Model.
         * @memberof uvpjs.RP_Platform#
         *
         * @param {Boolean} suppressFacadePlay - if TRUE; will avoid invoking facade.playVideo
         */
        loadVideoAndBeginPlayback: function(suppressFacadePlay) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_Platform loadVideoAndBeginPlayback; roc = ', this.rco);

            this.resetModelState();
            this._super(suppressFacadePlay);
        },

        //////////////
        // PRIVATE/PROTECTED
        /**
         * Create a valid selector call
         * @memberof uvpjs.RP_Platform#
         *
         * @return {Object} Object with error=true if unable to create a valid selector call, and url property.
         */
        getSelectorCall: function () {
            var rco = this.rco,
                url = (rco.has('selectorCall') && rco.selectorCall) || null,
                pid, guid, nullParam, usePid,
                useGuid, badCfg, idToUse, msg, re;

            if (!url) {
                url = this.cviModel.getClassListItemProperty('VideoSourceManager', 'Platform_MPX', 'MultiBitrateURL');
                usePid = url && url.indexOf('$PID$') > -1;
                useGuid = url && url.indexOf('$GUID$') > -1;

                pid = (rco.has('pid') && rco.pid) || null;
                guid = (rco.has('cmsRefGuid') && rco.cmsRefGuid) || null;

                badCfg = !usePid && !useGuid;
                nullParam = !pid && !guid;

                if (badCfg || nullParam) {
                    msg = 'Config error: ' +
                          (badCfg ? 'Suitable selector call not found in config or RCO.' :
                          'Missing expected param: ' + (usePid ? 'pid' : 'cmsRefGuid'));

                    return { error: true, message: msg};
                }

                idToUse = usePid ? pid : guid;
                re = usePid ? /\$PID\$/g : /\$GUID\$/g;

                url = url.replace(re, idToUse);
                url = url.replace(/manifest=f4m/g, 'manifest=m3u');
            }

            return {error: false, url: url};
        },

        /**
         * @memberof uvpjs.RP_Platform#
         * @protected
         */
        onDataProxyComplete: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_Platform - ContentDataProxy "complete" callback invoked');

            this.manageLocalAndGlobalResume();
            this.setContinuationParams();

            this.dataLoadedCB();
        },

        /**
         * @memberof uvpjs.RP_Platform#
         * @private
         */
        setContinuationParams: function() {
            var u = uvpjs.util;

            // contsess used by DW agent
            if (!u.isEmpty(this.cviModel.sessionOptions.contsess)) {
                this.contentDataProxy.setProperty('previousSessionId', this.cviModel.sessionOptions.contsess);
            }

            // for DW agent and ad calls; values are 'endcard', 'endcard_click', or empty string
            if (!u.isEmpty(this.rco.contPlayState)) {
                this.contentDataProxy.setProperty('contPlayState', this.rco.contPlayState);
            }
        },

        /**
         * Manages local and global content resume functionality; only applies to episodes.
         * Avoids resuming if resume time is within last 20 seconds of content
         * @memberof uvpjs.RP_Platform#
         * @protected
         */
        manageLocalAndGlobalResume: function() {
            var cvs = this.cviModel.contentVideoState,
                dp = this.contentDataProxy,
                rco = this.rco,
                shouldUseGlobalResume = function() {
                    var dur = dp.getProperty('duration'),
                        hasGlobalResume = !uvpjs.util.isEmpty(rco.globalResumeTime) && rco.globalResumeTime > 0;

                    return hasGlobalResume && dur > 0 && (dur - rco.globalResumeTime) > 20;
                },
                et, elapsedTime, useGlobalResume, st, useLocalResume, ct, ps, sp;

            this.populateContentVideoStateFromLocalStorage();

            elapsedTime = Date.now() - (+cvs.resumeEpochTime);

            dp.setProperty('resumePid', cvs.resumePid);
            dp.setProperty('resumeEpochTime', +cvs.resumeEpochTime);
            dp.setProperty('resumeSessionId', cvs.resumeSessionId);
            dp.setProperty('resumeContentTime', +cvs.resumeContentTime);
            dp.setProperty('playedChapterTime', +cvs.playedChapterTime);
            dp.setProperty('showPreroll', cvs.showPreroll);
            dp.setProperty("sendResumeEvent", false);

            if (dp.getProperty("episodeFlag") && cvs.isLive !== true) {
                useGlobalResume = shouldUseGlobalResume();
                useLocalResume = !useGlobalResume && rco.pid === cvs.resumePid;

                if (useGlobalResume || useLocalResume) {

                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_Platform; Resume: ' + useLocalResume ? 'Local' : 'Global');

                    st = useGlobalResume ? rco.globalResumeTime : (+cvs.resumeContentTime || 0);
                    et = useGlobalResume ? 0 : (elapsedTime || 0);
                    sp = useGlobalResume ? false : elapsedTime > this.ONE_HOUR_MS;
                    ps = useGlobalResume ? this.cviModel.sessionId : '';

                    ct = this.getPlayedChapterTimeForContentResume(st);

                    dp.setProperty('sendResumeEvent', true);
                    dp.setProperty('startTime', st);
                    dp.setProperty('elapsedTime', et);
                    dp.setProperty('showPreroll', sp);
                    dp.setProperty('playedChapterTime', ct);
                    dp.setProperty('previousSessionId', ps);

                    this.eventsMgr.dispatchEvent(
                        this.eventsMgr.eventTypes.USER_GESTURE,
                        {gestureInfo: [(useLocalResume ? 'local': 'global') + 'Resume']},
                        this.vidContId
                    );
                }
                else { /* No resume */
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_Platform; No global or local resume.');
                    this.clearLocalStorageItems();
                }
            }
        },

        /**
         * Determines the last played chapter time for the content resume functionality.
         * @memberof uvpjs.RP_Platform#
         * @private
         * @return {Integer} The closest playedChapterTime in seconds.
         */
        getPlayedChapterTimeForContentResume: function(resumeTime) {
            var playedChapTime = 0,
                csarr = this.contentDataProxy.getProperty('chapterStartTimes'),
                i = csarr.length || 0,
                ctime;

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_Platform: chapterStartTimes = ', csarr);

            if (i) {
                while(i--) {
                    ctime = csarr [i];
                    //  1) If resume time is close to chapter time, adjust resume time to ensure the ad slot is watched
                    //  2) If ctime not the first midroll, make the midroll previous to ctime be the
                    //     playedChapterTime so user won't watch 2 midroll slots esentially back-to-back.
                    if (resumeTime >= ctime) {
                        if (resumeTime - ctime >= 4) {
                            playedChapTime = ctime;
                        }
                        else {
                            this.contentDataProxy.setProperty('startTime', resumeTime - 4);
                            i > 0 && (playedChapTime = csarr[i-1]);
                        }

                        break;
                    }
                }
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_Platform resume using playedChapTime = ', playedChapTime);

            return playedChapTime;
        }
});

}(uvpjs.register('uvpjs')));

/**
 * Created by ldoyle on 12/16/15.
 */

'use strict';

(function (obj) {

    var _ = obj._;


    /**
     * ResourceProvider RP_Mdialog = “rp_mdialog” uvpjs.mediaCapabilities.RP_MDIALOG
     *
     * @constructor uvpjs.ResourceProvider.RP_Mdialog
     * @extends uvpjs.ResourceProvider
     */

    obj.RP_Mdialog = uvpjs.ResourceProvider.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PROVIDER,

        init: function(options) {
            this.debug = uvpjs.debug;
            this._super(options);
            this.providerType = uvpjs.mediaCapabilities.RP_MDIALOG;
        },

        /**
         * @memberof uvpjs.ResourceProvider.RP_Mdialog
         *
         * @param {object} rcObj - Validated Resource Config Object.
         * @param {object} cviMgr - Validated Core Video Instance Manager.
         * @param {string} vidContId - Validated Video Container Tag Element ID.
         */
        initialize: function(rcObj, cviMgr, vidContId) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'RP_Mdialog initialize vidContId        = ', vidContId);
            }
            this._super(rcObj, cviMgr, vidContId);
        },

        /**
         * Load any additional metadata, ex: Platform SMIL file, and call dataLoadedCallback() when done.
         * @memberof uvpjs.RP_Mdialog
         *
         * @param {function} dataLoadedCallback - RPM or RP callback invoked after data is sucessfully loaded.
         * @param {function} errorCallback - RPM or RP callback invoked if there is data load error.
         */
        loadData: function(dataLoadedCallback, errorCallback) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'RP_Mdialog loadData');
            }
            if (!_.isFunction(dataLoadedCallback)) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.UVPJS_WARNING,
                    {msg:'ResourceProvider initialize init params missing or invalid RETURN WITHOUT CREATING A RESOURCE PROVIDER'},
                    this.internalNS
                );

                return;
            }

            this.dataLoadedCB = dataLoadedCallback;
            this.dataLoadErrorCB = errorCallback;
            // todo need additional intelligence here to gather state asynchronously and callback in a different function.
            this.dataLoadedCB();  //callback when data is loaded. In this case calling the Resource Playlist Manager, which doesn't need a data object.
        },

        // TODO for other non-RP_URL resource providers create dataloadedCallback() so non-RPM RPs can callback their parrent RPs after dataload

    });

}(uvpjs.register('uvpjs')));


(function (obj) {
    'use strict';

    var _ = obj._;


    obj.RP_IMA = uvpjs.RP_Platform.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PROVIDER,
        STUCK_AD_DEBUG_ID: uvpjs.DebugManager.configParams.STUCK_AD,

        AD_SETTINGS: 'AdSettings',
        AD_CALL_OVERRIDE: 'adCallOverride',

        // IMA -> Content playback scenarios
        AD_CALL_ONLY: 'adCallOnly',
        PLATFORM: 'platform',
        CONTENT_AND_AD_CALL: 'contentAndAdCall',
        MDIALOG: 'mdialog',

        AD_BLOCKER_POLLING_INTERVAL: 120, // in seconds, time between calls to adBlockerCallback.
        IMA_TIMEOUT: 'imaTimeout',

        STUCK_AD_NUM_INTERVALS: 10, // Number of refresh intervals before an ad should be considered stuck

        /**
         * @constructor uvpjs.ResourceConfigObject.RP_IMA
         * @extends uvpjs.RP_Platform
         *
         * @param {Object} options
         */
        init: function(options) {
            this.imaAdCall = '';
            this.imaScenario = '';

            this.APM = {};
            this.currAdPod = {};
            this.isRP_IMACleanedUp = false;
            this.dynamicMidRollPodCount = 0;
            this.lastAdBlockCheckTime = 0;
            this.imaCuePoints = [];
            this.viewGuid = '';
            this.renderSettings = {};

            this.dynamicAdSessionInProgress = false;
            this._uvpEventListenersAdded = false;
            this.adTrackingHandle = null;

            this.contentPlayheadTracker = {
                currentTime: 0,
                pendingSeekTime: -1,
                seeking: false,
                duration: 0
            };

            this.adCallUrl = '';
            this.ad = null;

            this.previousRemainingTime = null;
            this.stuckIntervals = 0;

            this.seekPending = false;

            this._super(options);

            this.providerType = uvpjs.mediaCapabilities.RP_IMA;
        },

        /**
         * IMA Resource Provider load data scenarios:<br>
         *     1) AD_CALL_ONLY - Load and play an IMA ad, finish ad, cleanup, tell RPM we're finished.
         *     2) PLATFORM - Play ads and content using a Platform PID or Selector call. Requires constructing a
         *        Platform Resource Provider to load and parse a SMIL file, then provide it to IMA Resource Provider.
         *     3) CONTENT_AND_AD_CALL - Play content and ads using an Ad Call, content url, and content
         *        metadata provided in the IMA_RCO.
         * Dynamic Ads - Play content with Dynamic Ad Insertion. Ad break info would be in ID3 Tags or some side car
         *               feed. Use the VCI .loadDynamicAdCall(adcall) API method to initiate.
         * If an ads manager exists the dynamic ad is rejected. The ads manager is killed after each ad pod so the
         * existence of an ads manager would indicate either overlapping attempts to start a dynamic ad or
         * an ad call was used that returned a VMAP and the IMA ads manager persists between ads as it waits
         * for next mid0-roll or post-roll slot (an error case). Only simple ad calls can be used in Dynamic Ads case.
         *
         * (is this a separate use case?) Play a pre-roll for a SyncBack live Stream. - this seems like just a simple
         * play IMA RCO and when done play a Syncback RCO?
         *
         * @memberof uvpjs.ResourceConfigObject.RP_IMA
         *
         * @param {object} rcObj - Validated Resource Config Object.
         * @param {object} cviMgr - Validated Core Video Instance Manager.
         * @param {string} vidContId - Validated Video Container Tag Element ID.
         *
         * @returns {undefined} undefined
         */
        initialize: function(rcObj, cviMgr, vidContId) {
            var errorInfo, contentVideoDiv;

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'RP_IMA Initializing; IMA version = ', google.ima.VERSION);
                uvpjs.log(this.DEBUG_ID, 'RP_IMA Initializing: rcObj = ', rcObj);
                uvpjs.log(this.DEBUG_ID, 'RP_IMA Initializing: vidContId = ', vidContId);
            }

            this.playbackState = this.mc.EMPTY;
            this.vidContId = vidContId;
            this.adsLoader = null;
            this.adsManager = null;
            this.remainingTimeInterval = 0;
            this.refreshFrequency = 300;
            this.duration = 0;                    // reset on each ad load
            this.currImaAdTime = 0;
            this.savedSeekToTime = -1;            // set to -1 when there is no saved seek to time. Reset after finishing a seek.
            this.adPodInProgress = false;
            this.adStartEventReceived = false;    // set false when an ad call is made and true when the AdStarted event is received.
                                                  // Needed for error case where an ad is loaded but fails before starting.
            this.uvpjsAdStartOpened = false;      // set to false when AD_END sent, supports ad interruption recovery.
            this.uvpjsContentStartOpened = false; // set true when a CONTENT_START event is dispatched and needed when the
                                                  // IMA RP is interrupted so the cleanup can dispatch an content end.
            this.contentVideoPresent = false;     // set when a content video is present, either paused or playing. Use in interruption case.
            this.contentNeedsToBeLoaded = false;  // set when it knows content will need to be loaded in the _onContentResumeRequested callback.
            this.rco = rcObj;

            this.isContentScenario = false;

            this._super(rcObj, cviMgr, vidContId);

            this.cviModel.isCurrVideoAd = false;

            // scenarios: AD_CALL_ONLY, PLATFORM, CONTENT_AND_AD_CALL
            this.imaScenario = this._determineIMAScenario(this.rco);

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA initialize this.imaScenario = ', this.imaScenario);

            if (this.imaScenario === null) {
                errorInfo = this.getUnknownImaScenarioError();
                this.eventsMgr.dispatchEvent(errorInfo.eventType, { errorInfo: errorInfo }, vidContId);
            }
            else {
                contentVideoDiv = document.getElementById(uvpjs.domConstants.CONTENT_ID_PREFIX + this.vidContId);
                this.videoPlayerDiv = document.getElementById(this.vidContId);
                this.contentVideoTag = contentVideoDiv.getElementsByTagName('video')[0];

                // calling setAdVideoState with no args populates adVideoState with default prrops/values
                this.cviModel.setAdVideoState();
            }
        },

        /**
         * Step One - Called by RPM Resource Playlist Manager. Load any additional metadata.
         * @memberof uvpjs.RP_IMA#
         *
         * @param {function} dataLoadedCallback - RPM or RP callback invoked after data is successfully loaded.
         * @param {function} errorCallback - RPM or RP callback invoked if there is data load error.
         */
        loadData: function(dataLoadedCallback, errorCallback) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA loadData');

            this._updateIMAPlaybackState(this.mc.LOADING);
            !this.mc.isChromecast() && this._updateAdSize(0, 0);

            switch(this.imaScenario){
                case this.AD_CALL_ONLY:
                    dataLoadedCallback(); // all metadata exists in the RCO
                    break;

                case this.PLATFORM:
                    this._super(dataLoadedCallback, errorCallback);
                    break;

                case this.CONTENT_AND_AD_CALL:
                    dataLoadedCallback(); // all metadata exists in the RCO
                    break;

                default:
                    break;
            }
        },

        /**
         * @memberof uvpjs.RP_Platform#
         * @override
         *
         * @returns {undefined} undefined
         */
        onDataProxyComplete: function() {
            this.setImaAdUrl();
            this._super();
        },

        /**
         * Step Two - Called by RPM Resource Playlist Manager. Create, initialize, and play a IMA video only after
         * loading the metadata and in this method resetting the CVI_Model.
         * @memberof uvpjs.RP_IMA#
         * @override
         *
         * @param {Boolean} suppressFacadePlay - ignored in this implementation.
         */
        loadVideoAndBeginPlayback: function(suppressFacadePlay) {
            var rco = this.rco,
                mdl = this.cviModel,
                rcoAdCall = uvpjs.util.isDefinedString(rco.adCall) ? rco.adCall : null,
                isPlatform = this.imaScenario === this.PLATFORM,
                adCallToUse = rcoAdCall || (isPlatform ? this.imaAdCall : null);

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA load/beginPlay, id= ' + this.vidContId + '; RCO= ', this.rco);

            this.cviMgr.contentInitializedForIMA = false;
            this.resetModelState();
            this.setModelRcoOverrides();
            this._addUVPEventListeners();
            this.adsLoader = this.cviMgr.adsLoader; // adsLoader is created once and shared by all instances of IMA RPs

            if (this.imaScenario === this.AD_CALL_ONLY) {
                mdl.mergeCDOData();
                this.finishLoadVideoAndBeginPlayback(adCallToUse);
            }
            else {
                // 1) Populate the CVI_Model with contentDataProxy's model
                // 2) Overwrite contentVideoState with Resource Config Object values.
                // 3) Merge Config Data Object (CDO) data back into the content state and ad state objects.
                mdl.setNonDefaultContentVideoStateItems(this.contentDataProxy.getModel());
                mdl.setContentVideoStateItems(rco);
                mdl.mergeCDOData();

                if (this.multiCdnClient) {
                   this.multiCdnClient.getDecision(this.handleCdnDecision.bind(this, adCallToUse));
                }
                else {
                    this.doFlashCheck(adCallToUse);
                }
            }
        },

        /**
         *
         * @param adCall
         */
        finishLoadVideoAndBeginPlayback: function (adCall) {
            var adCallUrl = '',
                adu = uvpjs.adUtil,
                mdl = this.cviModel;

            this.cviMgr.setPlaybackInfoOnModel();

            if (this.imaScenario !== this.AD_CALL_ONLY) {
                this.dispatchContentDataLoaded();
                this.contentNeedsToBeLoaded = true;
                mdl.incrementMedNum();
                this.isContentScenario = true;
            }

            if (!adCall) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA finishLoadVideoAndBeginPlayback: No ad call.');
            }
            else {
                adCallUrl = adu.populateImaAdCallValues(adCall, mdl, this.isContentScenario);
                this.viewGuid = adu.getDwViewGuid(mdl);

                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA assembled ad call...', adCallUrl);
            }

            this.killDataProxy(); // no longer needed
            this.RPM.resourceStart(this.rco.rcoSeed);
            this.requestAdsManagerOrResume(adCallUrl);
        },

        /**
         * @memberof uvpjs.RP_Platform#
         *
         * @param {String} adCallUrl
         */
        requestAdsManagerOrResume: function (adCallUrl) {
            // In dynamic ad case there may be no pre-roll
            if (_.isString(adCallUrl) && !_.isEmpty(adCallUrl)) {
                this._requestAdsManager(adCallUrl);
            }
            else {
                this._onContentResumeRequested();
            }
        },

        /**
         * @memberof uvpjs.RP_Platform#
         *
         * @param smilXmlData
         *
         * @returns {boolean}
         */
        setImaAdUrl: function () {
            var adCallOverride = this.checkForAdCallOverride();

            if (adCallOverride) {
                this.contentDataProxy.setProperty('imaAdCall', adCallOverride);
                this.imaAdCall = adCallOverride;
            }
            else {
                // this happens prior to setting cvi model values, so data proxy is used here
                this.imaAdCall = this.contentDataProxy.getProperty('imaAdCall');
            }
        },

        /**
         * @memberof uvpjs.RP_Platform#
         * @return {String} The Ad Call override url or an empty string
         */
        checkForAdCallOverride: function(){
            var mod = this.cviModel.getModule(this.AD_SETTINGS),
                modActive = mod != null && mod.enabled == true,
                aco = this.cviModel.getModuleParam(this.AD_SETTINGS, this.AD_CALL_OVERRIDE),
                altAdCall = null;

            if (modActive && !_.isUndefined(aco)) {
                altAdCall = aco;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA dCallOverride: ' + (altAdCall || 'null'));

            return altAdCall;
        },

        /**
         * Manages local and global content resume functionality; only applies to episodes
         * @memberof uvpjs.RP_Platform#
         * @override
         */
        manageLocalAndGlobalResume: function() {
            this._super();
            this.contentDataProxy.setProperty("podsToSkip", this.getPodsToSkip());
        },

        /**
         * Determines the last played chapter time for the content resume functionality.
         * @memberof uvpjs.RP_Platform#
         *
         * @returns {String} A comma separated string of ad pod locations that can be appended to the IMA ad call to
         * prevent viewed pre-roll and mid-roll ads from playing in the Resume case.
         */
        getPodsToSkip: function() {
            var rtnStr = '',
                cdp = this.contentDataProxy,
                chapterTimes = cdp.getProperty('chapterStartTimes'),
                pos;

            if (!cdp.getProperty("showPreroll")) {
                rtnStr  = '1';
            }

            if (chapterTimes.length > 0){
                pos = chapterTimes.indexOf(cdp.getProperty("playedChapterTime"));

                if (pos >= 0) {
                    pos = pos + 2;
                    rtnStr = rtnStr.length > 0 ? rtnStr + ',' + String(pos) : String(pos);
                }
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_Platform getPodsToSkip returning: ', rtnStr);

            return rtnStr;
        },

        /**
         * Dispatches an error for an unknown IMA scenario
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        getUnknownImaScenarioError: function() {
            return new uvpjs.ErrorInfo({
                eventType: this.eventsMgr.eventTypes.PLAYER_START_ERROR,
                errorCode: uvpjs.ErrorInfo.errorCodes.IMA_SCENARIO_UNKNOWN,
                message: uvpjs.ErrorInfo.messages.IMA_SCENARIO_UNKNOWN,
                isFatal: true
            });
        },

        /**
         * Create Content Video Facade here.
         *
         * IMA SDK Ad Rules: Note: When the content has finished playing or the user has stopped playback,
         * be sure to call AdsLoader.contentComplete in order to signal to the SDK that the content is done.
         * The SDK will then play the post-roll ad break, if one has been scheduled.
         * The ALL_ADS_COMPLETED event will be raised when ALL ad breaks have been played.
         *
         * In addition, note that content tracking begins when init() is called and you should always
         * call init() before playing content.
         * @memberof uvpjs.RP_IMA#
         */
        createContentFacade: function () {
            this.createFacade();
            this.id3HandlingEnabled && this.createId3Parser(this.facade.facadeType);
        },

        /**
         * @override
         */
        facadeDisplayReady: function() {
            if (this.facade.facadeType === this.mc.FLASH_HLS) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.CAPTIONS_READY,
                    { vidState: this.cviModel.getContentVideoState()},
                    this.vidContId
                );
            }
        },

        facadeDone: function() {
            this.imaContentComplete();
        },

        /**
         * IMA Ad Event handler
         * @memberof uvpjs.RP_IMA#
         *
         * @param {Object} adEvent - IMA AdEvent object.
         */
        onAdEvent: function(adEvent) {
            var adData = adEvent.getAdData(),
                ad = adEvent.getAd(), // returns 'google.ima.ad' reference
                type = google.ima.AdEvent.Type,
                state, adPodId, podIdx;

            this.cviModel.isCurrVideoAd === true && this.trackAdEvent(adEvent.type);

            // NOTE: Some events (e.g. ALL_ADS_COMPLETED) don't have an ad object associated.'

            switch (adEvent.type) {
                // Fired when ad data is available.
                // CX note 4/6/2016:
                // For any single ad call you can get multiple google.ima.AdEvent.Type.LOADED messages depending
                // on how many ads are in the pod. Set this.adPodInProgress = true the first time. Check
                // this.adPodInProgress === true; if so bail out and don't dispatch ad pod start, etc. more than once.
                case type.LOADED:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.LOADED ad = ', ad);

                    this.cviModel.setAdVideoStateItems({adAssetUrl: this._getAdAssetUrl(adEvent)});
                    this._dispatchAdLoaded();

                    if (!this.adPodInProgress) {
                        // only do this once per POD though IMA will call this for each ad it plans to play in the pod.
                        this.adPodInProgress = true;

                        var adPodInfo = ad.getAdPodInfo();

                        podIdx = adPodInfo.getPodIndex();

                        if (this.debug) {
                            uvpjs.log(this.DEBUG_ID, 'RP_IMA ima.AdEvent.Type.LOADED podIdx = ', podIdx);
                            uvpjs.log(this.DEBUG_ID, 'RP_IMA ima.AdEvent.Type.LOADED podInfo = ', adPodInfo);
                        }

                        if (podIdx === 0) {
                            adPodId = 'pre';
                        }
                        else if (podIdx === -1) {
                            adPodId = 'post';
                        }
                        else if (podIdx >= 1) {
                            adPodId = 'mid_' + podIdx;
                        }

                        this.currAdPod = this.APM.getAdPodById(adPodId);

                        if (this.currAdPod === undefined) {
                            this.debug && uvpjs.warn(this.DEBUG_ID, 'AdEvent.Type.LOADED currAdPod is undefined.');

                            this.eventsMgr.dispatchEvent(
                                this.eventsMgr.eventTypes.AD_ERROR,
                                {
                                    errorInfo: new uvpjs.ErrorInfo({
                                        eventType: this.eventsMgr.eventTypes.AD_ERROR,
                                        errorCode: uvpjs.ErrorInfo.errorCodes.IMA_AD_ERROR,
                                        message: uvpjs.ErrorInfo.messages.IMA_ADPOD_ERROR,
                                        isFatal: false,
                                        adInfo: this.extractAdInfo(ad)
                                    }),
                                    adCallUrl: this.adCallUrl
                                },
                                this.vidContId
                            );

                            this.adErrorCheckForContentVideoBeforeCallingCleanUp();
                            return;
                        }

                        this.currAdPod.adCount = adPodInfo.getTotalAds();
                        this.currAdPod.podDuration = adPodInfo.getMaxDuration();

                        this.debug && uvpjs.log(this.DEBUG_ID, 'AdEvent.Type.LOADED this.currAdPod = ', this.currAdPod);

                        if (this.APM.isMidRoll(this.currAdPod) || this.dynamicMidRollPodCount > 0){
                            // dispatch CONTENT_END FOR MID-ROLLS test to make sure content video has been
                            // paused before this CONTENT_END event is dispatched.
                            this.uvpjsContentStartOpened = false;
                            this.dispatchContentEnd();
                        }

                        this.dispatchAdPodStart();
                    }

                    break;

                // Fired when the ad starts playing. //* This event indicates the ad has started - the video player can
                // adjust the UI, for example display a pause button and remaining time.
                // Dispatches AD_START!
                case type.STARTED:
                    var act = ad.getContentType(), podInfo, adCount;
                    this.ad = ad;

                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.STARTED');

                    this.adStartEventReceived = true;   // Set false when an ad call is made and true here when the
                                                        // AdStarted event is received. Needed for error case where an
                                                        //  ad is loaded but fails before starting.
                    this.cviModel.isCurrVideoAd = true; // Also set by the video progress event.
                    this.cviModel.incrementAdNum();
                    this.cviModel.resetAdPlaybackState();

                    this.duration = ad.getDuration();

                    // Custom click tracking is only used when an optional click tracking element is provided to the
                    // AdDisplayContainer, custom playback is used, and the current ad is not an AdSense/AdX ad.
                    // 'You can check ima.AdsManager.isCustomClickTrackingUsed when the google.ima.AdEvent.Type.STARTED
                    // event is fired to determine whether or not to display your custom click tracking element. '
                    //this.adVideoState.isCustomClickTrackingUsed = this.adsManager.isCustomClickTrackingUsed();
                    // Also set adAssetUrl here as it may not be available for some ads (VPAIDs) in LOADED
                    this._populateAdVideoState(ad, {
                        isCustomClickTrackingUsed: this.adsManager.isCustomClickTrackingUsed(),
                        adAssetUrl: this._getAdAssetUrl(adEvent)
                    });

                    // finally then have the CVI_Model merge and Config Data Object (CDO) data back into
                    // the content state and ad state objects.
                    this.cviModel.mergeCDOData();

                    // set isVPAID if content type is 'application/javascript'
                    // From Chris Feldman on the IMA team a list of all possible mime types:
                    // application/javascript [VPAID], application/x-shockwave-flash [VPAID],
                    // video/mp4, video/mpeg, application/x-mpegURL, video/ogg, video/3gpp,
                    // video/webm,audio/mpeg,audio/mp4,text/html,application/flash,application/shockwave-flash,
                    // text/javascript ,image/jpeg , image/jpg,image/png, image/gif
                    // This value is in the VAST response under the 'type' property of the MediaFile element,
                    // and you will be limited by the capabilities of your video player.


                    if (act === 'application/javascript' ||  act === 'application/x-shockwave-flash') {
                        this.cviModel.setAdVideoStateItems({isVPAID:true});
                    }
                    // log if content type is Flash VPAID until we are confident IMA is not delivering Flash ads.
                    act === 'application/x-shockwave-flash' && console.warn('IMA delivered FLash VPAID: application/x-shockwave-flash!');

                    this.trackAd(ad);
                    this.trackAdEvent(type.STARTED);

                    podInfo = ad.getAdPodInfo();
                    podInfo && (adCount = podInfo.getTotalAds());

                    // Dispatch AD_START.
                    this._dispatchAdStart(adCount);

                    this._updateIMAPlaybackState(this.mc.PLAYING);
                    this.onUVPJSTimerTick();
                    this._addVideoProgressTimerCallback();
                    this._startRemainingTimeInterval();
                    break;

                case type.FIRST_QUARTILE:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.FIRST_QUARTILE');
                    this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_QUARTILE, {percent:25}, this.vidContId);
                    break;

                case type.MIDPOINT:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.MIDPOINT');
                    this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_QUARTILE, {percent:50}, this.vidContId);
                    break;

                case type.THIRD_QUARTILE:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.THIRD_QUARTILE');
                    this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_QUARTILE, {percent:75}, this.vidContId);
                    this._checkForContentPreload();
                    break;

                // Fired when the ad completes playing.
                // This event indicates the ad has finished - the video player can perform appropriate UI actions
                case type.COMPLETE:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.COMPLETE');
                    this.ad = null;
                    this._updateIMAPlaybackState(this.mc.STOPPED);
                    this.untrackAd();
                    this._dispatchAdEnd();
                    break;

                // Fired when the ads manager is done playing all the ads.
                case type.ALL_ADS_COMPLETED:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.ALL_ADS_COMPLETED');

                    if (this.imaScenario === this.AD_CALL_ONLY || _.isEmpty(this.facade)){
                        // we know there is no content video so cleanup and end the resource.
                        this.cleanUpRP_IMA();
                    }
                    else {
                        // Destroy the ads manager. In the IMA VMAP case all ads have played and complete cleanup will
                        // execute when the content ends. In the Dynamic Ads case the loadDynamicAdCall() method will
                        // call this._requestAdsManager (adCallUrl) which creates a new Ads Manager for that ad pod.
                        this._destroyAdsManagerAndRemoveAdsManagerListeners();
                    }
                    break;

                // Fired when the ad is clicked.
                case type.CLICK:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.CLICK this.adsManager.pause()');

                    this.adsManager.pause();

                    state = this.cviModel.getAdVideoState();
                    state.paused = true;

                    this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_CLICK, {adData:state}, this.vidContId);
                    break;

                // Fired when the ad is paused.
                case type.PAUSED:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.PAUSED');
                    this._updateIMAPlaybackState(this.mc.PAUSED);
                    break;

                // Fired when the ad is resumed.
                case type.RESUMED:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.RESUMED');
                    this._updateIMAPlaybackState(this.mc.PLAYING);
                    break;

                // Fired when the ad is closed by the user.
                case type.USER_CLOSE:
                    this.stopVideo();
                    this.adErrorCheckForContentVideoBeforeCallingCleanUp();
                    break;

                // Fired when the ad is 'skipped' by the user.
                case type.SKIPPED:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent google.ima.AdEvent.Type.SKIPPED');

                    this.ad = null;

                    // VTG-326: Deprecating event; now passing `skipped` boolean with AD_END.
                    state = this.cviModel.getAdVideoState();
                    this.eventsMgr.dispatchEvent(
                        this.eventsMgr.eventTypes.AD_SKIPPED,
                        {
                            adData: state,
                            adCallUrl: this.adCallUrl
                        },
                        this.vidContId
                    );

                    uvpjs.warn(this.DEBUG_ID,
                        'DEPRECATION NOTICE: The AD_SKIPPED event will be removed in a future release. ' +
                        'Please listen for AD_END and reference the `skipped` boolean in the event object payload '+
                        '(e.g. `adData: { skipped: true }`).'
                    );

                    this._dispatchAdEnd(true);
                    break;

                // Fired when a non-fatal error is encountered.
                // The user need not take any action since the SDK will continue with
                // the same or next ad playback depending on the error situation.
                case type.LOG:
                    var err = adData && adData['adError'],
                        ei = uvpjs.ErrorInfo,
                        isNullAd = ad === null, // 'ad' from adEvent.getAd()
                        evt = this.eventsMgr.eventTypes.AD_ERROR,
                        msg = 'Unknown error - IMA.AdEvent.Type.LOG ',
                        code = ei.errorCodes.IMA_AD_ERROR,
                        imaErrCode = null,
                        imaVastErrCode = null,
                        abCb;

                    if (!err && isNullAd) {
                        // If there is no 'adError' property on adData, and if the ad object is null,
                        // then we have a condition that *might* indicate ad blocking is enabled, but
                        // this may also occur for non-ad blocking contexts.

                        msg += ei.messages.UNEXPECTED_NULL_VALUE_FOR_AD;

                        abCb = this.cviModel.getSessionOption('adBlockerCallback');
                        abCb && typeof abCb === 'function' && abCb() && this.dispatchAdBlockedEvent();
                    }
                    else if (err && 'function' === typeof err.getMessage) {
                        msg += err.getMessage();
                        imaErrCode = err.getErrorCode();
                        imaVastErrCode = err.getVastErrorCode();
                    }

                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent; Non-fatal; AdEvent.Type.LOG; ' + msg);

                    this.eventsMgr.dispatchEvent(
                        evt,
                        {
                            errorInfo: new uvpjs.ErrorInfo({
                                eventType: evt,
                                errorCode: code,
                                serverCode: null,
                                imaErrorCode: imaErrCode,
                                imaVastErrorCode: imaVastErrCode,
                                message: msg,
                                adInfo: this.extractAdInfo(ad),
                                isFatal: false
                            })
                        },
                        this.vidContId
                    );

                    this.checkForAdBlocker();

                    // if there was a seek pending (over a mid-roll, e.g.), but
                    // there's no ad, need to resume seek
                    if (isNullAd && !err && this.savedSeekToTime > -1) {
                        this.resumeContentPlay();
                    }

                    break;

                default:
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdEvent UNKNOWN AD EVENT adEvent.type = ', type);
                    return;
            }
        },

        /**
         * Retrieve the ad metadata from the IMA Ad Object and populate this.adVideoState which will be used to
         * populate the the CVI_Model.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {Object} ad returned by adEvent.getAd();
         * @param {Object} additionalProps additional properties to put on the adVideoState model
         */
        _populateAdVideoState: function(ad, additionalProps) {
            var q, adState;

            if (!_.isObject(ad)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'RP_IMA _populateAdVideoState !_.isObject(ad) RETURN');

                return;
            }

            adState = uvpjs.adUtil.extractAdStateData(ad, uvpjs.adUtil.context.IMA);

            if (additionalProps) {
                for (q in additionalProps) {
                    adState[q] = additionalProps[q];
                }
            }

            this.cviModel.setAdVideoState(adState);

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _populateAdVideoState; mdl.adVideoState: ', this.cviModel.getAdVideoState());
        },

        /**
         * Request ads to play. Calls back to onAdsManagerLoaded(adsManagerLoadedEvent)
         * @memberof uvpjs.RP_IMA#
         *
         * @param {String} adCallUrl - The ad call to obtain ads for the IMA SDK.
         */
        _requestAdsManager: function(adCallUrl) {
            var vidState = this.cviModel.contentVideoState;
            // check for ad blocker here and every 120 seconds if there are midrolls and right before a chapter ends.
            // checkForAdBlocker will dispatch an AD_BLOCK event if detected.
            this.checkForAdBlocker();

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _requestAdsManager adCallUrl = ', adCallUrl);

            // set false when an ad call is made and true when the AdStarted event is received.
            // Needed for error case where an ad is loaded but fails before starting.
            this.adStartEventReceived = false;

            this.adCallUrl = adCallUrl;

            // VTG-303 Error (cause presently unknown) can result in exception if invalid adsLoader instance
            if (uvpjs.util.isEmpty(this.adsLoader)) {
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.AD_ERROR,
                    {
                        errorInfo: new uvpjs.ErrorInfo({
                            eventType: this.eventsMgr.eventTypes.AD_ERROR,
                            errorCode: uvpjs.ErrorInfo.errorCodes.UNEXPECTED_CONDITION,
                            message: "Unexpected condtion: Encountered invalid ima.AdsLoader instance.",
                            isFatal: false
                        }),
                        adCallUrl: this.adCallUrl
                    },
                    this.vidContId
                );

                this.resumeContentPlay();

                return;
            }

            var adsRequest = new google.ima.AdsRequest();
            adsRequest.adTagUrl = adCallUrl;

            // Specify both the linear and nonlinear slot sizes.
            // This helps the SDK to select the correct creative if multiple creatives are returned.'
            this._updateAdSize();
            adsRequest.linearAdSlotWidth = this.containerWidth;
            adsRequest.linearAdSlotHeight = this.containerHeight;
            adsRequest.nonLinearAdSlotWidth = this.containerWidth;
            adsRequest.nonLinearAdSlotHeight = this.containerHeight;

            // VTG-551; r 2.8.3 - new AdsRenderingSettings methods for autoplay
            if ('function' === typeof adsRequest.setAdWillAutoPlay) {
                adsRequest.setAdWillAutoPlay(vidState.isAutoplay);
                adsRequest.setAdWillPlayMuted(vidState.isMuteAtPlayStart);
            }

            // Make request, callback is onAdsManagerLoaded().
            this._dispatchAdRequest();
            this.adsLoader.requestAds(adsRequest);
        },

        /**
         * onAdsManagerLoaded is called by the shared this.adsLoader.requestAds(adsRequest) callback in the CVI.
         *
         * contentPlaybackTracker aka contentPlayheadTracker Player that plays back publisher's content.
         * This must be an object that contains the property currentTime, which allows the SDK to query
         * playhead position to properly display midrolls in case ad server responds with an ad rule, and the duration
         * property. The HMTL5 video element fulfills these requirements. You may optionally implement your own
         * playhead tracker, as long as it fulfills the above requirements.
         * example: https:gist.github.com/adrianotadao/34d64ec633f35141b29f#file-ima-js-changed-js-L589
         * @memberof uvpjs.RP_IMA#
         *
         * @param {Object} adsManagerLoadedEvent - The ad manager loaded event object passed to the CVI version of this method.
         */
        onAdsManagerLoaded: function(adsManagerLoadedEvent) {
            var adObj = this.imaScenario === this.AD_CALL_ONLY ? this.contentVideoTag : this.contentPlayheadTracker,
                currentBitrate = this.cviModel.contentPlaybackState.facadeState.currentBitrate,
                u = uvpjs.util,
                adsMgr, chapStarts, vm;

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA adsManagerLoadedEvent = ', adsManagerLoadedEvent);

            this._dispatchAdResponse();

            // If Resource Provider was destroyed while IMA was waiting for the adsManager...
            if (u.isEmpty(this.RPM) || u.isEmpty(this.RPM.currRP)|| u.isEmpty(this.cviModel) ){
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdsManagerLoaded: resrc provider or cviModel is null');

                if (this.adsManager !== null){
                    this.adsManager.destroy();
                    this.adsManager = null;
                }
                return;
            }

            this.renderSettings = new google.ima.AdsRenderingSettings();

            var rs = this.renderSettings;

            // Maximum recommended bitrate. The value is in kbit/s. The SDK will pick media with bitrate below the
            // specified max, or the closest bitrate if there is no media with lower bitrate found.
            // Default value, -1, means the bitrate will be selected by the SDK.
            rs.bitrate = (currentBitrate > 0 && currentBitrate / 1000) || 750;
            rs.restoreCustomPlaybackStateOnAdBreakComplete = false;
            rs.enablePreloading = false;
            rs.loadVideoTimeout = this._returnIMATimeout();

            adsMgr = this.adsManager = adsManagerLoadedEvent.getAdsManager(adObj, rs);

            if (this.debug) {
                // Custom playback == IMA is using our content video tag to play the ad.
                uvpjs.log(this.DEBUG_ID, 'RP_IMA - adsMgr.isCustomPlaybackUsed() = ', adsMgr.isCustomPlaybackUsed());
                uvpjs.log(this.DEBUG_ID, 'RP_IMA - adsMgr.isCustomClickTrackingUsed() = ', adsMgr.isCustomClickTrackingUsed());
                uvpjs.log(this.DEBUG_ID, 'RP_IMA - adsMgr.getCuePoints() = ', adsMgr.getCuePoints());
            }

            if (this.imaScenario === this.PLATFORM || this.imaScenario === this.CONTENT_AND_AD_CALL){
                chapStarts = this.cviModel.contentVideoState.chapterStartTimes;
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA - chapterStartTimes = ', chapStarts);
            }

            this.imaCuePoints = this.adsManager.getCuePoints();

            if (_.isEmpty(this.imaCuePoints)) {
                this.imaCuePoints = [0];
            }

            // Create AdsPlaylistManager and have it generate the Ad Pod Objects object indexed by ad pod id.
            // Use this.imaCuePoints to determine if there are pre and post rolls and mid-roll pod times.
            this.cviModel.APM = new uvpjs.AdPlaylistManager();
            this.APM = this.cviModel.APM;

            if (this.imaScenario === this.PLATFORM){
                this.APM.initialize(this.vidContId, chapStarts, this.imaCuePoints, this.imaAdCall);
            }
            else if (this.imaScenario === this.CONTENT_AND_AD_CALL) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA; CONTENT_AND_AD_CALL chapterStartTimes = ', chapStarts);
                this.APM.initialize(this.vidContId, chapStarts, this.imaCuePoints, this.rco.adCall);
            }
            else {
                // 5//2/2016 added this.imaCuePoints here to detect case when a 'long form' ad
                // call that expects content is used as an AD_CALL_ONLY ad call, which would
                // stall the player because no ALL_ADS_CMPLETE event would be dispatched in that case.
                this.APM.initialize(this.vidContId, [], this.imaCuePoints, this.rco.adCall);
            }

            // todo (djl) - is the 'todo' below still valid?
            // todo add RESOURCE_AD_DATA_LOADED dispatch with ad data including this.imaCuePoints, no pre or post roll
            // points, format same as this.cviModel.contentVideoState.chapterStartTimes chapterStartTimes
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdsManagerLoaded this.imaCuePoints = ', this.imaCuePoints);

            // add IMA event listeners
            this._addAdsManagerEventListeners();

            // Initialize the ads manager. Ad rules playlist will start at this time.
            vm = this.cviModel.isFullscreen ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;
            this.adsManager.init(this.containerWidth, this.containerHeight, vm);

            // Set initial mute state.
            this.adsManager.setVolume(this.cviModel.isMuted ? 0 : this.cviModel.volume);

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onAdsManagerLoaded.. starting ads');

            if (this.imaUsesContentVideoTag()) {
                this._cleanUpContentVideoFacade();
                this.contentNeedsToBeLoaded = true;
            }

            this.startAds();
        },

        // Important: If the ads are loaded while the content <video> element is initializing, it is necessary
        // to delay the video ad playback until the initialization has finished. Our research shows that this is
        // when the loadedmetadata event is raised from the HTML5 video element. If this condition is not met,
        // it can cause the content to not start correctly after the pre-roll ad has completed. Call start to show ads.
        // Single video and overlay ads will start at this time; this call will be ignored for ad rules, as ad rules
        // ads start when the adsManager is initialized.
        /**
         * @memberof uvpjs.RP_IMA#
         */
        startAds: function() {
            var eCode = null,
                veCode = null,
                msg, ei;

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA startAds');

            try {
                this.adsManager.start(); // starts playback of ads
            }
            catch (adError) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'RP_IMA ERROR startAds adError = ', adError);

                // NOTE: NO_AD_CONTENT event to be deprecated
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.NO_AD_CONTENT, {}, this.vidContId);

                ei = uvpjs.ErrorInfo;
                msg = ei.messages.NO_AD_CONTENT;

                if (adError && 'function' === typeof adError.getMessage) {
                    msg += ": " + adError.getMessage();
                    eCode = adError.getErrorCode();
                    veCode = adError.getVastErrorCode();
                }

                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.AD_ERROR,
                    {
                        errorInfo: new ei({
                            eventType: this.eventsMgr.eventTypes.AD_ERROR,
                            errorCode: ei.errorCodes.IMA_AD_ERROR,
                            message: msg,
                            imaErrorCode: eCode,
                            imaVastErrorCode: veCode,
                            isFatal: false
                        }),
                        adCallUrl: this.adCallUrl
                    },
                    this.vidContId
                );

                this.adErrorCheckForContentVideoBeforeCallingCleanUp();
            }

        },

        /**
         * @memberof uvpjs.RP_IMA#
         *
         * @returns {Boolean}
         */
        imaUsesContentVideoTag: function() {
            return this.adsManager && this.adsManager.isCustomPlaybackUsed();
        },

        /**
         * Called after LOADED and before AD_START
         * 'Fired when content should be paused. This usually happens right before an ad is about to cover the content.'
         *
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _onContentPauseRequested: function() {
            var isLive = false,
                singleTag;

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _onContentPauseRequested by AdsManager');

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_PLUGIN_CONTENT_PAUSE_REQUEST, {}, this.vidContId);

            if (!_.isEmpty(this.facade)) {
                isLive = this.cviModel.contentVideoState.isLive;
                singleTag = this.imaUsesContentVideoTag();

                // VTG-160; prevent content from peeking thru between ads
                !singleTag && this.facade.hideVideo();

                if (isLive && !singleTag) {
                    this.muteContentForAdPlay(true);
                }
                else {
                    // this.cviModel.isCurrVideoAd = true is set when in the an IMA STARTED event case statement.
                    this.facade.pauseVideo();
                    singleTag && (this.savedSeekToTime = !isLive ? this.facade.getCurrentTime() : -1);
                }
                // VTG-172; ensure ad volume is correctly initialized
                this.adsManager.setVolume(this.cviModel.isMuted ? 0 : this.cviModel.volume);
            }
        },


        // NOTE: If a 'long form' ad call, one that expects content after the pre-roll, is used by an 'AD_CALL_ONLY' IMA_RP,
        // then the IMA ALL_ADS_COMPLETED will not be dispatched after this._onContentResumeRequested() is called,
        // and the IMA_RP will stall.
        // A proper 'AD_CALL_ONLY' ad call does not expect content and correctly calls this._onContentResumeRequested()
        // then dispatches the IMA ALL_ADS_COMPLETED event which calls this.cleanUpRP_IMA();
        // Trapping this is problematic since at this point we can't distinguish between a long form ad call and a simple ad call.
        // Hack fix adds ima pre and post cue points to the APM calls this.cleanUpRP_IMA() if there is a post-roll in
        // the AD_CALL_ONLY scenario because ALL_ADS_COMPLETED will not be called in that case.
        /**
         * 'Fired when content should be resumed. This usually happens when an ad finishes or collapses.'
         * Google Says: 'This function is where you should ensure that your UI is ready to play content.
         * It is the responsibility of the Publisher to implement this function when necessary.'
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _onContentResumeRequested: function() {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_PLUGIN_CONTENT_RESUME_REQUEST, {}, this.vidContId);
            this.resumeContentPlay();
        },

        /**
         * Signals to the SDK that the content is finished. This will allow the SDK to play post-roll ads, if any are loaded via ad rules.<br>
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        imaContentComplete: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA imaContentComplete');

            if (!_.isEmpty(this.APM) && this.APM.hasPostRoll()) {

                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA imaContentComplete this.APM.hasPostRoll() call this.adsLoader.contentComplete();');

                this.adsLoader.contentComplete();
                this._cleanUpContentVideoFacade();
            }
            else {

                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA imaContentComplete !this.APM.hasPostRoll() NO POST ROLL wrap it up! call this.cleanUpRP_IMA();');

                this.cleanUpRP_IMA();
            }
        },

        /**
         * Stops the IMA ad video and updates playback state. Called in response to an IMA USER_CLOSE event, but could be called from outside RP_IMA.
         * NOTE: as of 2/24/2016 UVPJS is not supporting CONTROL_STOP. Still looking for a use case.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        stopVideo: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA stopVideo');

            if (this.adsManager){
                this.adsManager.stop();
            }
            this._updateIMAPlaybackState(this.mc.STOPPED);
        },

        /**
         * Resumes content following a 'resume request' event from IMA, or if content needs to be resumed if recovering
         * from an ad failure
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        resumeContentPlay: function() {
            this.contentPlayheadTracker.pendingSeekTime = -1;

            if (this.adPodInProgress){

                // 1) mark currAdPod 'played'
                this.currAdPod.hasPlayed = true;

                // 2) if pod is a pre-roll may need to get some work done like
                //    preparing the content facade? catchall preroll catcher
                //    to ensure content plays? this.startContentAfterPreroll();?
                this.adPodInProgress = false;
                this.handleAdPodEnd();

                if (this.dynamicAdSessionInProgress) {
                    this.dynamicAdSessionInProgress = false;
                    this._destroyAdsManagerAndRemoveAdsManagerListeners();
                }
            }

            // if current ad is a post roll then jump out here

            if (!_.isEmpty(this.APM) && this.APM.isPostRoll(this.currAdPod)){
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA resumeContentPlay by AdsManager post-roll case, content already done RETURN');
                return;
            }

            if (this.contentNeedsToBeLoaded) {
                this.contentNeedsToBeLoaded = false;
                this.createContentFacade();
            }

            if (this.adStartEventReceived) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA resumeContentPlay this.adStartEventReceived === TRUE this._clearRemainingTimeInterval();' );

                this._clearRemainingTimeInterval();
            }
            else {
                // non-fatal error: ad load request made, ad start event not received
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA resumeContentPlay this.adStartEventReceived === FALSE error case, ad load request made but ad start event never received');

                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.AD_ERROR,
                    {
                        errorInfo: new uvpjs.ErrorInfo({
                            eventType: this.eventsMgr.eventTypes.AD_ERROR,
                            errorCode: uvpjs.ErrorInfo.errorCodes.IMA_AD_ERROR,
                            message: uvpjs.ErrorInfo.messages.IMA_AD_START_FAILED,
                            isFatal: false
                        }),
                        adCallUrl: this.adCallUrl
                    },
                    this.vidContId
                );

                this.adErrorCheckForContentVideoBeforeCallingCleanUp();

                return;
            }

            if (!_.isEmpty(this.facade)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA resumeContentPlay this.facade.playVideo() PLAY THE CONTENT VIDEO');

                this.cviModel.isCurrVideoAd = false;
                this.uvpjsContentStartOpened = true;
                this.contentVideoPresent = true;

                // VTG-232 Need to defer CONTENT_START until seek is done.
                this.dispatchContentStart();

                this.facade.setVolume(this.cviModel.volume);
                this.muteContentForAdPlay(false);

                if (this.savedSeekToTime > -1) {
                    if (this.mc.isIOS() && !this.cviModel.contentVideoState.isLive) {
                        this.seekPending = true;
                        this.facade.playVideo();
                        return;
                    }
                    this.facade.seekTo(this.savedSeekToTime);
                    this.savedSeekToTime = -1;
                }

                this.facade.showVideo();
                this.facade.playVideo();
            }
            else {
                this.debug && uvpjs.log(
                    this.DEBUG_ID,
                    'resumeContentPlay facade Empty, no video to play; CHECK FOR POST-ROLL and force cleanup'
                );

                if (this.imaScenario === this.AD_CALL_ONLY && !_.isEmpty(this.APM) && this.APM.hasPostRoll() ){
                    this.debug && uvpjs.warn(this.DEBUG_ID, 'resumeContentPlay; facade isEmpty, no video; HAS POST-ROLL FORCE CLEANUP');
                    this.cleanUpRP_IMA();
                }
            }
        },

        facadePlaybackStateChange: function (newState) {
            if (this.seekPending  && newState === this.mc.PLAYING) {
                this.facade.seekTo(this.savedSeekToTime);
                this.savedSeekToTime = -1;
                this.seekPending = false;
            }

            this._super(newState);
        },

        /**
         * Sets the local playback state. Dispatches VIDEO_STATE_CHANGE event.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {String} newState - The new playback state.
         */
        _updateIMAPlaybackState: function(newState) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _updateIMAPlaybackState this.playbackState = ' + this.playbackState, ' newState = ', newState);

            if (newState !== this.playbackState) {
                this.playbackState = newState;
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _updateIMAPlaybackState dispatch VIDEO_STATE_CHANGE newState = ', newState);

                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.VIDEO_STATE_CHANGE,
                    {
                        currentState: this.cviModel.getAdPlaybackState().playbackState,
                        newState: this.playbackState,
                        isAd: true,
                        adCallUrl: this.adCallUrl,
                        adAssetUrl: this.cviModel.getAdVideoState().adAssetUrl
                    },
                    this.vidContId
                );
            }
        },

        /**
         * Dispatches AD_START event.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {Number} adCount updated total ad count obtained from AdPodInfo object
         */
        _dispatchAdStart: function(adCount) {
            var state = this.cviModel.getAdVideoState();
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _dispatchAdStart dispatch AD_START');
            this.uvpjsAdStartOpened = true; // set to false when AD_END sent, supports ad interruption recovery.

            this.eventsMgr.dispatchEvent(
                this.eventsMgr.eventTypes.AD_START,
                {
                    podAdCount: adCount || 1,
                    adData: state,
                    adCallUrl: this.adCallUrl
                },
                this.vidContId
            );
        },

        /**
         * Dispatches AD_END event.
         *
         * @param {Boolean} skipped  Whether ad end was generated by ad skip button click.
         *
         * @memberof uvpjs.RP_IMA#
         *
         * @private
         */
        _dispatchAdEnd: function (skipped) {
            var state;

            if (!this.uvpjsAdStartOpened) {
                return;
            }

            state = this.cviModel.getAdVideoState();
            state.skipped = skipped === true;

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _dispatchAdEnd dispatch AD_END');
            this.uvpjsAdStartOpened = false; // set to false when AD_END sent, supports ad interruption recovery.
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_END,
                {
                    adData: state,
                    adCallUrl: this.adCallUrl
                },
                this.vidContId
            );
        },

        /**
         * Extract the current ad asset url from an IMA adEvent object
         *
         * @param {Object} adEvent Current ad event object
         *
         * @returns {String} Asset url for the current ad
         *
         * @memberof uvpjs.RP_IMA#
         *
         * @private
         */
        _getAdAssetUrl: function(adEvent) {
            var adData = typeof adEvent.getAdData === 'function' ? adEvent.getAdData() : {},
                ad = typeof adEvent.getAd === 'function' ? adEvent.getAd() : {},
                assetUrl = typeof ad.getMediaUrl === 'function' ? ad.getMediaUrl() : adData.mediaUrl;
            return assetUrl || null;
        },

        /**
         * Dispatches AD_LOADED event.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _dispatchAdLoaded: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _dispatchAdLoaded dispatch AD_LOADED');
            this.eventsMgr.dispatchEvent(
                this.eventsMgr.eventTypes.AD_LOADED,
                {
                    adCallUrl: this.adCallUrl,
                    adAssetUrl: this.cviModel.getAdVideoState().adAssetUrl
                },
                this.vidContId
            );
        },

        /**
         * Dispatches AD_REQUEST event.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _dispatchAdRequest: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _dispatchAdRequest dispatch AD_REQUEST');
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_REQUEST,
                {
                    adCallUrl: this.adCallUrl
                },
                this.vidContId
            );
        },

        /**
         * Dispatches AD_RESPONSE event.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _dispatchAdResponse: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _dispatchAdResponse dispatch AD_RESPONSE');
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_RESPONSE,
                {
                    adCallUrl: this.adCallUrl
                },
                this.vidContId
            );
        },

        /**
         * Dispatches AD_POD_START event with the current ad pod info object as the payload.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        dispatchAdPodStart: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA dispatchAdPodStart dispatch AD_POD_START this.currAdPod = ', this.currAdPod);

            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_POD_START, {adPod:this.currAdPod}, this.vidContId);
        },

        /**
         * Dispatches AD_POD_END event with the current ad pod info object as the payload.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        handleAdPodEnd: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA handleAdPodEnd dispatch AD_POD_END this.currAdPod = ', this.currAdPod);
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_POD_END, {adPod:this.currAdPod}, this.vidContId);

            // Reset adVideoState and current ad pod.
            this.cviModel.setAdVideoState();
            this.currAdPod = {};
        },

        /**
         * Playback state getter.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @returns {Number} Current video playback state.
         */
        getPlaybackState: function() {
            return this.playbackState;
        },

        /**
         * Allows the ad video div size to track the content video player div size
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _updateAdSize: function(w, h) {
            var nuWidth, nuHeight, vm;

            w && (this.containerWidth = w);
            h && (this.containerHeight = h);

            if (this.mc.isChromecast()){ return; } // in chromeCast case the Div is set to 100% x 100%

            nuWidth = parseInt(window.getComputedStyle(this.videoPlayerDiv, null).getPropertyValue('width'));
            nuHeight = parseInt(window.getComputedStyle(this.videoPlayerDiv, null).getPropertyValue('height'));

            if (nuWidth !== this.containerWidth || nuHeight !== this.containerHeight){
                this.containerWidth = nuWidth;
                this.containerHeight = nuHeight;
                if (this.adsManager){
                    vm = this.cviModel.isFullscreen ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL;
                    this.adsManager.resize(this.containerWidth, this.containerHeight, vm);
                }
            }
        },

        /**
         * Remaining time interval callback.
         * Get the remaining time of the current ad that is playing. If the ad is not loaded yet or has finished playing, the API would return -1.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _updateCurrentAdTime: function() {
            //uvpjs.log(this.DEBUG_ID, 'RP_IMA _updateCurrentAdTime');
            this._updateAdSize(); // even if paused still want to check for resize
            if (!this.adsManager || this.playbackState === this.mc.PAUSED || this.playbackState === this.mc.EMPTY){return;}

            var remainingTime = this.adsManager.getRemainingTime();
            if (this._checkForStuckAd(remainingTime)) {
                // Just allow stuck ads to be logged for now
                // return;
            }

            this.currImaAdTime = Math.floor(this.duration - remainingTime);
            this.cviModel.setAdPlaybackStateItems({currentTime: this.currImaAdTime});
        },

        /**
         * Check if the playback of an ad has stalled for more than the allowed threshold
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {Number} remainingTime Most recent remaining time value provided from IMA SDK
         */
        _checkForStuckAd: function(remainingTime) {
            this.debug && uvpjs.log(this.STUCK_AD_DEBUG_ID, 'RP_IMA _checkForStuckAd, remainingTime: ' + remainingTime);
            // If this is the first call, just keep track of the remaining time value and exit out
            if (this.previousRemainingTime === null) {
                this.previousRemainingTime = remainingTime;
                return false;
            }

            var timeDelta = this.previousRemainingTime - remainingTime;
            this.debug && uvpjs.log(this.STUCK_AD_DEBUG_ID, 'RP_IMA _checkForStuckAd, timeDelta: ' + timeDelta);

            if (timeDelta === 0) {
                this.stuckIntervals++;
                this.debug && uvpjs.log(this.STUCK_AD_DEBUG_ID, 'RP_IMA _checkForStuckAd, stuckIntervals: ' + this.stuckIntervals);

            } else {
                this.stuckIntervals = 0;
            }

            if (this.stuckIntervals === this.STUCK_AD_NUM_INTERVALS) {
                // TODO: Figure out how to handle cleaning up/bailing out of a stuck ad
                // this.adErrorCheckForContentVideoBeforeCallingCleanUp();
                // this.adsManager.discardAdBreak();

                // For now, just dispatch an AD_ERROR event
                var errorMessage = 'Ad playback stuck for ' + this.stuckIntervals + ' intervals.',
                    errorInfo = new uvpjs.ErrorInfo({
                        eventType: this.eventsMgr.eventTypes.AD_ERROR,
                        errorCode: uvpjs.ErrorInfo.errorCodes.STUCK_AD_ERROR,
                        message: errorMessage,
                        isFatal: false,
                        adInfo: this.extractAdInfo(this.ad)
                    });
                this.debug && uvpjs.error(this.STUCK_AD_DEBUG_ID, errorMessage, errorInfo);
                this.eventsMgr.dispatchEvent(
                    this.eventsMgr.eventTypes.AD_ERROR,
                    {
                        errorInfo: errorInfo,
                        adCallUrl: this.adCallUrl
                    },
                    this.vidContId
                );

                return true;
            }

            this.previousRemainingTime = remainingTime;
            return false;
        },

        /**
         * Start the remaining time interval.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _startRemainingTimeInterval: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA this.startRemainingTimeInterval()');

            if (this.remainingTimeInterval === 0) {
                // WAS HI5 this.remainingTimeInterval = window.setInterval(function (uvp_ima) {uvp_ima._updateCurrentAdTime();}, this.refreshFrequency, this);
                this.previousRemainingTime = null;
                this.stuckIntervals = 0;
                this.remainingTimeInterval = window.setInterval(this._updateCurrentAdTime.bind(this), this.refreshFrequency, this);
            }
        },

        /**
         * Clear the remaining time interval.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _clearRemainingTimeInterval: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _clearRemainingTimeInterval');

            if (this.remainingTimeInterval !== 0) {
                window.clearInterval(this.remainingTimeInterval);
            }
            this.remainingTimeInterval = 0;
            this.previousRemainingTime = null;
            this.stuckIntervals = 0;
        },

        /**
         * Destroy the Ads Manager: remove event listeners, destroy adsManager and null out ads manager
         * @memberof uvpjs.RP_IMA#
         */
        _destroyAdsManagerAndRemoveAdsManagerListeners: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _destroyAdsManagerAndRemoveAdsManagerListeners');

            if (this.adsManager !== null){
                this._removeAdsManagerEventListeners();
                this.adsManager.destroy();
                this.adsManager = null;
            }

            this.dynamicAdSessionInProgress = false;
        },

        /**
         * Ads Manager Ad Error callback; dispatches AD_ERROR event.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {Object} adErrorEvent - Object containing ad error state
         */
        onAdError: function(adErrorEvent) {
            var ad = (adErrorEvent && adErrorEvent.getAd && adErrorEvent.getAd()) || null;

            // VTG-205: NO_AD_CONTENT event to be deprecated
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.NO_AD_CONTENT, {}, this.vidContId);

            // IMA SDK change:
            // https://developers.google.com/interactive-media-ads/docs/sdks/html5/v3/apis#ima.AdError.getInnerError

            this.dispatchAdErrorEvent(adErrorEvent.getError(), ad);

            this.checkForAdBlocker();

            this.adErrorCheckForContentVideoBeforeCallingCleanUp();
        },

        /**
         * Invoked externally as the result of an AdsLoader error
         * @memberof uvpjs.RP_IMA#
         *
         * @param {Object} adErrorEvent
         */
        handleAdsLoaderError: function(adErrorEvent) {
            this.dispatchAdErrorEvent(adErrorEvent.getError());

            this.adErrorCheckForContentVideoBeforeCallingCleanUp();
        },

        /**
         * Extracts ad info from an IMA ad object (delegate for util method)
         * @private
         *
         * @memberof uvpjs.RP_IMA#
         *
         * @param {Object} ad
         */
        extractAdInfo: function(ad) {
            return uvpjs.adUtil.extractAdInfo(ad, uvpjs.adUtil.context.IMA);
        },

        /**
         * Dispatches an ad error event using the supplied IMA error object
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {Object} adError
         * @param {Object} ad
         */
        dispatchAdErrorEvent: function(adError, ad) {
            var imaMsg = null,
                eCode = null,
                veCode = null,
                code = 'Unknown',
                ei = uvpjs.ErrorInfo,
                isf = uvpjs.util.isFunction.bind(uvpjs.util),
                na = 'n/a',
                unspec = ' Unspecified IMA ad error.',
                innerErr, imsg, icode;

            if (adError && isf(adError.getMessage)) {
                imaMsg = adError.getMessage();
                eCode = adError.getErrorCode;
                veCode = adError.getVastErrorCode();
                code = 'ima code: ' + eCode + '; vast code: ' + veCode;
            }
            // See https://developers.google.com/interactive-media-ads/docs/sdks/html5/v3/apis#ima.AdError.getInnerError
            if (adError && isf(adError.getInnerError)) {
                innerErr = adError.getInnerError();
                if (innerErr) {
                    !imaMsg && (imaMsg = '');
                    imsg = isf(innerErr.getMessage) ? innerErr.getMessage() : (innerErr.message || na);
                    icode = isf(innerErr.getErrorCode) ?  innerErr.getErrorCode() : na;
                    imaMsg += ' Inner error: ' + imsg + '; IMA error code: ' + icode;
                }
            }

            this.debug && uvpjs.warn(this.DEBUG_ID, 'AD_ERROR: ' + imaMsg);

            this.eventsMgr.dispatchEvent(
                this.eventsMgr.eventTypes.AD_ERROR,
                {
                    errorInfo: new ei({
                        eventType: this.eventsMgr.eventTypes.AD_ERROR,
                        errorCode: ei.errorCodes.IMA_AD_ERROR,
                        message: ei.messages.IMA_AD_ERROR_EVENT_RECEIVED + (imaMsg || unspec),
                        isFatal: false,
                        imaErrorCode: eCode,
                        imaVastErrorCode: veCode,
                        adInfo: this.extractAdInfo(ad)
                    }),
                    adCallUrl: this.adCallUrl
                },
                this.vidContId
            );
        },

        /**
         * Dispatches an adBlocked event; invoked when ad blocking detected.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        dispatchAdBlockedEvent: function() {
            this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.AD_BLOCKED, {
                errorInfo: new uvpjs.ErrorInfo({
                    eventType: this.eventsMgr.eventTypes.AD_BLOCKED,
                    errorCode: uvpjs.ErrorInfo.errorCodes.AD_BLOCKING_DETECTED,
                    message: uvpjs.ErrorInfo.messages.AD_BLOCKING_DETECTED,
                    isFatal: false
                })
            }, this.vidContId);
        },

        /**
         * Platform Resource Provider data load error callback.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        adErrorCheckForContentVideoBeforeCallingCleanUp: function() {
            this.debug && uvpjs.warn(this.DEBUG_ID, 'RP_IMA adErrorCheckForContentVideoBeforeCallingCleanUp this.vidContId = ', this.vidContId);

            if (this.contentNeedsToBeLoaded) {
                this.contentNeedsToBeLoaded = false;
                this.createContentFacade();
            }

            if (_.isEmpty(this.facade)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'RP_IMA adErrorCheckForContentVideoBeforeCallingCleanUp this.facade is empty = ', this.facade);
                this.cleanUpRP_IMA();
                return;
            }

            this.cviModel.isCurrVideoAd = false;

            if (!this.contentVideoPresent) {
                this.contentVideoPresent = true;
                this.onUVPJSTimerTick();
                this._addVideoProgressTimerCallback();
            }

            if (!this.uvpjsContentStartOpened) {
                this.uvpjsContentStartOpened = true;
                this.dispatchContentStart();
            }

            this.facade.setVolume(this.cviModel.volume);

            if (this.cviModel.isMuted){
                this.facade.muteVideo();
            } else {
                this.facade.unMuteVideo();
            }

            this.facade.showVideo();
            this.facade.playVideo();
        },

        /*
         VTG-79; not gonna touch this now. There are numerous contexts in which this method is invoked,
                 but with goal of implementing destruction cleanly, need to understand:

            1) If this cleanUp method, like that of the superclass, is intended to carry out instance destruction
            2) How destruction (and proper superclass ResourceProvider destruction) actually should proceed
            3) If and how destruction of this instance is propagated to its creator (RPM)

         A higher-level question is: Should this class really be a subclass of ResourceProvider, or
         might it be advantageous to use a composition pattern implemented on RP?
         */
        /**
         * Cleans up IMA Resource Provider and calls this.super() to clean up the content facade.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        cleanUpRP_IMA: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA cleanUpRP_IMA RP_IMA this.isRP_IMACleanedUp = ', this.isRP_IMACleanedUp);

            if (!this.isRP_IMACleanedUp) {

                var rcoSeedCopy = this.rco.rcoSeed;
                this.isRP_IMACleanedUp = true;
                this._updateIMAPlaybackState(this.mc.STOPPED);
                this.adTrackingHandle = null;

                this._dispatchAdEnd();

                this._clearRemainingTimeInterval();
                this._removeTimers();
                this._removeUVPEventListeners();
                this._destroyAdsManagerAndRemoveAdsManagerListeners();

                // Ad Pod End
                if (this.adPodInProgress) {
                    this.adPodInProgress = false;
                    this.handleAdPodEnd();
                }

                this.killDataProxy();
                this.platformContentVideoState = {};
                this.APM = {};
                this.cviModel.APM = null;

                this._cleanUpContentVideoFacade();
                this.cleanUpObjects();
                this.RPM.resourceEnd(rcoSeedCopy);
            }
        },

        /**
         * CleanUp Content Video Facade items.
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _cleanUpContentVideoFacade: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _cleanUpContentVideoFacade');

            if (this.contentVideoPresent){
                this.contentVideoPresent = false; // helps when long form content is interrupted during an Ad Pod.
                this.dispatchVideoDone();

                if (this.uvpjsContentStartOpened){
                    this.uvpjsContentStartOpened = false;
                    this.dispatchContentEnd();
                }
            }

            this.destroyFacade();
        },

        /**
         * @memberof uvpjs.RP_IMA#
         *
         * @param {String} adCall - A fully qualified and baked IMA ad call.
         */
        loadDynamicAdCall: function(adCall) {
            var adCallUrl;

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA loadDynamicAdCall adCall = ', adCall);

            if (this.adsManager !== null){
                this.debug && uvpjs.warn(this.DEBUG_ID, 'RP_IMA loadDynamicAdCall WARNING this.adsManager != null; RETURN before making dynamic ad call');
                return;
            }

            this.dynamicMidRollPodCount++;

            adCallUrl = uvpjs.adUtil.populateImaAdCallValues(adCall, this.cviModel, this.isContentScenario, this.rco.cpAB);

            if (this.mc.isIOS() && !this.cviModel.contentVideoState.isLive) {
                this.savedSeekToTime = (this.facade && this.facade.getCurrentTime()) || -1;

            }
            this.dynamicAdSessionInProgress = true;

            this.rco.adCall = adCallUrl;
            this._requestAdsManager(adCallUrl);
        },

        /**
         * Ends a dynamic ad session
         * @memberof uvpjs.RP_IMA#
         */
        forceDynamicMidrollPodEnd: function() {
            if (!this.dynamicAdSessionInProgress) { return; }

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA closing dynamic ad session');

            // actions that occur on 'ad complete'
            this._updateIMAPlaybackState(this.mc.STOPPED);
            this._dispatchAdEnd();

            // action that occurs on 'all ads complete'
            this._destroyAdsManagerAndRemoveAdsManagerListeners();

            // resume; takes care of adPodEnd dispatch also
            this.resumeContentPlay();
        },

        /////// Core Video Interface (CVI) Event Callbacks ///////

        /**
         * CVI CONTROL_PAUSE event callback.
         *
         * this._updateIMAPlaybackState(this.mc.PAUSED); is taken care of in the IMA onAdEvent method when the pause actually occurs.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {Object} evtObj - event object with .name, .target:'video Container ID' is a dom element ID string, payload: {} is an empty object.
         */
        onPauseVideo: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onPauseVideo this.adsManager.pause(); this.vidContId = ', this.vidContId, ' this.adPodInProgress = ', this.adPodInProgress);

            if (_.has(evtObj, 'target') && evtObj.target === this.vidContId) {

                if (this.adPodInProgress) {
                    if(this.adsManager){
                        this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onPauseVideo adPodInProgress TRUE this.adsManager.pause(); this.vidContId = ', this.vidContId);
                        this.adsManager.pause();
                    }
                } else {
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onPauseVideo adPodInProgress FALSE this._super(evtObj); have the Resource Provider parent pause the CONTENT video');
                    this._super(evtObj); // have the Resource Provider parent pause the content video
                }

            }
        },

        /**
         * CVI CONTROL_PLAY event callback.<br>
         * Not used by IMA to play the ad, IMA uses adsManager.start();, but it will resume a paused ad.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {object} evtObj - event object with .name, .target:'video Container ID' is a dom element ID string, payload: {} is an empty object.
         */
        onPlayVideo: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onPlayVideo aka resume ima this.vidContId = ', this.vidContId, ' this.adPodInProgress = ', this.adPodInProgress);

            if (_.has(evtObj, 'target') && evtObj.target === this.vidContId) {

                if (this.adPodInProgress) {
                    if (this.adsManager) {
                        this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onPlayVideo adPodInProgress TRUE this.adsManager.resume(); this.vidContId = ', this.vidContId);
                        this.adsManager.resume();
                    }
                } else {
                    this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onPlayVideo adPodInProgress FALSE this._super(evtObj); have the Resource Provider parent play the CONTENT video');
                    this._super(evtObj); // have the Resource Provider parent play the content video
                }
            }
        },

        /**
         * No seeking in ads, this is a pass-thru to the CONTROL_SEEK callback in the content Facade.
         * Check for seeking over mid roll ad pods and set content time in
         * Call the facade seekTo() method with a time in seconds.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {object} e - Events Manager event object.
         */
        onVideoSeekTo: function(e) {
            var currentTime = this.cviModel.contentPlaybackState.currentTime,
                realSeekTime, absSeekTime, unplayedPod;

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onVideoSeekTo evtObj = ', e);

            // validate event, state, and params
            if (e.target !== this.vidContId || _.isEmpty(this.facade) || !this.canSeek(e && e.payload)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onVideoSeekTo BAD or out of range PARAMS, RETURN');
                return;
            }

            // check for no mid-rolls case.
            if (_.isEmpty(this.APM) || !this.APM.hasMidRoll()) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onVideoSeekTo NO MID-ROLLS CALL SUPER with evtObj argument and seek content');
                this._super(e);
                return;
            }

            realSeekTime = e.payload.seekTime;

            // VTG-232 Track seek from time for dispatching SEEK_DONE (super class property).
            this._seekFromTime = currentTime;

            // if ads are stitched into video we need to add the ad pod duration
            // to the content time to get the actual seek value. // todo implement
            // todo (djl) - get rid of MDialog related code
            absSeekTime = (this.imaScenario === this.MDIALOG) ? this.returnAbsSeekTime(realSeekTime) : realSeekTime;

            // determine if this seek event passes over an un-played ad pod.
            // if crossing an unplayed ad pod
            // 1) store seek destination
            // 2) determine preceeding ad pod
            // 3) set currtime in IMA Anon function to start of ad pod
            // 4) when adPodEnd seek to the saved seek destination.

            unplayedPod = this.APM.returnPrecedingUnplayedAdPod(absSeekTime);

            if (!_.isEmpty(unplayedPod) && !unplayedPod.hasPlayed) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onVideoSeekTo UNPLAYED AD POD FOUND unplayedPod.startTime = ', unplayedPod.startTime);
                this.savedSeekToTime = absSeekTime;

                // VTG-205: Setting this pod's hasPlayed to true here covers a case
                // where faulty seeking occurs when an ad blocker is on.
                // In this case, we'll find adpods that are unplayed, but may not get
                // any events, nor a content resume request, from the IMA SDK.
                unplayedPod.hasPlayed = true;

                this.contentPlayheadTracker.pendingSeekTime = unplayedPod.startTime;
            }
            else {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA onVideoSeekTo NO UNPLAYED POD CALL SUPER with evtObj argument and seek content');
                this._super(e);
            }
        },

        /**
         * @private
         * @memberof uvpjs.RP_IMA#
         * @param {Object} obj a seek event object payload
         *
         * @returns {Boolean}
         */
        canSeek: function(obj) {
            return obj.seekTime !== undefined &&
                 obj.seekTime !== null &&
                 obj.seekTime >= 0 &&
                 obj.seekTime <= this.cviModel.contentVideoState.duration;
        },

        /**
         * Takes real time, adds stitched video durations, and returns absolute time seek value. UNIMPLEMENTED
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {number} realSeekTime - the seek to time relative to the content duration, not including ads.
         *
         * @returns {number} absSeekTime -absolute seek time.
         */
        returnAbsSeekTime: function(realSeekTime) {
            // todo implement for stitched cases
            var absSeekTime = realSeekTime;

            return absSeekTime;
        },

        /**
         * CVI CONTROL_VOLUME_SET event callback. There is no programmatic volume change available on iDevices.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {object} evtObj - event object with .name, .target:'video Container ID' is a dom element ID string, payload: {vol: a Number bewteen 0 and 1}.
         */
        onChangeVideoVolume: function(evtObj) {
            if (!_.has(evtObj, 'target') || evtObj.target !== this.vidContId) {return;}

            if (!this.cviModel.isMuted &&
                evtObj.payload.vol >= 0 &&
                evtObj.payload.vol <= 1) {

                if (this.adPodInProgress) {
                    this.adsManager.setVolume(evtObj.payload.vol);
                }
                else {
                    this._super(evtObj);
                }

            }
        },

        /**
         * CVI CONTROL_MUTE event callback.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {object} evtObj - event object with .name, .target:'video Container ID' is a dom element ID string, payload: {} is an empty object.
         */
        onMuteVideo: function(evtObj) {
            if (!_.has(evtObj, 'target') || evtObj.target !== this.vidContId) {return;}

            if (this.adPodInProgress) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA muteVideo adPodInProgress TRUE; set volume via adsManager for vidContId = ', this.vidContId);
                this.adsManager.setVolume(0);
            }
            else {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA muteVideo adPodInProgress FALSE; passing to super...');
                this._super(evtObj);
            }
        },

        /**
         * CVI CONTROL_UNMUTE event callback.
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {object} evtObj - event object with .name, .target:'video Container ID' is a dom element ID string, payload: {} is an empty object.
         */
        onUnMuteVideo: function(evtObj) {
            if (!_.has(evtObj, 'target') || evtObj.target !== this.vidContId) {return;}

            if (this.adPodInProgress) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA unmuteVideo adPodInProgress TRUE; set volume via adsManager for vidContId = ', this.vidContId);
                this.adsManager.setVolume(this.cviModel.volume);
            }
            else {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA unmuteVideo adPodInProgress FALSE; passing to super...');
                this._super(evtObj);
            }
        },

        ///////// END Core Video Interface (CVI) Event Callbacks ///////

        /**
         * Create scope-bound AdsManager event handlers.
         *
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _createBoundAdEventHandlers: function() {
            this._onContentPauseRequested = this._onContentPauseRequested.bind(this);
            this._onContentResumeRequested = this._onContentResumeRequested.bind(this);
            this.onAdError = this.onAdError.bind(this);
            this.onAdEvent = this.onAdEvent.bind(this);
        },

        /**
         * Add AdsManager event listeners.
         *
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _addAdsManagerEventListeners: function() {
            var am = this.adsManager,
                imaEvt = google.ima.AdEvent.Type, oae;

            this._createBoundAdEventHandlers();
            oae = this.onAdEvent;

            // Error events listener
            am.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, this.onAdError);

            // Listen and respond to events which require you to pause/resume content
            am.addEventListener(imaEvt.CONTENT_PAUSE_REQUESTED, this._onContentPauseRequested);
            am.addEventListener(imaEvt.CONTENT_RESUME_REQUESTED, this._onContentResumeRequested);

            // Listen to any additional events, filter through onAdEvent()
            am.addEventListener(imaEvt.LOADED, oae);
            am.addEventListener(imaEvt.STARTED, oae);
            am.addEventListener(imaEvt.FIRST_QUARTILE, oae);
            am.addEventListener(imaEvt.MIDPOINT, oae);
            am.addEventListener(imaEvt.THIRD_QUARTILE, oae);
            am.addEventListener(imaEvt.COMPLETE, oae);
            am.addEventListener(imaEvt.ALL_ADS_COMPLETED, oae);
            am.addEventListener(imaEvt.CLICK, oae);
            am.addEventListener(imaEvt.PAUSED, oae);
            am.addEventListener(imaEvt.RESUMED, oae);
            am.addEventListener(imaEvt.USER_CLOSE, oae);
            am.addEventListener(imaEvt.SKIPPED, oae);
            am.addEventListener(imaEvt.LOG, oae);
            am.addEventListener(imaEvt.VOLUME_CHANGED, oae);
            am.addEventListener(imaEvt.VOLUME_MUTED, oae);
        },

        /**
         * Remove AdsManager event listeners.
         *
         * @memberof uvpjs.RP_IMA#
         * @private
         */
        _removeAdsManagerEventListeners: function() {
            var oae = this.onAdEvent,
                am = this.adsManager,
                imaEvt = google.ima.AdEvent.Type;

            if (!am) {return;}

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _removeAdsManagerEventListeners REMOVE listeners');

            am.removeEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, oae);

            am.removeEventListener(imaEvt.CONTENT_PAUSE_REQUESTED, this._onContentPauseRequested);
            am.removeEventListener(imaEvt.CONTENT_RESUME_REQUESTED, this._onContentResumeRequested);

            am.removeEventListener(imaEvt.LOADED, oae);
            am.removeEventListener(imaEvt.STARTED, oae);
            am.removeEventListener(imaEvt.FIRST_QUARTILE, oae);
            am.removeEventListener(imaEvt.MIDPOINT, oae);
            am.removeEventListener(imaEvt.THIRD_QUARTILE, oae);
            am.removeEventListener(imaEvt.COMPLETE, oae);
            am.removeEventListener(imaEvt.ALL_ADS_COMPLETED, oae);
            am.removeEventListener(imaEvt.CLICK, oae);
            am.removeEventListener(imaEvt.PAUSED, oae);
            am.removeEventListener(imaEvt.RESUMED, oae);
            am.removeEventListener(imaEvt.USER_CLOSE, oae);
            am.removeEventListener(imaEvt.SKIPPED, oae);
            am.removeEventListener(imaEvt.LOG, oae);
            am.removeEventListener(imaEvt.VOLUME_CHANGED, oae);
            am.removeEventListener(imaEvt.VOLUME_MUTED, oae);
        },

        /**
         * Dispatches a VIDEO_PROGRESS event with an IMA ad Video Progress Payload object.
         * If ads are playing it executes the IMA RP code, if ads are not playing it executes the parent RP Content
         * video Facade .onUVPJSTimerTick() method which includes a content video Video Progress payload.
         * Checks for changes in the content bitrate and updates the adRenderSettings.bitrate .
         *
         * @memberof uvpjs.RP_IMA#
         */

        onUVPJSTimerTick: function() {
            var u = uvpjs.util,
                currContentBitrate = this.cviModel.contentPlaybackState.facadeState.currentBitrate,
                isValidBitrate = !u.isEmpty(currContentBitrate) && currContentBitrate > 0,
                bitrateHasChanged = currContentBitrate / 1000 !== this.renderSettings.bitrate,
                isContentScenario = this.imaScenario === this.PLATFORM || this.imaScenario === this.CONTENT_AND_AD_CALL,
                hasAdsMgr = !u.isEmpty(this.adsManager),
                hasFacade = !u.isEmpty(this.facade),
                facadeTime, isCloseToMidroll, now, hasFn, isTime;

            if (hasAdsMgr && isValidBitrate && bitrateHasChanged) {
                this.renderSettings.bitrate = currContentBitrate / 1000;
                this.adsManager.updateAdsRenderingSettings(this.renderSettings);
            }

            // capture content video duration in Platform case.
            if (isContentScenario) {
                this.contentPlayheadTracker.duration = this.cviModel.contentPlaybackState.duration;

                // A seek across un-played ads has been requested; content is paused at the previous location. Make
                // IMA think that content has reached the requested seek location to trigger ads that need to be played.
                if (this.contentPlayheadTracker.pendingSeekTime > -1) {
                    this.contentPlayheadTracker.currentTime = this.contentPlayheadTracker.pendingSeekTime;
                }
                else if (hasFacade) {
                    facadeTime = this.facade.getCurrentTime();
                    this.contentPlayheadTracker.currentTime = facadeTime;
                }
                else {
                    this.contentPlayheadTracker.currentTime = 0;
                }
            }

            if (!this.adPodInProgress) {
                hasFn = hasAdsMgr && isContentScenario && (this.cviModel.sessionOptions.adBlockerCallback || null);
                isCloseToMidroll = hasFn && this._checkForCloseToMidrollPod(this.contentPlayheadTracker.currentTime);
                isTime = hasFn && (now = new Date().getTime()) && (this.lastAdBlockCheckTime < now || isCloseToMidroll);

                // check for ad blocker every 120 seconds and right before mid-roll pods.
                if (isTime) {
                    this.lastAdBlockCheckTime = now + (this.AD_BLOCKER_POLLING_INTERVAL * 1000);
                    this.checkForAdBlocker();
                }

                this._super();

                return;
            }

            // Note that code below only executes if an ad is in progress

            // Need to look for ID3 events while ad in view for livestream/dynamic midroll cases
            this.id3HandlingEnabled && hasFacade && this.checkId3Events(facadeTime);

            if (this.playbackState === this.mc.PLAYING) {
                var payload = this.createAdVideoProgressPayload();
                this.eventsMgr.dispatchEvent(this.eventsMgr.eventTypes.VIDEO_PROGRESS, payload, this.vidContId);
            }
        },

        /**
         * Check to see if the content is close to the start of a mid-roll ad pod
         * @memberof uvpjs.RP_IMA#
         *
         * @param {Number} time
         *
         * @return {Boolean} True if the current time is 5 seconds before a mid roll pod.
         */
        _checkForCloseToMidrollPod: function(time) {
            var mpods = this.APM.getMidRollPods(), i, t, pod;

            if (time <= 0) return false;

            i = mpods.length;

            while (i--) {
                pod = mpods[i];
                t = pod.startTime - time;

                if (t > 0 && t < 1 && !pod.hasPlayed && !pod.hasBeenChecked) {
                    pod.hasBeenChecked = true;

                    return true;
                }
            }

            return false;
        },

        /**
         * Creates the payload object used in VIDEO_PROGRESS events.
         * @memberof uvpjs.RP_IMA#
         *
         * @return {Object} video progress payload object
         */
        createAdVideoProgressPayload: function() {

            var payload = {
                isAd: true,
                duration: this.duration,
                playbackStarted: true,
                playbackComplete: false,
                sourceBitrate: 0,
                playbackBitrate: 0,
                videoFramerate: 0,
                isSeeking: false,

                // is user at the 'true' live point of a live stream or are they watching 'behind' the live point
                // isHDStreamLive = true for live stream; false for dvr stream.
                isHDStreamLive: false,

                // isPlayingLive - is duration of live stream increasing or is live stream being played as an archive?
                //      true -> video is playing at the live point of of a live stream
                //      false-> video is 'behind' the live point. default = true
                // currently unimplemented in mobile web
                isPlayingLive: false,

                currentContentSegment: 1,
                currentMaxBandwidth: 0,
                averageDroppedFPS: 0,
                errorInfo: '',
                lastSecondCompleted: 0,
                lastPercentageCompleted: 0,
                currentTime: this.currImaAdTime,
                bufferLength: 0,
                playbackState: this.playbackState,
                facadeState: {}
            };

            return payload;
        },

        /**
         * @memberof uvpjs.RP_IMA#
         * @private
         *
         * @param {Object} rco
         *
         * @returns {String|null}
         */
        _determineIMAScenario: function(rco) {
            var u = uvpjs.util,
                assetUrl = this._getAssetUrl(rco),
                hasPid = u.isDefinedString(rco.pid),
                hasGuid = u.isDefinedString(rco.cmsRefGuid),
                hasSelectorCall = u.isDefinedString(rco.selectorCall),
                hasAssetUrl = u.isDefinedString(rco.assetURL);

            if (hasPid || (hasGuid && !hasAssetUrl) || hasSelectorCall) {
                return this.PLATFORM;
            }
            else if (u.isDefinedString(assetUrl)) {
                return this.CONTENT_AND_AD_CALL;
            }
            else if (u.isDefinedString(rco.adCall)) {
                return this.AD_CALL_ONLY;
            }

            this.debug && uvpjs.warn(this.DEBUG_ID,
                'RP_IMA Cannot determine IMA Scenario from RCO.'
            );

            return null;
        },

        /**
         * Checks if ad blocking is both detectable & detected, if so, dispatches AD_BLOCKED event
         *
         * @memberof uvpjs.RP_IMA
         *
         * @returns {Boolean} True if an ad blocker is detected
         */
        checkForAdBlocker: function() {
            var isBlocked = uvpjs.adUtil.checkForAdBlocker(this.cviModel);

            if (isBlocked) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA: ad blocking detected.');

                this.dispatchAdBlockedEvent();
            }

            return isBlocked;
        },

        /**
         * Check for preloading content video. Must be 'preLoadContent' true, Platform case, last ad of pod,
         * over 5 seconds long, and two video tag case.
         *
         * @memberof uvpjs.RP_IMA
         */

        _checkForContentPreload: function() {
            var isValidScenario = this.imaScenario === this.PLATFORM || this.imaScenario === this.CONTENT_AND_AD_CALL,
                isCustomPlayback = this.adsManager.isCustomPlaybackUsed(),
                isValidAdState = this.currAdPod.adCount === this.cviModel.adVideoState.adPosition && !isCustomPlayback;

            if (
                this.cviModel.sessionOptions.preloadContent &&
                this.contentNeedsToBeLoaded &&
                isValidScenario &&
                this.duration > 5 &&
                isValidAdState
            ) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA Will start loading content video; creating facade.');

                this.contentNeedsToBeLoaded = false;
                this.createContentFacade();
            }
        },

        /**
         * Check for an IMA Timeout value in the Ad_Settings config module and convert to milliseconds.
         * From the IMA docs: 'Timeout (in milliseconds) when loading a video ad media file.
         * If loading takes longer than this timeout, the ad playback is canceled and the next ad in the pod plays,
         * if available. Use -1 for the default of 15 seconds.'
         *
         * @memberof uvpjs.RP_IMA
         * @return {Number} The IMA Timeout in milliseconds in the ad_settings
         * config module or -1 which tells IMA to use the default value of 15 seconds.
         */
        _returnIMATimeout: function() {
            var timeout = -1,
                CMSDataDefaultModule = this.cviModel.getModule(this.AD_SETTINGS),
                moduleActive = CMSDataDefaultModule && CMSDataDefaultModule.enabled,
                toParam = moduleActive && this.cviModel.getModuleParam(this.AD_SETTINGS, this.IMA_TIMEOUT);

            if (toParam) {
                timeout = parseInt(toParam);
                timeout = timeout > 0 ? timeout * 1000 : -1;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'RP_IMA _returnIMATimeout: ' + timeout);

            return timeout;
        },

        /**
         * Gather metadata and init MOAT Viewability tracking
         *
         * @memberof uvpjs.RP_IMA#
         */
        trackAd: function() {
            this.adTrackingHandle = uvpjs.adUtil.trackAd({
                adVideoContainer: this.cviMgr.adVideoDiv,
                context: uvpjs.adUtil.context.IMA,
                model: this.cviModel
            });
        },

        /**
         * Kill adTracking handle
         *
         * @memberof uvpjs.RP_IMA#
         */
        untrackAd: function() {
            this.adTrackingHandle = null;
        },

        /**
         * Track an event for an ad.
         *
         * @memberof uvpjs.RP_IMA#
         */
        trackAdEvent: function(eventName) {
            if (!this.adTrackingHandle) return;

            uvpjs.adUtil.trackAdEvent({
                trackingHandle: this.adTrackingHandle,
                eventName: eventName,
                context: uvpjs.adUtil.context.IMA,
                volume: this.adsManager.getVolume()
            });
        }

    });

}(uvpjs.register('uvpjs')));

(function (obj) {
    'use strict';

    var _ = obj._,
        streamEvents = [ /* DAI StreamEvent.Type */
            'LOADED', 'STREAM_INITIALIZED','STARTED',
            'AD_BREAK_STARTED', 'AD_BREAK_ENDED',
            'AD_PROGRESS', 'FIRST_QUARTILE', 'MIDPOINT', 'THIRD_QUARTILE',
            'CLICK', 'COMPLETE', 'CUEPOINTS_CHANGED', 'ERROR'
        ],
        hArr = [ /* event handlers; will be mapped to stream events listed above */
            'hStreamLoaded', 'hStreamInitialized', 'hAdStarted',
            'hAdBreakStart', 'hAdBreakEnd',
            'hAdProgress', 'hAdProgress', 'hAdProgress', 'hAdProgress',
            'hAdClick', 'hAdComplete', 'hCuePointsChanged', 'hStreamError'
        ],
        daiapi;


    obj.DaiResourceProvider = uvpjs.RP_Platform.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PROVIDER,

        AD_SETTINGS: 'AdSettings',
        AD_CALL_OVERRIDE: 'adCallOverride',

        /**
         * @constructor uvpjs.DaiResourceProvider
         * @extends uvpjs.RP_Platform
         *
         * @param {Object} options
         */
        init: function(options) {
            this.debug = uvpjs.debug;

            this.daiStreamId = null;
            this.streamManager = null;
            this.adClickElement = null;

            this.isLiveStream = false;

            this.adBreakPending = false;
            this.currAdPercentComplete = 0;
            this.currAd = null;

            this.contentDuration = null;
            this.suppressFacadePlayOnLoad = false;

            this.lastAdBlockCheckTime = 0;
            this.adBlockCheckInterval = 60;

            this.hMap = {}; // stream event handler map
            this.adPods = null;
            this.currAdPod = null;
            this.adTrackingHandle = null;

            this._super(options);
            this.providerType = uvpjs.mediaCapabilities.RP_DAI;
        },

        /**
         * @override
         *
         * @param {Object} rco - Validated Resource Config Object.
         * @param {Object} cviMgr - Validated Core Video Instance Manager.
         * @param {String} vidContId - Validated Video (outer) Container Tag Element ID.
         */
        initialize: function(rco, cviMgr, vidContId) {
            var vContainer = document.getElementById(uvpjs.domConstants.CONTENT_ID_PREFIX + vidContId),
                vidEl = vContainer.getElementsByTagName('video')[0];

            !daiapi && (daiapi = google.ima.dai.api); // (presence of api has been validated by DaiRco)

            this.debug && this.log("DAI RP init'ing, IMA version = " + google.ima.VERSION);

            this.streamManager = new daiapi.StreamManager(vidEl);
            this.adClickElement = this.createAdClickElement(vidEl);
            this.streamManager.setClickElement(this.adClickElement);

            this._super(rco, cviMgr, vidContId);

            this.resetAdStates();

            this.contentVideoDiv = vContainer;

            this.hStreamEvent = this.hStreamEvent.bind(this);
        },

        /**
         * @override
         */
        cleanUp: function() {
            this.removeStreamEventListeners();
            this.streamManager = null;

            if (this.isAdPlaying()) {
                this.currAd && this.dispatchAdEnd();
                this.currAdPod && this.dispatchAdPodEnd();
                this.resetAdStates();
            }

            this.adClickElement = null;
            this.adClickElement = null;
            this.adTrackingHandle = null;

            this.currAdPod = null;
            this.currAd = null;
            this.adPods = null;
            this.hMap = null;
            this.hStreamEvent = Function.prototype;

            this.resetModelState();

            this._super();
        },

        ///////////////////////
        // Load and Begin Playback
        /**
         * Will initiate a call to load content metadata, if appropriate.
         * @override
         */
        loadData: function(dataLoadedCallback, errorCallback) {
            var u = this.cviModel.getClassListItemProperty('VideoSourceManager', 'Platform_MPX', 'MultiBitrateURL');
            this.dispatchLoading();

            if (this.rco.canMakePlatformCall(u)) {
                this._super(dataLoadedCallback, errorCallback);
            }
            else {
                this.dataLoadedCB = dataLoadedCallback;
                this.onDataProxyComplete();
            }
        },

        /**
         * @override
         */
        onDataProxyComplete: function() {
            var guid = this.contentDataProxy.getProperty('cmsRefGuid');

            !uvpjs.util.isEmpty(guid) && !this.rco.getVideoId() && this.rco.setCmsRefGuid(guid);

            this._super();
        },

        /**
         * @override
         */
        loadVideoAndBeginPlayback: function(suppressFacadePlay) {
            var rco = this.rco,
                mdl = this.cviModel,
                proxyModel = this.contentDataProxy.getModel(),
                resDef;

            this.suppressFacadePlayOnLoad = suppressFacadePlay === true;

            this._addUVPEventListeners();
            this.addStreamEventListeners();

            // final model prep
            this.resetModelState();
            this.setModelRcoOverrides();
            mdl.setNonDefaultContentVideoStateItems(proxyModel);
            mdl.setContentVideoStateItems(rco);
            mdl.mergeCDOData();

            this.killDataProxy(); // data proxy no longer needed

            resDef = this.assembleResourceDefinition();

            if (!resDef) {
                this.debug && this.log("DAI RP Fatal error: Invalid RCO", this.rco, 'error');

                this.dispatchError(
                    this.eventsMgr.eventTypes.VIDEO_START_ERROR,
                    'DAI RP: Invalid RCO',
                    uvpjs.ErrorInfo.errorCodes.INVALID_RESOURCE_FORMAT,
                    true
                );

                return;
            }

            this.requestStream(resDef);
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         *
         * @param {Object} resourceDefinition
         * @param {String} resourceDefinition.apiKey optional key for encrypted streams
         * @param {String} resourceDefinition.assetKey used for live streams
         * @param {String} resourceDefinition.contentSourceId (= DAI-specific 'cms id")
         * @param {String} resourceDefinition.videoId (= mpx guid)
         */
        requestStream: function(resourceDefinition) {
            var isLive = this.cviModel.contentVideoState.isLive,
                reqType = isLive ? daiapi.LiveStreamRequest : daiapi.VODStreamRequest,
                req = new reqType(),
                def = resourceDefinition || testRsrcDef;

            req.apiKey = def.apiKey || null;

            req.adTagParameters = def.adTagParameters;

            if (isLive) {
                req.assetKey = def.assetKey;
                req.attemptPreroll = true;
                this.id3HandlingEnabled = true;
            }
            else {
                req.contentSourceId = def.contentSourceId;
                req.videoId = def.videoId;
            }

            this.streamManager.requestStream(req);
        },


        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        createContentFacade: function () {
            this.debug && this.log("DAI RP creating facade; ID3 handling = " + this.id3HandlingEnabled);

            this.createFacade();
            this.id3HandlingEnabled && this.createId3Parser(this.facade.facadeType);
        },

        // End Loading and Playback
        ////////////////////////////


        /////////////////////////
        // StreamEvent handling

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {window.google.ima.dai.api.StreamEvent} e
         */
        hStreamLoaded: function(e) {
            var assetUrl = e.getStreamData().url;

            if (!uvpjs.util.isDefinedString(assetUrl)) {
                this.debug && this.log("DAI RP: No asset url in StreamLoaded event StreamData", null, 'error');

                this.dispatchError(
                    this.eventsMgr.eventType.VIDEO_START_ERROR,
                    uvpjs.ErrorInfo.messages.DAI_ASSET_URL_ERROR,
                    uvpjs.ErrorInfo.errorCodes.UNEXPECTED_CONDITION,
                    true
                );

                return;
            }

            this.cviModel.contentVideoState.assetURL = assetUrl;

            this.dispatchContentDataLoaded();
            this.cviModel.incrementMedNum();

            this.RPM.resourceStart(this.rco.rcoSeed);

            this.createContentFacade();
            if(!this.suppressFacadePlayOnLoad) {
                this.facade.showVideo();
                this.facade.playVideo();
            }
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {window.google.ima.dai.api.StreamEvent} e
         */
        hStreamInitialized: function(e) {
            this.daiStreamId = e.getStreamData().streamId;
            this.cviModel.daiStreamId = this.daiStreamId;
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.StreamEvent} e
         */
        hAdBreakStart: function(e) {
            this.showAdClickEl(true);
            this.resetAdStates();

            this.checkForAdBlocker(this.facade.getCurrentTime(), true);

            if (this.contentStartOpen) {
                this.dispatchContentEnd();
                this.contentStartOpen = false;
            }

            // Defer signalling adpod start until we can get pod info from the first ad
            this.adBreakPending = true;
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.StreamEvent} e
         */
        hAdBreakEnd: function(e) {
            this.showAdClickEl(false);
            this.dispatchAdPodEnd(this.currAdPod);
            this.resetAdStates();
            this.currAdPod = null;
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.StreamEvent} e
         */
        hCuePointsChanged: function(e) {
            this.currAdPod = this.getNewPod(e.getStreamData().cuepoints);
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.StreamEvent} e
         */
        hAdStarted: function(e) {
            var ad = e.getAd();

            this.resetAdStates();
            this.updateAdModel(ad);
            this.currAd = ad;

            this.trackAd();

            if (this.adBreakPending) {
                this.adBreakPending = false;

                if (this.currAdPod) {
                    this.trackAdEvent(e.type);
                    this.dispatchAdPodStart();
                }
                else {
                    this.dispatchError(
                        this.eventsMgr.eventTypes.AD_ERROR,
                        uvpjs.ErrorInfo.messages.DAI_ADPOD_ERROR,
                        uvpjs.ErrorInfo.errorCodes.DAI_AD_ERROR
                    );
                }
            }

            this.cviModel.incrementAdNum();
            this.dispatchAdStart();
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        hAdComplete: function() {
            this.dispatchAdEnd();
            this.resetAdStates();
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.StreamEvent} e
         */
        hAdProgress: function(e) {
            var etype = e.type,
                types = daiapi.StreamEvent.Type,
                pct = null, sd, prog, p;

            switch (etype) {
                case types.FIRST_QUARTILE:
                    pct = 25;
                    break;

                case types.MIDPOINT:
                    pct = 50;
                    break;

                case types.THIRD_QUARTILE:
                    pct = 75;
                    break;

                case types.AD_PROGRESS:
                    sd = e.getStreamData();
                    prog = sd && sd.adProgressData;
                    p = prog && this.createAdProgressPayload(prog);
                    p && this.dispatchVideoProgress(p);
                    break;
            }

            if (pct) {
                this.checkForAdBlocker(this.facade.getCurrentTime(), true);
                this.currAdPercentComplete = pct;
                this.dispatchAdQuartile(pct);
            }
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.StreamEvent} e
         */
        hStreamError: function(e) {
            var sd = e.getStreamData(),
                msg = sd && sd.errorMessage;

            this.debug && this.log('DAI StreamManager Error: ' + msg, null, 'error');

            this.dispatchError(
                this.eventsMgr.eventTypes.VIDEO_START_ERROR,
                msg || 'Uknown DAI stream error.',
                uvpjs.ErrorInfo.errorCodes.DAI_STREAM_ERROR,
                true
            );
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.StreamEvent} e
         */
        hAdClick: function(e) {
            // behavior handled internally by SDK;
            // handle here if we need to dispatch event
        },

        /**
         * Handler for all events from dai.api.StreamManager
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.StreamEvent} e
         */
        hStreamEvent: function(e) {
            this.isAdPlaying() && this.trackAdEvent(e.type);
            this[this.hMap[e.type]](e);
        },

        // End StreamEvent handling
        ////////////////////////////

        ////////////////////////////
        // control event override
        /**
         * @override
         */
        onVideoSeekTo: function (evtObj) {
            var target = evtObj && evtObj.target,
                payload = evtObj && evtObj.payload,
                seekTime = payload && payload.seekTime,
                facade = this.facade,
                hasFacade = this._hasFacade(),
                duration = facade.getDuration(),
                currentTime = this.facade.getCurrentTime();

            if (typeof seekTime !== 'number' || target !== this.vidContId) {
                return;
            }

            seekTime = this.streamManager.streamTimeForContentTime(seekTime);

            if (seekTime < 0 || seekTime > duration) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'onVideoSeekTo out of range seekTime = ' + seekTime);
                return;
            }

            // VTG-232 Track seek from time for dispatching SEEK_DONE.
            this._seekFromTime = this._seekFromTime || currentTime;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onVideoSeekTo ' + JSON.stringify({
                seekTime: seekTime,
                seekFromTime: this._seekFromTime
            }, null, 2));

            hasFacade && facade.seekTo(seekTime);
        },

        ///////////////////
        // Event dispatch

        dispatch: function(type, payload) {
            this.eventsMgr.dispatchEvent(type, payload, this.vidContId);
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        dispatchLoading: function() {
            this.dispatch(this.eventsMgr.eventTypes.VIDEO_STATE_CHANGE, {newState: this.mc.LOADING});
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        dispatchContentDataLoaded: function () {
            var vs = this.cviModel.getContentVideoState();

            this.dispatch(this.eventsMgr.eventTypes.CONTENT_DATA_LOADED, { vidState: vs});
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        dispatchAdPodStart: function() {
            this.dispatch(this.eventsMgr.eventTypes.AD_POD_START, {adPod: this.currAdPod});
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        dispatchAdPodEnd: function() {
            this.dispatch(this.eventsMgr.eventTypes.AD_POD_END, {adPod: this.currAdPod});
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        dispatchAdStart: function() {
            var state = this.cviModel.getAdVideoState();

            this.dispatch(this.eventsMgr.eventTypes.AD_START, {adData:state});
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        dispatchAdEnd: function() {
            var state = this.cviModel.getAdVideoState();

            this.dispatch(this.eventsMgr.eventTypes.AD_END, {adData:state});
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {Number} percent
         */
        dispatchAdQuartile: function(percent) {
            this.dispatch(this.eventsMgr.eventTypes.AD_QUARTILE, {percent: percent});
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {Object} payload progress payload, for content or ad
         */
        dispatchVideoProgress: function(payload) {
            this.dispatch(this.eventsMgr.eventTypes.VIDEO_PROGRESS, payload);
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {String} etype event type
         * @param {String} msg error message
         * @param {Number} code error code
         * @param {Boolean} fatal  optional; defaults to false
         */
        dispatchError: function (etype, msg, code, fatal) {
            this.dispatch(etype, {
                errorInfo: new uvpjs.ErrorInfo({
                    eventType: etype,
                    errorCode: code,
                    message: msg + '; DAI stream id: ' + (this.daiStreamId || 'n/a'),
                    isFatal: fatal === true,
                    adInfo: this.currAd ? this.extractAdInfo(this.currAd) : null
                })
            });
        },

        /**
         * Dispatches an adBlocked event; invoked when ad blocking detected.
         *
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        dispatchAdBlockedEvent: function() {
            this.dispatch(this.eventsMgr.eventTypes.AD_BLOCKED, {
                errorInfo: new uvpjs.ErrorInfo({
                    eventType: this.eventsMgr.eventTypes.AD_BLOCKED,
                    errorCode: uvpjs.ErrorInfo.errorCodes.AD_BLOCKING_DETECTED,
                    message: uvpjs.ErrorInfo.messages.AD_BLOCKING_DETECTED,
                    isFatal: false
                })
            });
        },

        // End Event dispatch
        /////////////////////


        /////////////////////
        // AdPod utils

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {Array} cuepts array of cuepoint objects
         *
         * @return {Object|null} the newly-active pod or null
         */
        getNewPod: function(cuepts) {
            var newPod = null,
                i = cuepts && cuepts.length, p, pod;

            // if first cuepoint event, create ad pod objects
            i && !this.adPods && this.createAdPods(cuepts);

            // locate the latest cuepoint to be newly-marked as 'played'
            while (i--) {
                p = cuepts[i];
                pod = this.adPods['t_' + p.start];
                if (!newPod && (pod.hasPlayed !== p.played)) {
                    newPod = pod;
                }
                pod.hasPlayed = p.played;
            }

            return newPod;
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {Array}  c array of cuepoints
         */
        createAdPods: function(c) {
            var pfx = function (j) {
                    return j === n - 1 ? "post" : j === 0 ? "pre" : "mid";
                },
                midrollIdx = 0,
                startTimes = [],
                n = c.length,
                p, i, pre, st;

            this.adPods = {};

            for (i = 0; i < n; i++) {
                p = c[i];
                pre = pfx(i);
                st = p.start;
                startTimes.push(st);

                this.adPods["t_" + st] = {
                    startTime: st,
                    hasPlayed: false,
                    adPodId: pre + (pre === 'mid' ? '_' + midrollIdx++ : '_0'),
                    adCount: 0,
                    podDuration: p.end - st,
                }
            }

            this.cviModel.contentVideoState.chapterStartTimes = startTimes;
        },

        /////////////////////////////////////
        // Ads:  model maintenance and utils
        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        resetAdStates: function () {
            var mdl = this.cviModel;

            mdl.resetAdPlaybackState();
            mdl.resetAdVideoState();
            mdl.isCurrVideoAd = false;

            this.currAdPercentComplete = 0;
            this.currAd = null;
            this.showAdClickEl(false);

            this.untrackAd();
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.Ad} ad a DAI ad object
         */
        updateAdModel: function(ad) {
            var podInfo = ad.getAdPodInfo();

            this.populateAdVideoState(ad);

            if (podInfo && this.currAdPod) {
                this.currAdPod.adCount = podInfo.getTotalAds();
                this.currAdPod.podDuration = podInfo.getMaxDuration();
            }

            this.cviModel.isCurrVideoAd = true;
            this.cviModel.mergeCDOData();
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.Ad} ad a DAI ad object
         */
        populateAdVideoState: function(ad) {
            var state = uvpjs.adUtil.extractAdStateData(ad, uvpjs.adUtil.context.DAI);

            this.cviModel.setAdVideoState(state);
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {Object} data google.ima.dai.api.StreamData.adProgressData object
         * @param {Number} data.adBreakDuration
         * @param {Number} data.adPosition
         * @param {Number} data.currentTime
         * @param {Number} data.duration
         * @param {Number} data.totalAds
         * @param {Number} data.percent
         */
        createAdProgressPayload: function(data) {
            var p = this.getVideoProgressPayload(),
                ct = data.currentTime;

            p.isAd = true;
            p.duration = data.duration;
            p.currentTime = ct;
            p.absoluteStreamTime = this.facade.getCurrentTime();
            p.lastSecondCompleted = Math.floor(ct);
            p.lastPercentageCompleted = this.currAdPercentComplete;

            return p;
        },

        /**
         * Extracts ad info from an ad object
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.Ad} ad
         */
        extractAdInfo: function(ad) {
            return uvpjs.adUtil.extractAdInfo(ad, uvpjs.adUtil.context.DAI);
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        trackAd: function() {
            this.adTrackingHandle = uvpjs.adUtil.trackAd({
                adVideoContainer: this.contentVideoDiv,
                context: uvpjs.adUtil.context.DAI,
                model: this.cviModel
            });
        },

        /**
         * Kill adTracking handle
         *
         * @memberof uvpjs.RP_IMA#
         */
        untrackAd: function() {
            this.adTrackingHandle = null;
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {String} eventName
         */
        trackAdEvent: function(eventName) {
            if (!this.adTrackingHandle || eventName == daiapi.StreamEvent.Type.AD_PROGRESS || !this.facade) {
                return;
            }

            uvpjs.adUtil.trackAdEvent({
                trackingHandle: this.adTrackingHandle,
                eventName: eventName,
                context: uvpjs.adUtil.context.DAI,
                volume: this.cviModel.isMuted ? 0 : this.facade.getVolume()
            });
        },

        /////////////////////////////////////
        // Content progress, buffering check

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        startOrResumeContent: function () {
            if (!this.contentDuration) {
                this.contentDuration = this.streamManager.contentTimeForStreamTime(this.facade.getDuration());
                this.cviModel.contentVideoState.duration = this.contentDuration;
            }
            this.contentStartOpen = true;
            this.showAdClickEl(false);
            this.dispatchContentStart();
        },

        /**
         * Only handles progress update for content; see adProgress handling for ad progress updating
         * @override
         */
        onUVPJSTimerTick: function() {
            var shouldContinue = this.facade && this.facade.getPlaybackState() === this.mc.PLAYING && !this.isAdPlaying(),
                contentTime, absStreamTime, p;

            if (!shouldContinue) return;

            absStreamTime = this.facade.getCurrentTime();
            this.checkForAdBlocker(absStreamTime, false);

            contentTime = this.streamManager.contentTimeForStreamTime(absStreamTime);
            !this.contentStartOpen && contentTime > 0 && this.startOrResumeContent();

            this.id3HandlingEnabled && this.checkId3Events(contentTime);

            p = this.createVideoProgressPayload(contentTime, absStreamTime);
            this.dispatchVideoProgress(p);
        },

        /**
         * Creates the payload object used in VIDEO_PROGRESS events.
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {Number} contentTime current time for content only
         * @param {Number} absStreamTime stream time including ad time
         *
         * @return {Object} video progress payload object
         */
        createVideoProgressPayload: function(contentTime, absStreamTime) {
            var p = this.getVideoProgressPayload();

            p.currentTime = contentTime;
            p.absoluteStreamTime = absStreamTime;
            p.duration = this.contentDuration || -1;

            return p;
        },

        /**
         * @override
         */
        checkBuffering: function (time) {
            if (this.cviModel.playbackState !== this.mc.PAUSED) {
                // Need to use absolute stream time here.
                this._super(this.facade.getCurrentTime());
            }
        },

        /**
         * Uses the session options adBlockerCallback: to determine if an ad blocker has been detected,
         * results in AD_BLOCKED event dispatch.
         *
         * @memberof uvpjs.RP_IMA
         *
         * @param {Number} absStreamTime current stream time
         * @param {Boolean}force force an ad block check regardless of when last checked
         *
         * @return {Boolean} True if an ad blocker is detected, false if no ad blocker detected.
         */
        checkForAdBlocker: function(absStreamTime, force) {
            var diffCheck = (absStreamTime - this.lastAdBlockCheckTime) > this.adBlockCheckInterval,
                shouldCheck = force || diffCheck,
                isBlocked = shouldCheck && uvpjs.adUtil.checkForAdBlocker(this.cviModel);

            shouldCheck && (this.lastAdBlockCheckTime = absStreamTime);

            if (isBlocked) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'DaiResourceProvider: ad blocking detected.');

                this.dispatchAdBlockedEvent();
            }

            return !!isBlocked;
        },

        /////////////////////////////////////
        // initialization helpers

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @return {Object}
         */
        assembleResourceDefinition: function () {
            var a = this.rco.getAdTagParameters(),
                v = this.rco.getVideoId(),
                c = this.rco.getContentSourceId();

            if (a && v && c) {
                return {
                    adTagParameters: a,
                    videoId: v,
                    contentSourceId: c,
                }
            }

            return null;
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        addStreamEventListeners: function() {
            this.streamManager && this.addOrRemoveStreamListeners("add");
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        removeStreamEventListeners: function() {
            this.streamManager && this.addOrRemoveStreamListeners("remove");
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         */
        addOrRemoveStreamListeners: function(mName) {
            var m = mName === "add" ? "addEventListener" : "removeEventListener",
                isAdd = m === "addEventListener",
                etypes = daiapi.StreamEvent.Type,
                i = streamEvents.length,
                inputArr = [], ename;

            while (i--) {
                ename = etypes[streamEvents[i]];
                inputArr.push(ename);
                isAdd && (this.hMap[ename] = hArr[i]);
            }

            this.streamManager[m](inputArr, this.hStreamEvent, false);
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {HTMLElement} vidEl
         */
        createAdClickElement: function(vidEl) {
            var role = 'uvpjsDaiContainer',
                nextSib = vidEl.nextSibling,
                adiv, obj, q, styl;

            if (nextSib && nextSib.getAttribute('data-role') === role) {
                return nextSib;
            }

            adiv = document.createElement('div');
            adiv.setAttribute('data-role', 'uvpjsDaiContainer');

            obj = {
                position: 'absolute',
                width: '100%', height: '100%',
                left: 0, top: 0, zIndex: 1
            };
            styl = adiv.style;

            for (q in obj) {
                styl[q] = obj[q];
            }

            vidEl.insertAdjacentElement('afterend', adiv);

            return adiv;
        },


        /////////////////////////////
        // player event callbacks - all override parent class methods

        /**
         * @override
         */
        onPauseVideo: function (e) {
            var target = e && e.target;

            if (target === this.vidContId && this._hasFacade()) {
                this.facade.pauseVideo();
                this.isAdPlaying() && this.trackAdEvent(e.type);
            }
        },

        /**
         * @override
         */
        onPlayVideo: function (e) {
            var target = e && e.target;

            if (target === this.vidContId && this._hasFacade()) {
                this.facade.showVideo();
                this.facade.playVideo();
                this.isAdPlaying() && this.trackAdEvent(e.type);
            }
        },

        /**
         * @override
         */
        onChangeVideoVolume: function (e) {
            var target = e && e.target,
                payload = e && e.payload,
                volume = payload && payload.vol,
                inRange = uvpjs.util.inRange(volume, 0, 1),
                isMuted = this.cviModel.isMuted;

            if (target === this.vidContId && inRange && !isMuted && this._hasFacade()) {
                this.facade.setVolume(volume);
                this.isAdPlaying() && this.trackAdEvent(e.type);
            }
        },

        /**
         * @override
         */
        onMuteVideo: function (e) {
            var target = e && e.target;

            if (target === this.vidContId  && this._hasFacade()) {
                this.facade.muteVideo();
                this.isAdPlaying() && this.trackAdEvent(e.type);
            }
        },

        /**
         * @override
         */
        onUnMuteVideo: function (e) {
            var target = e && e.target;

            if (target === this.vidContId  && this._hasFacade()) {
                this.facade.unMuteVideo();
                this.isAdPlaying() && this.trackAdEvent(e.type);
            }
        },

        /////////////////////////////
        //  Methods called by facade
        /**
         * @override
         */
        facadeId3Data: function(data) {
            var n, f, i;

            // Required by DAI SDK for live streams to identify/dispatch ad events

            // Code below is provisional and applies to hlsjs only, here mainly for testing.
            // In UVPJS 2.6.0, DAI + live is NOT supported.  Tp provide support, we should parse
            // once via this.id3Parser() to make sure we can extract Nielsen or any
            // other metadata needed, and if we get a DAI cuepoint, we should be listening
            // for videocuepoint events in this class and pass parsed data to
            // DAI SDK via StreamManager.onTimedMetadata.
            //
            // A bit of investigation is needed to know what these cuepoint payloads look like, and
            // how to package data correctly for the onTimedMetadata method.
            //
            // https://developers.google.com/interactive-media-ads/docs/sdks/html5/dai/apis#ima.dai.api.StreamManager.onTimedMetadata
            //
            //
            // Note that StreamManager.processMetaData (used below) only accepts UInt8Array
            n = data.length;
            for (i = 0; i < n; i++) {
                f = data[i];
                this.streamManager.processMetadata('ID3', f.data, f.pts);
            }
        },

        /**
         * @override
         */
        facadeProgress: function(data) {
            // no impl; don't want to update time directly from facade
        },

        /**
         * @override
         */
        facadeTimeUpdate: function(data) {
            // no impl; don't want to update time directly from facade
        },

        /**
         * @override
         */
        facadeDurationChanged: function(data) {
            this.contentDuration = this.streamManager.contentTimeForStreamTime(data.duration);
            this.cviModel.contentVideoState.duration = this.contentDuration;
        },

        /**
         * @override
         */
        facadeDisplayReady: function() {
            this.startVideoProgressTimer();
        },

        // END facade-invoked methods
        ///////////////////////////

        ////////
        // util

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @return {Boolean}
         */
        isAdPlaying: function() {
            return this.cviModel && this.cviModel.isCurrVideoAd === true;
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {Boolean} flag
         */
        showAdClickEl: function (flag) {
            this.adClickElement && (this.adClickElement.style.display = flag !== false ? 'block' : 'none');
        },

        /**
         * @memberof uvpjs.DaiResourceProvider#
         * @private
         *
         * @param {String} msg message
         * @param {*}      obj optional data
         * @param {String} type  log|warn|error
         */
        log: function(msg, obj, type) {
            var m = type ? type : 'log';

            uvpjs[m](this.DEBUG_ID, msg, obj || '');
        }

    });

}(uvpjs.register('uvpjs')));


(function (obj) {
    'use strict';

    var streamEvents = {
            /* keys are ID3 payload data values */
            google_ad_start: 'handleAdStart',
            google_ad_end: 'handleAdEnd'
        };

    obj.DaiSsbResourceProvider = uvpjs.ResourceProvider.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PROVIDER,

        /**
         * @constructor uvpjs.DaiSsbResourceProvider
         * @extends uvpjs.RP_Platform
         *
         * @param {Object} options
         */
        init: function(options) {
            this.debug = uvpjs.debug;

            this.isLiveStream = false;
            this.suppressFacadePlayOnLoad = false;
            this.quartiles = {'25': 0, '50': 0, '75': 0};

            this.contentStartOpen = false;
            this.contentDuration = null;
            this.absoluteDuration = null;
            this.contentStartTime = null;
            this.contentVideoDiv = null;
            this.vidEl = null;

            this._super(options);
            this.providerType = uvpjs.mediaCapabilities.RP_DAI;
        },

        /**
         * @override
         */
        initialize: function(rco, cviMgr, vidContId) {
            this._super(rco, cviMgr, vidContId);

            this.contentVideoDiv = document.getElementById(uvpjs.domConstants.CONTENT_ID_PREFIX + vidContId);
            this.vidEl = this.contentVideoDiv.getElementsByTagName('video')[0];

            this.resetAdStates();
        },

        /**
         * @override
         */
        cleanUp: function() {
            if (this.isAdPlaying()) {
                this.dispatchAdEnd();
                this.dispatchAdPodEnd();
                this.resetAdStates();
            }
            this.unlistenForTextTrackId3();

            this.resetModelState();

            this._super();
        },

        ///////////////////////
        // Load and Begin Playback
        /**
         * @override
         */
        loadData: function(dataLoadedCallback) {
            dataLoadedCallback();
        },

        /**
         * @override
         */
        loadVideoAndBeginPlayback: function(suppressFacadePlay) {
            var rco = this.rco,
                mdl = this.cviModel,
                url;

            this.suppressFacadePlayOnLoad = suppressFacadePlay === true;
            this._addUVPEventListeners();

            // final model prep
            this.resetModelState();
            this.setModelRcoOverrides();
            mdl.setNonDefaultContentVideoStateItems(this.contentDataProxy.getModel());
            mdl.setContentVideoStateItems(rco);
            mdl.mergeCDOData();

            this.killDataProxy();

            this.contentDuration = mdl.contentVideoState.duration;

            this.debug && this.log("DaiSsb: content duration (from rco) = " + this.contentDuration);

            url = this.assembleAssetUrl(rco);

            if (!url) {
                this.dispatchError(
                    this.eventsMgr.eventTypes.VIDEO_START_ERROR,
                    "Missing 'assetURL' in RCO",
                    uvpjs.ErrorInfo.errorCodes.UNEXPECTED_CONDITION,
                    true
                );

                return;
            }

            this.cviModel.contentVideoState.assetURL = url;

            this.dispatchContentDataLoaded();
            this.cviModel.incrementMedNum();

            this.RPM.resourceStart(rco.rcoSeed);

            this.createContentFacade();
            this.id3HandlingEnabled && this.createId3Parser(this.facade.facadeType);

            !this.suppressFacadePlayOnLoad && this.facade.playVideo();
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @return {String}
         */
        assembleAssetUrl: function (rco) {
            var base = rco.assetURL,
                u = uvpjs.util, atq, atp;

            if (u.isEmpty(base)) {
                return null;
            }

            if (base.indexOf('?') > -1) {
                return base;
            }

            atp = rco.getAdTagParameters();
            atq = atp ? u.queryStrFromObj(atp) : null;

            return !u.isEmpty(atq) ? base + '?' + atq : base;
        },


        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        createContentFacade: function () {
            this.createFacade();
            this.listenForTextTrackId3();
        },

        //////////////////////////////////////////////
        // Stream "event" handling (via ID3 metadata)

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @param {Object}
         */
        handleAdStart: function(startTime) {
            this.resetAdStates();
            this.cviModel.incrementAdNum();
            this.updateAdModel();

            this.dispatchAdPodStart(startTime);
            this.dispatchAdStart();
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        handleAdEnd: function() {
            this.dispatchAdEnd();
            this.dispatchAdPodEnd();

            this.resetAdStates();
            this.contentStartTime = this.facade.getCurrentTime();
            this.debug && this.log("DaiSsb provider: contentStartTime = " + this.contentStartTime);

            this.startContent();
        },

        ///////////////////
        // Event dispatch

        dispatch: function(type, payload) {
            this.eventsMgr.dispatchEvent(type, payload, this.vidContId);
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        dispatchContentDataLoaded: function () {
            var vs = this.cviModel.getContentVideoState();

            this.dispatch(this.eventsMgr.eventTypes.CONTENT_DATA_LOADED, { vidState: vs});
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        dispatchAdPodStart: function(starTime) {
            var p = this.getPrerollPod(starTime);

            this.dispatch(this.eventsMgr.eventTypes.AD_POD_START, {adPod: p});
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        dispatchAdPodEnd: function() {
            var p = this.getPrerollPod();

            p.hasPlayed = true;
            this.dispatch(this.eventsMgr.eventTypes.AD_POD_END, {adPod: p});
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        dispatchAdStart: function() {
            var state = this.cviModel.getAdVideoState();

            this.dispatch(this.eventsMgr.eventTypes.AD_START, {adData: state});
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        dispatchAdEnd: function() {
            var state = this.cviModel.getAdVideoState();

            this.dispatch(this.eventsMgr.eventTypes.AD_END, {adData: state});
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @param {Number} percent
         */
        dispatchAdQuartile: function(percent) {
            this.dispatch(this.eventsMgr.eventTypes.AD_QUARTILE, {percent: percent});
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @param {Object} payload progress payload, for content or ad
         */
        dispatchVideoProgress: function(payload) {
            this.dispatch(this.eventsMgr.eventTypes.VIDEO_PROGRESS, payload);
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @param {String} etype event type
         * @param {String} msg error message
         * @param {Number} code error code
         * @param {Boolean} fatal  optional; defaults to false
         */
        dispatchError: function (etype, msg, code, fatal) {
            this.dispatch(etype, {
                errorInfo: new uvpjs.ErrorInfo({
                    eventType: etype,
                    errorCode: code,
                    message: msg,
                    isFatal: fatal === true,
                    adInfo: null
                })
            });
        },

        /////////////////////
        // AdPod utils

        /**
         * @private
         * @param {Number} startTime
         *
         * @return {Object}
         */
        getPrerollPod: function (st) {
            if (!this.adPod) {
                this.adPod = {
                    startTime: st,
                    hasPlayed: false,
                    adPodId: 'pre_0',
                    adCount: 1,
                    podDuration: this.getPrerollAdDuration(),
                };
            }

            return this.adPod;
        },

        /////////////////////////////////////
        // Ads:  model maintenance and utils
        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        resetAdStates: function () {
            var mdl = this.cviModel;

            mdl.resetAdPlaybackState();
            mdl.resetAdVideoState();
            mdl.isCurrVideoAd = false;
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @param {google.ima.dai.api.Ad} ad a DAI ad object
         */
        updateAdModel: function() {
            this.populateAdVideoState();
            this.cviModel.isCurrVideoAd = true;
            this.cviModel.mergeCDOData();
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        populateAdVideoState: function() {
            var state = uvpjs.adUtil.getAdStateBlank();

            // Note: For SSB, currently making the assumption
            // that only a single pre-roll ad will be shown

            state.adServerName = 'dai_ssb';
            state.duration = this.getPrerollAdDuration();
            state.adClipID = 'pre_0';
            state.adPosition = 1;
            state.adType = 'pre';

            this.cviModel.setAdVideoState(state);
        },

        /**
         * Returns a time derived from site-supplied content duration (must be in RCO)
         * and the absolute stream duration reported by the facade
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @return {number}
         */
        getPrerollAdDuration: function () {
            if (this.absoluteDuration > 0 && this.contentDuration > 0) {
                return this.absoluteDuration - this.contentDuration;
            }

            return -1;
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        createAdProgressPayload: function() {
            var p = this.getVideoProgressPayload(),
                ct = this.facade.getCurrentTime(),
                adDur = this.getPrerollAdDuration(),
                pct = Math.floor((ct / adDur) * 100),
                q, qpct;

            // Note: assumes that only a single preroll ad
            // is played, such that currentTime and ad time are the same

            switch (pct) {
                case 25:
                    q = this.quartiles['25'];
                    qpct = 25;
                    break;

                case 50:
                    q = this.quartiles['50'];
                    qpct = 50;
                    break;

                case 75:
                    q = this.quartiles['75'];
                    qpct = 75;
                    break;

            }

            qpct && !q && this.dispatchAdQuartile(qpct);
            qpct && (this.quartiles[String(qpct)] = 1);

            p.isAd = true;
            p.duration = adDur;
            p.currentTime = ct;
            p.absoluteStreamTime = this.facade.getCurrentTime();
            p.lastSecondCompleted = Math.floor(ct);
            p.lastPercentageCompleted = pct;

            return p;
        },

        /////////////////////////////////////
        // video progress, buffering check

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         */
        startContent: function () {
            if (!this.contentStartOpen) {
                this.contentStartOpen = true;
                this.dispatchContentStart();
            }
        },

        /**
         * Only handles progress update for content; see adProgress handling for ad progress updating
         * @override
         */
        onUVPJSTimerTick: function() {
            var shouldContinue = this.facade && this.facade.getPlaybackState() === this.mc.PLAYING,
                adPlay = this.isAdPlaying(),
                cstarted = this.contentStartOpen,
                ct = shouldContinue && this.facade.getCurrentTime(),
                p;

            if (!shouldContinue) return;

            p = adPlay ? this.createAdProgressPayload() : (cstarted ? this.createVideoProgressPayload() : null);

            if (ct > 1 && !cstarted && !adPlay) {
                this.debug && this.log("DaiSsb provider: A 'no ad' start @ " + ct);
                this.contentStartTime = ct;
                this.startContent();
            }

            this.id3HandlingEnabled && this.checkId3Events(ct);

            p && this.dispatchVideoProgress(p);
        },

        /**
         * Creates the payload object used in VIDEO_PROGRESS events.
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @return {Object} video progress payload object
         */
        createVideoProgressPayload: function() {
            var p = this.getVideoProgressPayload(),
                ct = this.facade.getCurrentTime(),
                t = ct - this.contentStartTime;

            p.currentTime = t;
            p.absoluteStreamTime = ct;
            p.duration = this.contentDuration || -1;

            return p;
        },

        /**
         * @override
         */
        checkBuffering: function (time) {
            if (this.cviModel.playbackState !== this.mc.PAUSED) {
                // Need to use absolute stream time here.
                this._super(this.facade.getCurrentTime());
            }
        },

        ////////////////////////////
        // control event override

        /**
         * @override
         */
        onVideoSeekTo: function (evtObj) {
            var target = evtObj && evtObj.target,
                payload = evtObj && evtObj.payload,
                seekTime = payload && payload.seekTime,
                facade = this.facade,
                hasFacade = this._hasFacade(),
                duration = hasFacade && (this.absoluteDuration || facade.getDuration()),
                adDur = this.getPrerollAdDuration(),
                currentTime = this.facade.getCurrentTime();

            if (typeof seekTime !== 'number' || target !== this.vidContId || !duration) {
                return;
            }

            // seekTime supplied in event payload is in 'content time';
            // we need to adjust to absolute time by adding the ad duration to seekTime
            seekTime += adDur > 0 ? adDur : 0;

            if (seekTime < 0 || seekTime > duration) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'onVideoSeekTo out of range seekTime = ' + seekTime);
                return;
            }

            // VTG-232 Track seek from time for dispatching SEEK_DONE.
            this._seekFromTime = this._seekFromTime || currentTime;

            this.debug && uvpjs.log(this.DEBUG_ID, 'onVideoSeekTo ' + JSON.stringify({
                seekTime: seekTime,
                seekFromTime: this._seekFromTime
            }, null, 2));

            hasFacade && facade.seekTo(seekTime);
        },

        /////////////////////////////
        //  Methods called by facade
        /**
         * @override
         */
        facadeProgress: function(data) {
            // no impl; don't want to update time directly from facade
        },

        /**
         * @override
         */
        facadeTimeUpdate: function(data) {
            // no impl; don't want to update time directly from facade
        },

        /**
         * @override
         */
        facadeDurationChanged: function(data) {
            !this.absoluteDuration && (this.absoluteDuration = data.duration);
        },

        /**
         * @override
         */
        facadeDisplayReady: function() {
            this.startVideoProgressTimer();
        },


        /////////////////////////////
        // ID3 via metadata TextTrack
        /**
         * Add HTML5 media events.
         * @private
         */
        listenForTextTrackId3: function () {
            this.hAddTextTrack = this.hAddTextTrack.bind(this);
            this.vidEl.textTracks.addEventListener('addtrack', this.hAddTextTrack, false);
        },

        /**
         * Add HTML5 media events.
         * @private
         */
        unlistenForTextTrackId3: function() {
            this.vidEl.textTracks.removeEventListener('addtrack', this.hAddTextTrack, false);
        },

        /**
         * @private
         * @param e
         */
        hAddTextTrack: function(e) {
            if (e.track && e.track.kind === 'metadata') {
                e.track.addEventListener('cuechange', this.hCueChange.bind(this), false);
                e.track.mode = 'hidden';
            }
        },

        /**
         * @private
         * @param e
         */
        hCueChange: function(e) {
            if (e.target && e.target.activeCues && e.target.activeCues.length == 1) {
                this.handleId3Cue(e.target.activeCues[0]);
            }
        },

        /**
         * @private
         * @param {*} data
         */
        handleId3Cue: function(cue) {
            var key = cue.value.key,
                evt, m;

            if (key !== 'TXXX') {
                return;
            };

            evt = cue.value.data;
            m = streamEvents[evt];

            m && this[m](cue.startTime);
        },


        ////////
        // util

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @return {Boolean}
         */
        isAdPlaying: function() {
            return this.cviModel && this.cviModel.isCurrVideoAd === true;
        },

        /**
         * @memberof uvpjs.DaiSsbResourceProvider#
         * @private
         *
         * @param {String} msg message
         * @param {*}      obj optional data
         * @param {*|String} type  log|warn|error
         */
        log: function(msg, obj, type) {
            var m = type ? type : 'log';

            uvpjs[m](this.DEBUG_ID, msg, obj || '');
        }

    });

}(uvpjs.register('uvpjs')));


(function (obj) {
    'use strict';

    var SDK_LOAD_TIMEOUT = 2000;

    obj.P2pClient = uvpjs.Class.subClass({

        /**
         * @constructor uvpjs.P2pClient
         *
         * @param {Object}   options
         * @param {String}   options.clientName
         * @param {String}   options.requiredParams
         */
        init: function(options) {
            this.clientName = options.clientName || null;
            this.requiredParams = options.requiredParams || null;
        },

        destroy: function () {
            this.requiredParams = null;
        },

        /**
         * @memberof uvpjs.P2pClient#
         *
         * @return {*}
         */
        getHlsjsLoader: function() {
            var client = uvpjs.P2pClient.clientMap[this.clientName];

            return client && client.getHlsjsLoader && (client.getHlsjsLoader() || null);
        }
    });

    /////////////////
    // Static client map

    /**
     * @private
     * @static
     */
    obj.P2pClient.debugId = uvpjs.DebugManager.configParams.P2P_CLIENT;

    /**
     * @private
     * @static
     */
    obj.P2pClient.clientMap = {
        peer5: {
            uvpcModuleName: 'Peer5PluginJS',
            sdkPath: '//api.peer5.com/peer5.js?id=',
            hlsjsLoaderPath: '//api.peer5.com/peer5.hlsjs.loader.js',
            requires: ['apiKey'],
            validateScriptLoad: function() {
                return this.getHlsjsLoader() !== null;
            },
            getHlsjsLoader: function () {
                return (window.peer5 && window.peer5.HlsJsLoader) || null;
            },
            getApi: function () {
                return window.peer5;
            },
            loadScripts: function (readyCallback, requiredParams) {
                var cb;

                if (this.getHlsjsLoader()) {
                    readyCallback();
                }
                else if (!requiredParams.apiKey) {
                    readyCallback(true); // error
                }
                else {
                    cb = this.loadHlsLoader.bind(this, readyCallback);
                    uvpjs.VideoDeliveryPluginService.load(this.sdkPath + requiredParams.apiKey, cb, SDK_LOAD_TIMEOUT);
                }
            },
            loadHlsLoader: function (readyCallback, error) {
                if (error) {
                    uvpjs.debug && uvpjs.log(uvpjs.P2pClient.debugId, 'P2pClient: Peer5 SDK load failed', error);
                    readyCallback(true);

                    return;
                }
                uvpjs.VideoDeliveryPluginService.load(this.hlsjsLoaderPath, readyCallback, SDK_LOAD_TIMEOUT);
            }
        }
    };


}(uvpjs.register('uvpjs')));
(function (obj) {
    'use strict';

    var DECSION_TIMEOUT = 2000;

    /*
        May need refactoring if other clients are added and they differ in the mechanics of decision making
     */
    obj.MultiCdnClient = uvpjs.Class.subClass({

        /**
         * @constructor uvpjs.MultiCdnClient
         *
         * @param {Object}   options
         * @param {String}   options.clientName
         */
        init: function(options) {
            this.clientName = options.clientName || null;
            this.requiredParams = options.requiredParams || null;
            this.url = uvpjs.MultiCdnClient.clientMap[this.clientName].getDecisionUrl(this.requiredParams);
            this.decisionCallback = null;
            this.timeoutHandle = null;
            this.aborted = false;
            this.inFlight = false;
        },

        destroy: function () {
            this.decisionCallback = Function.prototype;
            this.requiredParams = null;
        },

        getDecision: function(callback) {
            var cl;

            if (this.inFlight) return;

            this.inFlight = true;
            this.decisionCallback = callback;

            this.timeoutHandle = setTimeout(this.abortOnTimeout.bind(this), DECSION_TIMEOUT);

            cl = new uvpjs.CodeLoader();
            cl.loadXHR(this.url, this.handleDecision.bind(this), this.handleError.bind(this), "json");
        },

        abortOnTimeout: function () {
            this.aborted = true;
            this.decisionCallback(null);
        },

        handleDecision: function (xhr) {
            clearTimeout(this.timeoutHandle);
            !this.aborted && this.decisionCallback(xhr.response);
            this.reset();
        },

        handleError: function () {
            clearTimeout(this.timeoutHandle);
            !this.aborted && this.decisionCallback(null);
            this.reset();
        },

        reset: function () {
            this.inFlight = false;
            this.aborted = false;
        }

    });


    /**
     * @private
     * @static
     */
    obj.MultiCdnClient.clientMap = {
        cedexis: {
            uvpcModuleName: 'CedexisMultiCDNPlugin',
            decisionUrl: '//hopx.cedexis.com/zones/1/customers/{customerId}/apps/{appId}/decision',
            requires: ['customerId', 'appId'],
            getDecisionUrl: function(requiredParams) {
                if (requiredParams && requiredParams.customerId && requiredParams.appId) {
                    return this.decisionUrl
                        .replace('{customerId}', requiredParams.customerId)
                        .replace('{appId}', requiredParams.appId);
                }

                return null;
            },
            validateScriptLoad: function() {
                return true;
            },
            loadScripts: function (readyCallback) {
                readyCallback();
            }
        }
    };
}(uvpjs.register('uvpjs')));

(function (obj) {
    'use strict';

    obj.VideoDeliveryPluginService = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.CORE_VIDEO_INSTANCE,

        /**
         * @constructor uvpjs.VideoDeliveryPluginService
         * @param callback
         * @param model
         */
        init: function(callback, model) {
            var types = uvpjs.VideoDeliveryPluginService.clientType;

            this.model = model;
            this.callback = callback;

            this.staticSvc = uvpjs.VideoDeliveryPluginService;

            this.p2pClientOptions = this.getClientOptions(types.P2P);
            this.multiCdnClientOptions = this.getClientOptions(types.MULTI_CDN);
        },

        //////////
        // Public
        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         */
        destroy: function() {
            this.model = null;
            this.callback = Function.prototype;
            this.p2pClientOptions = null;
            this.multiCdnClientOptions = null;
        },

        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         */
        createPlugins: function() {
            if (this.p2pClientOptions.canUse || this.multiCdnClientOptions.canUse) {
                this.loadDeliveryPluginScripts();
            }
            else {
                this.callback(null, null);
            }
        },

        ///////////
        // Private
        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         */
        handleAllScriptsLoaded: function () {
            var pc = null, mc = null;

            if (!this.p2pClientOptions) return;

            if (this.p2pClientOptions.canUse) {
                pc = this.createClient(this.staticSvc.clientType.P2P, this.p2pClientOptions);
            }

            if (this.multiCdnClientOptions.canUse) {
                mc = this.createClient(this.staticSvc.clientType.MULTI_CDN, this.multiCdnClientOptions);
            }

            this.callback(pc, mc);
        },

        ////
        // P2P and Multi-CDN script loading sequence
        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         *
         * @param {Boolean} error
         */
        handleMcdnReady: function(error) {
            var mo = this.multiCdnClientOptions,
                ok = !error && this.validateScriptLoad(
                    this.staticSvc.clientType.MULTI_CDN,
                    mo.clientName
                );

            if (!ok) {
                mo.canUse = false;
                this.debug && uvpjs.log(this.DEBUG_ID, "Error loading SDK for " + mo.clientName);
            }

            this.handleAllScriptsLoaded();
        },

        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         */
        loadMultiCdn: function() {
            var mcdn = this.multiCdnClientOptions;

            this.loadClientScripts(
                this.staticSvc.clientType.MULTI_CDN,
                mcdn.clientName,
                this.handleMcdnReady.bind(this),
                mcdn.requiredParams
            );
        },

        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         *
         * @param {Boolean} loadMultiCdn
         * @param {Boolean} error
         */
        handleP2pReady: function (loadMultiCdn, error) {
            var po = this.p2pClientOptions,
                ok = !error && this.validateScriptLoad(this.staticSvc.clientType.P2P, po.clientName);

            if (!ok) {
                po.canUse = false;
                this.debug && uvpjs.log(this.DEBUG_ID, "Error loading SDK for " + po.clientName);
            }

            if (loadMultiCdn) {
                this.loadMultiCdn();
            }
            else {
                this.handleAllScriptsLoaded();
            }
        },

        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         */
        loadDeliveryPluginScripts: function () {
            var p2po = this.p2pClientOptions,
                mcdn = this.multiCdnClientOptions,
                useMcdn = mcdn.canUse;

            if (p2po.canUse) {
                this.loadClientScripts(
                    this.staticSvc.clientType.P2P,
                    p2po.clientName,
                    this.handleP2pReady.bind(this, useMcdn),
                    p2po.requiredParams
                )
            }
            else if (useMcdn) {
                this.loadMultiCdn();
            }
            else {
                this.handleAllScriptsLoaded();
            }
        },

        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         */
        loadClientScripts: function (clientType, clientName, callback, requiredParams) {
            var cObj = this.getClientObject(clientType, clientName);

            if (!cObj) {
                callback(true); // error
            }
            cObj.loadScripts(callback, requiredParams);
        },

        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         *
         * @param clientName
         * @return {Boolean}
         */
        validateScriptLoad: function (clientType, clientName) {
            var co = this.getClientObject(clientType, clientName);

            return (co && co.validateScriptLoad()) || false;
        },

        // END P2P and Multi-CDN script loading sequence
        ////

        // helpers
        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         *
         * @param clientType
         * @param options
         */
        createClient: function (clientType, options) {
            return new clientType(options);
        },

        /**
         * Determine if UVPJS is configured to use a given resource download/offload client
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         */
        getClientOptions: function(clientType) {
            var mdl = this.model,
                clients = this.getSupportedClients(clientType),
                def = {
                    canUse: false,
                    clientName: null
                },
                q, clientName, client, reqp,
                i, modp, rpObj, mod, canUse;

            if (clientType === this.staticSvc.clientType.P2P && !uvpjs.mediaCapabilities.canUseP2p()) {
                return def;
            }

            for (q in clients) {
                clientName = q;
                client = clients[clientName];
                mod = client && client.uvpcModuleName;

                if (mod && mdl.isModuleEnabled(mod)) {
                    reqp = client.requiredParams;
                    i = (reqp && reqp.length) || 0;
                    rpObj = {};
                    canUse = true;

                    while (i--) {
                        modp = mdl.getModuleParam(mod, reqp[i]);

                        if (uvpjs.util.isEmpty(modp)) {
                            canUse = false;
                            break;
                        }
                        else {
                            rpObj[reqp[i]] = modp;
                        }
                    }

                    return {
                        canUse: canUse,
                        clientName: clientName,
                        requiredParams: rpObj
                    };
                }
            }

            return def;
        },

        /**
         * Returns clients supported for P2P or multi-cdn
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         *
         * @return {Object}
         */
        getSupportedClients: function (clientType) {
            var out = {},
                map = clientType.clientMap,
                q, co;

            if (!map) return out;

            for (q in map) {
                co = map[q];
                out[q] = {
                    uvpcModuleName: co.uvpcModuleName,
                    requiredParams: co.requires
                };
            }

            return out;
        },

        /**
         * @memberof uvpjs.VideoDeliveryPluginService#
         * @private
         *
         * @param {*}      type  - a VideoDeliveryPluginService.clientType constant
         * @param {String} name
         *
         * @return {Object}
         */
        getClientObject: function (type, name) {
            return type.clientMap[name] || null;
        }
    });

    ///////////////////////////
    // Static

    var vps = obj.VideoDeliveryPluginService;

    vps.clientType = {
        P2P: uvpjs.P2pClient,
        MULTI_CDN: uvpjs.MultiCdnClient
    };

    /**
     * @memberof uvpjs.VideoDeliveryPluginService
     * @static
     *
     * @param url
     * @param callback
     * @param timeout
     */
    vps.load = function(url, callback, timeout) {
        var cl = new uvpjs.CodeLoader();
        cl.loadScript(url, callback, timeout);
    };


}(uvpjs.register('uvpjs')));

(function (obj) {

    var METADATA_LOADED_EVENT = 'loadedmetadata';

    obj.FullscreenManager = uvpjs.Class.subClass({

        /**
         * @constructor uvpjs.FullscreenManager
         *
         * @param {Object}      options
         * @param {HTMLElement} options.videoElement              the video element used for content (or content + ad)
         * @param {HTMLElement} options.container                 the outermost container of the video presentation
         * @param {Function}    options.fullscreenChangeCallback  a function invoked when the display state changes
         * @param {Function}    options.readyCallback             a function invoked when the determination is made
         *                      whether fullscreen is available (may be after content video loadedmetadata event)
         */
        init: function (options) {
            var u = uvpjs.util,
                o = options || {},
                mc = uvpjs.mediaCapabilities;

            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.SKIN_MANAGER;

            if (!o.videoElement || !o.container) {
                uvpjs.error(this.DEBUG_ID, "FullscreenManager: constructor missing required options.");

                return;
            }

            this.videoEl = o.videoElement;
            this.container = o.container;

            this.fullscreenChangeCallback = u.isFunction(o.fullscreenChangeCallback) && o.fullscreenChangeCallback;
            this.readyCallback = u.isFunction(o.readyCallback) && o.readyCallback;

            this.fsElement = null; // the element to be taken full screen (i.e., either video el or container)
            this.hasFsApiSupport = false;
            this.hasValidEntryMethod = false;

            this.enterEvt = null;
            this.exitEvt = null;
            this.exitScope = null;
            this.canUseFullscreen = false;

            this.enterMethod = mc.getEnterFullscreenMethodName();
            this.exitMethod = mc.getExitFullscreenMethodName();
            this.fsElementName = mc.getFullScreenElementName(); // property holding current fullscreen element
            this.isFullscreenProperty = mc.getIsFullscreenPropertyName(); // property to query for 'is fullscreen?'

            this.hMetadataLoaded = this.hMetadataLoaded.bind(this);
            this.hFullScreenEvent = this.hFullScreenEvent.bind(this);

            this.initialize();
        },

        /**
         * @memberof uvpjs.FullscreenManager#
         */
        destroy: function() {
            if (this.hasFsApiSupport) {
                this.fsElement && this.fsElement.removeEventListener(this.enterEvt, this.hFullScreenEvent, false);
            }
            else if (this.fsElement) {
                this.fsElement.removeEventListener(this.enterEvt, this.hFullScreenEvent, false);
                this.fsElement.removeEventListener(this.exitEvt, this.hFullScreenEvent, false);
            }
            this.videoEl = null;
            this.fsElement = null;
            this.container = null;
            this.exitScope = null;
            this.fullscreenChangeCallback = null;
            this.hMetadataLoaded = this.hFullScreenEvent = this.readyCallback = Function.prototype;
        },

        /**
         * @memberof uvpjs.FullscreenManager#
         */
        enterFullscreen: function() {
            if (!this.isFullscreen() && this.hasValidEntryMethod) {
                this.fsElement[this.enterMethod]();
            }
        },

        /**
         * @memberof uvpjs.FullscreenManager#
         */
        exitFullscreen: function() {
            if (this.isFullscreen() && this.hasValidExitMethod) {
                this.exitScope[this.exitMethod]();
            }
        },

        /**
         * Returns TRUE if if fullscreen display is available
         * (not just supported, but both supported and available for
         * the current context and any fullscreen policy in effect for that context (e.g, iframe)
         * @memberof uvpjs.FullscreenManager#
         *
         * @return {Boolean}
         */
        isFullscreenAvailable: function() {
            return uvpjs.mediaCapabilities.isFullscreenAvailable(this.videoEl);
        },

        /**
         * @memberof uvpjs.FullscreenManager#
         *
         * @return {Boolean}
         */
        isFullscreen: function () {
            return !!(this.hasFsApiSupport ? document[this.fsElementName] : this.videoEl[this.isFullscreenProperty]);
        },

        /**
         * @memberof uvpjs.FullscreenManager#
         *
         * @return {Boolean}
         */
        usesFullscreenApi: function() {
            return this.hasFsApiSupport;
        },

        ///////////////////////
        // PRIVATE

        /**
         * @memberof uvpjs.FullscreenManager#
         * @private
         */
        hFullScreenEvent: function(e) {
            var fs = this.isFullscreen();

            e.stopPropagation();

            this.fullscreenChangeCallback && this.fullscreenChangeCallback(fs);
        },

        /**
         * Handle webkit case; formally, we can't tell if fullscreen is available until this video event occurs
         * @memberof uvpjs.FullscreenManager#
         * @private
         */
        hMetadataLoaded: function() {
            this.canUseFullscreen = this.isFullscreenAvailable();

            this.readyCallback && this.readyCallback(this.canUseFullscreen);

            this.videoEl.removeEventListener(METADATA_LOADED_EVENT, this.hMetadataLoaded, false);
            this.hMetadataLoaded = Function.prototype;
        },

        /**
         * Debugging/diagnostic only
         * @memberof uvpjs.FullscreenManager#
         * @private
         */
        getInfo: function() {
            return {
                userAgent: navigator.userAgent,
                hasFullscreenApiSupport: this.hasFsApiSupport,
                canUseFullscreen: this.canUseFullscreen,
                enterEvent: this.enterEvt,
                enterMethod: this.enterMethod,
                exitEvent: this.exitEvt,
                exitMethod: this.exitMethod,
                fullScreenElementTag: this.fsElement.tagName,
                documentFullscreenElement: this.fsElementName,
            };
        },

        /**
         * Retrieves object on which the exit fullscreen method will be invoked
         * @memberof uvpjs.FullscreenManager#
         * @private
         *
         * @return {HTMLElement|HTMLDocument}
         */
        getExitScope: function() {
            var s = document[this.exitMethod] ? document : (this.videoEl[this.exitMethod] ? this.videoEl : null);

            return s && uvpjs.util.isFunction(s[this.exitMethod]) ? s : null;
        },

        /**
         * @memberof uvpjs.FullscreenManager#
         * @private
         */
        validateEntryAndExitMethods: function () {
            var fe = this.fsElement && this.fsElement[this.enterMethod],
                fx = this.exitScope && this.exitScope[this.exitMethod],
                u = uvpjs.util;

            this.hasValidEntryMethod = u.isFunction(fe);
            this.hasValidExitMethod = u.isFunction(fx);
        },

        /**
         * @memberof uvpjs.FullscreenManager#
         * @private
         */
        initialize: function() {
            var mc = uvpjs.mediaCapabilities,
                fsEventSource,
                enterEvt, exitEvt,
                fsEvt;

            this.hasFsApiSupport = mc.supportsFullscreenApi();
            this.hasFsApiSupport && (this.canUseFullscreen = this.isFullscreenAvailable());

            this.exitScope = this.getExitScope();

            if (this.hasFsApiSupport) {
                fsEvt = mc.getFullscreenEventName();
                fsEventSource = mc.isFirefox() || mc.isIE() ? document : this.container;

                fsEventSource.addEventListener(fsEvt, this.hFullScreenEvent, false);

                this.fsElement = this.container;
            }
            else if (this.enterMethod) {
                this.fsElement = this.videoEl;
                enterEvt = mc.getFullscreenEnterEventName();
                exitEvt = mc.getFullscreenExitEventName();

                this.fsElement.addEventListener(enterEvt, this.hFullScreenEvent, false);
                this.fsElement.addEventListener(exitEvt, this.hFullScreenEvent, false);

                this.enterEvt = enterEvt;
                this.exitEvt = exitEvt;
            }

            this.validateEntryAndExitMethods();

            if (!this.hasValidEntryMethod) {
                this.debug && uvpjs.log("Fullscreen determined not available", this.getInfo());
                return;
            }

            this.canUseFullscreen && this.readyCallback && this.readyCallback(true);

            if (!this.hasFsApiSupport || !this.canUseFullscreen) {
                this.videoEl.addEventListener(METADATA_LOADED_EVENT, this.hMetadataLoaded, false);
            }

            this.debug && uvpjs.log("Fullscreen management init'd; info: ", this.getInfo());
        }

    });


    obj.FullscreenManager.hasFullscreenSupport = function () {
        return !!uvpjs.mediaCapabilities.getEnterFullscreenMethodName();
    };

}(uvpjs.register("uvpjs")));
(function (obj) {
    'use strict';

    var _addClass,
        _hasClass,
        _removeClass,
        _toggleClass,
        _ = obj._;

    obj.SkinManager = uvpjs.Class.subClass({

        // Leave constants on prototype; no apparent need as class constants
        DEFAULT_SKIN_PATH: 'css/default.css', // The absolute path to the default skin.
        NULL_TIME: '00:00', // Appearance of null time.
        HIDE_DELAY: 2000, // Used only for hiding the controlbar during fullscreen, at the moment.
        TAP_THRESHOLD: 300, // The amount of time to wait before canceling a click event after touch.
        THROTTLE_WAIT: 250, // Time to throttle UI updates to prevent browser performance degradation.
        INITIAL_DOM_SETUP_WAIT: 100, // Time to wait until the DOM classes are applied and the CSS is loaded.
        CAPTION_PADDING: 10, // Small padding to keep captions from absolute bottom.

        // Breakpoints used to determine the display size modifier.
        SIZE_XS_BREAKPOINT: 480, // Extra small screen / phone
        SIZE_SM_BREAKPOINT: 550, // Small screen / tablet
        SIZE_MD_BREAKPOINT: 992, // Medium screen / desktop
        SIZE_LG_BREAKPOINT: 1200, // Large screen / wide desktop

        // IMPORTANT: Do not change.
        //
        // These prefixes are used to construct <div> `id` attributes that are
        // used throughout UVPJS.

        AD_CONTAINER_ID_PREFIX: 'ad', // ad container div id prefix
        CONTENT_CONTAINER_ID_PREFIX: 'content', // content container div id prefix
        CONTROLS_CONTAINER_ID_PREFIX: 'controls', // controls container div id prefix
        VIDEO_CONTAINER_ID_PREFIX: 'video', // video container div id prefix

        AD_LEARNMORE_ID_PREFIX: 'learnMore',
        AD_COUNTDOWN_ID_PREFIX: 'countDown',
        AD_LEARNMORE_TEXT: 'Learn More',

        // Blocks.
        PRIMARY_BLOCK: 'uvpjs', // primary prefix used to namespace all css.

        // Elements.
        //
        // Note: We're using the above <div> `id` prefixes to construct the
        //       class names for the primary ad, content, and controls elements.
        //       Otherwise, we would add those element name prefixes here.

        // Modifiers.
        AD_MODIFIER: 'ad',
        LIVE_MODIFIER: 'live',
        PAUSED_MODIFIER: 'paused',
        STREAMING_MODIFIER: 'streaming',

        ACTIVE_MODIFIER: 'active',
        DISABLED_MODIFIER: 'disabled',
        FULLSCREEN_MODIFIER: 'fullscreen',
        HIDDEN_MODIFIER: 'hidden',
        MOBILE_MODIFIER: 'mobile',
        TOUCH_MODIFIER: 'touch',

        SIZE_XS_MODIFIER: 'xs',
        SIZE_SM_MODIFIER: 'sm',
        SIZE_MD_MODIFIER: 'md',
        SIZE_LG_MODIFIER: 'lg',

        // Delimiters.
        BLOCK_DELIMITER: '_', // single underscore, used between different parts of the same block name
        BLOCK_ELEMENT_DELIMITER: '__', // double underscore, used between blocks and elements
        ELEMENT_DELIMITER: '-', // single dash, used between different parts of the same element name
        ELEMENT_MODIFIER_DELIMITER: '--', // double dash, used between elements and modifiers
        MODIFIER_DELIMETER: '-',

        CLASS_SELECTOR_PREFIX: '.',
        ID_SELECTOR_PREFIX: '#',

        // BEM element names used to construct the CSS class names.
        // Loosely following BEM. Naming convention is BLOCK__ELEMENT--MODIFIER.
        // See more (Harry Roberts' style):
        // https://en.bem.info/method/naming-convention/#alternative-naming-schemes
        css: {

            // In order of how they appear in the DOM. Indentating to represent
            // DOM hierarchy.
            CONTENT: 'content',
            VIDEO: 'video',
            AD: 'ad',
            AD_LEARNMORE: 'ad-learnmore',
            CONTROLS: 'controls',
            PREVIEW_BTN: 'btn-preview',
            REPLAY_BTN: 'btn-replay',
            LARGE_PLAY_BTN: 'btn-large-play',
            BUFFERING_FRAME: 'buffering-frame',
            SETTINGS_MENU: 'settings-menu',
            SETTINGS_MENU_ITEM: 'settings-menu-item',
            SETTINGS_MENU_INPUT: 'settings-menu-input',
            CONTROL_BAR: 'controlbar',
            PLAYSTATE_BTN: uvpjs.Type.Button.PLAYSTATE,
            TIME: 'time',
            TIME_CURRENT: 'time-current',
            TIME_DURATION: 'time-duration',
            TIME_LIVE: 'time-live',
            VOLUME_BTN: uvpjs.Type.Button.VOLUME,
            CLOSED_CAPTION_BTN: uvpjs.Type.Button.CLOSED_CAPTION,
            SETTINGS_BTN: uvpjs.Type.Button.SETTINGS,
            FULLSCREEN_BTN: uvpjs.Type.Button.FULLSCREEN,
            PROGRESS: 'progress',
            PROGRESS_SLIDER: 'progress-slider',
            PROGRESS_LOADED: 'progress-loaded',
            VOLUME_SLIDER: 'volume-slider',
        },

        // Settings menu data structure.
        settingsMenu: [{
            name: 'controls',
            label: 'Controls',
            enabled: false,
            items: [{
                name: 'background-opacity',
                label: 'Background opacity',
                items: [
                    {value: '.25', label: '25%'},
                    {value: '.50', label: '50%'},
                    {value: '.75', label: '75%'},
                    {value: '1', label: '100%', default: true},
                ],
            }],
        }, {
            name: 'cc',
            label: 'Subtitles/CC',
            enabled: false,
            items: [{
                name: 'background-color',
                label: 'Background color',
                items: [
                    {value: '#ffffff', label: 'White'},
                    {value: '#ffff00', label: 'Yellow'},
                    {value: '#008000', label: 'Green'},
                    {value: '#00ffff', label: 'Cyan'},
                    {value: '#0000ff', label: 'Blue'},
                    {value: '#ff00ff', label: 'Magenta'},
                    {value: '#ff0000', label: 'Red'},
                    {value: '#000000', label: 'Black', 'default': true,}
                ],
            }, {
                name: 'background-opacity',
                label: 'Background opacity',
                items: [
                    {value: '0', label: '0%'},
                    {value: '.25', label: '25%'},
                    {value: '.50', label: '50%'},
                    {value: '.75', label: '75%'},
                    {value: '1', label: '100%', default: true},
                ],
            }, {
                name: 'font-color',
                label: 'Font color',
                items: [
                    {value: '#ffffff', label: 'White', 'default': true},
                    {value: '#ffff00', label: 'Yellow'},
                    {value: '#008000', label: 'Green'},
                    {value: '#00ffff', label: 'Cyan'},
                    {value: '#0000ff', label: 'Blue'},
                    {value: '#ff00ff', label: 'Magenta'},
                    {value: '#ff0000', label: 'Red'},
                    {value: '#000000', label: 'Black'}
                ],
            }, {
                name: 'font-opacity',
                label: 'Font opacity',
                items: [
                    {value: '0', label: '0%'},
                    {value: '.25', label: '25%'},
                    {value: '.50', label: '50%'},
                    {value: '.75', label: '75%'},
                    {value: '1', label: '100%', default: true},
                ],
            }, {
                name: 'font-size',
                label: 'Font size',
                items: [
                    {value: '50%'},
                    {value: '75%'},
                    {value: '100%', default: true},
                    {value: '125%'},
                    {value: '150%'},
                    {value: '175%'},
                    {value: '200%'},
                ],
            }, {
                name: 'font-weight',
                label: 'Font weight',
                items: [
                    {value: 'Normal', default: true},
                    {value: 'Bold'},
                ],
            }, {
                name: 'font-family',
                label: 'Font family',
                items: [
                    {value: 'Arial', label: 'Arial', default: true},
                    {value: 'Avenir'},
                    {value: 'Copperplate'},
                    {value: 'Courier'},
                    {value: 'Helvetica'},
                    {value: 'Iowan'},
                    {value: 'Menlo'},
                    {value: 'sans-serif', label: 'Sans Serif'},
                    {value: 'Trebuchet'}
                ]
            }, {
                name: 'text-position',
                label: 'Position',
                enabled: true, // NOTE: Disabled.
                items: [
                    {value: 'default', label: 'Default'},
                    {value: 'top-left', label: 'Top Left'},
                    {value: 'top-center', label: 'Top Center'},
                    {value: 'top-right', label: 'Top Right'},
                    {value: 'middle-left', label: 'Middle Left'},
                    {value: 'middle-center', label: 'Middle Center'},
                    {value: 'middle-right', label: 'Middle Right'},
                    {value: 'bottom-left-floated', label: 'Bottom Left'},
                    {value: 'bottom-center-floated', label: 'Bottom Center', default: true},
                    {value: 'bottom-right-floated', label: 'Bottom Right'},
                ]
            }, {
                name: 'text-edge-style',
                label: 'Text edge style',
                items: [
                    {value: 'none', label: 'None', default: true},
                    {value: 'drop-shadow', label: 'Drop Shadow'},
                    {value: 'raised', label: 'Raised'},
                    {value: 'outline', label: 'Outline'},
                ],
            }]
        }, {
            name: 'debug',
            label: 'Debug',
            enabled: true,
            items: [
                {value: 'diagnostic-window', label: 'Show diagnostics'},
            ],
        }],

        /**
         * @constructor uvpjs.SkinManager
         * @description Creates custom and default skins for uvpjs.
         *
         * @param {Object}                      options
         * @param {uvpjs.VideoControlInterface} options.vci
         * @param {Function}                    options.skinReadyCallback
         * @param {Object}                      options.skinConfig
         * @param {Boolean}                     options.skinConfig.autoPlay     Whether to autoplay video.
         * @param {String}                      options.skinConfig.customCSS    Url to custom CSS file.
         * @param {String}                      options.skinConfig.previewImage Url to preview image.
         * @param {Boolean}                     options.skinConfig.enableReplay Whether to replay after video complete.
         * @param {String}                      options.skinConfig.themeName    Name of theme for CSS namespacing.
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.SKIN_MANAGER;

            this.debug && uvpjs.log(this.DEBUG_ID, 'init');

            this.vci = options.vci;
            this.dom = this.vci.dom;

            this._namespace = null;

            this._containerEl = this.dom.outer.el;
            this._contentEl = this.dom.content.el;
            this._videoEl = this.dom.video.el;
            this._adEl = this.dom.ad.el;
            this._controlsEl = this.dom.controls.el;
            this._containerId = this._containerEl.id;
            this._controlsId = this._controlsEl.id;

            this._skinReadyCB = options.skinReadyCallback;
            this.mc = uvpjs.mediaCapabilities;

            this.fullscreenMgr = null;

            this._autoPlay = false;
            this._playbackState = this.mc.EMPTY; // When you know you know, but set it to empty first.
            this._controlList = {}; // A list of controls as they were added with all control class names for reference
            this._controlCache = {}; // The cached DOM elements so don't have to query them directly from page
            this._intervals = {}; // SetTimer interval ids
            this._disabledButtons = []; // Array of buttons to restrict internal calls from overriding API states.

            this._downloaded = 0; // The amount the video has downloaded

            this._isMouseActive = false; // Track active mouse movements
            this._previewCallbackDone = false; // Set when preview callback button clicked or touched.
            this._canFullscreen = false;
            this._captionsLoaded = false;
            this._enableReplay = false;
            this._isSliding = false;
            this._isTouchActive = false;

            this._cssPath = ''; // The path to the CSS file
            this._cssRules = {}; // Contains the CSS rules added to the page
            this._styleEl = null; // The stylesheet created for updating progress and slider styles
            this._previewImage = ''; // A default preview image
            this._waitCount = 0;

            this._vendorPrefix = this.mc.getBrowserVendorPrefix();

            this._isMSEdge = this.mc.isEdge();
            this._isTouch = this.mc.isMobile() && this.mc.isTouch();

            this._hasFirstTouch = false;

            this._isIOS = this.mc.isIOS();
            this._isAndroid = this.mc.isAndroid();

            this._playstateBtn = null;
            this._playToggleFrame = null;
            this._progress = null;
            this._progressSlider = null;
            this._controlBar = null;
            this._previewBtn = null;
            this._replayBtn = null;
            this._volumeSlider = null;
            this._volumeBtn = null;
            this._ccBtn = null;
            this._settingsBtn = null;
            this._fullscreenBtn = null;
            this._touchStartTime = null;

            this.isMonitoringMuting = false;
            this.muteMonitorIntervalId = null;
            this.currVolumeInfo = null;

            this.durationChecked = false;

            this._menuSelections = {};

            this._hPlay = null;

            this._onSettingsMenuBtnClick = this._onSettingsMenuBtnClick.bind(this);
            this._onSettingsMenuInputClick = this._onSettingsMenuInputClick.bind(this);
            // TODO: Replace with _.debounce.
            this._intervals[this._getClassName(this.PRIMARY_BLOCK, this.ACTIVE_MODIFIER)] = -1;

            this.initialize(options.skinConfig);
        },

        /**
         * Destroy the instance
         *
         * @memberof uvpjs.SkinManager#
         */
        destroy: function () {
            var mt = function () {
            };

            this._clearIntervals();
            this._removeUIEventListeners();
            this._removeUVPJSEventListeners();
            this._removeMenuEventListeners();

            clearTimeout(this.muteMonitorIntervalId);

            this.vci = null;
            this.mc = null;
            this.dom = null;
            this._containerEl = null;
            this._contentEl = null;
            this._videoEl = null;
            this._adEl = null;
            this._controlsEl = null;
            this._containerId = null;
            this._controlsId = null;
            this._playstateBtn = null;
            this._playToggleFrame = null;
            this._progress = null;
            this._progressSlider = null;
            this._controlBar = null;
            this._previewBtn = null;
            this._replayBtn = null;
            this._volumeSlider = null;
            this._volumeBtn = null;
            this._ccBtn = null;
            this._settingsBtn = null;
            this._fullscreenBtn = null;
            this._updateProgressSlider = null;
            this._skinReadyCB = mt;
            this._replayCB = mt;
            this._controlList = null;
            this._controlCache = null;
            this._intervals = null;
            this._previewImage = null;
            this._disabledButtons = null;
            this._touchStartTime = null;
        },

        /**
         * @memberof uvpjs.SkinManager#
         * @param {Object}     cfg                      Configuration that controls the UVPJS default skin.
         * @param {Boolean}    cfg.isMutedAutoplay      True if using silent autoplay
         * @param {Boolean}    cfg.isUnmutedAutoplay    True if autoplaying with sound
         * @param {String}     cfg.customCSS            Url to custom CSS file.
         * @param {String}     cfg.previewImage         Url to preview image.
         * @param {Boolean}    cfg.enableReplay         Whether to replay after video complete.
         * @param {String}     cfg.themeName            Name of theme for CSS namespacing
         */
        initialize: function (cfg) {
            var u = uvpjs.util,
                path = uvpjs.Configuration.path,
                containerId = this._containerId,
                css = cfg.customCSS;

            this._namespace = '.' + containerId + '.' + 'skin';
            this._autoPlay = cfg.isMutedAutoplay || cfg.isUnmutedAutoplay;
            this._isMutedAutoplay = cfg.isMutedAutoplay;
            this._previewImage = cfg.previewImage;
            this._enableReplay = cfg.enableReplay;
            this._themeName = cfg.themeName;
            this._canFullscreen = uvpjs.FullscreenManager.hasFullscreenSupport();
            this._cssPath = (u.isDefinedString(css) && css) || path + this.DEFAULT_SKIN_PATH;

            this.debug && uvpjs.log(this.DEBUG_ID, 'initialize cfg', JSON.stringify(cfg));

            this._hideContainers();
            this._setupDom();
            this._addStylesheetToDom();

            this._disableButton(this.css.FULLSCREEN_BTN); // re-enabled when fullscreenmgr is ready

            if (this._canFullscreen) {
                this.fullscreenMgr = new uvpjs.FullscreenManager({
                    videoElement: this._videoEl,
                    container: this._containerEl,
                    readyCallback: this._handleFullscreenMgrReady.bind(this),
                    fullscreenChangeCallback: this._handleFullscreenChange.bind(this),
                });
            }
        },

        /**
         * Public API call to disable button.
         * @param {String} elementName - Element name.
         * @memberof uvpjs.SkinManager#
         */
        disableButton: function (elementName) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'disableButton', elementName);
            if (!_.includes(this._disabledButtons, elementName)) {
                this._disabledButtons.push(elementName);
            }

            this._disableButton(elementName);
        },

        /**
         * Public API call to enable button.
         * @param {String} elementName - Element name.
         * @memberof uvpjs.SkinManager#
         */
        enableButton: function (elementName) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'enableButton', elementName);
            _.pull(this._disabledButtons, elementName);
            this._enableButton(elementName);
        },


        /**
         * Callback invoked by FullsccreenManager when ready
         * @memberof uvpjs.SkinManager#
         * @private
         *
         * @param {Boolean} fullScreenAvailable
         */
        _handleFullscreenMgrReady: function(fullScreenAvailable) {
            fullScreenAvailable && this._enableButton(this.css.FULLSCREEN_BTN);
        },

        /**
         * Callback invoked by FullsccreenManager on a fullscreen event
         * @memberof uvpjs.SkinManager#
         * @private
         *
         * @param {Boolean} isFullscreen TRUE if currently displaying fullscreen
         */
        _handleFullscreenChange: function(isFullscreen) {
            var fsapi = this.fullscreenMgr.usesFullscreenApi(),
                checkCc = this._isIOS && this._videoEl.webkitClosedCaptionsVisible !== undefined,
                customCcVisible = checkCc && this._hasActive(this.css.CLOSED_CAPTION_BTN);

            this._hide(this.css.VOLUME_SLIDER);

            if (isFullscreen) {
                this.vci.fullscreen(true);
                fsapi && this._addModifier(this.PRIMARY_BLOCK, this.FULLSCREEN_MODIFIER);

                if (checkCc) {
                    this.monitorMuting(true);
                    customCcVisible && this.vci.hideCaptions();
                    this._videoEl.webkitClosedCaptionsVisible = customCcVisible;
                }
            }
            else {
                this.vci.fullscreen(false);
                fsapi && this._removeModifier(this.PRIMARY_BLOCK, this.FULLSCREEN_MODIFIER);

                if (checkCc) {
                    if (this._videoEl.webkitClosedCaptionsVisible || customCcVisible) {
                        this._addModifier(this.css.CLOSED_CAPTION_BTN, this.ACTIVE_MODIFIER);
                        this.vci.showCaptions();
                        this._setCCPosition();
                    }
                    else  {
                        this._removeModifier(this.css.CLOSED_CAPTION_BTN, this.ACTIVE_MODIFIER);
                        this.vci.hideCaptions();
                    }

                    this._videoEl.webkitClosedCaptionsVisible = false;

                    this.monitorMuting(false, true);
                    this._updateVolumeUI();
                }

            }
        },

        /**
         * Disable button.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         */
        _disableButton: function (elementName) {
            var el = this._queryByElementName(elementName);
            this.debug && uvpjs.log(this.DEBUG_ID, '_disableButton', elementName);
            this._disable(elementName);
            el && (el.disabled = true);
        },

        /**
         * Enable button.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         */
        _enableButton: function (elementName) {
            var el = this._queryByElementName(elementName);
            this.debug && uvpjs.log(this.DEBUG_ID, '_enableButton', elementName);
            if (_.includes(this._disabledButtons, elementName)) {
                return;
            }
            this._enable(elementName);
            el && (el.disabled = false);
        },

        /**
         * Register callbacks to events dispatched by UVPJS.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _addUVPJSEventListeners: function () {

            var vci = this.vci,
                ns = this._namespace,
                uEvt = uvpjs.EventType;

            // Note: Listener removal via VCI#removeEventListener does not require a function reference
            // so no need to retain one. (All listeners on supplied namespaced event are removed).
            vci.addEventListener(uEvt.AD_START + ns, this._onAdStart.bind(this));
            vci.addEventListener(uEvt.AD_END + ns, this._onAdEnd.bind(this));
            vci.addEventListener(uEvt.CAPTIONS_READY + ns, this._onCaptionsReady.bind(this));
            vci.addEventListener(uEvt.CONTENT_START + ns, this._onContentStart.bind(this));
            vci.addEventListener(uEvt.CONTENT_END + ns, this._onContentEnd.bind(this));
            vci.addEventListener(uEvt.VIDEO_PROGRESS + ns, this._onVideoProgress.bind(this));
            vci.addEventListener(uEvt.VIDEO_STATE_CHANGE + ns, this._onVideoStateChange.bind(this));
            vci.addEventListener(uEvt.VIDEO_LOADING + ns, this._onVideoLoading.bind(this));
            vci.addEventListener(uEvt.CONTROL_MUTE + ns, this._onControlMuteUnmute.bind(this));
            vci.addEventListener(uEvt.CONTROL_UNMUTE + ns, this._onControlMuteUnmute.bind(this));
            vci.addEventListener(uEvt.RESOURCE_START + ns, this._onResourceStart.bind(this));
            vci.addEventListener(uEvt.RESOURCE_END + ns, this._onResourceEnd.bind(this));
            vci.addEventListener(uEvt.CONTAINER_RESIZE + ns, this._onUVPJSResize.bind(this));
            vci.addEventListener(uEvt.DIAGNOSTIC_WINDOW_CLOSE_BUTTON + ns, this._onDiagCloseButton.bind(this));
        },

        /**
         * Remove VCI event listeners (namespaced)
         *
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _removeUVPJSEventListeners: function () {
            var vci = this.vci,
                ns = this._namespace,
                uEvt = uvpjs.EventType;

            // Note: Listener removal doesn't need a function reference
            if (vci && vci instanceof uvpjs.VideoControlInterface) {
                vci.removeEventListener(uEvt.AD_START + ns);
                vci.removeEventListener(uEvt.AD_END + ns);
                vci.removeEventListener(uEvt.CAPTIONS_READY + ns);
                vci.removeEventListener(uEvt.CONTENT_START + ns);
                vci.removeEventListener(uEvt.CONTENT_END + ns);
                vci.removeEventListener(uEvt.VIDEO_PROGRESS + ns);
                vci.removeEventListener(uEvt.VIDEO_STATE_CHANGE + ns);
                vci.removeEventListener(uEvt.VIDEO_LOADING + ns);
                vci.removeEventListener(uEvt.CONTROL_MUTE + ns);
                vci.removeEventListener(uEvt.CONTROL_UNMUTE + ns);
                vci.removeEventListener(uEvt.RESOURCE_END + ns);
                vci.removeEventListener(uEvt.CONTAINER_RESIZE + ns);
            }
        },

        /**
         * Bind to UI events.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _addUIEventListeners: function () {
            // Bug: IE 11 doesn't recognize 'input' events for range input elements.
            //      Fixed in Microsoft Edge November Update build 10586.
            var rangeEvent = this.mc.isIE() ? 'change' : 'input',
                el = this._containerEl,
                css = this.css,
                trapTaps = this.shouldTrapTaps();

            // these methods get permanently re-assigned to scope-bound copies
            var fns = [
                '_hideMenu',
                '_onUVPJSGestureEvent',
                '_onPreviewBtn',
                '_onReplayBtn',
                '_onControlBarMouseOver',
                '_onControlBarMouseOut',
                '_onProgressMouseOver',
                '_onProgressMouseOut',
                '_onProgressSliderEvent',
                '_onVolumeSliderEvent',
                '_onPlayToggle',
                '_onVolumeBtnEvent',
                '_onClosedCaptionBtnClick',
                '_onSettingsBtnClick',
                '_onFullscreenBtnClick',
                '_hNonTap'
            ], i = fns.length;

            while (i--) {
                this[fns[i]] = this[fns[i]].bind(this);
            }

            var hUvpGesture = this._onUVPJSGestureEvent,
                hNonTap = this._hNonTap,
                hSlider = this._onProgressSliderEvent,
                hVolSlider = this._onVolumeSliderEvent,
                hVolBtn = this._onVolumeBtnEvent;

            document.addEventListener('click', this._hideMenu, false);

            window.addEventListener('scroll', hNonTap);

            // Container - Show and hide control bar.
            el.addEventListener('mouseenter', hUvpGesture, true);
            el.addEventListener('mouseleave', hUvpGesture, true);
            el.addEventListener('mousemove', hUvpGesture, true);
            el.addEventListener('mousedown', hUvpGesture, false);
            el.addEventListener('mouseup', hUvpGesture, false);
            el.addEventListener('click', hUvpGesture, false);
            el.addEventListener('touchstart', hUvpGesture, true);
            el.addEventListener('touchend', hUvpGesture, true);

            // Preview btn
            this._previewBtn = this._queryByElementName(css.PREVIEW_BTN);
            this._previewBtn.addEventListener('touchend', this._onPreviewBtn, true);
            this._previewBtn.addEventListener('touchmove', hNonTap);
            !this._isTouch && this._previewBtn.addEventListener('click', this._onPreviewBtn, true);

            // Replay btn
            this._replayBtn = this._queryByElementName(css.REPLAY_BTN);
            this._replayBtn.addEventListener('touchend', this._onReplayBtn, true);
            !this._isTouch && this._replayBtn.addEventListener('click', this._onReplayBtn, true);

            // Control bar
            this._controlBar = this._queryByElementName(css.CONTROL_BAR);
            this._controlBar.addEventListener('mouseover', this._onControlBarMouseOver, false);
            this._controlBar.addEventListener('mouseout', this._onControlBarMouseOut, false);

            // Progress
            this._progress = this._queryByElementName(css.PROGRESS);
            this._progress.addEventListener('mouseover', this._onProgressMouseOver, false);
            this._progress.addEventListener('mouseout', this._onProgressMouseOut, false);

            // Progress slider
            this._progressSlider = this._queryByElementName(css.PROGRESS_SLIDER);
            this._progressSlider.addEventListener(rangeEvent, hSlider, false);
            this._progressSlider.addEventListener('mousedown', hSlider, false);
            this._progressSlider.addEventListener('mouseup', hSlider, false);
            this._progressSlider.addEventListener('touchstart', hSlider, true);
            this._progressSlider.addEventListener('touchend', hSlider, true);

            // Volume slider
            this._volumeSlider = this._queryByElementName(css.VOLUME_SLIDER);

            if (this.mc.supportsVolume()) {
                this._volumeSlider.addEventListener(rangeEvent, hVolSlider, false);
                this._volumeSlider.addEventListener('mouseover', hVolSlider, false);
                this._volumeSlider.addEventListener('mouseout', hVolSlider, false);
            }
            else {
                this._disable(this.css.VOLUME_SLIDER);
            }

            // Play toggle btn
            this._playToggleFrame = this._queryByElementName(css.LARGE_PLAY_BTN);
            !trapTaps && this._playToggleFrame.addEventListener('click', this._onPlayToggle, false);

            // Note "trapTaps" impl'd to deal with iOS issue - these controls become
            // non-clickable after the scrubber (progress slider) is dragged.

            // Playstate btn
            this._playstateBtn = this._queryByElementName(css.PLAYSTATE_BTN);
            !trapTaps && this._playstateBtn.addEventListener('click', this._onPlayToggle, false);

            // Volume btn
            this._volumeBtn = this._queryByElementName(css.VOLUME_BTN);
            !trapTaps && this._volumeBtn.addEventListener('click', hVolBtn, false);
            this._volumeBtn.addEventListener('mouseover', hVolBtn, false);
            this._volumeBtn.addEventListener('mouseout', hVolBtn, false);

            // CC btn
            this._ccBtn = this._queryByElementName(css.CLOSED_CAPTION_BTN);
            !trapTaps && this._ccBtn.addEventListener('click', this._onClosedCaptionBtnClick, false);

            // Settings btn
            this._settingsBtn = this._queryByElementName(css.SETTINGS_BTN);
            !trapTaps && this._settingsBtn.addEventListener('click', this._onSettingsBtnClick, false);

            this._updateProgressSlider = this._updateSliderUI.bind(
                this,
                this._progressSlider,
                css.PROGRESS_SLIDER
            );

            // Fullscreen.
            this._fullscreenBtn = this._queryByElementName(css.FULLSCREEN_BTN);
            this._canFullscreen && this._listenToFullscreenBtn();
        },

        /**
         * Remove listeners add via _addUIEventListeners()
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _removeUIEventListeners: function () {
            var rangeEvent = this.mc.isIE() ? 'change' : 'input',
                el = this._containerEl,
                hNonTap = this._hNonTap,
                hUvpGesture = this._onUVPJSGestureEvent,
                hSlider = this._onProgressSliderEvent,
                hVolSlider = this._onVolumeSliderEvent,
                hVolBtn = this._onVolumeBtnEvent;

            document.removeEventListener('click', this._hideMenu, false);

            window.removeEventListener('scroll', hNonTap, false);

            // video container
            el.removeEventListener('mouseenter', hUvpGesture, true);
            el.removeEventListener('mouseleave', hUvpGesture, true);
            el.removeEventListener('mousemove', hUvpGesture, true);
            el.removeEventListener('mousedown', hUvpGesture, false);
            el.removeEventListener('mouseup', hUvpGesture, false);
            el.removeEventListener('click', hUvpGesture, false);
            el.removeEventListener('touchstart', hUvpGesture, true);
            el.removeEventListener('touchend', hUvpGesture, true);

            // Preview btn
            if (this._previewBtn) {
                this._previewBtn.removeEventListener('touchend', this._onPreviewBtn, true);
                this._previewBtn.removeEventListener('touchmove', hNonTap, true);
                this._previewBtn.removeEventListener('click', this._onPreviewBtn, true);
            }

            // Replay btn
            if (this._replayBtn) {
                this._replayBtn.removeEventListener('touchend', this._replayBtn, true);
                this._replayBtn.removeEventListener('click', this._replayBtn, true);
            }

            // Control bar
            if (this._controlBar) {
                this._controlBar.removeEventListener('mouseover', this._onControlBarMouseOver, false);
                this._controlBar.removeEventListener('mouseout', this._onControlBarMouseOut, false);
            }

            // Progres
            if (this._progress) {
                this._progress.removeEventListener('mouseover', this._onProgressMouseOver, false);
                this._progress.removeEventListener('mouseout', this._onProgressMouseOut, false);
            }

            // Progres slider
            if (this._progressSlider) {
                this._progressSlider.removeEventListener(rangeEvent, hSlider, false);
                this._progressSlider.removeEventListener('mousedown', hSlider, false);
                this._progressSlider.removeEventListener('mouseup', hSlider, false);
                this._progressSlider.removeEventListener('touchstart', hSlider, true);
                this._progressSlider.removeEventListener('touchend', hSlider, true);
            }

            // Volume slider
            if (this._volumeSlider) {
                this._volumeSlider.removeEventListener(rangeEvent, hVolSlider, false);
                this._volumeSlider.removeEventListener('mouseover', hVolSlider, false);
                this._volumeSlider.removeEventListener('mouseout', hVolSlider, false);
            }

            // Playstate btn
            this._playstateBtn && this._playstateBtn.removeEventListener('click', this._onPlayToggle, false);

            // Play toggle btn
            this._playToggleFrame && this._playToggleFrame.removeEventListener('click', this._onPlayToggle, false);

            // Volume btn
            if (this._volumeBtn) {
                this._volumeBtn.removeEventListener('click', hVolBtn, false);
                this._volumeBtn.removeEventListener('mouseover', hVolBtn, false);
                this._volumeBtn.removeEventListener('mouseout', hVolBtn, false);
            }

            // CC btn
            this._ccBtn && this._ccBtn.removeEventListener('click', this._onClosedCaptionBtnClick, false);

            // Settings btn
            this._settingsBtn && this._settingsBtn.removeEventListener('click', this._onSettingsBtnClick, false);

            // Fullscreen.
            if (this._canFullscreen && this._fullscreenBtn) {
                this._fullscreenBtn.removeEventListener('touchend', this._onFullscreenBtnClick, true);
                this._fullscreenBtn.removeEventListener('click', this._onFullscreenBtnClick, false);
            }
        },

        /**
         * set up a skin stylesheet tag in the page.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _addStylesheetToDom: function () {
            var cb = this._setStyleSheet.bind(this, this._waitForControls.bind(this, this._finalizeSkin));
            uvpjs.util.createStyleSheet(cb, this._cssPath);
        },

        /**
         * Loop through controls of this instance and make sure they are on the DOM.
         * @private
         * @memberof uvpjs.SkinManager#
         * @returns {Boolean}
         */
        _haveControlsLoaded: function () {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, '_haveControlsLoaded.');
                uvpjs.log(this.DEBUG_ID, 'controlsLoaded: control list: ', this._controlList);
            }

            var loaded = true;

            for (var control in this._controlList) {
                if (!this._checkControlOnDOM(this._controlList[control])) {
                    loaded = false;
                }
            }

            return loaded;
        },

        /**
         * create an interval to check if list of controls are all on the DOM before allowing the skin to finalize.
         *
         * TODO: Timer needs to be reconsidered and cleared correctly.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         * @param {String} callback function string to return to.
         */
        _waitForControls: function (callback) {

            this.debug && uvpjs.log(this.DEBUG_ID, '_waitForControls.');

            // Create an interval timer check to see if all controls and skin
            // style sheets are loaded.
            var timeout = setTimeout(function () {
                if (++this._waitCount > 100) {
                    return;
                }

                if (this._haveControlsLoaded()) {
                    callback.call(this);
                    return;
                }

                this._waitForControls(callback);
            }.bind(this), 50);
        },

        /**
         * Clear mouse interval.
         * @param {String} elementName
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _clearMouseMoveInterval: function (elementName) {
            var active = this._getClassName(elementName, this.ACTIVE_MODIFIER);

            // Leave is there's no active interval.
            if (!this._intervals || this._intervals[active] === -1) {
                return;
            }

            clearInterval(this._intervals[active]);
            this._intervals[active] = -1;
        },

        /**
         * Clear all intervals.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _clearIntervals: function () {
            var obj = this._intervals, i;

            for (i in obj) {
                if (obj[i] !== -1) {
                    clearInterval(obj[i]);
                    obj[i] = -1;
                }
            }
        },


        //
        // DOM setup.
        // --------------------------------------------------


        /**
         * Add elements to the DOM.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _setupDom: function () {
            var css = this.css;

            this.debug && uvpjs.log(this.DEBUG_ID, 'creating skin controls', this._containerId);

            // Make sure the primary containers have the appropriate classnames.
            _addClass(this._containerEl, this.PRIMARY_BLOCK);
            _addClass(this._contentEl, this._getClassName(css.CONTENT));
            _addClass(this._controlsEl, this._getClassName(css.CONTROLS));

            // Add theme data attribute.
            this.debug && uvpjs.log(this.DEBUG_ID, '_themeName', this._themeName);
            this._setDataAttribute(this._containerEl, 'theme', this._themeName);

            // Ads are optional, so only add if necessary.
            if (this._adEl) {
                _addClass(this._adEl, this._getClassName(css.AD));

            }

            this._hide(css.CONTROLS);
            this._setupControlsContainer();

            this._createAdLearnMoreButton();
            this._addBufferingIndicator();

            // Set initial states.
            this._hide(css.BUFFERING_FRAME);
            this._hide(css.LARGE_PLAY_BTN);
            this._hide(css.CONTROL_BAR);
            this._hide(css.PROGRESS);
            this._hide(css.VOLUME_SLIDER);
            this._hide(css.AD_LEARNMORE);
            this._show(css.CONTROLS);
            this._hide(css.BUFFERING_FRAME);
            this._hide(css.SETTINGS_MENU);

            // Will show if preview image added below.
            this._hide(css.PREVIEW_BTN);
            this._hide(css.REPLAY_BTN);

            if (this._autoPlay !== true) {
                this._setupPreview();
            }
        },

        /**
         * After skin is on DOM, need to position, bind events, and finalize controls state.
         * @private
         * @memberof uvpjs.SkinManager#
         * @returns {Undefined}
         */
        _finalizeSkin: function () {
            this._disableControls();
            this._disableInactiveButtons();

            this._addUVPJSEventListeners();
            this._addUIEventListeners();
            this._determineBreakpoint();


            if (this.mc.isMobile()) {
                // VTG-147/154 - 'isMobile' is the correct semantic here, or is there a better one?
                this._addModifier(this.PRIMARY_BLOCK, this.MOBILE_MODIFIER);
            }

            // Signal that the skin is ready with calling callback.
            this._skinReadyCB();

            setTimeout(this._showContainers.bind(this), this.INITIAL_DOM_SETUP_WAIT);
        },

        /**
         * Hide main elements.
         *
         * Prevent blip of unstyled elements while loading and applying CSS.
         * The visibility is reset in the _finalizeSkin method.
         *
         * @private
         *
         * @memberof uvpjs.SkinManager#
         */
        _hideContainers: function () {
            this._containerEl.style.visibility = 'hidden';
            this._contentEl.style.visibility = 'hidden';
            this._videoEl.style.visibility = 'hidden';
            this._controlsEl.style.visibility = 'hidden';
        },

        /**
         * Show main elements.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _showContainers: function () {
            this._containerEl.style.visibility = 'visible';
            this._contentEl.style.visibility = 'visible';
            this._videoEl.style.visibility = 'visible';
            this._controlsEl.style.visibility = 'visible';
        },

        /**
         * Append an item to the control list.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _appendControlList: function (className) {
            this._controlList[this.ID_SELECTOR_PREFIX + this._controlsId + ' ' + this.CLASS_SELECTOR_PREFIX + className] = className;
        },

        /**
         * Add the control bar elements from the controlbar object.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _setupControlsContainer: function () {
            var elements = [
                { el: 'PREVIEW_BTN', type: 'button', label: 'Start video' },
                { el: 'REPLAY_BTN', type: 'button', label: 'Replay video' },
                { el: 'LARGE_PLAY_BTN', type: 'button', label: 'Large play-pause toggle' },
                { el: 'CONTROL_BAR', type: 'div', children: [
                    { el: 'PLAYSTATE_BTN', type: 'button', label: 'Play pause' },
                    { el: 'TIME', type: 'div', children: [
                        { el: 'TIME_CURRENT', type: 'span', text: this.NULL_TIME },
                        { el: 'TIME_DURATION', type: 'span', text: this.NULL_TIME },
                        { el: 'TIME_LIVE', type: 'span', text: 'Live' }
                    ]},
                    { el: 'CLOSED_CAPTION_BTN', type: 'button', label: 'Closed captions' },
                    { el: 'SETTINGS_BTN', type: 'button', label: 'Settings' },
                    { el: 'VOLUME_BTN', type: 'button', label: 'Volume' },
                    { el: 'FULLSCREEN_BTN', type: 'button', label: 'Fullscreen' }
                ]},
                { el: 'PROGRESS', type: 'div', children: [
                    { el: 'PROGRESS_SLIDER', type: 'range', value: 0, step: .0001 },
                    { el: 'PROGRESS_LOADED', type: 'progress', value: 0, step: .0001 },
                ]},
                { el: 'VOLUME_SLIDER', type: 'range', value: 1, step: .05 },
                { el: 'SETTINGS_MENU', type: 'div', children: [] },
            ];

            this._controlsEl.innerHTML = this._templateToHTML(elements);
        },

        /**
         * Dynamically add the settings menu items on click.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Array} items - Array of items.
         * @param {String} path - Link path.
         */
        _generateSettingsMenu: function (items, path) {
            var menu = this._queryByElementName(this.css.SETTINGS_MENU),
                menuItemClass = this._getClassName(this.css.SETTINGS_MENU_ITEM),
                selected = _.assign({}, this._menuSelections, this._getCaptionsStyle()),
                range = document.createRange(),
                u = uvpjs.util,
                elements = [],
                trapTaps = this.shouldTrapTaps(),
                menuItem, menuInput, parent, target, name, item, el, i, n;

            // Create array of menu elements.
            // NOTE: Order matters so we need to loop forward.
            n = items && items.length;
            for (i = 0; i < n; i++) {
                item = items[i];
                name = item.name;
                target = path;

                if (name) {
                    target = u.isDefinedString(path) && [path, name].join(':') || name;
                }

                elements.push(getElement(item, target));
            }

            // Create a back button.
            if (path) {
                parent = this._findMenuItem(path);
                target = path.split(':').slice(0, -1).join(':');
                el = getElement(parent, target);
                el.cls = menuItemClass + '--back';
                elements.unshift(el);
            }

            // Remove previous elements.
            range.selectNodeContents(menu);
            range.deleteContents();

            // Create menu items.
            menu.insertAdjacentHTML('beforeend', this._templateToHTML(elements));

            // Get menu elements.
            menuItem = this._queryAllByElementName(this.css.SETTINGS_MENU_ITEM);
            menuInput = this._queryAllByElementName(this.css.SETTINGS_MENU_INPUT);

            // Add event listeners to menu items.
            // NOTE: will not be added in duplicate, per addEventListener spec
            i = menuItem && menuItem.length;
            while (i--) {
                !trapTaps && menuItem[i].addEventListener('click', this._onSettingsMenuBtnClick);
            }

            // Add event listeners to menu inputs.
            // NOTE: will not be added in duplicate, per addEventListener spec
            i = menuInput && menuInput.length;
            while (i--) {
                !trapTaps && menuInput[i].addEventListener('click', this._onSettingsMenuInputClick);
            }

            // Determine if the menu item being created is selected
            function isSelected(o) {
                var val = o.value,
                    prop = o.property,
                    sel = prop && selected[prop];

                return !!((sel && sel.toLowerCase()) === (val && val.toLowerCase()));
            }

            // Create the element object to be rendered as a DOM element.
            function getElement(item, target) {
                var obj = {};

                if (item.enabled === false) {
                    return;
                }

                // Lowest menu items with submenus.
                if (item.value === undefined) {
                    obj.el = 'SETTINGS_MENU_ITEM';
                    obj.type = 'button';
                    obj.label = item.label;
                    obj.target = target;
                }
                // Selectable menu items.
                else {
                    obj.el = 'SETTINGS_MENU_INPUT';
                    obj.type = 'menu';
                    obj.label = item.label || item.value;
                    obj.value = item.value;
                    obj.property = target && _.last(target.split(':'));
                    obj.selected = isSelected(obj);
                }

                return obj;
            }
        },

        /**
         * Remove menu event listeners
         * @memberof uvpjs.SkinManager#
         * @private
         */
        _removeMenuEventListeners: function () {
            var menuItem = this._queryAllByElementName(this.css.SETTINGS_MENU_ITEM),
                menuInput = this._queryAllByElementName(this.css.SETTINGS_MENU_INPUT),
                i;

            i = menuItem && menuItem.length;
            while (i--) {
                menuItem[i].removeEventListener('click', this._onSettingsMenuBtnClick);
            }

            i = menuInput && menuInput.length;
            while (i--) {
                menuInput[i].removeEventListener('click', this._onSettingsMenuInputClick);
            }
        },

        /**
         * Find an item in the setting menu.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} target - Colon delimited string.
         * @returns {Object} Menu item.
         */
        _findMenuItem: function (target) {
            var menu = {items: this.settingsMenu};

            // Link is back to the root menu.
            if (_.isEmpty(target)) {
                return menu;
            }

            var self = this,
                path = target.split(':');

            _(path).each(function (key) {
                if (self.debug) {
                    uvpjs.log(self.DEBUG_ID, '_findMenuItem key', key);
                }
                menu = _.find(menu.items, function (o) {
                    return o.name === key
                });
            });

            return menu;
        },

        /**
         * Create the Google IMA custom click tracking element last.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _createAdLearnMoreButton: function () {
            var adLearnMore = document.createElement('button');

            adLearnMore.id = uvpjs.domConstants.AD_LEARNMORE_ID_PREFIX + this.ID_SELECTOR_PREFIX + this._containerId;
            adLearnMore.className = this._getClassName(this.css.AD_LEARNMORE);
            adLearnMore.innerHTML = this.AD_LEARNMORE_TEXT;
            adLearnMore.setAttribute('aria-label', this.AD_LEARNMORE_TEXT);

            this._controlsEl.appendChild(adLearnMore);
        },

        /**
         * Add the preview image.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _setupPreview: function () {
            var u = uvpjs.util,
                cls = this.css.PREVIEW_BTN,
                img = this._previewImage,
                btn = this._queryByElementName(cls);

            uvpjs.log(this.DEBUG_ID, '_setupPreview', img);

            if (u.isDefinedString(img)) {
                btn.style.backgroundImage = "url('" + img + "')";
            }

            this._show(cls);
        },

        /**
         * Setup replay screen.
         *
         * @private
         *
         * @memberof uvpjs.SkinManager#
         */
        _setupReplay: function () {
            var u = uvpjs.util,
                css = this.css,
                cls = css.REPLAY_BTN,
                img = this._previewImage,
                btn = this._queryByElementName(cls);

            this.debug && uvpjs.log(this.DEBUG_ID, '_setupReplay');

            if (u.isDefinedString(img)) {
                btn.style.backgroundImage = "url('" + img + "')";
            }

            this._hide(css.LARGE_PLAY_BTN);
            this._hide(css.PREVIEW_BTN);
            this._hide(css.BUFFERING_FRAME);
            this._show(css.CONTROLS);
            this._hide(css.CONTROL_BAR);
            this._hide(css.PROGRESS);
            this._show(cls);

            this._disableControls();

            this._replayCB = this.vci.replayVideo.bind(this.vci);

        },

        /**
         * Add the buffering indicator. This creates the element and adds it to the control bar.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _addBufferingIndicator: function () {
            var className = this._getClassName(this.css.BUFFERING_FRAME);

            // Spinner options.
            // See more: http://fgnass.github.io/spin.js/
            var opts = {
                lines: 7 // The number of lines to draw
                , length: 0 // The length of each line
                , width: 12 // The line thickness
                , radius: 9 // The radius of the inner circle
                , scale: 1 // Scales overall size of the spinner
                , corners: 1 // Corner roundness (0..1)
                , color: '#ecf0f1' // #rgb or #rrggbb or array of colors
                , opacity: 0 // Opacity of the lines
                , rotate: 0 // The rotation offset
                , direction: 1 // 1: clockwise, -1: counterclockwise
                , speed: 1.2 // Rounds per second
                , trail: 95 // Afterglow percentage
                , fps: 30 // Frames per second when using setTimeout() as a fallback for CSS
                , zIndex: 2e9 // The z-index (defaults to 2000000000)
                , className: className // The CSS class to assign to the spinner
                , top: '50%' // Top position relative to parent
                , left: '50%' // Left position relative to parent
                , shadow: false // Whether to render a shadow
                , hwaccel: false // Whether to use hardware acceleration
                , position: 'absolute' // Element positioning
            };

            // Attach spinner to element.
            new Spinner(opts).spin(this._controlsEl);
        },

        /**
         * Disabled closed captioning and setting buttons.
         * @todo Some of these are temporary until these features are built out.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _disableInactiveButtons: function () {
            this._disableCaptions();

            if (!this.mc.supportsMute()) {
                this._disableButton(this.css.VOLUME_BTN);
            }
        },

        // UVPJS events.
        // --------------------------------------------------
        /**
         * On ad start.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onAdStart: function (data) {
            var css = this.css;

            if (this._containerId !== data.target) return;

            this.currVolumeInfo = {
                muted: this.vci.getPlayerMuted(),
                volume: this._videoEl.volume
            };

            this.debug && uvpjs.log(this.DEBUG_ID, '_onAdStart');

            this.mc.supportsMute() && this._enableButton(css.VOLUME_BTN);

            this._disableButton(css.SETTINGS_BTN);
            this._disableButton(css.CLOSED_CAPTION_BTN);
            this._disableProgress();
            this._addModifier(this.PRIMARY_BLOCK, this.AD_MODIFIER);

            if (data.payload.adData.isCustomClickTrackingUsed) {
                this._show(css.AD_LEARNMORE);
                this._addModifier(this.PRIMARY_BLOCK, css.AD_LEARNMORE);
                return;
            }

            this._disable(css.LARGE_PLAY_BTN);
        },

        /**
         * On ad end.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onAdEnd: function (data) {
            if (this._containerId !== data.target) return;

            this.debug && uvpjs.log(this.DEBUG_ID, '_onAdEnd', this._containerId, data.target);

            this._removeModifier(this.PRIMARY_BLOCK, this.AD_MODIFIER);
            this._enable(this.css.LARGE_PLAY_BTN);
            this._hide(this.css.AD_LEARNMORE);

            this._isWaitingForFirstTouch = false;

            this._resetProgressSlider();
        },

        /**
         * On captions ready.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onCaptionsReady: function (data) {

            this.debug && uvpjs.log(this.DEBUG_ID, '_onCaptionsReady', data);

            if (this._containerId !== data.target) {
                return;
            }

            this._enableCaptions();
        },

        /**
         * On captions unavailable.
         * @memberof uvpjs.SkinManager
         * @param {Object} data - Event data object.
         * @returns {Undefined}
         */
        _onCaptionsUnavailable: function (data) {

            this.debug && uvpjs.log(this.DEBUG_ID, '_onCaptionsUnavailable', data);

            if (this._containerId !== data.target) {
                return;
            }

            this._disableCaptions();
        },

        /**
         * On content start.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onContentStart: function (data) {
            var css = this.css;

            this.debug && uvpjs.log(this.DEBUG_ID, '_onContentStart', data);

            if (this._containerId !== data.target) {
                return;
            }

            this._isWaitingForFirstTouch = false;

            this.currVolumeInfo = {
                muted: this.vci.getPlayerMuted(),
                volume: this._videoEl.volume
            };

            this.debug && uvpjs.log(this.DEBUG_ID, '_onContentStart this._captionsLoaded', this._captionsLoaded);

            this._enableProgress();
            this._enableSettingsBtn();

            this.mc.supportsMute() && this._enableButton(css.VOLUME_BTN);

            // These buttons get disabled during ads so we enable them here.
            if (this._captionsLoaded) {
                this._enableButton(css.CLOSED_CAPTION_BTN);
            }

            // For safe measure, in case of an ad error.
            if (this._hasAd()) {
                this._removeModifier(this.PRIMARY_BLOCK, this.AD_MODIFIER);
                this._enable(css.LARGE_PLAY_BTN);
                this._hide(css.AD_LEARNMORE);
            }

            if (this._isLive()) {
                this._setDataAttribute(this._containerEl, 'stream', this.LIVE_MODIFIER);
            }
            else if (this._isStreaming()) {
                this._addModifier(this.PRIMARY_BLOCK, this.STREAMING_MODIFIER);
            }
        },

        /**
         * On content end.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onContentEnd: function (data) {

            this.debug && uvpjs.log(this.DEBUG_ID, '_onContentEnd');

            if (this._containerId !== data.target) {
                return;
            }

            this._removeDataAttribute(this._containerEl, 'stream');
            this._removeModifier(this.PRIMARY_BLOCK, this.STREAMING_MODIFIER);

            this._resetProgressSlider();
        },

        /**
         * Fired when the volume mute / unmute event is sent out from facade.
         * @todo This is only implemented for ads right now.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onControlMuteUnmute: function (data) {
            var muted = (data.type === 'controlMute');

            if (this._containerId !== data.target) return;

            this._updateVolumeUI(this._volumeSlider.value, muted);
        },

        /**
         * DIAGNOSTIC_WINDOW_CLOSE_BUTTON event handler.
         *
         * @param {Object} evtObj - Event data object.
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _onDiagCloseButton: function (evtObj) {
            if (this._containerId !== evtObj.target) return;

            uvpjs.log(this.DEBUG_ID, '_onDiagCloseButton', evtObj);

            this._menuSelections.debug = null;
        },

        /**
         * RESOURCE_START event callback.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onResourceStart: function (data) {
            var target = data && data.target;

            if (target !== this._containerId) return;

            uvpjs.log(this.DEBUG_ID, '_onResourceStart', data);

            this.durationChecked = false;

            // Now allow touch events.
            this._previewCallbackDone = true;

            this._show(this.css.CONTROLS);
        },

        /**
         * RESOURCE_END event callback.
         *
         * @param {Object} evtObj  Event data object.
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _onResourceEnd: function (evtObj) {
            var target = evtObj.target,
                payload = evtObj.payload,
                playlistEmpty = payload.playlistLength === 0;

            if (this._containerId !== target) {
                return;
            }

            uvpjs.log(this.DEBUG_ID, '_onResourceEnd', evtObj);

            this._hide(this.css.CONTROLS);

            if (this._enableReplay && playlistEmpty) {
                this._setupReplay();
            }
            else {
                this._captionsLoaded = false;
            }

            this._resetProgressSlider();
        },

        /**
         * Video Progress Event callback.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onVideoProgress: function (data) {
            var payload = data.payload,
                newState = payload.playbackState,
                volume = this.vci.getVolume(),
                td = this.css.TIME_DURATION,
                tc = this.css.TIME_CURRENT,
                bumpWidth = false,
                duration, time;

            if (this._containerId !== data.target) {
                return;
            }

            // REMOVE? Not sure the purpose of this. -Andi 5/18/17
            if (volume !== Number(this._volumeSlider.value)) {
                this._updateVolumeUI(volume);
            }

            if (newState !== this._playbackState) {
                this._playbackState = newState;
                this._updatePlaybackStateUI(this._playbackState);
            }

            this._updateProgressLoad(payload);

            // Don't update progress bar position or time display while sliding.
            if (newState === this.mc.PLAYING && !this._isSliding) {

                if (payload.duration !== Infinity) {
                    duration = this._queryByElementName(td);
                    time = this._queryByElementName(tc);

                    if (!this._isLive() && !this.durationChecked) {
                        this.durationChecked = true;
                        payload.duration >= 3600 && (bumpWidth = true);
                    }
                    else if (this._isLive() && !this.durationChecked) {
                        payload.duration >= 3600  && (this.durationChecked = bumpWidth = true);
                    }

                    bumpWidth && (time.parentNode.style.width = '100px');

                    duration.innerHTML = this._formatTimestampByType(td, payload.duration);
                    time.innerHTML = this._formatTimestampByType(tc, payload.currentTime);

                    this._updateProgressUI(payload);
                }
            }

            this.isMonitoringMuting && this.checkMute();
        },

        /**
         * On video media is downloading event.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onVideoLoading: function (data) {
            // uvpjs.log(this.DEBUG_ID, '_onVideoLoading', data);

            if (!_.has(data, 'target') || this._containerId !== data.target) {
                return;
            }

            if (!_.isObject(data) || !_.has(data, 'payload.data')) {
                return;
            }

            this._updateProgressLoad(data.payload.data);
        },

        /**
         * VIDEO_STATE_CHANGE Event callback
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - Event data object.
         */
        _onVideoStateChange: function (data) {

            this.debug && uvpjs.log(this.DEBUG_ID, '_onVideoStateChange', data);

            if (!_.isObject(data) || this._containerId !== data.target) return;

            if (!_.isObject(data.payload) || !_.isNumber(parseInt(data.payload.newState))) {
                return;
            }

            var newState = data.payload.newState;

            if (newState !== this._playbackState) {
                this._playbackState = newState;
                this._updatePlaybackStateUI(this._playbackState);
            }

            if (newState === this.mc.PAUSED && this.isMonitoringMuting) {
                this.monitorMuting(null, true, true);
            }
            else if (this.isMonitoringMuting) {
                this.monitorMuting(null, true, false);
            }
        },

        /**
         * @private
         * @param flag
         */
        monitorMuting: function (flag, clearTimer, setTimer) {
            flag !== null && (this.isMonitoringMuting = flag);

            if (clearTimer) clearInterval(this.muteMonitorIntervalId);

            if (setTimer) {
                this.muteMonitorIntervalId = setInterval(this.checkMute.bind(this), 300);
            }
        },

        checkMute: function () {
            var vmute = this._videoEl.muted;

            if (vmute === this.currVolumeInfo.muted) return;

            this.currVolumeInfo.muted = vmute;

            vmute ? this.vci.mute() : this.vci.unMute();
        },

        //
        // Bound UI events.
        // --------------------------------------------------

        /**
         * Broker event handling for DOM elements.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Event} e
         */
        _onUVPJSGestureEvent: function (e) {
            var isClickOrTouch = false;

            switch (e.type) {
                case 'mouseenter':
                    this._onUVPJSMouseEnter(e);
                    break;

                case 'mouseleave':
                    this._onUVPJSMouseLeave(e);
                    break;

                case 'mousemove':
                    this._onUVPJSMouseMove(e);
                    break;

                case 'mousedown':
                    this._onUVPJSMouseDown(e);
                    break;

                case 'mouseup':
                    this._onUVPJSMouseUp(e);
                    break;

                case 'click':
                    this._showControlBar(e);
                    isClickOrTouch = true;
                    break;

                case 'touchstart':
                    this._onUVPJSTouchStart(e);
                    break;

                case 'touchend':
                    this._onUVPJSTouchEnd(e);
                    isClickOrTouch = true;
                    break;
            }

            if (!this._hasFirstTouch && isClickOrTouch) {
                this._hasFirstTouch = true;
                this.vci.handleFirstGesture(this._getTargetInfo(e));
            }
        },

        /**
         * Returns minimal info for the first gesture event
         * @private
         */
        _getTargetInfo: function(e) {
            var tgt = e.target,
                isVol = tgt.className.indexOf(this.css.VOLUME_BTN) !== -1,
                isPlay = tgt.className.indexOf(this.css.PLAYSTATE_BTN) !== -1;

            return {
                isVolumeButton: isVol,
                isPlayPauseToggle: isPlay
            }
        },


        /**
         * Broker event handling for progress bar
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Event} e
         */
        _onProgressSliderEvent: function (e) {

            switch (e.type) {
                case 'input':
                case 'change':
                    this._onProgressSliderChange(e);
                    break;

                case 'touchstart':
                case 'mousedown':
                    this._onProgressSliderStart(e);
                    break;

                case 'touchend':
                case 'mouseup':
                    this._onProgressSliderEnd(e);
                    break;

                default:
                    break;
            }
        },

        /**
         * Broker event handling for volume slider
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Event} e
         */
        _onVolumeSliderEvent: function (e) {

            switch (e.type) {
                case 'input':
                case 'change':
                    this._onVolumeSliderChange(e);
                    break;

                case 'mouseover':
                    this._showVolumeSlider(e);
                    break;

                case 'mouseout':
                    this._hideVolumeSlider(e);
                    break;

                default:
                    break;
            }
        },

        /**
         * Broker event handling for volume button
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Event} e
         */
        _onVolumeBtnEvent: function (e) {

            switch (e.type) {
                case 'click':
                case 'touchend':
                    this._onVolumeBtnClick(e);
                    break;

                case 'mouseover':
                    this._showVolumeSlider(e);
                    break;

                case 'mouseout':
                    this._hideVolumeSlider(e);
                    break;

                default:
                    break;
            }
        },

        /**
         * When mouse enters UVPJS.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _onUVPJSMouseEnter: function (e) {

            e.stopPropagation();

            if (this._containerEl !== e.target) {
                return;
            }

            if (this._hasPaused()) {
                return;
            }

            this._showControlBar(e);
        },

        /**
         * Tracks the mouse down action and check if it's intended for UVPJS.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onUVPJSMouseDown: function (e) {
            e.stopPropagation();

            if (this._hasAd()) {
                return;
            }

            this._addModifier(this.PRIMARY_BLOCK, this.ACTIVE_MODIFIER);
            this._isMouseActive = true;

        },

        /**
         * Touch start.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onUVPJSTouchStart: function (e) {
            var ps = this.vci.getCurrentPlaybackState().playbackState,
                value;

            this.debug && uvpjs.log(this.DEBUG_ID, '_onUVPJSTouchStart');

            this._touchStartTime = e.timeStamp;

            // Special case for loading blank video on mobile.
            if (!this._previewCallbackDone) {
                this.debug && uvpjs.log(this.DEBUG_ID,'Ignoring touchstart; preview callback not executed yet.');
                return;
            }

            // Don't show if controls are disabled.
            if (this._hasDisabled(this.css.CONTROLS)) {
                return;
            }

            if (ps === this.mc.EMPTY) {
                return;
            }

            this._isTouchActive = this._hasModifier(this.PRIMARY_BLOCK, this.TOUCH_MODIFIER);

            // Handle touch events on the progress slider.
            //  - Not sure layerX is a browser standard touch property.
            //  - If click is on the thumb, don't update slider position.
            if (e.target === this._progressSlider) {
                value = 1 - ((e.target.clientWidth - e.layerX) / e.target.clientWidth);
                this._onProgressSliderChange(e, value);
            }
        },

        /**
         * Touch end.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onUVPJSTouchEnd: function (e) {
            var css = this.css,
                isTap = this._isTap(e.timeStamp),
                names = [
                    css.CLOSED_CAPTION_BTN,
                    css.VOLUME_BTN,
                    css.PLAYSTATE_BTN,
                    css.SETTINGS_BTN,
                    css.SETTINGS_MENU,
                    css.SETTINGS_MENU_ITEM,
                    css.SETTINGS_MENU_INPUT,
                    css.LARGE_PLAY_BTN,
                    // any controls added here that are under 'trapTap' control
                    // must be added above, those excluded should be added below
                    css.FULLSCREEN_BTN
                ],
                i = names.length,
                className = e.target.className,
                timeoutId, controlBtn, preventClick, delay;

            // Don't show if controls are disabled.
            if (this._hasDisabled(css.CONTROLS)) {
                return;
            }

            // Check if target of touch is a control button .
            while (i--) {
                controlBtn = controlBtn || className.indexOf(names[i]) > -1;
                if (controlBtn) break;
            }

            if (this.shouldTrapTaps() && controlBtn && i < (names.length - 1)) {
                e.stopPropagation();
                e.preventDefault();
                this.handleTap(names[i], e);

                return;
            }

            preventClick = !controlBtn && (!this._isTouchActive || !isTap);
            preventClick && e.preventDefault();
            preventClick && this._addModifier(this.PRIMARY_BLOCK, this.TOUCH_MODIFIER);

            delay = (timeoutId || preventClick) ? this.HIDE_DELAY : 0;

            timeoutId && clearTimeout(timeoutId);
            timeoutId = setTimeout(cleanup.bind(this), delay);

            function cleanup () {
                if (this._hasPaused()) {
                    return;
                }

                timeoutId = null;
                this._removeModifier(this.PRIMARY_BLOCK, this.TOUCH_MODIFIER);
            }
        },

        /**
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String}
         * @param {Event}
         */
        handleTap: function(name, e) {
            var c = this.css;

            switch (name) {
                case c.CLOSED_CAPTION_BTN:
                    this._onClosedCaptionBtnClick(e);
                    break;

                case c.VOLUME_BTN:
                    this._onVolumeBtnEvent(e);
                    break;

                case c.PLAYSTATE_BTN:
                case c.LARGE_PLAY_BTN:
                    this._onPlayToggle(e);
                    break;

                case c.SETTINGS_BTN:
                    this._onSettingsBtnClick(e);
                    break;

                case c.SETTINGS_MENU_ITEM:
                    this._onSettingsMenuBtnClick(e);
                    break;

                case c.SETTINGS_MENU_INPUT:
                    this._onSettingsMenuInputClick(e);
                    break;
            }
        },

        /**
         * @private
         * @memberof uvpjs.SkinManager#
         */
        shouldTrapTaps: function() {
            return this._isIOS;
        },

        /**
         * When the mouse click is released.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onUVPJSMouseUp: function (e) {
            e.stopPropagation();

            this._removeModifier(this.PRIMARY_BLOCK, this.ACTIVE_MODIFIER);
            this._isMouseActive = false;
        },

        /**
         * When mouse moves around UVPJS.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _onUVPJSMouseMove: function (e) {
            var active = this._getClassName(this.PRIMARY_BLOCK, this.ACTIVE_MODIFIER);

            if (this._intervals[active] !== -1) {
                return;
            }

            if (this._hasHidden(this.css.CONTROL_BAR)) {
                this._showControlBar();
            }

            this._addModifier(this.PRIMARY_BLOCK, this.ACTIVE_MODIFIER);
            this._intervals[active] = setInterval(this._onUVPJSMouseMoveStop.bind(this, this.PRIMARY_BLOCK), this.HIDE_DELAY);
        },

        /**
         * When mouse stops moving around UVPJS.
         * @param {String} elementName
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _onUVPJSMouseMoveStop: function (elementName) {
            if (this._isMouseActive) {
                return;
            }

            this._clearMouseMoveInterval(elementName)
            this._removeModifier(elementName, this.ACTIVE_MODIFIER);
            this._hideControlBar();
        },

        /**
         * When mouse leaves UVPJS.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _onUVPJSMouseLeave: function (e) {
            e.stopPropagation();

            if (this._containerEl !== e.target) {
                return;
            }

            if (this._hasPaused()) {
                return;
            }

            if (this._hasHidden(this.css.CONTROL_BAR)) {
                return;
            }

            this._hideControlBar();
        },

        /**
         * Mouse over the control bar.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onControlBarMouseOver: function (e) {
            e.stopPropagation();
            this._addModifier(this.css.CONTROL_BAR, this.ACTIVE_MODIFIER);
        },

        /**
         * Mouse out of the control bar.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onControlBarMouseOut: function (e) {
            e.stopPropagation();
            this._removeModifier(this.css.CONTROL_BAR, this.ACTIVE_MODIFIER);
        },

        /**
         * When the outer container resizes.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _onUVPJSResize: function (evtObj) {
            if (evtObj.target !== this._containerId)  return;

            this._determineBreakpoint();
        },

        /**
         * Determine breakpoint classes to add.
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _determineBreakpoint: function () {
            var width = this._containerEl.offsetWidth;

            if (width >= this.SIZE_XS_BREAKPOINT) {
                this._addModifier(this.PRIMARY_BLOCK, this.SIZE_XS_MODIFIER);
            }
            if (width >= this.SIZE_SM_BREAKPOINT) {
                this._addModifier(this.PRIMARY_BLOCK, this.SIZE_SM_MODIFIER);
            }
            if (width >= this.SIZE_MD_BREAKPOINT) {
                this._addModifier(this.PRIMARY_BLOCK, this.SIZE_MD_MODIFIER);
            }
            if (width >= this.SIZE_LG_BREAKPOINT) {
                this._addModifier(this.PRIMARY_BLOCK, this.SIZE_LG_MODIFIER);
            }
            if (width < this.SIZE_XS_BREAKPOINT) {
                this._removeModifier(this.PRIMARY_BLOCK, this.SIZE_XS_MODIFIER);
            }
            if (width < this.SIZE_SM_BREAKPOINT) {
                this._removeModifier(this.PRIMARY_BLOCK, this.SIZE_SM_MODIFIER);
            }
            if (width < this.SIZE_MD_BREAKPOINT) {
                this._removeModifier(this.PRIMARY_BLOCK, this.SIZE_MD_MODIFIER);
            }
            if (width < this.SIZE_LG_BREAKPOINT) {
                this._removeModifier(this.PRIMARY_BLOCK, this.SIZE_LG_MODIFIER);
            }
        },

        /**
         * When the volume button is clicked.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onVolumeBtnClick: function (e) {
            var vci = this.vci,
                muted = vci.getPlayerMuted();

            if (this._hasDisabled(this.css.VOLUME_BTN)) return;

            muted ? this.vci.unMute() : this.vci.mute();
        },

        /**
         * Mouse click or drag of the volume slider.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onVolumeSliderChange: function (e) {
            var volume = parseFloat(e.target.value),
                muted = this.vci.getPlayerMuted();

            // Unmute first if silder dragged but player muted.
            if (muted && volume > 0) {
                this.vci.unMute();
            }

            this.vci.setVolume(volume);
            this._updateVolumeUI(volume, muted);
        },

        /**
         * toggle in and out of fullscreen mode
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _onFullscreenBtnClick: function (e) {
            e.stopPropagation();

            this._hideVolumeSlider();

            if (this.fullscreenMgr.isFullscreen()) {
                this.fullscreenMgr.exitFullscreen();
            }
            else {
                this.fullscreenMgr.enterFullscreen();
            }
        },

        /**
         * Play toggle button.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onPlayToggle: function (e) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onPlayToggle this.vci.vidContId = ', this.vci.vidContId);

            e.stopPropagation();
            e.preventDefault();

            var ps = this.vci.getCurrentPlaybackState().playbackState;

            this.debug && uvpjs.log(this.DEBUG_ID, '_onPlayToggle playbackState = ', ps);

            if (ps === this.mc.PAUSED ||
                ps === this.mc.EMPTY ||
                ps === this.mc.LOADING) {
                this.vci.playVideo();
                return;
            }

            // Don't pause on initial load.
            if (ps === this.mc.BUFFERING) {
                return;
            }

            this._addModifier(this.PRIMARY_BLOCK, this.PAUSED_MODIFIER);
            this.vci.pauseVideo();
        },

        /**
         * Execute the preview callback function.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onPreviewBtn: function (e) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onPreviewBtn');

            if (this._isTouch && !this._isTap(e.timeStamp)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'Long touch detected; not executing preview-button callback.');
                return;
            }

            e.stopPropagation();

            this.vci.onPreviewButton(this._skinReadyCB.bind(this));
        },

        _hNonTap: function() {
            this._touchStartTime = null;
        },

        /**
         * Execute the replay button callback function.
         *
         * @param {Object} e - event object
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _onReplayBtn: function (e) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onReplayBtn');

            e.stopPropagation();

            this._hide(this.css.REPLAY_BTN);
            this._show(this.css.BUFFERING_FRAME);

            this._replayCB && this._replayCB();
        },

        /**
         * Setup fullscreen button listener
         *
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _listenToFullscreenBtn: function () {
            if (!this._canFullscreen) {
                return;
            }

            this._fullscreenBtn.addEventListener('touchend', this._onFullscreenBtnClick.bind(this), true);
            !this._isTouch && this._fullscreenBtn.addEventListener('click', this._onFullscreenBtnClick.bind(this), false);

        },

        /**
         * On closed caption button click.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onClosedCaptionBtnClick: function (e) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onClosedCaptionBtnClick');

            e.stopPropagation();

            var cls = this.css.CLOSED_CAPTION_BTN,
                isActive = this._hasActive(cls);

            if (isActive) {
                this._removeModifier(this.css.CLOSED_CAPTION_BTN, this.ACTIVE_MODIFIER);
                this.vci.hideCaptions();
                return;
            }

            this._addModifier(this.css.CLOSED_CAPTION_BTN, this.ACTIVE_MODIFIER);
            this.vci.showCaptions();
            this._setCCPosition();
        },

        /**
         * On settings button click.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onSettingsBtnClick: function (e) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onSettingsBtnClick');
            e.stopPropagation();

            var cls = this.css.SETTINGS_MENU,
                isHidden = this._hasHidden(cls);

            uvpjs.log(this.DEBUG_ID, '_onSettingsBtnClick isHidden', isHidden);

            if (isHidden) {
                this._addModifier(cls, this.ACTIVE_MODIFIER);
                this._generateSettingsMenu(this.settingsMenu);
                this._show(cls);
                return;
            }

            this._removeModifier(cls, this.ACTIVE_MODIFIER);
            this._hide(cls);
        },

        /**
         * On settings menu item button click.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onSettingsMenuBtnClick: function (e) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onSettingsMenuBtnClick', e);

            var target = e.target.getAttribute('data-target');
            this.debug && uvpjs.log(this.DEBUG_ID, '_onSettingsMenuBtnClick target', target);

            e.target.parentNode.setAttribute('data-target', target);

            var currentMenu = this._findMenuItem(target);
            this._generateSettingsMenu(currentMenu.items, target);
        },

        /**
         * On settings menu input change.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onSettingsMenuInputClick: function (e) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onSettingsMenuInputClick', e);

            var el = e.target,
                parent = el.parentNode,
                target = parent.getAttribute('data-target'),
                menu = target && target.split(':')[0];

            switch (menu) {
                case 'cc':
                    this._onSettingsCaptionsChange(e);
                    break;

                case 'controls':
                    this._onSettingsControlsChange(e);
                    break;

                case 'debug':
                    this._onSettingsDiagWindowChange(e);
                    break;
            }
        },

        /**
         * On settings captions menu input change.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onSettingsCaptionsChange: function (e) {
            var el = e.target,
                parent = el.parentNode,
                property = el.getAttribute('data-property'),
                value = el.getAttribute('data-value').toLowerCase();

            this.debug && uvpjs.log(this.DEBUG_ID, '_onSettingsCaptionsChange property, value', property, value);

            // De-select all items.
            _(parent.children).each(function (node) {
                node.setAttribute('data-selected', 'false');
            }.bind(this));

            // Set the clicked button as selected.
            el.setAttribute('data-selected', 'true');

            // Special case for positioning to determine float.
            if (property === 'text-position') {
                this._setCCPosition(value);
                return;
            }

            this.vci.setCaptionsStyleProperty(property, value);
        },

        /**
         * On settings controls menu input change.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - event object
         */
        _onSettingsControlsChange: function (e) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onSettingsControlsChange', e);

            var el = e.target,
                property = el.getAttribute('data-property'),
                value = el.getAttribute('data-value').toLowerCase();

            var selector = '#' + this._containerId + ' ';

            // Special case to handle background opacity.
            if (property === 'background-opacity') {
                property = 'background-color';

                var controlBar = this._queryByElementName(this.css.CONTROL_BAR),
                    bgColor = getComputedStyle(controlBar).getPropertyValue(property);

                // If not rgba, return for now.
                // TODO: Add support for colors and hex values.
                if (bgColor.indexOf('rgba') === -1) {
                    return;
                }

                // Construct new color.
                value = bgColor.split(',').slice(0, -1).join(',') + ', ' + value + ')';

                if (this.debug) {
                    uvpjs.log(this.DEBUG_ID, '_onSettingsControlsChange value', value);
                }

                selector += this._getClassName(this.css.CONTROL_BAR);
            }

            this._addCSSRule(selector, property, value);
        },

        /**
         * On settings diagnostic window click.
         *
         * @param {Object} e - event object
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _onSettingsDiagWindowChange: function (e) {
            var el = e.target,
                prop = el.getAttribute('data-property'),
                value = el.getAttribute('data-value'),
                selected = el.getAttribute('data-selected') === 'true',
                newState = !selected; // Toggle checkmark

            this.debug && uvpjs.log(this.DEBUG_ID, '_onSettingsDiagWindowChange', e);

            this._menuSelections[prop] = value;

            el.setAttribute('data-selected', newState);

            if (newState) {
                this.vci.showDiagnosticWindow();
            } else {
                this.vci.hideDiagnosticWindow();
            }
        },


        //
        // UI changes.
        // --------------------------------------------------

        /**
         * Set multiple CSS properties.
         * @param {Array} props - CSS properties.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _setCaptionsStyle: function (props) {

            if (!this._captionsLoaded) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_setCaptionsStyle', props);
            this.vci.setCaptionsStyle(props);
        },

        /**
         * Set a single CSS property.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} name - CSS property name.
         * @param {String} value - CSS property value.
         */
        _setCaptionsStyleProperty: function (name, value) {

            if (!this._captionsLoaded) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_setCaptionsStyleProperty', name, value);

            this.vci.setCaptionsStyleProperty(name, value);
        },

        /**
         * Change property of all closed captioning cues.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} key - Property key name.
         * @param {String} value - Property value.
         */
        _setCueProperty: function (key, value) {

            if (!this._captionsLoaded) {
                return;
            }

            var tracks = this._videoEl.textTracks;

            if (!tracks) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, '_setCueProperty', key, value);

            this.vci.setCaptionsCueProperty(key, value);
        },

        /**
         * Adjusts the vertical position of captions when the control bar
         * changes from hidden to showing and vice versa.
         *
         * @param {String} value Position (optional).
         *
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _setCCPosition: function (value) {
            var prop = 'text-position';

            if (!this._captionsLoaded) {
                return;
            }

            value = value || this._getCaptionsStyle()[prop];

            this.debug && uvpjs.log(this.DEBUG_ID, '_setCCPosition prop, value', prop, value);

            this.vci.setCaptionsStyleProperty(prop, value);
        },

        /**
         * Show the control bar.
         * @private
         * @memberof uvpjs.SkinManager#
         * @param {Object} e - Event object.
         */
        _showControlBar: function (e) {
            var ps = this.vci.getCurrentPlaybackState().playbackState,
                css = this.css;

            if (!this._hasHidden(this.css.CONTROL_BAR) || this._hasDisabled(this.css.CONTROLS)) {
                return;
            }

            // this.debug && uvpjs.log(this.DEBUG_ID, '_showControlBar');

            // Don't show the control bar when the video is empty.
            if (ps === this.mc.EMPTY) {
                return;
            }

            // Cancel any requests to hide the control bar.
            if (!_.isUndefined(this._hideControlBar.hide)) {
                this._hideControlBar.hide.cancel();
            }

            this._removeModifier(this.PRIMARY_BLOCK, [css.CONTROL_BAR, this.HIDDEN_MODIFIER]);
            this._show(css.CONTROL_BAR);
            this._show(css.PROGRESS);
        },

        /**
         * Hide the control bar menu.
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _hideMenu: function (e) {

            // Exit if the settings menu is not showing.
            if (this._hasHidden(this.css.SETTINGS_MENU)) {
                return;
            }

            // Exit if the item clicked was a menu item.
            if (e.target.className.indexOf(this._getClassName(this.css.SETTINGS_MENU)) > -1) {
                return;
            }

            this._hide(this.css.SETTINGS_MENU);
        },

        /**
         * Hide the control bar and volume bar.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Number} delay - Optiona delay before hiding.
         */
        _hideControlBar: function (delay) {
            if (this._hasHidden(this.css.CONTROL_BAR) || this._hasDisabled(this.css.CONTROLS)) {
                return;
            }

            // uvpjs.log(this.DEBUG_ID, '_hideControlBar');

            // VTG-347 - icky poo!
            this._hideControlBar.hide = _.debounce(function () {
                if (this._hasActive(this.PRIMARY_BLOCK)
                    || this._hasActive(this.css.PROGRESS)
                    || this._hasActive(this.css.PROGRESS_SLIDER)
                    || this._hasActive(this.css.VOLUME_SLIDER)
                    || this._hasActive(this.css.CONTROL_BAR)
                    || !this._hasHidden(this.css.SETTINGS_MENU)
                    || this._hasPaused()
                    || this._isTouch) {
                    this._hideControlBar.hide.cancel();
                    return;
                }

                this._addModifier(this.PRIMARY_BLOCK, [this.css.CONTROL_BAR, this.HIDDEN_MODIFIER]);

                this._hideVolumeSlider();
                this._hide(this.css.CONTROL_BAR);
                this._hide(this.css.PROGRESS);


            }, delay || this.HIDE_DELAY);

            this._hideControlBar.hide.cancel();
            this._hideControlBar.hide.call(this);
        },

        /**
         * Show the volume bar when hovering over volume button or bar.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         *
         */
        _showVolumeSlider: function (e) {
            var css = this.css, vol;

            // Don't show if the volume button is disabled.
            if (this._hasDisabled(css.VOLUME_BTN)) {
                return;
            }

            // Don't show if controls are disabled.
            if (this._hasDisabled(css.CONTROLS)) {
                return;
            }

            // Don't show if the settings menu is up.
            if (this._hasActive(css.SETTINGS_MENU)) {
                this._hide(css.SETTINGS_MENU);
            }

            this._setDataAttribute(this._containerEl, css.VOLUME_SLIDER, true);
            this._addModifier(css.VOLUME_SLIDER, this.ACTIVE_MODIFIER);
            this._show(css.VOLUME_SLIDER);


            if (this.mc.isFirefox() || this.mc.isEdge()) {
                // hacky - fix firefox/edge here.
                // real issue- use of rotated range control
                vol = this._controlsEl.querySelector('.uvpjs__volume-slider');
                vol && vol.setAttribute('style', 'bottom: 62px');
            }
        },

        /**
         * Hide the volume bar.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         *
         * @returns {Undefined}
         */
        _hideVolumeSlider: function (e) {

            // Don't hide the volume bar while the mouse click is down.
            if (this._isMouseActive) {
                return;
            }

            this._removeDataAttribute(this._containerEl, this.css.VOLUME_SLIDER);
            this._removeModifier(this.css.VOLUME_SLIDER, this.ACTIVE_MODIFIER);
            this._hide(this.css.VOLUME_SLIDER);
        },

        /**
         * Disable controls.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _disableControls: function () {
            this._disable(this.css.CONTROLS);
        },

        /**
         * Enable controls.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _enableControls: function () {
            this._enable(this.css.CONTROLS);
        },

        /**
         * Disable progress bar.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _disableProgress: function () {
            this._disable(this.css.PROGRESS);
        },

        /**
         * Enable progress bar.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _enableProgress: function () {
            this._enable(this.css.PROGRESS);
        },

        /**
         * Enable closed captions button and styles.
         * @memberof uvpjs.SkinManager
         * @returns {Undefined}
         */
        _enableCaptions: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, '_enableCaptions');

            this._captionsLoaded = true;

            this._enableMenuItem('cc');
            this.enableButton(this.css.CLOSED_CAPTION_BTN);

            if (this._hasModifier(this.css.CLOSED_CAPTION_BTN, this.ACTIVE_MODIFIER)) {
                this.vci.showCaptions();
            }
        },

        /**
         * Disable closed captions button and styles.
         * @memberof uvpjs.SkinManager
         * @returns {Undefined}
         */
        _disableCaptions: function () {
            this._captionsLoaded = false;
            this._disableButton(this.css.SETTINGS_BTN);
            this._disableButton(this.css.CLOSED_CAPTION_BTN);
        },

        /**
         * Enable progress bar.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _enableSettingsBtn: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, '_enableSettingsBtn');

            var menuEnabled = _.some(this.settingsMenu, 'enabled');

            if (!menuEnabled) {
                return;
            }

            this._enableButton(this.css.SETTINGS_BTN);
        },


        //
        // Volume slider.
        // --------------------------------------------------

        /**
         * Decides if the volume bar displays the muted or non-muted icon and
         * adjusts the volume slider height.
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Number} volume New volume level.
         * @param {Boolean} isMute Is muted or not.
         */
        _updateVolumeUI: function (volume, isMute) {
            var u = uvpjs.util,
                el = this._containerEl,
                muted = this.vci.getPlayerMuted(),
                level;

            // Set data-volume attribute (e.g. data-volume="medium")
            if (muted === true) {
                level = 'mute';
            } else if (volume > .85) {
                level = 'full';
            } else if (u.inRange(volume, .5, .85)) {
                level = 'high';
            } else if (u.inRange(volume, .15, .5)) {
                level = 'medium';
            } else if (u.inRange(volume, 0, .15)) {
                level = 'low';
            }

            this._volumeSlider.value = volume || this._videoEl.volume;
            this._setDataAttribute(el, 'volume-level', level);
            this._updateSliderUI(this._volumeSlider, this.css.VOLUME_SLIDER, volume);
        },

        //
        // Progress bar.
        // --------------------------------------------------


        /**
         * When the progress input is changed.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         * @param {Object} value - Optional click value.
         */
        _onProgressSliderChange: function (e, value) {
            var vs = this.vci.getContentVideoData(),
                ps = this.vci.getCurrentPlaybackState(),
                tc = this.css.TIME_CURRENT,
                currentTime = this._queryByElementName(tc),
                clickPercent = value || this._progressSlider.value,
                seekTo, delta;

            // this.debug && uvpjs.log(this.DEBUG_ID, '_onProgressSliderChange');

            // Make sure the progress bar has the correct bounds.
            clickPercent = (clickPercent > 1) ? 1 : (clickPercent < 0) ? 0 : clickPercent;

            seekTo = Math.ceil((clickPercent * vs.duration) * 10000) / 10000;
            delta = Math.abs((ps.currentTime - seekTo) / seekTo);

            this._updateProgressSlider(clickPercent);

            // Update current time while seeking.
            currentTime.innerHTML = this._formatTimestampByType(tc, seekTo);

            // Don't scrub.
            if (this._hasActive(this.css.PROGRESS_SLIDER)) {
                return;
            }

            // Establish a 2% tolerance to avoid circular updates and UI jitter.
            if (delta <= 0.02) {
                return;
            }

            this.vci.seekTo(seekTo);
        },

        /**
         * Mouse over the progress slider.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onProgressMouseOver: function (e) {
            e.stopPropagation();
            this._addModifier(this.css.PROGRESS, this.ACTIVE_MODIFIER);
        },

        /**
         * Mouse out of the progress slider.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} e - Event object.
         */
        _onProgressMouseOut: function (e) {
            e.stopPropagation();
            this._removeModifier(this.css.PROGRESS, this.ACTIVE_MODIFIER);
        },

        /**
         * When the mouse or touch is initiated.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _onProgressSliderStart: function (e) {
            var css = this.css;

            if (this._hasAd() || this._hasDisabled(css.PROGRESS)) {
                e.stopPropagation();
                e.preventDefault();
                return;
            }

            this._addModifier(css.PROGRESS_SLIDER, this.ACTIVE_MODIFIER);
            this._isSliding = true;
        },

        /**
         * When the mouse or touch is finished.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         */
        _onProgressSliderEnd: function (e) {
            if (this._hasAd() || this._hasDisabled(this.css.PROGRESS)) {
                e.stopPropagation();
                e.preventDefault();
                return;
            }

            this._removeModifier(this.css.PROGRESS_SLIDER, this.ACTIVE_MODIFIER);
            this._isSliding = false;

            // We're not scrubbing, so only seek on mouse release. We need to
            // call one final time.
            this._onProgressSliderChange(e);
        },

        /**
         * Reset progress slider state.
         *
         * @private
         *
         * @memberof uvpjs.SkinManager#
         */
        _resetProgressSlider: function () {
            if (!this._updateProgressSlider) {
                return;
            }

            this._updateProgressSlider(0);
        },

        /**
         * Update the progress download bar.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - pass in this.vci.getCurrentPlaybackState() object
         */
        _updateProgressLoad: function (data) {
            var newWidth, progressLoad;

            // uvpjs.log(this.DEBUG_ID, '_updateProgressLoad', data.bufferLength);

            if (this._isLive()) {
                return;
            }

            newWidth = Math.ceil(((data.bufferLength) / data.duration) * 10000) / 10000;

            if (_.isNaN(newWidth) || newWidth === Infinity || newWidth <= 0) {
                return;
            }

            // Get downloaded percentage.
            this._downloaded = newWidth;

            // Don't update when ads are playing.
            if (this._hasAd()) {
                return;
            }

            progressLoad = this._queryByElementName(this.css.PROGRESS_LOADED);
            progressLoad.value = this._downloaded;
        },

        /**
         * handle the different playback states, allows for changing visual skin state when needed.
         * @private
         * @memberof uvpjs.SkinManager#
         * @param {Number} newState - the new playback state.
         * @returns {Undefined}
         */
        _updatePlaybackStateUI: function (newState) {
            var css = this.css;

            this.debug && uvpjs.log(this.DEBUG_ID, '_updatePlaybackStateUI newState = ', newState);

            switch (newState) {
                case this.mc.PLAYING:
                    this._show(css.CONTROLS);
                    this._enableControls();

                    // Show control bar for touch devices.
                    if (this._isTouch) {
                        this._showControlBar();
                    }

                    this._hide(css.LARGE_PLAY_BTN);
                    this._hide(css.PREVIEW_BTN);
                    this._hide(css.REPLAY_BTN);
                    this._hide(css.BUFFERING_FRAME);
                    this._removeModifier(this.PRIMARY_BLOCK, this.PAUSED_MODIFIER);
                    break;

                case this.mc.PAUSED:
                    this._show(css.CONTROLS);
                    this._showControlBar();
                    this._hide(css.BUFFERING_FRAME);
                    this._addModifier(this.PRIMARY_BLOCK, this.PAUSED_MODIFIER);
                    this._show(css.LARGE_PLAY_BTN);
                    break;

                case this.mc.STOPPED:
                    this._hide(css.CONTROLS);
                    break;

                case this.mc.BUFFERING:
                    this._show(css.CONTROLS);
                    this._hide(css.PREVIEW_BTN);
                    this._hide(css.REPLAY_BTN);
                    this._hide(css.LARGE_PLAY_BTN);
                    this._show(css.BUFFERING_FRAME);
                    break;

                case this.mc.LOADING:
                    this._show(css.CONTROLS);
                    this._hide(css.PREVIEW_BTN);
                    this._hide(css.REPLAY_BTN);
                    this._hide(css.LARGE_PLAY_BTN);
                    this._show(css.BUFFERING_FRAME);
                    break;
            }
        },

        /**
         * update the progress current time bar
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Object} data - pass in this.vci.getCurrentPlaybackState() object
         */
        _updateProgressUI: function (data) {
            var value = Math.ceil((data.currentTime / data.duration) * 10000) / 10000;

            this._updateProgressSlider(value);
        },

        /**
         * Normalize slider update behavior.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {HTMLElement} el - DOM element.
         * @param {String} elementName - Element name.
         * @param {Number} value - The value to determine the background-size between 0 and 1.
         */
        _updateSliderUI: function (el, elementName, value) {
            var self = this,
                slider = {};

            if (_.isUndefined(this._vendorPrefix) || _.isUndefined(el)) {
                return;
            }

            // this.debug && uvpjs.log(this.DEBUG_ID, '_updateSliderUI', slider);

            slider.id = '#' + this._containerId;
            slider.cls = self._getClass(elementName);
            slider.pseudo = {
                'moz': '::-moz-range-track',
                'webkit': '::-webkit-slider-runnable-track'
            }[self._vendorPrefix];

            // Handle special MS Edge browser built on webkit but not fully supported.
            if (this._isMSEdge) {
                slider.pseudo = '';
            }

            slider.add = function (size, before, after) {

                // No pseudo for IE.
                if (_.isUndefined(this.pseudo)) {
                    return;
                }

                var selector = this.id + (before || '') + ' ' + this.cls + (after || '') + this.pseudo;
                self._addCSSRule(selector, 'background-size', (size * 100) + '% 100%');
            };
            slider.before = function (size, modifier) {
                var cls = self._getClass(self.PRIMARY_BLOCK);

                // Add modifier for specificity (e.g. .uvpjs.uvpjs--ad).
                if (modifier) {
                    cls += self._getClass(self.PRIMARY_BLOCK, modifier);
                }

                this.add(size, cls, null);
            };
            slider.after = function (size, cls) {
                this.add(size, null, cls);
            };

            //** Volume slider update.
            if (elementName === self.css.VOLUME_SLIDER) {
                slider.add(value);
                return;
            }

            //** Progress slider update.
            var width = value * el.offsetWidth,
                thumb = (.5 - value) * el.offsetHeight,
                bar = width / el.offsetWidth,
                both = (width + thumb) / el.offsetWidth; // 50% of the thumb diameter.

            el.value = value;

            var isAd = self._hasAd();

            // Make the selector more specific during ads.
            slider.before(bar, isAd ? self.AD_MODIFIER : null);

            // Account for hover state.
            if (!isAd) {
                slider.after(both, ':hover');
            }

            // Account for the gap created by the slider thumb.
            if (this._isTouch) {
                slider.before(both, self.TOUCH_MODIFIER);
            }
        },

        //
        // DOM.
        // --------------------------------------------------


        /**
         * check an individual control element to see if it's on the DOM yet
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} className - the value of the control class name
         * @returns {Boolean} A true/false depending on if a control is now on the DOM.
         */
        _checkControlOnDOM: function (className) {
            var selector = (
                    this.ID_SELECTOR_PREFIX +
                    this._controlsId + ' ' +
                    this.CLASS_SELECTOR_PREFIX +
                    className
                );

            return !!this._controlCache[selector];
        },

        /**
         * Get CSS class name.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @param {String} modifierName - Modifier name.
         * @returns {String}
         */
        _getClassName: function (elementName, modifierName) {
            var className = this.PRIMARY_BLOCK;

            if (elementName !== this.PRIMARY_BLOCK) {
                className += this.BLOCK_ELEMENT_DELIMITER + elementName;
            }

            if (modifierName) {
                className += this.ELEMENT_MODIFIER_DELIMITER + modifierName;
            }

            return className;
        },

        /**
         * Get full CSS class name.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @param {String} modifierName - Modifier name.
         * @returns {String}
         */
        _getClass: function (elementName, modifierName) {
            return this.CLASS_SELECTOR_PREFIX + this._getClassName(elementName, modifierName);
        },

        /**
         * Returns the DOM element based on a full element class name.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} className - Class name.
         * @returns {Object} DOM element.
         */
        _queryByClassName: function (className) {
            var selector, control;

            if (!this._containerId) {
                return;
            }

            selector = this.ID_SELECTOR_PREFIX + this._containerId;

            // If the selector is not the main container.
            if (className !== this.PRIMARY_BLOCK) {
                selector += ' ' + this.CLASS_SELECTOR_PREFIX + className;
            }

            control = this._controlCache[selector] || document.querySelector(selector);

            if (control) {
                this._controlCache[selector] = control;
            }

            return control;
        },

        /**
         * Returns array of DOM elements based on a full element class name.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} className - Class name.
         * @returns {Array} Array of DOM elements.
         */
        _queryAllByClassName: function (className) {
            var selector = this.ID_SELECTOR_PREFIX + this._containerId;

            // If the selector is not the main container.
            if (className !== this.PRIMARY_BLOCK) {
                selector += ' ' + this.CLASS_SELECTOR_PREFIX + className;
            }

            return document.querySelectorAll(selector);
        },

        /**
         * Returns the DOM element based on the element name (this.css.<elementName>)
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @returns {Object} DOM element.
         */
        _queryByElementName: function (elementName) {
            return this._queryByClassName(this._getClassName(elementName));
        },

        /**
         * Returns all DOM elements based on the element name (this.css.<elementName>)
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @returns {Array} Array of DOM element objects.
         */
        _queryAllByElementName: function (elementName) {
            return this._queryAllByClassName(this._getClassName(elementName));
        },

        /**
         * Show an element.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         */
        _show: function (elementName) {
            this._removeModifier(elementName, this.HIDDEN_MODIFIER);
        },

        /**
         * Hide an element.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         */
        _hide: function (elementName) {
            this._addModifier(elementName, this.HIDDEN_MODIFIER);
        },

        /**
         * Enable an element.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         */
        _enable: function (elementName) {
            this._removeModifier(elementName, this.DISABLED_MODIFIER);
        },

        /**
         * Disable an element.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         */
        _disable: function (elementName) {
            this._addModifier(elementName, this.DISABLED_MODIFIER);
        },

        /**
         * Enable a menu item.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} path - Menu item path, colon delimited.
         */
        _enableMenuItem: function (path) {
            var item;

            if (!path) {
                return;
            }

            item = this._findMenuItem(path);
            item && (item.enabled = true);
        },


        //
        // Helpers.
        // --------------------------------------------------


        /**
         * Whether an element is displaying or not.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @returns {Boolean}
         */
        _hasHidden: function (elementName) {
            return this._hasModifier(elementName, this.HIDDEN_MODIFIER);
        },

        /**
         * Check for the active modifier.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @returns {Boolean}
         */
        _hasActive: function (elementName) {
            return this._hasModifier(elementName, this.ACTIVE_MODIFIER);
        },

        /**
         * Check for an ad modifier.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _hasAd: function () {
            return this._hasModifier(this.PRIMARY_BLOCK, this.AD_MODIFIER);
        },

        /**
         * Check for the hidden modifier.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @returns {Boolean}
         */
        _hasDisabled: function (elementName) {
            return this._hasModifier(elementName, this.DISABLED_MODIFIER);
        },

        /**
         * Check for the paused modifier.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _hasPaused: function () {
            return this._hasModifier(this.PRIMARY_BLOCK, this.PAUSED_MODIFIER);
        },

        /**
         * Check if playback state is live.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _isLive: function () {
            var vs = this.vci.getContentVideoData();
            return vs.isLive && this._isStreaming();
        },

        /**
         * Check if playback state is playing.
         *
         * // TODO unused?
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _isPlaying: function () {
            var vs = this.vci.getContentVideoData();
            return vs.deliveryType && vs.deliveryType === this.mc.PLAYING;
        },

        /**
         * Check if playback state is streaming.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Boolean}
         */
        _isStreaming: function () {
            var vs = this.vci.getContentVideoData();
            return vs.deliveryType && vs.deliveryType === this.mc.STREAMING;
        },

        /**
         * Add class name modifier.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @param {String|Array} modifierName - Modifier name(s).
         *
         * @returns {Boolean}
         */
        _hasModifier: function (elementName, modifierName) {

            if (_.isArray(modifierName)) {
                modifierName = modifierName.join(this.MODIFIER_DELIMETER);
            }

            var className = this._getClassName(elementName, modifierName),
                el = this._queryByElementName(elementName);

            if (!el) {
                return false;
            }

            return _hasClass(el, className);
        },

        /**
         * Add class name modifier.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @param {String|Array} modifierName - Modifier name(s).
         */
        _addModifier: function (elementName, modifierName) {

            if (_.isArray(modifierName)) {
                modifierName = modifierName.join(this.MODIFIER_DELIMETER);
            }

            var className = this._getClassName(elementName, modifierName),
                el = this._queryByElementName(elementName);

            if (!el) {
                return;
            }

            _addClass(el, className);
        },

        /**
         * Remove class name modifier.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @param {String|Array} modifierName - Modifier name(s).
         */
        _removeModifier: function (elementName, modifierName) {
            var el = this._queryByElementName(elementName),
                className;

            if (_.isArray(modifierName)) {
                modifierName = modifierName.join(this.MODIFIER_DELIMETER);
            }

            className = this._getClassName(elementName, modifierName);

            if (!el) {
                return;
            }

            _removeClass(el, className);
        },

        /**
         * Toggle class name modifier.
         *
         * // TODO - VTG-347 - Unused ?
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} elementName - Element name.
         * @param {String|Array} modifierName - Modifier name(s).
         */
        _toggleModifier: function (elementName, modifierName) {

            if (_.isArray(modifierName)) {
                modifierName = modifierName.join(this.MODIFIER_DELIMETER);
            }

            var className = this._getClassName(elementName, modifierName),
                el = this._queryByElementName(elementName);

            if (!el) {
                return;
            }

            _toggleClass(el, className);
        },

        /**
         * Add data attribute to element.
         *
         * @param {HTMLElement} el
         * @param {String} attr Data attribute name.
         * @param {String} value Data attribute value.
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _setDataAttribute: function (el, attr, value) {
            el.setAttribute('data-' + attr, value);
        },

        /**
         * Remove data attribute to element.
         *
         * @param {HTMLElement} el
         * @param {String} attr Data attribute name.
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _removeDataAttribute: function (el, attr) {
            el.removeAttribute('data-' + attr);
        },

        /**
         * formats seconds to a timestamp 00:00
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Number} seconds - seconds to convert to timestamp string
         *
         * @returns {String} returns a properly formatted video player timestamp 00:00
         */
        _formatTimestamp: function (seconds) {
            var date, iso;

            if (uvpjs.util.isEmpty(seconds) || seconds === Infinity) return this.NULL_TIME;
            if (isNaN(seconds)) seconds = 0;

            date = new Date(null);
            date.setSeconds(Math.round(seconds));

            iso = date.toISOString();

            return seconds >= 3600 ? iso.substr(11, 8) : iso.substr(14, 5);
        },

        /**
         * formats time for current time, duration, or other timestamp from seconds.
         * marks when a duration is a live stream, unknown time, etc.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {String} type - type of timestamp; currently current or duration time (type as a string).
         * @param {Number} seconds - seconds to convert to timestamp string
         *
         * @returns {String} returns a properly formatted video player timestamp 00:00
         */
        _formatTimestampByType: function (type, seconds) {

            if (typeof seconds === 'undefined' || seconds < 0) {

                if (type === this.css.TIME_DURATION) {
                    return this.NULL_TIME;
                }

                if (type === this.css.TIME_CURRENT) {
                    return this.NULL_TIME;
                }
            }

            return this._formatTimestamp(seconds);
        },

        /**
         * Dynamically insert CSS style onto the page.
         *
         * @param {String} selector - CSS selector.
         * @param {String} name - CSS rule name
         * @param {String} value - CSS rule value.
         *
         * @memberof uvpjs.SkinManager#
         *
         * @private
         */
        _addCSSRule: function (selector, name, value) {

            var sheet = this._styleEl.sheet,
                ruleCount = sheet.cssRules.length;

            // Update rule if it exists.
            if (!_.isUndefined(this._cssRules[selector])) {
                var rules = sheet.rules || sheet.cssRules;

                if (rules.length > 0) {
                    rules[this._cssRules[selector]].style[name] = value;
                    return;
                }
            }

            // If it's a new rule, add it the object so we can track the
            // selector and update it on future calls.
            this._cssRules[selector] = ruleCount;

            uvpjs.util.addCSSRule(this._styleEl, selector, name, value)
        },

        /**
         * Creates the stylesheet for progress and volume slider updates.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Function} callback - Callback function when stylesheet is added to the DOM.
         */
        _setStyleSheet: function (callback) {
            var cbDone = false;

            this.debug && uvpjs.log(this.DEBUG_ID, '_setStyleSheet', this.styleSheet);

            if (this._styleEl) {
                return;
            }

            uvpjs.util.createStyleSheet(function (styleEl) {
                this._styleEl = styleEl;

                // VTG-282: This seems confusing; may be better handled in util method.
                if (!cbDone && typeof callback === 'function') {
                    this.debug && uvpjs.log(this.DEBUG_ID, '_setStyleSheet executing callback.');
                    cbDone = true;
                    callback();
                }

            }.bind(this));
        },

        /**
         * Creates HTML elements using Lodash the template method.
         *
         * @private
         * @memberof uvpjs.SkinManager#
         *
         * @param {Array} elements - Array of objects.
         *
         * @returns {String}
         */
        _templateToHTML: function (elements) {

            if (!_.isArray(elements) || _.isEmpty(elements)) {
                return;
            }

            var cls = function (name) {
                return this._getClassName(this.css[name]);
            }.bind(this);

            var tmpl = {
                'button': '<button class="${ o.cls }" data-target="${ o.target }" aria-label="${ o.label }">${ o.label }</button>\n',
                'div': '<div class="${ o.cls }">${ o.children }</div>\n',
                'span': '<span class="${ o.cls }">${ o.text }</span>\n',
                'menu': '<button class="${ o.cls }" data-property="${ o.property }" data-value="${ o.value }" data-selected="${ o.selected }">${ o.label }</button>\n',
                'range': '<input type="range" value="${ o.value }" min="0" max="1" step="${ o.step }" class="${ o.cls }" />\n',
                'progress': '<progress class="${ o.cls }" value="${ o.value }" max="1" step="${ o.step }"></progress>\n',
            };

            var self = this;

            function create(data) {
                var html = '';

                _(data).each(function (o) {
                    if (!o) {
                        return;
                    }
                    o.cls = _.isUndefined(o.cls) ? cls(o.el) : [o.cls, cls(o.el)].join(' ');
                    if (o.children) {
                        o.children = create(o.children);
                    }
                    // uvpjs.log(self.DEBUG_ID, '_templateToHTML create', o);
                    html += _.template(tmpl[o.type], {variable: 'o'})(o);
                });

                return html;
            }

            return create(elements);
        },

        /**
         * Returns captions style object.
         *
         * @private
         *
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Object}
         */
        _getCaptionsStyle: function () {
            return this.vci.getCaptionsStyle()
        },

        /**
         * Returns whether touch event is short enough to be considered a tap.
         *
         * @param {Number} endTs The touchend timestamp
         *
         * @private
         *
         * @memberof uvpjs.SkinManager#
         *
         * @returns {Object}
         */
        _isTap: function (endTs) {
            if (!this._touchStartTime) return false;

            return (endTs - this._touchStartTime) < this.TAP_THRESHOLD;
        }

    });


    //
    // Static helpers.
    // --------------------------------------------------


    /**
     * Determines if element has a CSS class.
     * @param {HTMLElement} el - DOM element.
     * @param {String} className - Class name.
     * @returns {Boolean}
     */
    _hasClass = function (el, className) {
        return !_.isNull(el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)')));
    };

    /**
     * Add a class to a DOM element.
     * @param {HTMLElement} el - DOM element.
     * @param {String} className - Class name.
     * @returns {Undefined}
     */
    _addClass = function (el, className) {
        if (_hasClass(el, className)) {
            return;
        }

        el.className = (el.className += ' ' + className).trim();
    };

    /**
     * Removes a class from a DOM element.
     * @param {HTMLElement} el - DOM element.
     * @param {String} className - Class name.
     * @returns {Undefined}
     */
    _removeClass = function (el, className) {
        el.className = el.className.replace(new RegExp('(\\s|^)' + className + '(\\s|$)'), ' ').trim();
    };

    /**
     * Toggles a class on a DOM element.
     * @param {HTMLElement} el - DOM element.
     * @param {String} className - Class name.
     * @returns {Undefined}
     */
    _toggleClass = function (el, className) {
        if (_hasClass(el, className)) {
            _removeClass(el, className);
            return;
        }

        _addClass(el, className);
    };

}(uvpjs.register('uvpjs')));

/**
 * Created by ldoyle on 3/13/16.
 */
'use strict';

(function (obj) {

    var _ = obj._;

    obj.AdPlaylistManager = uvpjs.Class.subClass({

        DEBUG_ID: uvpjs.DebugManager.configParams.RESOURCE_PROVIDER,
        PRE: 'pre',
        MID: 'mid',
        MID_: 'mid_',
        POST: 'post',

        /**
         * IMA Resource Provider helper class. Creates, updates, exposes and destroys Ad Pod Information Objects (APOs). <br>
         *     Helps manage moving between Ads and Content. <br>
         *     Ad Pod Info Objects are created for pre-rolls, mid-rolls and post-rolls. <br>
         *
         * @constructor uvpjs.AdPlaylistManager
         */
        init: function() {
            this.debug = uvpjs.debug;
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager init');
            }
            this.vidContId = '';
            this.midRollPods = null;
            this.adPods = {};            // Object of Ad Pod Objects indexed by the Pod ID
        },

        /**
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @param {String} vidContId - Video Container ID.
         * @param {Array} adStartTimes - Mid-roll chapter times.
         * @param {Array} imaCuePoints - Mid-roll chapter times with 0 indicating a pre-roll pod and -1 indicating a post-roll pod
         *  An empty array indicates the ad or ad pod has no schedule and can be played at any time.
         * @param {String} adCallURL - The ad call url string.
         */
        initialize: function(vidContId, adStartTimes, imaCuePoints, adCallURL) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager initialize vidContId    = ', vidContId);
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager initialize adStartTimes = ', adStartTimes);
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager initialize imaCuePoints = ', imaCuePoints);
            }

            if (!_.isArray(adStartTimes)) {
                if (this.debug) {
                    uvpjs.warn('AdPlaylistManager initialize  !_.isArray(adStartTimes) RETURN');
                }
                return;
            }

            // TODO - Validate adStartTimes VS. imaCuePoints midroll start times.
            this.vidContId = vidContId;
            this._generateAdPods(adStartTimes, imaCuePoints, adCallURL);

        },

        /**
         * Creates and returns the ad Playlist.
         *
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @param {Array} adStartTimes - Mid-roll chapter times.
         * @param {Array} imaCuePoints - IMA pre, post and mid-roll chapter times with 0 indicating a pre-roll pod and -1 indicating a post-roll pod.
         * @param {Array} adCallURL - The IMA ad call url.
         */
        _generateAdPods: function(adStartTimes, imaCuePoints, adCallURL) {
            var n = imaCuePoints.length,
                i, podIndex, imaCuePoint,
                getPodObj = function(id, u, st) {
                    return {
                        hasBeenChecked: false,
                        startTime: st || 0,
                        hasPlayed: false,
                        adPodId: id,
                        adCount: 0,
                        podDuration: 0,
                        adCallURL: u
                    }
                };

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager _generateAdPods adStartTimes = ', adStartTimes);
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager _generateAdPods imaCuePoints = ', imaCuePoints);
            }

            this.adPods = {};

            if (n > 0){
                if (imaCuePoints.indexOf(0) > -1){
                    this.adPods[this.PRE] = getPodObj(this.PRE + '_0', adCallURL)
                }

                if (imaCuePoints.indexOf(-1) > -1){
                    this.adPods[this.POST] = getPodObj(this.POST + '_0', adCallURL);
                }
            }

            for (i = 0; i < n; i++) {
                podIndex = imaCuePoints[0] === 0 ? i : i + 1;
                imaCuePoint = imaCuePoints[i];

                if (!isNaN(imaCuePoint) && imaCuePoint !== 0 && imaCuePoint !== -1) {
                    this.adPods[this.MID_ + podIndex] = getPodObj(this.MID_ + podIndex, adCallURL, imaCuePoint);
                }
            }

           this.debug && uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager _generateAdPods this.adPods = ', this.adPods);
        },

        /**
         * Ad Pod Object getter.
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @param {string} adPodId - Ad pod id, 'pre', 'mid_1', 'mid_2', ... , 'post'.
         *
         * @returns {Object} the requested ad pod or 'undefined' if the ad pod is not found.
         */
        getAdPodById: function(adPodId) {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager getAdPodById      adPodId = ', adPodId);
            }
            if (!_.isString(adPodId)){return;}
            var adPod = this.adPods[adPodId];
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager getAdPodById RETURN adPod = ', adPod);
            }
            return adPod;
        },

        /**
         * adPods object getter.
         *
         * @memberof uvpjs.AdPlaylistManager
         *
         * @returns {Object} The adPods object.
         */
        getAdPods: function () {
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager getAdPods', this.adPods);
            }
            return this.adPods;
        },

        /**
         * Returns the number of adPods in the video.
         *
         * @memberof uvpjs.AdPlaylistManager
         *
         * @returns {Integer} Length of adPods object.
         */
        getNumberOfPods: function () {
            var count = Object.keys(this.adPods).length;
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'AdPlaylistManager getNumberOfPods', count);
            }
            return count;
        },

        /**
         * Returns array of mid-roll pods
         *
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @returns {Array}
         */
        getMidRollPods: function() {
            var out = [], q;

            if (!this.midRollPods) {
                out = [];
                for (q in this.adPods) {
                    q.indexOf(this.MID) >= 0 && out.push(this.adPods[q]);
                }
                this.midRollPods = out;
            }

            return this.midRollPods;
        },

        /**
         * Determine if the current ad pod is a pre-roll.
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @param {Object} adPod - An adPlaylistManager ad pod object.
         *
         * @returns {Boolean}
         */
        isPreRoll: function(adPod) {
            if (_.isUndefined(adPod.adPodId)) {
                return false;
            } else {
                return (adPod.adPodId.indexOf(this.PRE) > -1);
            }
        },

        /**
         * Determine if the current ad pod is a mid-roll.
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @param {Object} adPod - An adPlaylistManager ad pod object.
         *
         * @returns {Boolean}
         */
        isMidRoll: function(adPod) {
            if (_.isUndefined(adPod.adPodId)) {
                return false;
            } else {
                return (adPod.adPodId.indexOf(this.MID) > -1);
            }
        },

        /**
         * Determine if the current ad pod is a post-roll.
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @param {Object} adPod - An adPlaylistManager ad pod object.
         *
         * @returns {Boolean}
         */
        isPostRoll: function(adPod) {
            if (_.isUndefined(adPod.adPodId)) {
                return false;
            } else {
                return (adPod.adPodId.indexOf(this.POST) > -1);
            }
        },

        /**
         * Determine if there are mid-roll ad pods in this.adPods.
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @returns {Boolean}
         */
        hasMidRoll: function() {
           for (var q in this.adPods) {
               if (q.indexOf(this.MID) > -1) return true;
           }

           return false;
        },

        /**
         * Determine if there is a post-roll ad pod in this.adPods.
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @returns {Boolean}
         */
        hasPostRoll: function() {
            return this.adPods.hasOwnProperty(this.POST);
        },

        /**
         * Determine if this seek event passes over an un-played ad pod.
         * @memberof uvpjs.AdPlaylistManager#
         *
         * @param {number} absSeekTime - Seek time of current seek event.
         *
         * @returns {Object} The preceding ad pod object if it hasn't played yet or an empty object.
         */
        returnPrecedingUnplayedAdPod: function(absSeekTime) {
            var rtnPod = null,
                msg = 'No eligible ad pod found.',
                adPod, hasPlayed, q;

            // loop through Ad Pods looking for one that precedes seek time
            for (q in this.adPods) {
                if (!this.adPods.hasOwnProperty(q)) { continue; }

                adPod = this.adPods[q];

                if (this.isPreRoll(adPod) || this.isPostRoll(adPod)) { continue; }

                if (adPod.startTime <= absSeekTime ) {
                    if (!rtnPod) {
                        rtnPod = adPod;
                    } else if (absSeekTime - adPod.startTime <  absSeekTime - rtnPod.startTime) {
                        rtnPod = adPod;
                    }
                }
            }

            if (rtnPod) {
                hasPlayed = rtnPod.hasPlayed ? 'has played, returning null.' : 'not yet played - returning found pod.';
                msg = 'Found Ad pod; adPodId = ' + rtnPod.adPodId + '; ' + hasPlayed
            }

            this.debug && uvpjs.log(
                this.DEBUG_ID,
                'AdPlaylistManager returnPreceedingUnplayedAdPod() for absSeekTime: ' + absSeekTime + ';  ' + msg
            );

            return rtnPod;
        }

    });

}(uvpjs.register('uvpjs')));

'use strict';

(function (obj) {

    var _ = obj._,
        _getVideoLength;

    // TODO - refactor to eliminate properties stored on callback fns

    obj.TrackingManager = uvpjs.Class.subClass({

        debug: uvpjs.DebugManager.isEnabled,

        PLAYER_NAME: uvpjs.Configuration.name + '_' + uvpjs.Configuration.version,
        PLAYER_NAME_ONLY: uvpjs.Configuration.name,
        PLAYER_VERSION_ONLY: uvpjs.Configuration.version,

        // ConfigDataObject module names.
        ADOBE_HEARTBEAT_MODULE_NAME: 'SiteCatalyst',
        COMSCORE_SS_MODULE_NAME: 'ComScore_ss',
        CONVIVA_MODULE_NAME: "ConvivaQOSPluginJS",
        DW_MODULE_NAME: 'DWTracking',
        LEGACY_DW_MODULE_NAME: 'CNetTracking',
        NIELSEN_MODULE_NAME: 'NielsenTracking_SDK',
        AKAMAI_ANALYTICS_MODULE_NAME: 'AkamaiQOSPluginJS',
        MUX_MODULE_NAME: 'MuxQOSPluginJS',
        CONCURRENCY_BEACON_MODULE_NAME: 'Beacon',

        DEFAULT_SITEID: '17', // '17' for external sites, or siteID from page, or 'CNetTracking' config module 'siteid'
        PLATFORM_CMS: 'platform',
        LUMIERE_CMS: 'lumiere',
        PI_CMS: 'pi',
        ZDNET_CMS: 'zdnet',
        CONCURRENCY_BEACON_SITE_ID: 164, // Default Site Id for Concurrency Beacons.
        CONCURRENCY_BEACON_USER_ID: -1, // Default User Id for Concurrency Beacons.

        progressEvents: {
            // Quartiles.
            FIRST_QUARTILE: 'firstQuartile',
            MID_QUARTILE: 'midQuartile',
            THIRD_QUARTILE: 'thirdQuartile',
            // Timed.
            TIMED: 'timed'
        },

        agentConfigs: [], // Array of agent config items of the format: {name: "agentName", enabled: boolean}

        beaconEndPoint: {}, // Object containing beacon production and staging end points.

        /**
         * @constructor uvpjs.TrackingManager
         *
         * @param {Object}                         options
         * @param {String}                         options.vidContId
         * @param {uvpjs.CoreVideoInstanceManager} options.cviMgr
         */
        init: function(options) {
            this.debug = uvpjs.debug;
            // OPTIMIZE?: No debug id per tracking manager?
            this.DEBUG_ID = uvpjs.DebugManager.configParams.TRACKING_MANAGER;

            this.debug && uvpjs.log(this.DEBUG_ID, 'init');

            // An associative array of event types mapped to arrays of callback methods.
            this.eventCBs = {};

            this.vidContId = null;
            this.eventsMgr = null;
            this.cviModel = null;
            this.internalNS = null;

            this._contentFirstQFired = false;
            this._contentMidFired = false;
            this._contentThirdQFired = false;
            this._contentTimeFired = {}; // An object to hold the timestamp since progress events fire 10 times per second.
            this.componentid = '';
            this._lastContentSecondCompleted = 0;

            this._contentLength = 0;
            this._adLength = 0;

            this._beaconElement = false;

            // Array of agents that require plugins.
            this.agents = [];

            this.mc = uvpjs.mediaCapabilities;

            if (options) {
                this.initialize(options.vidContId, options.cviMgr);
            }
        },

        /**
         * @memberof uvpjs.TrackingManager#
         */
        destroy: function() {
            var i = this.agents.length, eventType;

            while(i--) {
                this.agents[i] && typeof this.agents[i].destroy === "function" && this.agents[i].destroy();
                this.agents.splice(i, 1);
            }

            for (eventType in this.eventCBs) {
                this.eventsMgr.removeEventListener(eventType + this.internalNS + '.agent');
                delete this.eventsMgr[eventType];
            }

            for (eventType in this.progressEvents) {
                delete this.progressEvents[eventType];
            }

            this._removeTrackingEventListeners();

            this.eventsMgr = null;
            this.cviModel = null;
            this.mc = null;

            this.agents = null;
            this.eventCBs = null;
            this.progressEvents = null;

            this._beaconElement = null;

            this._contentFirstQFired = false;
            this._contentMidFired = false;
            this._contentThirdQFired = false;
            this._contentTimeFired = {};
            this._lastContentSecondCompleted = 0;

            this._contentLength = 0;
            this._adLength = 0;
        },

        /**
         * @param {String} vidContId - DOM ID string of the video container on the page.
         * @param {Object} cviMgr - reference to the Core Video Instance Manager.
         * @memberof uvpjs.TrackingManager#
         */
        initialize: function(vidContId, cviMgr) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'initialize');

            if (!_.isString(vidContId) || !_.isObject(cviMgr)) {
                return;
            }

            this.vidContId = vidContId;

            this.eventsMgr = cviMgr.getEventsMgr();
            this.cviModel = cviMgr.getModelRef();
            this.internalNS = '.' + this.vidContId + '.trackingMgr';
            this.componentid = this.cviModel.sessionId;

            // Create wrapper element for tracking beacons.
            this._beaconElement = document.createElement('div');
            this._beaconElement.id = 'uvpjs-tracking-' + (new Date()).getTime();
            document.getElementsByTagName('body')[0].appendChild(this._beaconElement);

            this._createAgentsArray();
            this._addTrackingEventListeners();
            this._initializeAgents();
        },

        /**
         * Checks if trackingConfigOverrides exist.
         * @param {Object} cfg - Config object
         * @memberof uvpjs.TrackingManager#
         * @returns {Boolean}
         */
        hasTrackingConfigOverrides: function(cfg) {
            return cfg !== null && cfg.hasOwnProperty("trackingConfigOverrides")
                && cfg.trackingConfigOverrides !== null;
        },

        /**
         * Retrieves one agent config from the array of agent configs.
         * Each agent config is an object of the format:
         * {name: "NielsenTracking_SDK", enabled: true}
         * @param {String} agentArray - the array of agent configs
         * @param {String} agentKey - the key of the agent object
         * @memberof uvpjs.TrackingManager#
         * @returns {Object}
         */
        getAgentConfig: function(agentArray, agentKey) {
            var config = null;
            var i = agentArray.length;

            while (i-- > 0) {
                var item = agentArray[i];
                if (item.name === agentKey) {
                    config = item;
                    break;
                }
            }

            return config;
        },

        /**
         * Performs agent config overrides by inspecting session configs
         * and matching the agent name against trackingConfigOverrides.
         * @param {Object} cfg - Config object
         * @memberof uvpjs.TrackingManager#
         */
        doTrackingConfigOverrides: function(cfg) {
            if (!this.hasTrackingConfigOverrides(cfg)) {
                this.agentConfigs = cfg.getModules().slice(0);

                return;
            }

            var agentModules = cfg.getModules().slice(0);
            var i = agentModules.length;

            while (i-- > 0) {
                var agentConfig = agentModules[i];
                var configOverride = this.getAgentConfig(cfg.trackingConfigOverrides, agentConfig.name);

                if (configOverride !== null) {
                    agentModules[i] = configOverride;
                }
            }

            this.agentConfigs = agentModules;
        },

        /**
         * Checks if the given agent is enabled in the agent config.
         * @param {Object} agentKey - name of the tracking agent
         * @memberof uvpjs.TrackingManager#
         * @returns {Boolean}
         */
        isTrackingAgentEnabled: function(agentKey) {
            var config = this.getAgentConfig(this.agentConfigs, agentKey);
            return config !== null && config.enabled;
        },

        /**
         * Determine which agents are enabled.
         * @param {String} cdo - instance of the ConfigDataObject
         * @memberof uvpjs.TrackingManager#
         */
        _createAgentsArray: function(cdo) {
            var agent, cfg, obj, isEnabled, isSet, isDW, playerName;

            this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray');

            // CDO as argument or use attached instance of CVIModel.
            cfg = cdo || this.cviModel;

            // Perform tracking config overrides with the given CVI Model
            this.doTrackingConfigOverrides(cfg);

            // Shortcut to CDO isModuleEnabled method.
            isEnabled = cfg.isModuleEnabled.bind(cfg);
            isSet = cfg.isModuleSet.bind(cfg);

            obj = {
                trackingMgr: this,
                cviModel: this.cviModel,
                eventsMgr: this.eventsMgr
            };

            playerName = this.getPlayerName();

            //
            // Adobe Heartbeat
            //
            if (this.isTrackingAgentEnabled(this.ADOBE_HEARTBEAT_MODULE_NAME)) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray AdobeHeartbeatAgent');

                obj.moduleName = this.ADOBE_HEARTBEAT_MODULE_NAME;
                obj.playerName = playerName;

                agent = new uvpjs.AdobeHeartbeatAgent(obj);

                this.agents.push(agent);
            }

            //
            // Akamai Analytics
            //
            if (this.isTrackingAgentEnabled(this.AKAMAI_ANALYTICS_MODULE_NAME)) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray AkamaiAnalyticsAgent');

                obj.moduleName = this.AKAMAI_ANALYTICS_MODULE_NAME;
                agent = new uvpjs.AkamaiAnalyticsAgent(obj);

                this.agents.push(agent);
            }

            //
            // comScore
            //
            if (this.isTrackingAgentEnabled(this.COMSCORE_SS_MODULE_NAME)) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray ComScoreAgent');

                obj.moduleName = this.COMSCORE_SS_MODULE_NAME;
                obj.playerName = this.getPlayerName('|', '_'), // Format UVPJS|1_0_0

                agent = new uvpjs.ComScoreAgent(obj);

                this.agents.push(agent);
            }

            //
            // Conviva
            //
            if (this.isTrackingAgentEnabled(this.CONVIVA_MODULE_NAME)) {
                if (this.cviModel != null) {
                    this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray ConvivaAgent');
                }

                obj.moduleName = this.CONVIVA_MODULE_NAME;
                obj.playerName = playerName;

                agent = new uvpjs.ConvivaAgent(obj);

                this.agents.push(agent);
            }

            //
            // DW
            //
            isDW = isEnabled(this.DW_MODULE_NAME);

            if (isDW || isEnabled(this.LEGACY_DW_MODULE_NAME)) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray DWAgent');

                obj.moduleName = isDW ? this.DW_MODULE_NAME : this.LEGACY_DW_MODULE_NAME;
                obj.playerName = this.getPlayerName(';'); // Format UVPJS;1.0.0

                agent = new uvpjs.DWAgent(obj);

                this.agents.push(agent);
            }

            //
            // Nielsen
            //
            if (this.isTrackingAgentEnabled(this.NIELSEN_MODULE_NAME)) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray NielsenAgent');

                obj.moduleName = this.NIELSEN_MODULE_NAME;
                obj.playerName = playerName;

                agent = new uvpjs.NielsenAgent(obj);

                this.agents.push(agent);
            }

            //
            // Mux
            //
            if (isSet(this.MUX_MODULE_NAME) && !isEnabled(this.MUX_MODULE_NAME)) {
                this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray MuxAgent. Mux Disabled in UVPC');
            } else {
                this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray MuxAgent');
                obj.moduleName = this.MUX_MODULE_NAME;
                obj.playerName = this.PLAYER_NAME_ONLY;
                obj.playerVersion = this.PLAYER_VERSION_ONLY;
                if (isEnabled(this.MUX_MODULE_NAME)) {
                    obj.useDefaultProperty = false;
                } else {
                    this.debug && uvpjs.log(this.DEBUG_ID, '_createAgentsArray MuxAgent. Using default property');
                    obj.useDefaultProperty = true;
                }

                agent = new uvpjs.MuxAgent(obj);
                this.agents.push(agent);
            }

            //
            // Beacon
            //
            var config = this.getAgentConfig(this.agentConfigs, this.CONCURRENCY_BEACON_MODULE_NAME);

            if (config && config.params && config.params.length > 0) {
                var i = config.params.length;

                // Copy params to beacon friendly object.
                while (i-- > 0) {
                    this.beaconEndPoint[config.params[i].name] = config.params[i].value;
                }
            }
        },

        /**
         * Callback when script is done loading to the page.
         * @memberof uvpjs.TrackingManager#
         */
        _onPluginLoaded: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onPluginLoaded');

            // Determine if all agent plugins are loaded.

            var pluginsLoaded = _.every(this.agents, 'isPluginLoaded');

            this.debug && uvpjs.log(this.DEBUG_ID, 'pluginLoadedCB pluginsLoaded', pluginsLoaded);

            if (pluginsLoaded && _.isFunction(this.agentsLoadedCB)) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'loadAgentPlugins _pluginsLoaded all loaded.');
                this.agentsLoadedCB();
            }
        },

        /**
         * Add event listeners for the Tracking Manager.
         * @memberof uvpjs.TrackingManager#
         */
        _addTrackingEventListeners: function() {
            var em = this.eventsMgr,
                et = em.eventTypes,
                ns = this.internalNS;

            em.addEventListener(et.VIDEO_PROGRESS + ns, this._onVideoProgress.bind(this));
            em.addEventListener(et.RESOURCE_START + ns, this._onResourceStart.bind(this));
            em.addEventListener(et.PLAYBACK_DURATION_RESUME + ns, this._onPlaybackDurationResume.bind(this));
        },

        /**
         * Add event listeners for the Tracking Manager.
         * @memberof uvpjs.TrackingManager#
         */
        _removeTrackingEventListeners: function() {
            var em = this.eventsMgr,
                et = em.eventTypes,
                ns = this.internalNS;

            em.removeEventListener(et.VIDEO_PROGRESS + ns);
            em.removeEventListener(et.AD_QUARTILE + ns);
            em.removeEventListener(et.RESOURCE_START + ns);
        },

        /**
         * Initialize agents for Tracking Manager events.
         * @memberof uvpjs.TrackingManager#
         * @private
         */
        _initializeAgents: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, '_initializeAgents');

            if (_.isEmpty(this.agents)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'loadAgentPlugins no tracking agents enabled.');
                return;
            }

            var i = this.agents.length;

            while (i--) {
                this.agents[i].initialize();
            }

            this._addAgentEventListeners();
        },

        /**
         * Load agent plugins for UVPJS.
         * @param {Object} CDO - instance of the ConfigDataObject
         * @param {Object} callback - callback from VideoManager
         * @memberof uvpjs.TrackingManager#
         */
        loadAgentPlugins: function(CDO, callback) {
            var hasTealium, agent, i;

            this._createAgentsArray(CDO);

            if (_.isEmpty(this.agents)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'loadAgentPlugins no tracking agents enabled.');
                callback();
                return;
            }

            hasTealium = this.mc.hasTealium();

            // TODO: This will eventually populate properties used by all agents.
            if (hasTealium) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'Tealium detected on the page.');
            }

            this.agentsLoadedCB = callback;

            i = this.agents.length;

            while (i--) {
                agent = this.agents[i];

                // Not all tracking agents have plugins (e.g. DW).
                if (!_.isFunction(agent.loadPlugin)) {
                    this._onPluginLoaded.call(this);
                    continue;
                }

                agent.loadPlugin(this._onPluginLoaded.bind(this), CDO);
            }
        },

        /**
         * Fire tracking pixel.
         * @param {String} url - Track url.
         * @memberof uvpjs.TrackingManager#
         */
        fireTrackingPixel: function(url) {
            var img = document.createElement('img');

            img.setAttribute('src', url);
            img.setAttribute('width', '1');
            img.setAttribute('height', '1');
            img.setAttribute('border', '0');
            img.style.position = 'absolute';
            img.style.bottom = '0';
            img.style.right = '0';

            this._beaconElement.appendChild(img);
        },

        /**
         * Called by tracking agents to register listeners for only specific events.
         * @param {Object} callbackObj - mapping of eventTypes to agent methods
         * @memberof uvpjs.TrackingManager#
         */
        registerEventCallbacks: function(callbackObj) {

            if (!_.isPlainObject(callbackObj) || _.isEmpty(callbackObj)) {
                return;
            }

            for (var eventType in callbackObj) {
                // uvpjs.log(this.DEBUG_ID, 'registerEventCallbacks eventType', eventType);
                this.eventCBs[eventType] = this.eventCBs[eventType] || []; // Create empty array if event not added yet.
                this.eventCBs[eventType].push(callbackObj[eventType]);
            }
        },

        /**
         * Called by tracking agents to register listeners for progress events.
         * @param {Object} callbacks - mapping of progressEvents to agent methods
         * @memberof uvpjs.TrackingManager#
         */
        registerProgressEvents: function(callbacks) {

            if (!_.isPlainObject(callbacks) || _.isEmpty(callbacks)) {
                return;
            }

            for (var progressEvent in callbacks) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'registerEventCallbacks progressEvent', progressEvent);
                this.progressEvents[progressEvent] = this.progressEvents[progressEvent] || []; // Create empty array if event not added yet.
                this.progressEvents[progressEvent].push(callbacks[progressEvent]);
            }
        },

        /**
         * Get current playback time.
         * @memberof uvpjs.TrackingManager#
         * @private
         */
        getContentPlayhead: function() {
            var ct = this.cviModel.contentPlaybackState.currentTime;

            // this.debug && uvpjs.log(this.DEBUG_ID, 'getContentPlayhead', ct);

            return parseInt(ct);
        },

        /**
         * Get the player name
         * @param {String} nameDelim - Character to use between the name and the version.
         * @param {String} versionDelim - Character to use between the version numbers (<major>.<minor>.<patch>).
         * @memberof uvpjs.TrackingManager#
         * @returns {String} Player name, default format UVPJS_1.0.0
         */
        getPlayerName: function(nameDelim, versionDelim) {
            var playerName = this.PLAYER_NAME;

            // Just for safe measure.
            if (_.isEmpty(playerName)) {
                return 'UVPJS';
            }

            if (nameDelim) {
                playerName = playerName.replace('_', nameDelim);
            }

            if (versionDelim) {
                playerName = playerName.replace(/\./g, versionDelim);
            }

            return playerName;
        },

        /**
         * Get ad length.
         *
         * @returns {Number} In milliseconds.
         *
         * @memberof uvpjs.TrackingManager#
         */
        getAdLength: function () {
            this._adLength = _getVideoLength(this._adLength, this.cviModel.adVideoState.duration);
            return this._adLength;
        },

        /**
         * Get content length.
         *
         * @returns {Number} In milliseconds.
         *
         * @memberof uvpjs.TrackingManager#
         */
        getContentLength: function () {
            this._contentLength = _getVideoLength(this._contentLength, this.cviModel.contentVideoState.duration);
            return this._contentLength;
        },

        /**
         * Dynamically add events listeners.
         * @memberof uvpjs.TrackingManager#
         */
        _addAgentEventListeners: function() {

            for (var eventType in this.eventCBs) {
                // uvpjs.log(this.DEBUG_ID, 'addEventListeners registerEventCallbacks eventType', eventType);
                this.eventsMgr.addEventListener(eventType + this.internalNS + '.agent', this._onTrackingEvent.bind(this));
            }
        },

        /**
         * Calls functions in eventCBs arrays for event dispatched by the VCI.
         * @param {Object} evtObj - Event object with .type, .payload, and .target properties.
         * @memberof uvpjs.TrackingManager#
         */
        _onTrackingEvent: function(evtObj) {

            if (evtObj.target !== this.vidContId) {
                // uvpjs.warn(this.DEBUG_ID, 'onTrackingEvent evtObj.target !== this.vidContId');
                return;
            }

            var cbArray = this.eventCBs[evtObj.type],
                n;

            if (_.isEmpty(cbArray)) {
                return;
            }

            n = cbArray.length;

            for (var i = 0; i < n; i++) {
                cbArray[i](evtObj);
            }
        },

        /**
         * RESOURCE_START event callback.
         * @param {Object} evtObj - Event object data.
         * @memberof uvpjs.TrackingManager#
         */
        _onResourceStart: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onResourceStart', evtObj);

            this._contentFirstQFired = false;
            this._contentMidFired = false;
            this._contentThirdQFired = false;
            this._contentTimeFired = {};
            this._lastContentSecondCompleted = 0;
        },

        /**
         * Calls functions in progressEventCBs arrays for progress eventss
         * @param {Object} progressEvent - Progress event.
         * @memberof uvpjs.TrackingManager#
         */
        _onProgressEvent: function(progressEvent) {
            var cbArray = this.progressEvents[progressEvent],
                n;

            if (_.isEmpty(cbArray)) {
                return;
            }

            n = cbArray.length;

            for(i = 0; i < n; i++) {
                cbArray[i]();
            }
        },

        /**
         * Maps data points from cviModel and fires the concurrency beacon.
         * @param {Object} evtObj - payload of PLAYBACK_DURATION_RESUME
         * @memberof uvpjs.TrackingManager#
         */
        _onPlaybackDurationResume: function(evtObj) {
            var getModuleParam = this.cviModel.getModuleParam.bind(this.cviModel, this._moduleName),
                contentVideoState = this.cviModel.getContentVideoState(),

                // Required concurrency beacon query params.
                params = {
                    ts: Math.floor(Date.now() / 1000),
                    contentid: contentVideoState.cmsRefGuid,
                    userid: this.cviModel.getSessionOption('userId') || this.CONCURRENCY_BEACON_USER_ID,
                    siteid: getModuleParam('siteid') || this.CONCURRENCY_BEACON_SITE_ID,
                    sessionid: this.cviModel.sessionId,
                    platform: this.mc.isDesktop() ? 'desktop' : 'mobile_web',
                    premium: contentVideoState.isPaidContent,
                    affiliate: contentVideoState.isAffiliateFeed,
                    medtime: Math.round(this.cviModel.contentPlaybackState.currentTime)
                },

                // Build concurrency beacon url.
                beaconUrl = new obj.BeaconBuilder()
                                .concurrencyBeacon(this.beaconEndPoint)
                                .queryParams(params)
                                .devMode(this.debug)
                                .buildUrl();
            // Fire the beacon.
            this.fireTrackingPixel(beaconUrl);
        },

        /**
         * Create progress events timer.
         *
         * @param {Object} evtObj Progress event object..
         *
         * @memberof uvpjs.TrackingManager#
         */
        _onVideoProgress: function (evtObj) {
            var cps = evtObj.payload,
                flooredTime = Math.floor(cps.currentTime),
                duration = cps.duration,
                percentDone;

            // Make sure playback is not ad and time is greater than zero.
            if (!flooredTime || !duration || cps.isAd) {
                return;
            }

            if (this._lastContentSecondCompleted >= flooredTime) {
                return;
            }

            this._lastContentSecondCompleted = flooredTime;

            //
            // Time-based progress events.
            //
            // For VOD and live
            //     - 0-60 seconds: Make tracking calls every 15 seconds.
            //     - 61-end of stream: Make tracking calls every minute.
            //     - 10% increments (For shortform video clips this can be eliminated.)
            if ((flooredTime % 15 === 0 && flooredTime <= 60) || flooredTime % 60 === 0) {

                if (this._contentTimeFired[flooredTime]) {
                    return;
                }

                this._contentTimeFired[flooredTime] = true;
                this.debug && uvpjs.log(this.DEBUG_ID, '_onVideoProgress flooredTime', flooredTime);
                this._onProgressEvent(this.progressEvents.TIMED);
            }

            //
            // Percentage-based progress events.
            //

            // Don't send percentage-based events for super short clips or live events.
            if (cps.isPlayingLive || duration <= 10) {
                return;
            }

            percentDone = Math.floor((flooredTime / duration) * 100);

            if (percentDone !== this.percentDone) {
                this.percentDone = percentDone;
                // uvpjs.log(this.DEBUG_ID, '_onVideoProgress percentDone', percentDone);
            }

            if (_.inRange(percentDone, 25, 50) && !this._contentFirstQFired) {
                this._contentFirstQFired = true;
                this.debug && uvpjs.log(this.DEBUG_ID, '_onVideoProgress FIRST_QUARTILE');
                this._onProgressEvent(this.progressEvents.FIRST_QUARTILE);
            }

            if (_.inRange(percentDone, 50, 75) && !this._contentMidFired) {
                this._contentMidFired = true;
                this.debug && uvpjs.log(this.DEBUG_ID, '_onVideoProgress MID_QUARTILE');
                this._onProgressEvent(this.progressEvents.MID_QUARTILE);
            }

            if (percentDone >= 75 && !this._contentThirdQFired) {
                this._contentThirdQFired = true;
                this.debug && uvpjs.log(this.DEBUG_ID, '_onVideoProgress THIRD_QUARTILE');
                this._onProgressEvent(this.progressEvents.THIRD_QUARTILE);
            }

        },
    });

    /**
     * Return the content length; don't update if within +/- one second.
     *
     * @returns {Number} In milliseconds.
     *
     * @memberof uvpjs.TrackingManager#
     */
    _getVideoLength = function (existing, duration) {
        var oneSec = 1000,
            newTime = (duration > 0) ? Math.floor(duration * oneSec) : 0,
            isSame = uvpjs.util.inRange(existing, newTime - oneSec, newTime + oneSec);

        return isSame ? existing : newTime;
    };

}(uvpjs.register('uvpjs')));

(function (obj) {
    'use strict';

    var MediaHeartbeat,
        MediaHeartbeatConfig,
        MediaHeartbeatDelegate,
        _isPluginAbsent,
        _isSObject,
        _;

    _ = obj._;

    /*
        OPTIMIZE?: General note - It could be advantageous to decouple Tealium from AdobeHeartbeatAgent.
        Code can be rather confusing if Tealium is replacing AdobeAppMeasurement.
        See loadPlugin(), getTealium(), initializePlugin()
    */

    obj.AdobeHeartbeatAgent = uvpjs.Class.subClass({

        SDK_VERSION: '2.0.1',

        TEALIUM_SETUP_TIMEOUT: 10000,
        TEALIUM_RETRY_INTERVAL: 100,

        // Path to concatenated script.
        // TODO: Separate out custom delegates.
        scriptPaths: {
            APP_MEASUREMENT: uvpjs.Configuration.path + 'lib/tracking/adobe/AppMeasurement-2.3.0.min.js',
            HEARTBEAT: uvpjs.Configuration.path + 'lib/tracking/adobe/VideoHeartbeat-2.0.2.min.js'
        },

        // CDO values.
        ACCOUNT_PARAM_NAME: 'account',
        BRAND_PARAM_NAME: 'brand',
        CHAR_SET_PARAM_NAME: 'charSet',
        CURRENCY_CODE_PARAM_NAME: 'currencyCode',
        EDITION_PARAM_NAME: 'edition',
        HEARTBEAT_ADOBE_PUBLISHER_ID_PARAM_NAME: 'heartbeatAdobePublisherId',
        HEARTBEAT_TRACKING_SERVER_PARAM_NAME: 'heartbeatTrackingServer',
        HEARTBEAT_MKTNG_CLOUD_ORG_ID: 'heartbeatVisitorMarketingCloudOrgId',
        PARTNER_ID_PARAM_NAME: 'partnerID',
        SITE_CODE_PARAM_NAME: 'siteCode',
        SITE_TYPE_PARAM_NAME: 'siteType',
        TRACKING_SERVER_PARAM_NAME: 'trackingServer',
        VISITOR_NAMESPACE_PARAM_NAME: 'visitorNamespace',
        // Agreed upon keys for incoming page-level context data.
        PAGE_REPORT_SUITE_ID_KEY: 'sitePrimaryRsid',
        PAGE_SITE_ACCOUNT_KEY: 'siteRsids',

        // Heartbeat player events.
        HEARTBEAT_AD_START: 'AdStart',
        HEARTBEAT_AD_COMPLETE: 'AdComplete',
        HEARTBEAT_AD_SKIP: 'AdSkip',
        HEARTBEAT_AD_BREAK_START: 'AdBreakStart',
        HEARTBEAT_AD_BREAK_COMPLETE: 'AdBreakComplete',
        HEARTBEAT_BUFFER_START: 'BufferStart',
        HEARTBEAT_BUFFER_COMPLETE: 'BufferComplete',
        HEARTBEAT_CHAPTER_START: 'ChapterStart',
        HEARTBEAT_CHAPTER_COMPLETE: 'ChapterComplete',
        HEARTBEAT_PLAY: 'Play',
        HEARTBEAT_PAUSE: 'Pause',
        HEARTBEAT_COMPLETE: 'Complete',
        HEARTBEAT_SEEK_START: 'SeekStart',
        HEARTBEAT_SEEK_COMPLETE: 'SeekComplete',
        HEARTBEAT_SESSION_START: 'SessionStart',
        HEARTBEAT_SESSION_END: 'SessionEnd',

        CLIPS: 'clips',
        FULL_EPISODES: 'fullepisodes',
        MOVIES: 'movies',

        TRACKING_SERVER_SSL_PREFIX: 's',

        /**
         * @constructor uvpjs.AdobeHeartbeatAgent
         * @description Implementation of Adobe Heartbeat.
         * SDK repo: https://github.com/Adobe-Marketing-Cloud/video-heartbeat/tree/master/sdks/js
         *
         * @param {Object}                  options
         * @param {uvpjs.TrackingManager}   options.trackingMgr TrackingManager instance.
         * @param {uvpjs.CVI_Model}         options.cviModel    CVIModel instance.
         * @param {uvpjs.EventsManager}     options.eventTypes  EventsManager event types.
         * @param {String}                  options.moduleName  AdobeHeartbeat config module name.
         * @param {String}                  options.playerName  UVPJS player name.
         *
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.TRACKING_MANAGER;
            this.LIB_DEBUG_ID = uvpjs.DebugManager.configParams.TRACKING_LIB;

            this.trackingMgr = options.trackingMgr;
            this.cviModel = options.cviModel;
            this.eventsMgr = options.eventsMgr;
            this._moduleName = options.moduleName;
            this._playerName = options.playerName;

            this._mediaHeartbeat = null;

            this._videoInfo = null;
            this._qosObject = null;
            this._adBreakInfo = null;
            this._adInfo = null;
            this._chapterInfo = null;
            this._adObject = null;
            this._adBreakObject = null;
            this._chapterObject = null;
            this._mediaObject = null;
            this._adContextData = null;
            this._chapterCustomMetadata = null;
            this._getTealiumTimer = null;

            this.mc = null;

            // Flags.
            this._videoLoaded = false;
            this._isBuffering = false;
            this._adBreakStartSent = false;
            this._initialPlaySent = false;
            this._heartbeatDebug = false;
            this._contextMetadataCBSetup = false;
            this._seekPending = false;
            this._contentStarted = false;

            // Data objects.
            this._appMeasurementData = {};
            this._heartbeatData = {};
            this._visitorData = {};
            this._contextMetadata = {};
            this._sessionMetadata = {};

            // Tealium "s" object
            this._s = null;
            this._usesTealium = false;
            this._waitForTealium = false;

            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent init');
        },

        /**
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        destroy: function() {
            this.trackingMgr = null;
            this.eventsMgr = null;
            this.cviModel = null;
            this._moduleName = null;
            this._playerName = null;
            this.mc = null;
            this._mediaHeartbeat = null;
            this._appMeasurementData = null;
            this._heartbeatData = null;
            this._visitorData = null;
            this._contextMetadata = null;
            this._sessionMetadata = null;
            this._adContextData = null;
            this._chapterCustomMetadata = null;
            this._mediaObject = null;
            this._videoInfo = null;
            this._adBreakInfo = null;
            this._adInfo = null;
            this._chapterInfo = null;
            this._adObject = null;
            this._adBreakObject = null;
            this._chapterObject = null;
            this._s = null;
            this._getTealiumTimer = null;
            this.pluginLoadedCB = Function.prototype;
        },

        /**
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        initialize: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent initialize');

            this.mc = uvpjs.mediaCapabilities;

            this._loadSessionOptions();
            this._loadConfigData();

            if (_.isUndefined(this._visitorData.marketingCloudOrgId)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'AdobeHeartbeatAgent initialize no Adobe Marketing Cloud Org ID.');
                return;
            }

            this.loadPlugin(this._initializePlugin.bind(this));
        },

        /**
         * Load plugin into the page.
         *
         * @param {Function} callback function.
         * @param {uvpjs.ConfigDataObject} CDO - Instance of the CDO.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        loadPlugin: function(callback, CDO) {
            var sessionOptions;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent loadPlugin');

            if (!_.isFunction(callback)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'AdobeHeartbeatAgent loadPlugin no callback supplied!');
                return;
            }

            sessionOptions = CDO ? CDO.sessionOptions : this.cviModel.sessionOptions;

            this.pluginLoadedCB = function () {
                this.isPluginLoaded = true;
                callback();
            }.bind(this);

            this._usesTealium = sessionOptions.usesTealium;

            // Scripts to load.
            var scripts = [
                this.scriptPaths.APP_MEASUREMENT,
                this.scriptPaths.HEARTBEAT
            ];

            // Tealium loaded AppMeasurement so remove it from the array of scripts to load.
            if (this._usesTealium) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent loadPlugin not loading AppMeasurement script.');
                scripts = _.without(scripts, this.scriptPaths.APP_MEASUREMENT);
            }

            // Grab SDK scripts if they're not loaded into the page.

            if (_isPluginAbsent() && !this.isPluginLoaded) {
                this.codeLoader = new uvpjs.CodeLoader();
                this.codeLoader.loadScript(scripts, this.pluginLoadedCB);

                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent loadPlugin plugin already loaded into the page');

            this.pluginLoadedCB();
        },

        /**
         * Returns a VideoInfo object that contains details about the video player and the currently playing video.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         * @returns {Object} VideoInfo object
         */
        getVideoInfo: function() {
            // uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent getVideoInfo');
            return this._videoInfo;
        },

        /**
         * Ad breaks provide insight as to when a particular ad was displayed. For example, if you have a pre-roll and
         * a midpoint ad break, you can collect position data along with the specific ad data. If you have only one ad
         * break, you can simply provide 1 for the position and leave the name blank.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         * @returns {Object} AdBreakInfo object
         */
        getAdBreakInfo: function() {
            return this._adBreakInfo;
        },

        /**
         * Ad information is retrieved using a similar process used to retrieve video information, except you return an
         * AdInfo object instead with details about the currently playing video ad.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         * @returns {Object} AdInfo object
         */
        getAdInfo: function() {
            return this._adInfo;
        },

        /**
         * If you are tracking chapters, you'll need to coordinate the chapter information returned with each call you
         * make to trackChapterStart. Since chapters are likely defined by you and not your video player, you'll need a
         * way to retrieve chapter definitions to populate this object.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         * @returns {Object} ChapterInfo object
         */
        getChapterInfo: function() {
            return this._chapterInfo;
        },

        /**
         * No QoS information.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         * @returns {Null} null
         */
        getQoSInfo: function() {
            var q = this._qosObject;

            return MediaHeartbeat.createQoSObject(q.bitrate, q.startupTime, q.fps, q.droppedFrames);
        },

        /**
         * Returns playhead.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         *
         * @returns {Number} Video playhead.
         */
        getCurrentPlaybackTime: function () {
            return this._videoInfo ? this._videoInfo.playhead : 0;
        },

        /**
         * Gets data from the Config Data Object.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _loadConfigData: function() {
            // Shortcut to CDO getModule method.
            var getHBParam = this.cviModel.getModuleParam.bind(this.cviModel, this._moduleName),
                heartbeatTrackingServer = getHBParam(this.HEARTBEAT_TRACKING_SERVER_PARAM_NAME),
                trackingServer = getHBParam(this.TRACKING_SERVER_PARAM_NAME);

            if (this.mc.isSecure()) {

                if (_.isString(trackingServer)) {
                    if (trackingServer.indexOf(this.TRACKING_SERVER_SSL_PREFIX) !== 0) {
                        trackingServer = this.TRACKING_SERVER_SSL_PREFIX + trackingServer;
                    }
                }

                if (_.isString(heartbeatTrackingServer)) {
                    heartbeatTrackingServer = heartbeatTrackingServer.replace('heartbeats.omtrdc.net', 'cbsinteractive.hb.omtrdc.net');
                }
            }

            this._appMeasurementData = {
                account: getHBParam(this.ACCOUNT_PARAM_NAME),
                charSet: getHBParam(this.CHAR_SET_PARAM_NAME),
                trackingServer: trackingServer,
            };

            this._heartbeatData = {
                publisher: getHBParam(this.HEARTBEAT_ADOBE_PUBLISHER_ID_PARAM_NAME),
                trackingServer: heartbeatTrackingServer,
            };

            this._visitorData = {
                marketingCloudOrgId: getHBParam(this.HEARTBEAT_MKTNG_CLOUD_ORG_ID),
                trackingServer: trackingServer,
            };

            // Show SDK output.
            this._heartbeatDebug = uvpjs.DebugManager.isParamEnabled(this.LIB_DEBUG_ID);

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _loadConfigData this._heartbeatData =', this._heartbeatData);
                uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _loadConfigData this._visitorData =', this._visitorData);
                uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _loadConfigData this._appMeasurementData =', this._appMeasurementData);
            }
        },

        /**
         * Load applicable CDO session options.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _loadSessionOptions: function() {
            var sessionOptions = this.cviModel.sessionOptions;

            // Store `usesTealium` session option.
            this._usesTealium = sessionOptions.usesTealium;

            // Valid session options.
            var keys = {
                'ftag': 'ftag',
                'netwk': 'Network'
            };

            _.each(keys, function(title, key) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _loadSessionOptions', title, key);

                var value = sessionOptions[key];

                if (_.isNull(value) || _.isUndefined(value) || _.isEmpty(value)) {
                    return;
                }

                this._sessionMetadata[title] = value;
            }.bind(this));

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _loadSessionOptions this._sessionMetadata', this._sessionMetadata);
        },

        /**
         * Assigns callbacks to specified events and registers them with the Tracking Manager.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _setupEventCallbacks: function() {
            var evtTypes = this.eventsMgr.eventTypes,
                evtCbs = {};

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _setupEventCallbacks');

            evtCbs[evtTypes.AD_START] = this._onAdStart.bind(this);
            evtCbs[evtTypes.AD_END] = this._onAdEnd.bind(this);
            evtCbs[evtTypes.AD_POD_START] = this._onAdPodStart.bind(this);
            evtCbs[evtTypes.AD_POD_END] = this._onAdPodEnd.bind(this);
            evtCbs[evtTypes.AD_CLICK] = this._onAdClick.bind(this);
            evtCbs[evtTypes.CONTENT_START] = this._onContentStart.bind(this);
            evtCbs[evtTypes.CONTENT_END] = this._onContentEnd.bind(this);
            evtCbs[evtTypes.CONTROL_PLAY] = this._onControlPlay.bind(this);
            evtCbs[evtTypes.CONTROL_PAUSE] = this._onControlPause.bind(this);
            evtCbs[evtTypes.CONTROL_SEEK] = this._onControlSeek.bind(this);
            evtCbs[evtTypes.SEEK_DONE] = this._onSeekDone.bind(this);
            evtCbs[evtTypes.RESOURCE_END] = this._onResourceEnd.bind(this);
            evtCbs[evtTypes.VIDEO_STATE_CHANGE] = this._onVideoStateChange.bind(this);

            // Update playhead.
            evtCbs[evtTypes.VIDEO_PROGRESS] = this._updatePlayhead.bind(this);

            // Update video info.
            evtCbs[evtTypes.PLAYER_DATA_LOADED] = this._updateVideoInfo.bind(this);
            evtCbs[evtTypes.PLAYER_LOADED] = this._updateVideoInfo.bind(this);
            evtCbs[evtTypes.RESOURCE_START] = this._updateVideoInfo.bind(this);
            evtCbs[evtTypes.VIDEO_RESUME] = this._updateVideoInfo.bind(this);
            evtCbs[evtTypes.VIDEO_DONE] = this._updateVideoInfo.bind(this);


            // OPTIMIZE?: property assignment to function (in CodeLoader)

            // If not already setup during the _initializePlugin method when the
            // "account" param was an empty string.
            if (!this._contextMetadataCBSetup) {
                evtCbs[evtTypes.CONTEXT_METADATA] = this._onContextMetadata.bind(this);
            }

            this.trackingMgr.registerEventCallbacks(evtCbs);
        },

        /**
         * Special event callback for situations where the "account" param is
         * left blank in the config, but later comes in through the page API.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _setupContextMetadataEventCallback: function() {
            var evtCbs = {};
            evtCbs[this.eventsMgr.eventTypes.CONTEXT_METADATA] = this._onContextMetadata.bind(this);
            this.trackingMgr.registerEventCallbacks(evtCbs);
            this._contextMetadataCBSetup = true;
        },

        /**
         * Setup instance of the Adobe Heartbeat plugin.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _initializePlugin: function() {
            var account, appMeasurement, mediaConfig, mediaDelegate, visitor;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _initializePlugin');

            // Sanity check for possible error conditions grabbing scripts.
            if (_isPluginAbsent()) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'AdobeHeartbeatAgent _initializePlugin AdobeHeartbeat SDK not properly loaded.');
                return;
            }

            if (this._mediaHeartbeat) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'AdobeHeartbeatAgent: plugin already initialized. No further page context metadata updates used.');
                return;
            }

            // Create shortcuts to the plugins.
            MediaHeartbeat = ADB.va.MediaHeartbeat;
            MediaHeartbeatConfig = ADB.va.MediaHeartbeatConfig;
            MediaHeartbeatDelegate = ADB.va.MediaHeartbeatDelegate;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent loadPlugin this._s, this._usesTealium, this._waitForTealium', this._s, this._usesTealium, this._waitForTealium);

            if (this._usesTealium && !_isSObject(this._s) && !this._waitForTealium) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent: Tealium detected on the page.');
                this._getTealium();
                return;
            }

            // First try to use Tealium "s" object.
            if (this._usesTealium) {
                // Set to Tealium "s" object, by default.
                appMeasurement = this._s;

                this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent setting appMeasurement to Tealium "s" object.');
            // Setup Visitor and AppMeasurement objects, if no Tealium.
            } else {
                if (typeof(Visitor) === 'undefined') {
                    this.debug && uvpjs.error(this.DEBUG_ID, 'AdobeHeartbeatAgent: Unable to create Visitor object. Adobe Heartbeat tracking setup failed.');
                    return;
                }

                if (typeof(AppMeasurement) === 'undefined') {
                    this.debug && uvpjs.error(this.DEBUG_ID, 'AdobeHeartbeatAgent: Unable to create AppMeasurement object. Adobe Heartbeat tracking setup failed.');
                    return;
                }

                account = this._appMeasurementData.account;

                if (_.isString(account) && _.isEmpty(account)) {
                    this._setupContextMetadataEventCallback();
                    this.debug && uvpjs.warn(this.DEBUG_ID, 'AdobeHeartbeatAgent: "account" param is an empty string. Waiting for API call to define "account" param and continue initiaization.');
                    return;
                }

                visitor = new Visitor(this._visitorData.marketingCloudOrgId);
                visitor.trackingServer = this._visitorData.trackingServer;
                visitor.setCustomerIDs({
                    'userId': {
                        'id': this._visitorData.dpid
                    },
                    'puuid': {
                        'id': this._visitorData.dpuuid
                    }
                });

                // Set-up the AppMeasurement component.
                appMeasurement = new AppMeasurement(account);
                appMeasurement.visitor = visitor;
                appMeasurement.account = account;
                appMeasurement.trackingServer = this._appMeasurementData.trackingServer;
                appMeasurement.pageName = this._appMeasurementData.pageName;
                appMeasurement.charSet = this._appMeasurementData.charSet;
                appMeasurement.visitorID = this._appMeasurementData.visitorID;
            }

            if (_.isNull(appMeasurement)) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'AdobeHeartbeatAgent: Error while setting up AppMeasurement object. Adobe Heartbeat tracking setup failed.');
                return;
            }

            // Media Hearteat initialization.
            mediaConfig = new MediaHeartbeatConfig();
            mediaConfig.trackingServer = this._heartbeatData.trackingServer;
            mediaConfig.playerName = this._playerName;
            mediaConfig.channel = this._heartbeatData.channel;
            mediaConfig.debugLogging = this._heartbeatDebug;
            mediaConfig.appVersion = this.SDK_VERSION;
            mediaConfig.ssl = this.mc.isSecure();
            mediaConfig.ovp = '';

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _initializePlugin mediaConfig', mediaConfig);

            /*
                Implement the MediaHeartbeatDelegate to provide playhead information and
                QoS information from the agent.
             */
             _.extend(CustomMediaHeartbeatDelegate.prototype, MediaHeartbeatDelegate.prototype);

            function CustomMediaHeartbeatDelegate(agent) {
                this._agent = agent;
            }

            CustomMediaHeartbeatDelegate.prototype.getCurrentPlaybackTime = function () {
                return this._agent.getCurrentPlaybackTime();
            };

            CustomMediaHeartbeatDelegate.prototype.getQoSObject = function () {
                return this._agent.getQoSInfo();
            };

            // Create primary `_mediaHeartbeat` object.
            this._mediaHeartbeat = new MediaHeartbeat(new CustomMediaHeartbeatDelegate(this), mediaConfig, appMeasurement);

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent this._mediaHeartbeat object created.');

            // Setup event callbacks after plugin initialized.
            this._setupEventCallbacks();

            // Set the video load, which will update the VideoInfo object and start
            // the Heartbeat session. This happens if the agent was waiting for the
            // "account" param to come in through the page API and the video already
            // started.
            if (this.cviModel.getCurrentPlaybackState().playbackStarted) {
                this._setVideoLoad();
            }
        },

        /**
         * Get Tealium "s" object.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _getTealium: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _getTealium.');

            if (_isSObject(this._s) || this._waitForTealium) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent Tealium already loaded.');
                return;
            }

            // OPTIMIZE?: property assignment to function

            // Set a timer to wait for Tealium to load.
            if (!this._getTealiumTimer) {
                this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _getTealium setting timeout.');
                this._getTealiumTimer = setTimeout(this._onTealiumTimeout.bind(this), this.TEALIUM_SETUP_TIMEOUT);
            }

            if (!_.has(window, 's') || !_isSObject(window.s)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'AdobeHeartbeatAgent "usesTealium" is "true", but no Tealium "s" object detected.', window.s);
                setTimeout(this.loadPlugin.bind(this, this.pluginLoadedCB.bind(this)), this.TEALIUM_RETRY_INTERVAL);
                return;
            }

            this._s = window.s;
            this._waitForTealium = true;
            this._initializePlugin();
        },

        /**
         * Abort waiting for Tealium after timeout.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onTealiumTimeout: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, '_onTealiumTimeout.');

            if (!this._waitForTealium) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'Tealium wait-time expired. Failed to load Tealium from the page.');
                this._getTealiumTimer = null;
                this._waitForTealium = true;
                this._initializePlugin();
            }
        },

        /**
         * Track Heartbeat player events and call appropriate plugin method.
         * @param {String} action - the Heartbeat player event (e.g. HEARTBEAT_SESSION_START).
         * @param {String} errorId - the ID of the error, if passed.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _trackHeartbeatInfo: function(action, errorId) {

            if (_.isNull(this._mediaHeartbeat)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'AdobeHeartbeatAgent _trackHeartbeatInfo no player plugin defined');
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _trackHeartbeatInfo action =', action);

            switch (action) {
                case this.HEARTBEAT_SESSION_START:
                    this._mediaHeartbeat.trackSessionStart(this._mediaObject, this._getContentVideoMetadata());
                    break;
                case this.HEARTBEAT_SESSION_END:
                    this._mediaHeartbeat.trackSessionEnd();
                    break;
                case this.HEARTBEAT_PLAY:
                    this._mediaHeartbeat.trackPlay();
                    break;
                case this.HEARTBEAT_PAUSE:
                    this._mediaHeartbeat.trackPause();
                    break;
                case this.HEARTBEAT_COMPLETE:
                    this._mediaHeartbeat.trackComplete();
                    break;
                case this.HEARTBEAT_SEEK_START:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.SeekStart);
                    break;
                case this.HEARTBEAT_SEEK_COMPLETE:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.SeekComplete);
                    break;
                case this.HEARTBEAT_BUFFER_START:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.BufferStart);
                    break;
                case this.HEARTBEAT_BUFFER_COMPLETE:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.BufferComplete);
                    break;
                case this.HEARTBEAT_AD_BREAK_START:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.AdBreakStart, this._adBreakObject);
                    break;
                case this.HEARTBEAT_AD_BREAK_COMPLETE:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.AdBreakComplete);
                    break;
                case this.HEARTBEAT_AD_START:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.AdStart, this._adObject, this._adContextData);
                    break;
                case this.HEARTBEAT_AD_SKIP:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.AdSkip);
                    break;
                case this.HEARTBEAT_AD_COMPLETE:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.AdComplete);
                    break;
                case this.HEARTBEAT_CHAPTER_START:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.ChapterStart, this._chapterObject, this._chapterCustomMetadata);
                    break;
                case this.HEARTBEAT_CHAPTER_COMPLETE:
                    this._mediaHeartbeat.trackEvent(MediaHeartbeat.Event.ChapterComplete);
                    break;
                case this.HEARTBEAT_BITRATE_CHANGE:
                    this._mediaHeartbeat.trackBitrateChange();
                    break;
                case this.HEARTBEAT_VIDEO_PLAYER_ERROR:
                    this._mediaHeartbeat.trackError(errorId);
                    break;
            }
        },

        /**
         * Returns content video metadata.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         * @returns {Object} Content video metadata.
         */
        _getContentVideoMetadata: function() {
            var vs = this.cviModel.getContentVideoState(),
                cmd = this._contextMetadata,
                smd = this._sessionMetadata,
                metadata = {},
                p, vsm;

            // Loop through metadata sent in from the page and add it to the metadata object.
            for (p in cmd) {
                if (cmd.hasOwnProperty(p)) {
                    metadata[p] = cmd[p];
                }
            }

            // Loop through session options sent in from the page and add it to the metadata object.
            for (p in smd) {
                if (smd.hasOwnProperty(p)) {
                    metadata[p] = smd[p];
                }
            }

            // 2.8.0; added for general tracking of arbitrary name/value pairs;
            // contextMetadata maintained on contentVideoState is supplied by user via RCO
            if (vs.contextMetadata) {
                vsm = vs.contextMetadata;
                for (p in vsm) {
                    if (vsm.hasOwnProperty(p)) {
                        metadata[p] = vsm[p];
                    }
                }
            }

            metadata.tl = vs.videoTitle;

            // DSSCDM-2133
            metadata.mediaAutoPlay = vs.isAutoplay;
            metadata.mediaMuted = vs.isMuteAtPlayStart;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _getContentVideoMetadata metadata', metadata);

            return metadata;
        },

        /**
         * On context metadata event.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onContextMetadata: function (evtObj) {
            var data = evtObj.payload.contextMetadata,
                accountKey;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onContextMetadata', evtObj);

            if (_.isEmpty(data)) {
                return;
            }

            this._contextMetadata = data;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onContextMetadata this._contextMetadata', this._contextMetadata);

            if (!_.isEmpty(data[this.PAGE_REPORT_SUITE_ID_KEY])) {
                // TODO: Is the primary report ID still used? Commented out in Flash.
                // this.primaryReportID = this.contextMetadata[this.PAGE_REPORT_SUITE_ID_KEY];
            }

            accountKey = data[this.PAGE_SITE_ACCOUNT_KEY];

            if (!_.isEmpty(accountKey)) {
                var reinitialize = _.isEmpty(this._appMeasurementData.account);

                this._appMeasurementData.account = accountKey;

                // IMPORTANT: If account info was missing from config, use account
                //            info coming in from the page and reinitialize plugin.
                if (reinitialize) {
                    if (this.debug) {
                        uvpjs.warn(this.DEBUG_ID, 'AdobeHeartbeatAgent: No "account" specified in config. '+
                            'Attempting to reinitialize plugin with "account" = ' + accountKey);
                    }
                    this._initializePlugin();
                }
            }
        },

        /**
         * On video load.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _setVideoLoad: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _setVideoLoad', this._mediaHeartbeat);
            this._updateVideoInfo();
            this._videoLoaded = true;
            this._qosObject = {
                droppedFrames: 0,
                startupTime: 0,
                fps: 0,
                bitrate: 0
            };
            this._trackHeartbeatInfo(this.HEARTBEAT_SESSION_START);
        },

        /**
         * Set chapter.
         * @param {Object} data - Content data.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _setChapterInfo: function(data) {
            var chapterTimes = data.chapterStartTimes,
                numChapters = chapterTimes && chapterTimes.length || 0,
                currentSegment = parseInt(data.currentContentSegment),
                currentIndex,
                currentTime,
                nextTime,
                chapterInfo,
                length;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _getChapter', data);

            if (isNaN(currentSegment)) {
                currentSegment = 1;
            }

            currentIndex = currentSegment < 0 ? 0 : currentSegment - 1;
            currentTime = currentIndex <= 0 ? 0 : chapterTimes[currentIndex];
            nextTime = ((currentIndex + 1) > numChapters) ? data.duration : chapterTimes[currentIndex + 1];
            length = nextTime - currentTime;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _getChapter', nextTime, currentTime);

            chapterInfo = {};
            chapterInfo.name = '';
            chapterInfo.length = isNaN(length) ? 0 : length;
            chapterInfo.position = currentSegment;
            chapterInfo.startTime = chapterTimes[currentIndex];

            this._chapterObject = MediaHeartbeat.createChapterObject(
                chapterInfo.name,
                chapterInfo.position,
                chapterInfo.length,
                chapterInfo.startTime
            );

            this._chapterInfo = chapterInfo;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _getChapter this._chapterInfo', this._chapterInfo);
        },

        /**
         * Prepare the ad and ad-break info.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onAdStart: function (evtObj) {
            var adInfo, adBreakInfo, adBreakPosition, adType, clipId, data;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onAdStart', evtObj);

            data = evtObj.payload.adData;

            clipId = data.adClipID.split('_');
            adType = clipId[0];

            if (adType === 'pre') {
                adBreakPosition = 1;
            } else if (adType === 'mid') {
                adBreakPosition = parseInt(clipId[1]) + 1;
            } else if (adType === 'post') {
                adBreakPosition = this.cviModel.getNumberOfAdPods();
            }

            // Prepare the ad-break info.
            adBreakInfo = {};
            adBreakInfo.name = !_.isEmpty(data.adVideoTitle) ? data.adVideoTitle : 'na';
            adBreakInfo.position = adBreakPosition;
            adBreakInfo.playerName = this._playerName;
            adBreakInfo.startTime = this.getCurrentPlaybackTime();

            // Prepare the ad info.
            adInfo = {};
            adInfo.id = !_.isEmpty(data.adVideoId) ? data.adVideoId : !_.isEmpty(data.adVatId) ? data.adVatId : 'na';
            adInfo.name = adBreakInfo.name;
            adInfo.length = data.duration;
            adInfo.position = data.adPosition;

            // Create ad object.
            this._adObject = MediaHeartbeat.createAdObject(
                adInfo.name,
                adInfo.id,
                adInfo.position,
                adInfo.length
            );

            // Create ad break object.
            this._adBreakObject = MediaHeartbeat.createAdBreakObject(
                adBreakInfo.name,
                adBreakInfo.position,
                adBreakInfo.startTime
            );

            // Create instance properties.
            this._adInfo = adInfo;
            this._adBreakInfo = adBreakInfo;

            // Prepare ad metadata.
            this._adContextData = {};

            this._sendInitialPlay();

            if (!this._adBreakStartSent) {
                this._trackHeartbeatInfo(this.HEARTBEAT_AD_BREAK_START);
                this._adBreakStartSent = true;
            }

            this._trackHeartbeatInfo(this.HEARTBEAT_AD_START);
        },

        // VTG-332 Disabling ad skip until SDK fix.
        /**
         * Clear the ad and ad-break info.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onAdEnd: function (evtObj) {
            // var evt = evtObj.payload.adData.skipped ?
            //     this.HEARTBEAT_AD_SKIP :
            //     this.HEARTBEAT_AD_COMPLETE;
            var evt = this.HEARTBEAT_AD_COMPLETE;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onAdEnd');

            this._trackHeartbeatInfo(evt);
        },

        /**
         * Ad clicks pause the ad; send pause ping.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onAdClick: function (evtObj) {
            var paused = evtObj.payload.adData.paused === true;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onAdPaused');

            paused && this._trackHeartbeatInfo(this.HEARTBEAT_PAUSE);
        },

        /**
         * AD_POD_START.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onAdPodStart: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onAdPodStart');
            this._adBreakStartSent = false;
        },

        /**
         * AD_POD_END.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onAdPodEnd: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onAdPodEnd');

            this._adBreakStartSent && this._trackHeartbeatInfo(this.HEARTBEAT_AD_BREAK_COMPLETE);
        },

        /**
         * On content start.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onContentStart: function (evtObj) {
            var data = evtObj.payload.contentData;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onContentStart', data);

            this._contentStarted = true;

            this._sendInitialPlay();

            if (data.chapterStartTimes.length > 0) {
                this._setChapterInfo(data);
                this._trackHeartbeatInfo(this.HEARTBEAT_CHAPTER_START);
            }
        },

        /**
         * On content end.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onContentEnd: function (evtObj) {
            var data = evtObj.payload.contentData;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent; ContentEnd', data);

            this._seekPending = false;

            if (!this._videoLoaded) {
                return;
            }

            if (this._chapterInfo && data.chapterStartTimes.length > 0) {
                this._chapterInfo = null;
                this._trackHeartbeatInfo(this.HEARTBEAT_CHAPTER_COMPLETE);
            }
        },

        /**
         * On resource end cleanup.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onResourceEnd: function (evtObj) {
            var vi = this._videoInfo,
                contentCompleted = this._contentStarted && vi && Math.ceil(vi.playhead) >= (vi.length * 0.95);

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent; ResourceEnd; completed ? ', contentCompleted);

            this._videoInfo = null;
            this._adBreakInfo = null;
            this._adInfo = null;
            this._chapterInfo = null;
            this._initialPlaySent = false;
            this._qosObject = {
                droppedFrames: 0,
                startupTime: 0,
                fps: 0,
                bitrate: 0
            };

            if (!this._videoLoaded) return;

            this._videoLoaded = false;
            this._seekPending = false;

            contentCompleted && this._trackHeartbeatInfo(this.HEARTBEAT_COMPLETE);
            this._contentStarted = false;
            this._trackHeartbeatInfo(this.HEARTBEAT_SESSION_END);
        },

        /**
         * On control play.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onControlPlay: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onControlPlay');

            if (this._seekPending) return;

            this._trackHeartbeatInfo(this.HEARTBEAT_PLAY);
        },

        /**
         * On control pause.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onControlPause: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onControlPause');

            this._trackHeartbeatInfo(this.HEARTBEAT_PAUSE);
        },

        /**
         * On control seek.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onControlSeek: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onControlSeek');
            if (this._seekPending) return;

            this._seekPending = true;
            this._trackHeartbeatInfo(this.HEARTBEAT_SEEK_START);
        },

        /**
         * On seek done.
         *
         * @param {Object} evtObj Event object.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onSeekDone: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onSeekDone');


            this._seekPending && this._trackHeartbeatInfo(this.HEARTBEAT_SEEK_COMPLETE);

            this._seekPending = false;
        },

        /**
         * On video state change.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _onVideoStateChange: function (evtObj) {
            var newState = evtObj.payload.newState;

            uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _onVideoStateChange', newState);

            // Only send buffer start and end events after video is playing.
            if (this._videoLoaded) {
                // Buffer start.
                if (!this._isBuffering && newState === this.mc.BUFFERING) {
                    this._isBuffering = true;
                    this._trackHeartbeatInfo(this.HEARTBEAT_BUFFER_START);
                }
                // Buffer complete.
                else if (this._isBuffering && newState !== this.mc.BUFFERING) {
                    this._isBuffering = false;
                    this._trackHeartbeatInfo(this.HEARTBEAT_BUFFER_COMPLETE);
                }

                newState === this.mc.PLAYING &&  this._trackHeartbeatInfo(this.HEARTBEAT_PLAY);
            }
        },

        /**
         * Update Video Info object.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _updateVideoInfo: function () {
            var ps = this.cviModel.getCurrentPlaybackState(),
                vs = this.cviModel.getContentVideoState(),
                hbStreamTypes = MediaHeartbeat.StreamType,
                duration = vs.duration,
                isLive = vs.isLive,
                isEpisode = vs.episodeFlag,
                videoInfo = {},
                streamType;

            // Prepare the main video info.
            if (!_.isEmpty(vs.cmsRefGuid)) {
                videoInfo.id = vs.cmsRefGuid;
            }
            else if (!_.isEmpty(vs.mediaId)) {
                videoInfo.id = vs.mediaId;
            }
            else if (!_.isEmpty(vs.pid)) {
                videoInfo.id = vs.pid;
            }
            else if (!_.isEmpty(vs.assetURL)) {
                videoInfo.id = vs.assetURL;
            }
            else {
                videoInfo.id = 'na';
            }

            videoInfo.name = vs.videoTitle;
            videoInfo.playerName = this._playerName;
            videoInfo.length = isLive ? -1 : (isNaN(duration) ? 0 : duration);
            videoInfo.playhead = ps.currentTime;

            // Add streamType
            if (isLive) {
                streamType = hbStreamTypes.LIVE;
            }
            else {
                // VTG-315 Add "MOVIES" type when DRM protection in codebase.
                streamType = hbStreamTypes.VOD;
                streamType += ':' + (isEpisode ? this.FULL_EPISODES : this.CLIPS);
            }
            videoInfo.streamType = streamType;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _updateVideoInfo MediaHeartbeat', MediaHeartbeat);

            this._mediaObject = MediaHeartbeat.createMediaObject(
                videoInfo.name,
                videoInfo.id,
                videoInfo.length,
                videoInfo.streamType
            );

            // Create instance object.
            this._videoInfo = videoInfo;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AdobeHeartbeatAgent _updateVideoInfo this._videoInfo', this._videoInfo);
        },

        /**
         * Updates the QoS object
         * @memberof uvpjs.AdobeHeartbeatAgent#
         *
         * @param {Object} a contentPlaybackState object
         */
        _updateQosObj: function(data) {
            var fs = data && data.facadeState,
                q = this._qosObject;

            if (!fs || !q) return;

            q.bitrate = fs.currentBitrate || 0;
            q.droppedFrames = fs.droppedFrames || 0;
            q.fps = fs.playbackFramerate || 0;
        },

        /**
         * On playhead.
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _updatePlayhead: function (evtObj) {
            var data = evtObj.payload;

            if (!this._videoInfo || !data) {
                return;
            }

            if (data.isAd) {
                return;
            }

            this._updateQosObj(data);

            this._videoInfo.playhead = data.currentTime;
        },

        /**
         * Sends initial play ping.
         *
         * @memberof uvpjs.AdobeHeartbeatAgent#
         */
        _sendInitialPlay: function () {

            !this._videoLoaded && this._setVideoLoad();

            if (this._initialPlaySent) {
                return;
            }

            this._trackHeartbeatInfo(this.HEARTBEAT_PLAY);
            this._initialPlaySent = true;
        }
    });

    _isPluginAbsent = function() {
        return typeof ADB === 'undefined' || _.get(ADB, 'va.Heartbeat') === 'undefined';
    };

    _isSObject = function(s) {
        return _.isObject(s) && !_.isEmpty(s) && _.isFunction(s.isReadyToTrack);
    };

}(uvpjs.register('uvpjs')));

'use strict';

(function (obj) {

    var _ = obj._,
        _isPluginAbsent,

        /**
         * Utility method for padding single digit numbers with a leading zero.
         * @param {Number} n The number to pad.
         * @returns {String} The padded number as a string.
         * @private
         */
        _padSingleDigitWithZero = function(n) {
            return (n > 0 && n < 10 ? "0" : "") + n.toString();
        },

        /**
         * Path to the Comscore Streaming SDK.
         *
         * @var {String} JS_SDK
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        JS_SDK = 'lib/tracking/comscore/comscore.streaming.6.1.1.171219.min.js',

        /**
         * Default Publisher Id value assigned by Comscore.
         *
         * @var {String} PUBLISHER_ID
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        PUBLISHER_ID = '3005086',

        /**
         * Required Comscore value for items that should be set to null.
         *
         * @var {String} NULL_VALUE
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        NULL_VALUE = '*null',

        /**
         * Object containing Comscore key mappings.
         *
         * @var {Object} segmentKeys
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        segmentKeys = {
            publisherBrand:  'ns_st_pu',  /* CBS Sports */
            programTitle:    'ns_st_pr',  /* Sports HQ*/
            episodeTitle:    'ns_st_ep',  /* Running backs to watch */
            seasonNumber:    'ns_st_sn',  /* 05 */
            episodeNumber:   'ns_st_en',  /* 11 */
            stationTitle:    'ns_st_st',  /* CBS */
            clipLength:      'ns_st_cl',  /* 1440000 */
            contentGenre:    'ns_st_ge',  /* Sports */
            tmsGracenoteId:  'ns_st_ti',  /* EP01158124003 */
            episodeId:       'ns_st_tep',
            adLoadFlag:      'ns_st_ia',  /* 1 or 0 */
            fullEpisodeFlag: 'ns_st_ce',  /* 1 or 0 */
            digitalAirDate:  'ns_st_ddt', /* 2018-08-30 */
            tvAirDate:       'ns_st_tdt'  /* 2018-08-30 */
        };

    /**
     * @constructor uvpjs.ComScoreAgent
     * @extends uvpjs
     */

    obj.ComScoreAgent = uvpjs.Class.subClass({

        debug: uvpjs.Configuration.env !== 'production',

        SCRIPT_PATH: uvpjs.Configuration.path + JS_SDK,

        /**
         * Used to determine if _trackPlayStart() should be invoked.
         *
         * @var {Boolean} _shouldTrackPlayStart
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _shouldTrackPlayStart: false,

        /**
         * Object containing Comscore configuration.
         *
         * @var {Object} _comScoreConfig
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _comScoreConfig: null,

        /**
         * Object containing the content metadata.
         *
         * @var {Object} _contentMetadata
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _contentMetadata: null,

        /**
         * Object containing Ad metadata.
         *
         * @var {Object} _adMetadata
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _adMetadata: null,

        /**
         * Used for tracking the type of Ad.
         *
         * @var {String} _adType
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _adType: null,

        /**
         * Used for tracking the type of content.
         *
         * @var {String} _contentType
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _contentType: null,

        /**
         * Local copy of live segment data.
         *
         * @var {Object} _liveSegmentData
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _liveSegmentData: null,

        /**
         * @constructor uvpjs.ComScoreAgent
         *
         * @param {Object}                  options
         * @param {uvpjs.TrackingManager}   options.trackingMgr TrackingManager instance.
         * @param {uvpjs.CVI_Model}         options.cviModel    CVIModel instance.
         * @param {uvpjs.EventsManager}     options.eventTypes  EventsManager event types.
         * @param {String}                  options.moduleName  Config module name.
         * @param {String}                  options.playerName  UVPJS player name.
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.TRACKING_MANAGER;

            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent init');

            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;

            this.trackingMgr = options.trackingMgr;
            this.cviModel = options.cviModel;
            this.eventsMgr = options.eventsMgr;
            this._moduleName = options.moduleName;
            this._playerName = options.playerName;

            this.streamingTag = null;

            this._isAd = false;
        },

        /**
         * @memberof uvpjs.ComScoreAgent#
         */
        destroy: function() {
            this.trackingMgr = null;
            this.cviModel = null;
            this.eventsMgr = null;
            this._moduleName = null;
            this._playerName = null;
            this._isAd = false;
            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;

            this._comScoreConfig = null;
            this._contentMetadata = null;
            this._adMetadata = null;
            this._adType = null;
            this._contentType = null;
        },

        /**
         * @memberof uvpjs.ComScoreAgent#
         */
        initialize: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent initialize');

            this._loadConfigData();

            this.loadPlugin(this._initializePlugin.bind(this));
        },

        /**
         * Load plugin into the page.
         * @memberof uvpjs.ComScoreAgent#
         */
        loadPlugin: function(callback) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent loadPlugin');

            if (!_.isFunction(callback)) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'ComScoreAgent loadPlugin no callback supplied.');
                }
                return;
            }

            this.pluginLoadedCB = function () {
                this.isPluginLoaded = true;
                callback();
            }.bind(this);

            // Grab SDK scripts if they're not loaded into the page.
            if (_isPluginAbsent() && !this.isPluginLoaded) {
                this.codeLoader = new uvpjs.CodeLoader();
                this.codeLoader.loadScript(this.SCRIPT_PATH, this.pluginLoadedCB);
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent loadPlugin plugin already loaded into the page');

            this.pluginLoadedCB();
        },

        /**
         * Gets data from the Config Data Object.
         * @memberof uvpjs.ComScoreAgent#
         */
        _loadConfigData: function() {

            // Shortcut to CDO getModule method.
            var getParam = this.cviModel.getModuleParam.bind(this.cviModel, this.trackingMgr.COMSCORE_SS_MODULE_NAME);

            this._comScoreConfig = {
                publisherId: getParam('c2') || PUBLISHER_ID,
                ns_st_pu: getParam('partnerID') || this.cviModel.sessionOptions.partner
            };

            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _loadConfigData this', this);
        },

        /**
         * Assigns callbacks to specified events and registers them with the Tracking Manager.
         * @memberof uvpjs.ComScoreAgent#
         */
        _setupEventCallbacks: function() {
            var eventTypes = this.eventsMgr.eventTypes,
                callbackObj = {};

            callbackObj[eventTypes.AD_START] = this._onAdStart.bind(this);
            callbackObj[eventTypes.AD_END] = this._onAdEnd.bind(this);
            callbackObj[eventTypes.CONTENT_START] = this._onContentStart.bind(this);
            callbackObj[eventTypes.CONTENT_END] = this._onContentEnd.bind(this);
            callbackObj[eventTypes.CONTROL_PLAY] = this._onControlPlay.bind(this);
            callbackObj[eventTypes.CONTROL_PAUSE] = this._onControlPause.bind(this);
            callbackObj[eventTypes.RESOURCE_START] = this._onResourceStart.bind(this);
            callbackObj[eventTypes.RESOURCE_END] = this._onResourceEnd.bind(this);
            callbackObj[eventTypes.LIVE_SEGMENT_START] = this._onLiveSegmentStart.bind(this);
            callbackObj[eventTypes.LIVE_SEGMENT_END] = this._onLiveSegmentEnd.bind(this);
            callbackObj[eventTypes.VIDEO_PROGRESS] = this._onVideoProgress.bind(this);

            this.trackingMgr.registerEventCallbacks(callbackObj);
        },

        /**
         * Setup event callbacks if plugin present.
         * @memberof uvpjs.ComScoreAgent#
         */
        _initializePlugin: function() {

            // Sanity check for possible error conditions grabbing scripts.
            if (_isPluginAbsent()) {
                if (this.debug) {
                    uvpjs.warn(this.DEBUG_ID, 'ComScoreAgent _initializePlugin comScore SDK not properly loaded.');
                }
                return;
            }

            // Setup event callbacks after plugin initialized.
            this._setupEventCallbacks();
        },

        /**
         * Creates a new instance of the Streaming Tag.
         *
         * @param {Object} config Object of Comscore properties
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _createStreamingTag: function(config) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _createStreamingTag', config);
            this.streamingTag = new ns_.ReducedRequirementsStreamingAnalytics(config);
        },

        /**
         * Assemble StreamSense metadata object.
         *
         * @returns {Object} Comscore data
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _getContentMetadata: function() {
            /* Method Shortcuts */
            var videoState = this.cviModel.getContentVideoState(),
                playbackState = this.cviModel.getContentPlaybackState(),
                uvpjsUtil = uvpjs.util,
                getParam = this.cviModel.getModuleParam.bind(this.cviModel, this.trackingMgr.COMSCORE_SS_MODULE_NAME),
                isLive = this.cviModel.getContentVideoState().isLive;

            /* Local Data Points */
            var episodeNumber = parseInt(videoState.episodeNumber),
                seasonNumber = parseInt(videoState.seasonNumber),
                seriesTitle = videoState.seriesTitle,
                videoTitle = videoState.videoTitle, // showtitle - episodetitle
                episodeTitle = videoTitle && videoTitle.split('-')[1],
                isEpisodeNum = !isNaN(episodeNumber),
                isSeasonNum = !isNaN(seasonNumber),
                clientC4 = videoState.contextMetadata !== null && videoState.contextMetadata.comscore_c4,
                clientC6 = videoTitle,
                paddedEpisodeNumber,
                paddedSeasonNumber;

                if (isEpisodeNum && isSeasonNum) {
                    paddedEpisodeNumber = _padSingleDigitWithZero(episodeNumber);
                    paddedSeasonNumber = _padSingleDigitWithZero(seasonNumber);
                    clientC6 += ('--' + paddedSeasonNumber + paddedEpisodeNumber);
                }

                return {
                    /* Unique Content Id */
                    ns_st_ci: uvpjsUtil.getDefinedString(videoState.cmsRefGuid, videoState.mediaId, '0'),

                    /* Content Length */
                    ns_st_cl: isLive ? 0 : this.trackingMgr.getContentLength(),

                    /* Publisher Brand Name */
                    ns_st_pu: this._comScoreConfig[segmentKeys.publisherBrand],

                    /* Program Title */
                    ns_st_pr: uvpjsUtil.getDefinedString(videoState.seriesTitle, videoState.videoTitle),

                    /* Episode Title */
                    ns_st_ep: episodeTitle,

                    /* Episode Season Number */
                    ns_st_sn: (isSeasonNum && paddedSeasonNumber) || NULL_VALUE,

                    /* Episode Number */
                    ns_st_en: (isEpisodeNum && paddedEpisodeNumber) || NULL_VALUE,

                    /* Content Genre */
                    ns_st_ge: videoState.category || NULL_VALUE,

                    /* Episode Id */
                    //ns_st_tep: NULL_VALUE,

                    /* Advertisement Load Flag */
                    ns_st_ia: isLive ? 1 : 0,

                    /* Digital Airdate */
                    ns_st_ddt: NULL_VALUE,

                    /* TV Airdate */
                    ns_st_tdt: NULL_VALUE,

                    /* Station Title - Channel name */
                    ns_st_st: getParam('c4') || NULL_VALUE,

                    /* Complete Episode Flag */
                    ns_st_ce: videoState.episodeFlag ? 1 : 0,

                    /* Client Player Name */
                    c3: getParam('c3') || this._playerName,

                    /* Client Channel */
                    c4: clientC4 || (getParam('c4') || NULL_VALUE),

                    /* Client Video Title */
                    c6: getParam('c6') || clientC6
                };
        },

        /**
         * Method handler for AD_START event. Sets the ad type and metadata and
         * starts tracking ad play.
         *
         * @param {Object} evtObj Payload of the event
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _onAdStart: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onAdStart', evtObj);

            this._isAd = true;

            this._adMetadata = {ns_st_cl: this.trackingMgr.getAdLength()};
            this._adType = this._getAdType();

            this._trackAdPlay();
        },

        /**
         * Method handler for AD_END event. Invokes trackStop() to finish
         * tracking the current ad.
         *
         * @param {Object} evtObj Payload of the event
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _onAdEnd: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onAdEnd', evtObj);

            this._isAd = false;

            this._trackStop();
        },

        /**
         * Method handler for CONTENT_START event. Sets the content type and
         * metadata for tracking the current content item.
         *
         * @param {Object} evtObj Payload of the event
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _onContentStart: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onContentStart', evtObj);

            var type = ns_.ReducedRequirementsStreamingAnalytics.ContentType;

            this._contentType = this.cviModel.getContentVideoState().isLive
                        ? type.Live : type.LongFormOnDemand;

            this._contentMetadata = this._getContentMetadata();
            this._isAd = false;

            this._shouldTrackPlayStart = true;
        },

        /**
         * Method handler for CONTENT_END event. Invokes trackStop() to finish
         * tracking the current content item.
         *
         * @param {Object} evtObj Payload of the event
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _onContentEnd: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onContentEnd', evtObj);

            this._trackStop();
        },

        /**
         * Method handler for CONTROL_PLAY event. Invokes trackAdPlay() to track
         * ads on resume play or trackContentPlay() for normal content.
         * CONTROL_PLAY is triggered by the player's UI controls.
         *
         * @param {Object} evtObj Payload of the event
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _onControlPlay: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onControlPlay', evtObj);

            if (!this.streamingTag) {
                this.debug && uvpjs.warn(this.DEBUG_ID,  'Streaming tag not initialized');
                return;
            }

            if (this._isAd) {
                this._trackAdPlay();
                return;
            }

            this._trackContentPlay();
        },

        /**
         * Method handler for CONTROL_PAUSE event. Invokes trackAdPlay() to track
         * ads on resume play or trackContentPlay() for normal content.
         * CONTROL_PAUSE is triggered by the player's UI controls.
         *
         * @param {Object} evtObj Event object.
         * @memberof uvpjs.ComScoreAgent#
         * @private
         */
        _onControlPause: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onControlPause');

            this._trackStop();
        },

        /**
         * Method handler for RESOURCE_START event.
         *
         * @param {Object} evtObj Event object.
         * @memberof uvpjs.ComScoreAgent#
         * @private
         */
        _onResourceStart: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onResourceStart', evtObj);

            this._createStreamingTag(this._comScoreConfig);
        },

        /**
         * Method handler for RESOURCE_END event.
         *
         * @param {Object} evtObj Event object.
         * @memberof uvpjs.ComScoreAgent#
         * @private
         */
        _onResourceEnd: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onResourceEnd', evtObj);

            this.streamingTag = null;
        },

        /**
         * Method handler for LIVE_SEGMENT_START event. Determines if a new
         * instance of Streaming Tag is needed for playback.
         *
         * @param {Object} event Payload of the event
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _onLiveSegmentStart: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onLiveSegmentStart', evtObj);

            // Skip if not playing live streams
            if (!this._isLiveEvent(evtObj)) {
                return;
            }

            this._shouldTrackPlayStart = true;
            this._liveSegmentData = evtObj.payload.liveSegmentData;

            // Close out previous content play if any
            this._trackStop();

            // Start a new instance of Streaming Tag if changing stations (channels)
            if (this._contentMetadata != null && !this._isSameLiveStation(this._liveSegmentData)) {
                this._createStreamingTag(this._comScoreConfig);
            }
        },

        /**
         * Method handler for LIVE_SEGMENT_END event. Invokes trackStop() to
         * signal the live segment finished playing.
         *
         * @param {Object} evtObj Payload of the event
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _onLiveSegmentEnd: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _onLiveSegmentEnd', evtObj);

            this._trackStop();
        },

        /**
         * Method handler for VIDEO_PROGRESS event. Determines if _trackContentPlay()
         * should be invoked by checking _shouldTrackPlayStart boolean.
         * Note: This handler fires every 100 milliseconds. Do not overload with
         * expensive logic.
         *
         * @param {Object} evtObj Payload of the event
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _onVideoProgress: function(evtObj) {
            /* Invoke _trackContentPlay() only once at content/live segment start */
            if (this._shouldTrackPlayStart) {
                this._trackContentPlay();
                this._shouldTrackPlayStart = false;
            }
        },

        /**
         * Notifies the Streaming Tag an ad started to play.
         *
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _trackAdPlay: function() {
            this.streamingTag && this.streamingTag.playVideoAdvertisement(
                this._adMetadata,
                this._adType
            );
        },

        /**
         * Notifies the Streaming Tag content started to play.
         *
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _trackContentPlay: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ComScoreAgent _trackContentPlay');

            // Inject liveSegmentData into the metadata payload if available.
            this._contentMetadata = obj.util.copyObjectWithKeyMap(segmentKeys)
                                  .from(this._liveSegmentData)
                                  .to(this._getContentMetadata());

            this.streamingTag && this.streamingTag.playVideoContentPart(
                this._contentMetadata,
                this._contentType
            );
        },

        /**
         * Notifies the Streaming Tag content was stopped.
         *
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _trackStop: function() {
            this.streamingTag && this.streamingTag.stop();
        },

        /**
         * Determines if the live content segment contains data in its payload.
         *
         * @param {Object} event Payload
         * @returns {Boolean}
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _isLiveEvent: function(event) {
            return this.cviModel.getContentVideoState().isLive
                    && event.payload
                    && event.payload.hasOwnProperty('liveSegmentData')
                    && typeof event.payload.liveSegmentData === 'object';
        },

        /**
         * Compares station titles in the segment data. Used in onLiveSegmentStart
         * handler to determine if a new instance of Streaming tag should be created.
         *
         * @param {Object} liveSegmentData The segment data
         * @returns {Boolean}
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _isSameLiveStation: function(liveSegmentData) {
            return liveSegmentData.stationTitle === this._contentMetadata[segmentKeys.stationTitle];
        },

        /**
         * Determines the type of ad by inspecting adClipID in cviModel.
         *
         * @returns {String} ad type.
         * @memberof uvpjs.ComScoreAgent
         * @private
         */
        _getAdType: function() {
            var type = ns_.ReducedRequirementsStreamingAnalytics.AdType;
            var adClip = this.cviModel.getAdVideoState().adClipID.split('_')[0];
            var adType;

            if (adClip === 'pre') {
                adType = type.LinearOnDemandPreRoll;
            } else if (adClip === 'mid') {
                adType = type.LinearOnDemandMidRoll;
            } else {
                adType = type.LinearOnDemandPostRoll;
            }

            if (this.cviModel.getContentVideoState().isLive) {
                adType = type.LinearLive;
            }

            return adType;
        }
    });

    _isPluginAbsent = function() {
        return typeof ns_ === 'undefined' || _.isUndefined(ns_.ReducedRequirementsStreamingAnalytics);
    };

}(uvpjs.register('uvpjs')));

(function (obj) {
    'use strict';

    obj.ConvivaAgent = uvpjs.Class.subClass({
        /**
         * Performs Quality of Service (QOS) monitoring using Conviva SDK.
         * @constructor uvpjs.ConvivaAgent
         *
         * @param {Object}                  options
         * @param {uvpjs.TrackingManager}   options.trackingMgr TrackingManager instance.
         *                                  NOTE: Remove in the future to decouple parent from child.
         * @param {uvpjs.CVI_Model}         options.cviModel    CVIModel instance.
         * @param {uvpjs.EventsManager}     options.eventTypes  EventsManager event types.
         * @param {String}                  options.moduleName  Conviva config module name.
         * @param {String}                  options.playerName  UVPJS player name.
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.TRACKING_MANAGER;

            this.debug && uvpjs.log(this.DEBUG_ID, 'ConvivaAgent: construct', options);

            this.convivaClient = null;
            this.convivaSystemFactory = null;
            this.convivaPlayerStateManager = null;
            this.convivaSessionKey = null;
            this.hasConvivaSession = false;

            this.currAdPodInfo = null;

            this.trackingMgr = options.trackingMgr;
            this.cviModel = options.cviModel;
            // eventsMgr is null on "first" instantiation (will go away when SDK loader in play)
            this.eventTypes = (options.eventsMgr && options.eventsMgr.eventTypes) || null;
            this.moduleName = options.moduleName;
            this.playerName = options.playerName;

            this.moduleParams = null;
            this.defaultHeartbeatInterval = 20;

            this.playStates = {};

            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;

            this.adPodInProgress = false;
            this.adPodStartSent = false;

            // see _setConvivaPlayerState for usage
            this.startEvents = {ad: 0, content: 0};
        },

        /**
         * Destroys agent and Conviva client, if active
         * @memberof uvpjs.ConvivaAgent#
         */
        destroy: function () {
            this.hasConvivaSession && this._killConvivaSession();

            this.convivaClient && this.convivaClient.release();
            this.convivaSystemFactory && this.convivaSystemFactory.release();
            this.convivaClient = null;
            this.convivaSystemFactory = null;

            this.trackingMgr = null;
            this.cviModel = null;
            this.eventTypes = null;
            this.moduleParams = null;

            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;
        },

        /**
         * Initialize agent
         * @memberof uvpjs.ConvivaAgent#
         */
        initialize: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'ConvivaAgent initialize()');

            this._gatherModuleParams();

            this.loadPlugin(this._initializePlugin.bind(this));
        },

        /**
         * Load plugin into the page.
         * @memberof uvpjs.ConvivaAgent#
         */
        loadPlugin: function (callback) {
            if (typeof callback !== 'function') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'ConvivaAgent loadPlugin: no callback supplied.');

                return;
            }

            this.pluginLoadedCB = function () {
                this.isPluginLoaded = true;
                callback();
            }.bind(this);

            // Load if SDK not loaded
            if (window.Conviva === undefined && !this.isPluginLoaded) {
                this.codeLoader = new uvpjs.CodeLoader();
                this.codeLoader.loadScript(uvpjs.ConvivaAgent.SDK_PATH, this.pluginLoadedCB);

                return;
            }

            this.pluginLoadedCB();
        },


        //////////////////
        // Private

        /**
         * Creates Conviva client
         * @private
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _initializePlugin: function () {
            if (window.Conviva === undefined) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'ConvivaAgent _initializePlugin Conviva SDK not properly loaded.');

                return;
            }

            if (this.cviModel) {
                this.convivaClient = this._createConvivaClient();

                if (this.convivaClient !== null) {
                    this._setupEventCallbacks();
                    this.debug && uvpjs.log(this.DEBUG_ID, "ConvivaAgent: created Conviva client.");
                }
            }
        },

        /**
         * @private
         *
         * @param {String} type
         *
         * @returns {*}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _getAdType: function(type) {
            var t = typeof type == "string" ? type.toLowerCase() : null,
                pc = Conviva.Client.AdPosition,
                adPositions = uvpjs.ConvivaAgent.adPositions;

            if (!t) return "N/A";

            if (t.indexOf(adPositions.PRE) >= 0) { return pc.PREROLL; }
            if (t.indexOf(adPositions.MID) >= 0) { return pc.MIDROLL; }
            if (t.indexOf(adPositions.POST) >= 0) { return pc.POSTROLL; }
        },

        /**
         * @private
         * @param {Object} data adData
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _getArgsForStartAd: function(data) {
            var str = Conviva.Client.AdStream,
                plr = Conviva.Client.AdPlayer,
                isIma = data.adServerName == "ima";

            return {
                key: this.convivaSessionKey,
                pos: this._getAdType(data.adType),
                stream: isIma ? str.SEPARATE : str.CONTENT,
                player: isIma ? plr.SEPARATE : plr.CONTENT
            };
        },

        // Event handling

        /**
         * @private
         *
         * @param {Object} e Event data object.
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _onAdEvent: function(e) {
            var types = this.eventTypes,
                type = e.type,
                evtName = null,
                data, info, adStartArgs;

            this.startEvents.content = 0;

            if (!this.hasConvivaSession) { return; }

            switch (type) {

                case types.AD_POD_START:
                    this.currAdPodInfo = this._buildAdPodInfo(e.payload.adPod);
                    this.adPodInProgress = true;
                    this.adPodStartSent = false;
                    break;

                case types.AD_START:
                    data = e.payload.adData;
                    info = this._buildAdInfo(data);

                    if (this.adPodInProgress && !this.adPodStartSent) {
                        this.adPodStartSent = true;
                        this._sendCustomEvent("Conviva.PodStart", this.currAdPodInfo);
                    }

                    this.startEvents.ad = 1;
                    adStartArgs = this._getArgsForStartAd(data);

                    this.convivaClient.adStart(
                        adStartArgs.key,
                        adStartArgs.stream,
                        adStartArgs.player,
                        adStartArgs.pos
                    );
                    evtName = "adStart";
                    break;

                case types.AD_POD_END:
                    this.adPodInProgress = false;
                    this.adPodStartSent = false;
                    info = this.currAdPodInfo || {};
                    this.currAdPodInfo = null;
                    evtName = "Conviva.PodEnd";
                    break;

                case types.AD_END:
                    info = this._buildAdInfo(e.payload.adData);
                    evtName = "adEnd";
                    this.startEvents.ad = 0;
                    this.convivaClient.adEnd(this.convivaSessionKey);
                    break;

                default: break;
            }

            evtName && this._sendCustomEvent(evtName, info);
            this._setConvivaPlayerState();
        },

        /**
         * @private
         *
         * @param {Object} e Event data object.
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _onContentEvent: function(e) {
            var nullifyAdData = false;

            this.startEvents.ad = 0;

            if (e.type === this.eventTypes.CONTENT_DATA_LOADED) {
                this.startEvents.content && this.hasConvivaSession && this._killConvivaSession();
                !this.hasConvivaSession && this._createConvivaSession();
                nullifyAdData = true;
            }
            else {
                if (e.type == this.eventTypes.CONTENT_START) {
                    this.startEvents.content = 1;
                    nullifyAdData = true;
                }
                this._setConvivaPlayerState();
            }

            if (nullifyAdData) {
                this.adPodInProgress = false;
                this.adPodStartSent = false;
                this.currAdPodInfo = null;
            }
        },

        /**
         * Video event handler
         * @memberof uvpjs.ConvivaAgent#
         *
         * @param {Object} e Event data object.
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _onVideoEvent: function (e) {
            var types = this.eventTypes,
                type = e.type;

            if (!this.hasConvivaSession) { return; }

            switch (type) {
                case types.VIDEO_STATE_CHANGE:
                case types.VIDEO_TRANSITION_COMPLETE:
                case types.VIDEO_DONE:
                    this._setConvivaPlayerState();
                    break;

                case types.RESOURCE_END:
                    this._setConvivaPlayerState();
                    this._killConvivaSession();
                    break;

                default: break;
            }
        },

        /**
         * Handle all errors.
         * @param {Object} e event object with payload property
         * @memberof uvpjs.ConvivaAgent#
         * @private
         */
        _onError: function(e) {
            var errorInfo = e.payload.errorInfo;

            if (errorInfo.isFatal) {
                !this.hasConvivaSession && this._createConvivaSession();
                this._sendError(errorInfo.message, Conviva.Client.ErrorSeverity.FATAL);
                this._killConvivaSession();
            }
            else {
                this._sendError(errorInfo.message, Conviva.Client.ErrorSeverity.WARNING);
            }
        },

        // Conviva Session
        /**
         * @private
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _createConvivaSession: function() {
            if (!this.convivaClient) { return; }

            var mdl = this.cviModel,
                mc = this._getMediaCapabilities(),
                psmStates = Conviva.PlayerStateManager.PlayerState,
                udata = {
                    userId: mdl.getSessionOption("userId"),
                    userPPID: mdl.getSessionOption("userPPID"),
                    userStatus: mdl.getSessionOption("userStatus")
                },
                contentMetadata = new Conviva.ContentMetadata();

            this._setContentMetadata(contentMetadata, udata);
            this.convivaSessionKey = this.convivaClient.createSession(contentMetadata);

            this.convivaPlayerStateManager = this.convivaClient.getPlayerStateManager();
            this.convivaClient.attachPlayer(this.convivaSessionKey, this.convivaPlayerStateManager);

            // Map integer playstate values (found in state change event payload) to
            // Conviva.PlayerStateManager.PlayerState values
            this.playStates[mc.EMPTY]     = psmStates.UNKNOWN;
            this.playStates[mc.LOADING]   = psmStates.UNKNOWN;
            this.playStates[mc.STOPPED]   = psmStates.STOPPED;
            this.playStates[mc.PLAYING]   = psmStates.PLAYING;
            this.playStates[mc.PAUSED]    = psmStates.PAUSED;
            this.playStates[mc.BUFFERING] = psmStates.BUFFERING;

            this.hasConvivaSession = true;

            this.debug && uvpjs.log(this.DEBUG_ID, 'ConvivaAgent: Conviva session created');
        },

        /**
         * Kills session only, keeps client alive
         * @private
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _killConvivaSession: function() {
            if (!this.convivaClient || !this.hasConvivaSession) { return; }

            this.convivaPlayerStateManager && this.convivaClient.releasePlayerStateManager(this.convivaPlayerStateManager);
            this.convivaPlayerStateManager = null;

            this.convivaClient.cleanupSession(this.convivaSessionKey);
            this.convivaSessionKey = null;

            this.hasConvivaSession = false;

            this.adPodInProgress = false;
            this.adPodStartSent = false;
            this.currAdPodInfo = null;

            this.debug && uvpjs.log(this.DEBUG_ID, 'ConvivaAgent: Conviva session killed');
        },

        /**
         * @private
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _setConvivaPlayerState: function() {
            var mdl = this.cviModel,
                isAd = mdl.isCurrVideoAd,
                stateObj = isAd ? mdl.adPlaybackState : mdl.contentPlaybackState,
                facadeState = !isAd && mdl.contentPlaybackState.facadeState,
                currAbr = (facadeState && facadeState.currentAbr) || null,
                bitrate = currAbr ? currAbr.bitrate : (!isAd ? mdl.contentPlaybackState.playbackBitrate : 0),
                playState = stateObj.playbackState,
                stateLabel = this.playStates[playState];

            if (!this.hasConvivaSession) { return; }

            // VTG-169; Avoid setting play state to "playing" prior to receipt of adStart or
            // contentStart events. Change state to Conviva UNKNOWN state.
            if (stateLabel == "PLAYING") {
                if (isAd && !this.startEvents.ad || !isAd && !this.startEvents.content) {
                    stateLabel = Conviva.PlayerStateManager.PlayerState.UNKNOWN;
                }
            }

            if (stateLabel) {
                this.convivaPlayerStateManager.setPlayerState(stateLabel);
                if (bitrate > 0) {
                    bitrate = bitrate * 0.001;
                }
                this.convivaPlayerStateManager.setBitrateKbps(bitrate);
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'ConvivaAgent: _setConvivaPlayerState stateLabel', stateLabel);
        },

        /**
         * @private
         *
         * @param {String} eventName
         * @param {Object} eventData
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _sendCustomEvent: function(eventName, eventData) {
            var sessionKey = this.hasConvivaSession ? this.convivaSessionKey : Conviva.Client.NO_SESSION_KEY;

            this.convivaClient.sendCustomEvent(sessionKey, eventName, eventData);
        },

        /**
         * @private
         *
         * @param {String} errorMsg
         * @param {Number} severity
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _sendError: function(errorMsg, severity) {
            if (!this.hasConvivaSession) { return; }

            this.convivaPlayerStateManager.sendError(errorMsg, severity);

            this.debug && uvpjs.warn(this.DEBUG_ID, "ConvivaAgent: sending ERROR: " + errorMsg);
        },

        /**
         * Sets values on Conviva.ContentMetadata instance
         * @private
         *
         * @param {Conviva.ContentMetadata} contentMetadata
         * @param {Object|null} userData
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _setContentMetadata: function (contentMetadata, userData) {
            var mdl = this.cviModel,
                streamTypes = Conviva.ContentMetadata.StreamType,
                videoState = mdl.contentVideoState,
                defBitrate = videoState.defaultBitrate;

            // NOTE: intentionally not setting contentMetadata.encodedFrameRate;

            contentMetadata.applicationName = this.playerName; // includes version; format = UVPJS_<version>
            contentMetadata.assetName = this._validateStr(videoState.videoTitle, "N/A");
            contentMetadata.defaultBitrateKbps = defBitrate && defBitrate > 0 ? defBitrate : 700;
            contentMetadata.defaultResource = this._validateStr(videoState.cdn, "N/A");
            contentMetadata.duration = videoState.duration;
            contentMetadata.streamType = videoState.isLive ? streamTypes.LIVE : streamTypes.VOD;
            contentMetadata.streamUrl = this._validateStr(videoState.assetURL, "N/A");

            contentMetadata.viewerId = this._validateStr(userData.userId, "N/A");

            // Custom metadata
            contentMetadata.custom = {
                accessType: this._validateStr(userData.userStatus, "anon"),
                contentId: this._validateStr(videoState.cmsRefGuid, "N/A"),
                contentType: videoState.isLive ? "Live" : "VOD",
                isEpisode: !!videoState.episodeFlag ? "true" : "false",
                Partner_ID: this._validateStr(mdl.getSessionOption("partner"), "N/A"),
                Player_Version: uvpjs.Configuration.version,
                seriesTitle: this._validateStr(videoState.seriesTitle, "N/A"),
                winDimension: this._getWinDimension(),
                episodeTitle: this._validateStr(videoState.episodeTitle, videoState.videoTitle),
                appRegion: this._validateStr(mdl.sessionOptions.userCountry, 'us'),
                app: uvpjs.Configuration.name,
                appVersion: uvpjs.Configuration.name + ' ' + uvpjs.Configuration.version,
                drm: videoState.drm.enabled.toString(),
                drmType: this.trackingMgr.mc.getDrmType(videoState.drm),
                isAd: mdl.isCurrVideoAd.toString(),
                connectionType: this._validateStr(mdl.sessionOptions.userConnectionType, 'unknown')
            };
        },

        /**
         * Determines the size from the window screen if available. It defaults
         * to the video source dimensions if the screen is not available.
         *
         * @memberof uvpjs.ConvivaAgent
         * @returns {String}
         * @private
         */
        _getWinDimension: function() {
            var width = this.cviModel.contentVideoState.sourceWidth;
            var height = this.cviModel.contentVideoState.sourceHeight;

            if (window && window.screen) {
                if (window.screen.width) {
                    width = window.screen.width;
                }
                if (window.screen.height) {
                    height = window.screen.height;
                }
            }

            return width + 'x' + height;
        },

        // Conviva initialization
        /**
         * @private
         *
         * @returns {Conviva.Client}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _createConvivaClient: function() {
            var clientSettings = this._getConvivaClientSettings();

            if (!clientSettings) {
                return null;
            }

            this.convivaSystemFactory = this._createConvivaSystemFactory();

            return new Conviva.Client(clientSettings, this.convivaSystemFactory);
        },

        /**
         * Client settings for customer key, service url; derived from module params in session options
         * @private
         *
         * @returns {Conviva.ClientSettings}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _getConvivaClientSettings: function() {
            var p = this.moduleParams, clientSettings;

            if ( !this._isValidStr(p.customerKey) || !this._isValidStr(p.serviceUrl) ) {
                this.debug && uvpjs.warn(this.DEBUG_ID, "ConvivaAgent could not create client: key and/or service url invalid.");
                return null;
            }

            clientSettings = new Conviva.ClientSettings(p.customerKey);

            // configurable heartbeatInterval intended primarily for testing
            clientSettings.heartbeatInterval = p.heartbeatInterval || this.defaultHeartbeatInterval;
            clientSettings.gatewayUrl = p.serviceUrl;

            return clientSettings;
        },

        /**
         * Allows uncaught exceptions and logs warnings and errors only in dev env; errors and log are silent in prod
         * @private
         *
         * @param {Conviva.SystemSettings} systemSettings
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _setConvivaSystemProps: function(systemSettings) {
            var isDev = uvpjs.Configuration.env === "development",
                logLvl = Conviva.SystemSettings.LogLevel;

            systemSettings.allowUncaughtExceptions = isDev;
            systemSettings.logLevel = isDev ? logLvl.WARNING : logLvl.NONE;
        },

        /**
         * Required interface implementations, in lib/tracking/conviva
         * @private
         *
         * @returns {Conviva.SystemFactory}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _createConvivaSystemFactory: function() {
            var sysInterface = new Conviva.SystemInterface(
                new uvpjs.ConvivaHtml5Time(),
                new uvpjs.ConvivaHtml5Timer(),
                new uvpjs.ConvivaHtml5Http(),
                new uvpjs.ConvivaHtml5Storage(),
                new uvpjs.ConvivaHtml5Metadata(),
                new uvpjs.ConvivaHtml5Logging()
            ),
            sysSettings = new Conviva.SystemSettings();

            this._setConvivaSystemProps(sysSettings);

            return new Conviva.SystemFactory(sysInterface, sysSettings);
        },


        // util
        /**
         * @private
         *
         * @param {Object} data ad pod object
         *
         * @returns {Object}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _buildAdPodInfo: function(data) {
            var podInfo = {},
                adPositions = uvpjs.ConvivaAgent.adPositions,
                podIdSplit, pos, prefix, rawIdx, idx;

            if (!data) { return null; }

            /*
                data arg is adPod data:

                    adCallURL: "https://..."
                    adCount: 1
                    adPodId: "pre_0"
                    hasPlayed: false
                    podDuration: 29
                    startTime: 0
            */

            data.podDuration !== undefined && (podInfo.podDuration = String(data.podDuration));

            if (!data.adPodId) { return podInfo; }

            podIdSplit = data.adPodId.split("_");
            pos = podIdSplit[0].toLowerCase();
            prefix = pos.charAt(0).toUpperCase() + pos.slice(1); // conv to titlecase
            rawIdx = +podIdSplit[1];

            switch (pos) {
                case  adPositions.PRE:
                    idx = 1;
                    break;
                case  adPositions.MID:
                    idx = rawIdx + 1;
                    break;
                case  adPositions.POST:
                    idx = this.cviModel.getNumberOfAdPods();
                    break;
            }

            podInfo.podPosition = prefix + "-roll"; /* Pre-roll | Mid-roll | Post-roll */
            podInfo.podIndex = String(idx);

            return podInfo;
        },

        /**
         * @private
         *
         * @param {Object} data ad data object
         *
         * @returns {Object}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _buildAdInfo: function(data) {
            var adInfo = {},
                partnerId = this.cviModel.getSessionOption("partner");

            if (!data) { return null; }

            /*
              ad data: (only showing select properties)
				 adClipID: "pre_0_1"
				 adPosition: 1
				 adServerName: "ima"
				 adVideoId: "449599929"
				 adVideoTitle: "In-Stream Video"
				 ...
            */

            adInfo.adTitle = "(" + data.adVideoId + ")" + data.adVideoTitle;
            adInfo.adClipId = this._validateStr(data.adClipID, "N/A");
            adInfo.Partner_ID = this._validateStr(partnerId, "N/A");
            adInfo.adServerName = this._validateStr(data.adServerName, "N/A");

            return adInfo;
        },

        /**
         * @private
         *
         * @param {String} str
         *
         * @returns {Boolean}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _isValidStr: function(str) {
            return uvpjs.util.isDefinedString(str);
        },

        /**
         * If supplied string (str) is valid, return string, otherwise return the supplied default value (defValue)
         * @private
         *
         * @param {String} str
         * @param {String} defValue
         *
         * @returns {*}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _validateStr: function(str, defValue) {
            return this._isValidStr(str) ? str : defValue;
        },

        /**
         * @private
         *
         * @param {String} url
         *
         * @returns {String}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _isDynamicStreaming: function(url) {
            var uspl = url.split("?"),
                suf = uspl[0].substr(uspl[0].lastIndexOf(".") + 1);

            return suf === "mp4" ? "false" : "true";
        },

        /**
         * @private
         *
         * @returns {Object}
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _getMediaCapabilities: function() {
            return uvpjs.mediaCapabilities;
        },

        /**
         * Module params hold Conviva customer key and service url
         * @private
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _gatherModuleParams: function () {
            var model = this.cviModel,
                module = model.getModule(this.moduleName),
                mp = module.params,
                i = mp.length,
                params = {}, p;

            while (i--) {
                p = mp[i];
                params[p.name] = p.value;
            }

            this.moduleParams = params;
        },

        /**
         * Assigns callbacks to specified events and registers them with the Tracking Manager.
         *
         * @private
         *
         * @memberof uvpjs.ConvivaAgent#
         */
        _setupEventCallbacks: function () {
            var types = this.eventTypes,
                evtCbs = {},
                ha = this._onAdEvent.bind(this),
                hc = this._onContentEvent.bind(this),
                hv = this._onVideoEvent.bind(this),
                he = this._onError.bind(this);

            evtCbs[types.AD_START] = ha;
            evtCbs[types.AD_POD_START] = ha;
            evtCbs[types.AD_END] = ha;
            evtCbs[types.AD_POD_END] = ha;

            evtCbs[types.CONTENT_DATA_LOADED] = hc;
            evtCbs[types.CONTENT_START] = hc;
            evtCbs[types.CONTENT_END] = hc;

            evtCbs[types.VIDEO_STATE_CHANGE] = hv;
            evtCbs[types.VIDEO_TRANSITION_COMPLETE] = hv;
            evtCbs[types.VIDEO_DONE] = hv;
            evtCbs[types.RESOURCE_END] = hv;

            evtCbs[types.PLAYER_START_ERROR] = he;
            evtCbs[types.VIDEO_START_ERROR] = he;
            evtCbs[types.VIDEO_PLAYBACK_ERROR] = he;
            evtCbs[types.AD_ERROR] = he;

            this.trackingMgr.registerEventCallbacks(evtCbs);

            window.addEventListener("beforeunload", function() {
                this._killConvivaSession();
            }.bind(this), false);
        }

    });

    obj.ConvivaAgent.SDK_PATH = uvpjs.Configuration.path + 'lib/tracking/conviva-uvpjs-sdk.min.js';

    obj.ConvivaAgent.adPositions = {
        PRE: "pre",
        MID: "mid",
        POST: "post"
    };

}(uvpjs.register('uvpjs')));

(function (obj) {
    'use strict';

    obj.NielsenAgent = uvpjs.Class.subClass({

    	debug: uvpjs.DebugManager.isEnabled,

        SCRIPT_PATH: '//cdn-gl.imrworldwide.com/novms/js/2/ggcmb510.js',

        NIELSEN_APID_PARAM_NAME:            'apid',
        NIELSEN_CLIENTID_PARAM_NAME:        'clientid',
        NIELSEN_SFCODE_PARAM_NAME:          'sfcode',
        NIELSEN_VCID_PARAM_NAME:            'vcid',
        NIELSEN_CHANNEL_INFO_PARAM_NAME:    'channelInfo',
        NIELSEN_CHANNEL_NAME_PARAM_NAME:    'channelName',
        NIELSEN_IAG_SID_PARAM_NAME:         'iag_sid',
        NIELSEN_IAG_TFID_PARAM_NAME:        'iag_tfid',
        NIELSEN_NOL_DEV_DEBUG_PARAM_NAME:   'nol_devDebug',
        NIELSEN_APN:                        'cbsdesktop', // TODO: Should we still use this?
        NIELSEN_DEFAULT_APID:               'PF7B87067-BF4D-F80F-E040-070AAD316CE6', // Nielsen apid values provided by Tracy Paulenoff, 5/7/2016.
        NIELSEN_LIVE_VIDEO_DURATION:        86400,

        NIELSEN_VIDEO_CUEPOINT_NAME:        'www.nielsen.com',


        // Nielsen event mapping.
        // https://engineeringforum.nielsen.com/sdk/developers/bsdk-nielsen-browser-sdk-apis.php
        events: {
            PLAY:                   5,
            STOP:                   7,
            END:                    57,
            LOAD_METADATA:          15,
            SET_PLAYHEAD_POSITION:  49,
            SEND_ID3:               55
        },

        /**
         * Constructor function.
         *
         * @param {Object}                  options
         * @param {uvpjs.TrackingManager}   options.trackingMgr TrackingManager instance. NOTE: Remove in the future to decouple parent from child.
         * @param {uvpjs.CVI_Model}         options.cviModel    CVIModel instance.
         * @param {uvpjs.EventsManager}     options.eventTypes  EventsManager event types.
         * @param {String}                  options.moduleName  Nielsen config module name.
         * @param {String}                  options.playerName  UVPJS player name.
         *
         * @constructor uvpjs.NielsenAgent
         * @extends uvpjs
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.TRACKING_MANAGER;

            if (uvpjs.Configuration.env === 'development') {
                this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent init', options);
            }

            // TODO: Passing an instance of the Tracking Manager should be removed in the future.
            //       Have the Tracking Manager call a method on the agents to load event callbacks.
            //       Promotes a stricter parent -> child one-way relationship; child (agent) should
            //       be unaware of the parent (Tracking Manager). All required data should be passed
            //       into the agent when instantiated.
            this.trackingMgr = options.trackingMgr;
            this.cviModel = options.cviModel;
            this.eventsMgr = options.eventsMgr; // OPTIMIZE: Just pass in eventTypes?
            this._moduleName = options.moduleName;
            this._playerName = options.playerName;

            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;

            this._gg = null;
            this._nolggGlobalParams = null;

            this._metadata = null;
            this._lastAdSecond = null;
            this._lastContentSecond = null;
            this._numAdsInPod = null;
            this._adDisplayed = false;
        },

        /**
         * @memberof uvpjs.NielsenAgent#
         */
        destroy: function () {
            this.trackingMgr = null;
            this.cviModel = null;
            this.eventsMgr = null;
            this._moduleName = null;
            this._playerName = null;

            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;

            this._gg = null;
            this._nolggGlobalParams = null;

            this._metadata = null;
            this._lastAdSecond = null;
            this._lastContentSecond = null;
            this._numAdsInPod = null;
            this._adDisplayed = false;
        },

        /**
         * @memberof uvpjs.NielsenAgent#
         */
        initialize: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent initialize');

            this._metadata = {};
            this._initializeParams();

            this.loadPlugin(this._initializePlugin.bind(this));
        },

        /**
         * Load plugin into the page.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        loadPlugin: function (callback) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent loadPlugin');

            if (typeof callback !== 'function') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'NielsenAgent loadPlugin no callback supplied.');
                return;
            }

            this.pluginLoadedCB = function () {
                this.isPluginLoaded = true;
                callback();
            }.bind(this);

            // Grab SDK scripts if they're not loaded into the page.
            if (_isPluginAbsent() && !this.isPluginLoaded) {
                this.codeLoader = new uvpjs.CodeLoader();
                this.codeLoader.loadScript(this.SCRIPT_PATH, this.pluginLoadedCB);
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent loadPlugin plugin already loaded into the page');

            this.pluginLoadedCB();
        },

        /**
         * Sets the _nolggGlobalParams object from the CDO data.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _initializeParams: function () {
            var model = this.cviModel,
                metadata = this._metadata,
                partner = model.sessionOptions.partner,
                module = model.getModule(this._moduleName),
                arr = module.params, i = arr.length, params = {},
                p, ci, c6;

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _initializeParams');

            // Create a quick parameter lookup table.
            // OPTIMIZE: Consider making module and parameter lookup objects
            //           part of the model.
            while (i--) {
                p = arr[i];
                // Remove empty strings to avoid overriding later (not falsey).
                if (p.value !== '') {
                    params[p.name] = p.value;
                }
            }

            // Define GlobalParams.
            this._nolggGlobalParams = {
                nsdkv:          '511',
                apn:            this._playerName,
                sfcode:         params[this.NIELSEN_SFCODE_PARAM_NAME],
                apid:           params[this.NIELSEN_APID_PARAM_NAME] || this.NIELSEN_DEFAULT_APID,
                nol_sdkDebug:   params[this.NIELSEN_NOL_DEV_DEBUG_PARAM_NAME],
                // channelInfo:    param(this.NIELSEN_CHANNEL_INFO_PARAM_NAME) // Not sure this is recognized in the standalone SDK.
            };

            // Determine ci and c6 based on partner id.
            switch (partner) {
                case 'chow':
                    ci = 'us-700144';
                    c6 = 'c06';
                    break;
                case 'tvcom':
                    ci = 'us-200330';
                    c6 = 'c03';
                    break;
                case 'cbs':
                    ci = 'us-700144';
                    c6 = 'c01';
                    break;
                case 'can':
                    ci = 'us-700144';
                    c6 = 'c01';
                    break;
                case 'cbssports':
                    ci = 'us-201669';
                    c6 = 'c02';
                    break;
                case 'cbssports_test':
                    ci = 'us-201669';
                    c6 = 'c02';
                    break;
                case 'news':
                    ci = 'us-700144';
                    c6 = 'c03';
                    break;
                case 'gamespot':
                    ci = 'us-200330';
                    c6 = 'c13';
                    break;
                case 'cnettv':
                    ci = 'us-200330';
                    c6 = 'c05';
                    break;
                default:
                    ci = 'us-700144';
                    c6 = 'c01';
            }

            // Set metadata object with CDO parameter overrides.
            metadata.ci = params.clientid || ci;
            metadata.c6 = params.vcid || c6;
            metadata.iag_sid = params.iag_sid;
            metadata.iag_tfid = params.iag_tfid;
            metadata.channelName = params.channelName;
            metadata.segB = params.segB || '';

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _initializeParams params, metadata', params, metadata);
        },

        /**
         * Assigns callbacks to specified events and registers them with the Tracking Manager.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _setupEventCallbacks: function () {
            var evtTypes = this.eventsMgr.eventTypes,
                evtCbs = {};

            evtCbs[evtTypes.CONTENT_DATA_LOADED] = this._onContentDataLoaded.bind(this);
            evtCbs[evtTypes.AD_START] = this._onAdStart.bind(this);
            evtCbs[evtTypes.AD_POD_START] = this._onAdPodStart.bind(this);
            evtCbs[evtTypes.AD_END] = this._onAdEnd.bind(this);
            evtCbs[evtTypes.CONTENT_START] = this._onContentStart.bind(this);
            evtCbs[evtTypes.CONTENT_END] = this._onContentEnd.bind(this);
            evtCbs[evtTypes.CONTROL_PLAY] = this._onControlPlay.bind(this);
            evtCbs[evtTypes.VIDEO_PROGRESS] = this._onVideoProgress.bind(this);
            evtCbs[evtTypes.VIDEO_CUEPOINT] = this._onVideoCuepoint.bind(this);

            this.trackingMgr.registerEventCallbacks(evtCbs);
        },

        /**
         * Setup instance of the comScore Heartbeat plugin.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _initializePlugin: function () {

            // Sanity check for possible error conditions grabbing scripts.
            if (_isPluginAbsent()) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'NielsenAgent _initializePlugin Nielsen SDK not properly loaded.');
                return;
            }

            // Get instance of the SDK.
            this._gg = window.NOLCMB.getInstance();

            // Initialize the SDK.
            this._gg.ggInitialize(this._nolggGlobalParams);

            // Setup event callbacks after plugin initialized.
            this._setupEventCallbacks();
        },

        /**
         * Centralized SDK contact point
         *
         * @param {String} evtName
         * @param {*} payload
         */
        _notifySDK: function(evtName, payload) {

            if (this._isDisabled()) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent ggPM', evtName, payload);

            this._gg.ggPM(evtName, payload);
        },

        /**
         * CONTENT_DATA_LOADED event handler. Populates metadata object.
         *
         * NOTE: Content metadata should be loaded before ad preroll.
         *
         * @param {Object} evt Event data object.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _onContentDataLoaded: function (evt) {
            var isMobile = uvpjs.mediaCapabilities.isMobile(),
                metadata = this._metadata, payload = evt.payload,
                vs, duration, form, contentTitle, episodeNumber,
                seasonNumber, seriesTitle, videoTitle;

            if (!payload) {
                return;
            }

            vs = evt.payload.vidState;
            form = vs.chapterStartTimes.length > 0 ? 'lf' : 'sf';
            episodeNumber = vs.episodeNumber;
            seasonNumber = vs.seasonNumber;
            seriesTitle = vs.seriesTitle;
            videoTitle = vs.videoTitle;
            duration = vs.duration;
            contentTitle = [videoTitle, seasonNumber, episodeNumber, form].join('|');

            if (seasonNumber === '') seasonNumber = '0';
            if (episodeNumber === '') episodeNumber = '0';
            if (vs.isAffiliateFeed) metadata.tv = 'true';
            if (vs.isLive || duration === -1) duration = this.NIELSEN_LIVE_VIDEO_DURATION;

            // DCR metadata.
            metadata.pc = metadata.ci + metadata.c6 + metadata.cmsRefGuid;
            metadata.c10 = 'plt,' + (isMobile ? 'MBL' : 'DSK');
            metadata.sd = duration;
            metadata.dur = duration;
            metadata.cg = seriesTitle;
            metadata.tl = contentTitle;
            metadata.videotype = 'content';
            metadata.guid = vs.cmsRefGuid;
            metadata.seriestitle = seriesTitle;
            metadata.episodetitle = videoTitle;
            metadata.isfullepisode = vs.episodeFlag ? 'y' : 'n';
            metadata.crossId1 = vs.mediaId;

            // IAG metadata.
            metadata.iag_pgm = videoTitle;
            metadata.iag_epi = contentTitle;
            metadata.iag_pd = location.hostname;
            metadata.iag_fp = form;
            metadata.iag_cte = 'na';
            metadata.iag_oad = 'na';
            metadata.iag_seg = 1;

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onContentDataLoaded metadata', metadata);
        },

        /**
         * AD_START event handler.
         *
         * @param {Object} evt Event data object.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _onAdStart: function (evt) {
            var vs = this.cviModel.getContentVideoState(), payload = evt.payload,
                ad, adIDParts, adTitle, adTypePrefix, adVatID, adVideoURL,
                iagID, numPodsInVideo, currentPodIndex, adMetadata;

            if (!payload) {
                return;
            }

            this._metadata.hasAds = 1;
            this._adDisplayed = true;

            // Clone the content metadata to mutate specifically for ads.
            // NOTE: Must set hasAds on the content metadata object before this.
            adMetadata = uvpjs._.clone(this._metadata);

            ad = payload.adData;
            adIDParts = ad.adClipID.split('_');
            adTypePrefix = adIDParts[0];
            numPodsInVideo = this.cviModel.getNumberOfAdPods();
            currentPodIndex = adTypePrefix === 'post' ? numPodsInVideo : ++adIDParts[1];

            adTitle = ['dav0', vs.videoTitle, vs.seasonNumber, vs.episodeNumber].join('-');
            iagID = [numPodsInVideo, currentPodIndex, this._numAdsInPod, adIDParts[2]].join('_');

            adVatID = ad.adVatId;
            adVideoURL = ad.adVideoUrl;
            if (adVatID !== '') adVideoURL += '|' + adVatID;

            // Add to cloned metadata with ad info.
            adMetadata.videotype = adTypePrefix + 'roll';
            adMetadata.iag_cte = adVideoURL;
            adMetadata.iag_pod = iagID;
            adMetadata.iag_apt = 'na';
            adMetadata.tl = adTitle;
            adMetadata.c3 = 'st,a';

            // Send the content metadata along before the preroll ad metadata.
            if (adTypePrefix === 'pre') {
                this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onAdStart sending content metadata.');
                this._notifySDK(this.events.LOAD_METADATA, this._metadata);
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onAdStart adMetadata', adMetadata);

            // TODO: Is this needed if the progress events handle content and ad
            //       tracking? Used in Flash codebase so porting over to here.
            this._lastAdSecond = 0;
            this._notifySDK(this.events.SET_PLAYHEAD_POSITION, this._lastAdSecond);

            this._notifySDK(this.events.LOAD_METADATA, adMetadata);
        },

        /**
         * AD_POD_START event handler.
         *
         * NOTE: Strictly responsible for getting the number of ads in the current
         *       pod, which is used later in the ad start event.
         *
         * @param {Object} evt Event data object.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _onAdPodStart: function (evt) {
            var payload = evt.payload;

            if (!payload) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onAdPodStart adCount', payload.adPod.adCount);

            this._numAdsInPod = payload.adPod.adCount;
        },

        /**
         * AD_END event handler.
         *
         * @param {Object} evt Event data object.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _onAdEnd: function (evt) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onAdEnd');

            this._adDisplayed = false;

            this._notifySDK(this.events.STOP, this._lastAdSecond);
        },

        /**
         * CONTENT_START event handler.
         *
         * @param {Object} evt Event data object.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _onContentStart: function (evt) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onContentStart');

            // For safety we'll reset the flag here.
            this._adDisplayed = false;

            this._metadata.hasAds = this._hasAds();

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onContentStart this._metadata', this._metadata);

            this._notifySDK(this.events.LOAD_METADATA, this._metadata);
        },

        /**
         * CONTENT_END event handler.
         *
         * @param {Object} evt Event data object.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _onContentEnd: function (evt) {
            var payload = evt.payload, cd;

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onContentEnd');

            if (!payload) {
                return;
            }

            // Increase content segment number.
            if (this._metadata.iag_seg) {
                this._metadata.iag_seg++;
            }

            cd = evt.payload.contentData;

            // True content end.
            if (cd.duration > 0 && Math.abs(cd.duration - this._lastContentSecond) <= 5) {
                this._notifySDK(this.events.END, this._lastContentSecond);
                return;
            }

            // Segment end.
            this._notifySDK(this.events.STOP, this._lastContentSecond);
        },

        /**
         * CONTROL_PLAY event handler.
         *
         * @param {Object} evt Event data object.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _onControlPlay: function (evt) {

            if (this._adDisplayed) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onControlPlay');

            this._notifySDK(this.events.PLAY, this._lastContentSecond);
        },

        /**
         * VIDEO_PROGRESS event handler. Fires 10 times per second. Update ad or
         * content time tracker variable and send ping at most once per second.
         *
         * @param {Object} evt Event data object.
         *
         * @memberof uvpjs.NielsenAgent#
         */
        _onVideoProgress: function (evt) {
            var payload = evt.payload,
                currentTime;

            if (!payload) {
                return;
            }

            // Round down to the nearest second.
            currentTime = Math.floor(payload.currentTime);

            // Avoid Nielsen "negative playhead position" error message.
            if (currentTime < 0) {
                return;
            }

            // Ad
            if (payload.isAd) {
                if (this._lastAdSecond === currentTime) {
                    return;
                }
                this._lastAdSecond = currentTime;
            }
            // Content
            else {
                if (this._lastContentSecond === currentTime) {
                    return;
                }
                this._lastContentSecond = currentTime;
            }

            // uvpjs.log(this.DEBUG_ID, 'NielsenAgent _onVideoProgress currentTime', currentTime);

            this._notifySDK(this.events.SET_PLAYHEAD_POSITION, currentTime);
        },

        /**
         * VIDEO_CUEPOINT event handler; accepts events identified as "nielsen" and sends ID3 tag (as text) via SDK
         * @memberof uvpjs.NielsenAgent#
         *
         * @param {Object} e               Event data object.
         * @param {Object} e.payload       Event payload object
         * @param {String} e.payload.name  Cuepoint type identifier
         * @param {String} e.payload.data  ID3 info
         */
        _onVideoCuepoint: function (e) {
            var p = e.payload,
                d = p.data;

            if (p.name === this.NIELSEN_VIDEO_CUEPOINT_NAME && d && typeof d === "string") {
                this._notifySDK(this.events.SEND_ID3, d);
            }
        },

        /**
         * Whether current video has ads.
         *
         * @memberof uvpjs.NielsenAgent#
         *
         * @returns {Integer} 0, 1, or 2.
         */
         _hasAds: function () {
            var numAdPods = this.cviModel.getNumberOfAdPods();

            // Unknown if ads exist.
            if (numAdPods === -1) {
                return 2;
            }

            // No ads.
            if (numAdPods === 0) {
                return 0;
            }

            // Has ads.
            return 1;
         },

        /**
         * Returns true if model indicates that nielsen tracking is to be excluded
         *
         * @memberof uvpjs.NielsenAgent#
         * @private
         *
         * @return {Boolean}
         */
        _isDisabled: function() {
            var exc = this.cviModel.contentVideoState.excludeNielsenTracking;

            return exc === 'true' || exc === true;
        },

    });

    var _isPluginAbsent = function () {
        return window.NOLCMB === undefined;
    };

}(uvpjs.register('uvpjs')));

'use strict';

(function (obj) {

    var _ = obj._,
        _objToStr,
        _paramsToStr,
        _tagsToStr;


    obj.DWAgent = uvpjs.Class.subClass({

        debug: uvpjs.Configuration.env !== 'production',

        LEGACY_DW_MODULE_NAME: 'CNetTracking',
        DW_MODULE_NAME: 'DWTracking',

        BASE_URL: '//dw.cbsi.com/levt/video/e.gif?',
        RESUME_BEACON_URL: '//dw.cbsi.com/levt/beacon/e.gif?',

        // Event names and their required tags.
        events: {
            INIT: 'init',         // All events: 'componentid', 'device', 'event', 'mapp', 'part', 'playertime', 'siteid', 'ts'
            START: 'start',        // All events but init: 'distntwrk', 'medastid', 'medid', 'medlength', 'mednum', 'medtime', 'sdlvrytyp', 'v22'
            END: 'end',
            PLAY: 'play',
            STOP: 'stop',
            FORWARD: 'forward',      // 'eventdur'
            REWIND: 'rewind',       // 'eventdur'
            PAUSE: 'pause',        // 'gestval'
            UNPAUSE: 'unpause',      // 'eventdur'
            FORCED_END: 'forced_end',   // 'gestval'
            RESUME: 'resume',       // 'gestval'
            BEACON: 'beacon',      // 'gestval'
            PROMPT: 'prompt',
            AD_BLOCK: 'beam',
            AD_STUCK: 'adstuck'
        },

        /**
         * @constructor uvpjs.DWAgent
         *
         * @param {Object}                  options
         * @param {uvpjs.TrackingManager}   options.trackingMgr TrackingManager instance.
         * @param {uvpjs.CVI_Model}         options.cviModel    CVIModel instance.
         * @param {uvpjs.EventsManager}     options.eventTypes  EventsManager event types.
         * @param {String}                  options.moduleName  Config module name.
         * @param {String}                  options.playerName  UVPJS player name.
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.TRACKING_MANAGER;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent init');

            this.trackingMgr = options.trackingMgr;
            this.cviModel = options.cviModel;
            this.eventsMgr = options.eventsMgr;
            this._moduleName = options.moduleName;
            this._playerName = options.playerName;

            this._gestval = {};
            this._pauseStart = 0;
            this._agentStartTime = 0;
            this._onInitDone = false;
            this._setStartTagsDone = false;

            this._tags = this._getDefaultTagsObj();
            this._pageParams = this._getDefaultPageParamsObj();
            this.gestureInfoStr = '';

            // Used by the Tracking Manager to determine if all SDKs are loaded. In this case,
            // there's no external SDK script to load so default to true.
            this.isPluginLoaded = true;
        },

        /**
         * @memberof uvpjs.DWAgent#
         */
        destroy: function () {
            this.trackingMgr = null;
            this.cviModel = null;
            this.eventsMgr = null;
            this._moduleName = null;
            this._playerName = null;
            this._tags = null;
            this._pageParams = null;
            this._onInitDone = false;
            this._setStartTagsDone = false;
            this.isPluginLoaded = true;
            this.gestureInfoStr = null;
        },

        /**
         * @param {Object} trackingMgr - reference to the Tracking Manager.
         * @memberof uvpjs.DWAgent#
         */
        initialize: function () {
            var ctag = this._tags.content;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent initialize');

            // All events include: 'componentid', 'device', 'event', 'mapp', 'part', 'playertime', 'siteid', 'ts'
            ctag.componentid = this.trackingMgr.componentid;
            ctag.device = this._getDevice();
            ctag.mapp = this._playerName; // Format UVPJS;1.0.0
            ctag.part = this.cviModel.getSessionOption('partner');
            ctag.playertime = 0;
            ctag.siteid = this.trackingMgr.DEFAULT_SITEID;
            ctag.ts = this.eventsMgr.sessionStartTime;

            this._loadConfigParams();
            this._loadDWPageParams();

            this._setupEventCallbacks();
            this._registerProgressEvents();

            this._onInit();
        },

        /**
         * Set CMS values.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _setCMSDependentValues: function () {
            var mdl = this.cviModel,
                cms = mdl.getSessionOption('cms'),
                vs = mdl.getContentVideoState(),
                ps = mdl.getCurrentPlaybackState(),
                mc = uvpjs.mediaCapabilities,
                ctag = this._tags.content,
                atag = this._tags.ad,
                tm = this.trackingMgr;

            atag.adastid = cms === tm.PLATFORM_CMS ? '43': '0';

            // if medastid already has a valid value, leave it alone...
            if (!uvpjs.util.isEmpty(ctag.medastid) && ctag.medastid !== 0 && ctag.medastid !== '0') return;

            if (vs.isLive) {
                if (vs.isAffiliateFeed) {
                    // live affiliate stream
                    ctag.medastid = mdl.getSessionOption('playerId') === 'cbsnews' ? '601' : '600';
                }
                else if (ps.isHDStreamLive || mc.isChromecast()) {
                    ctag.medastid = '601';
                }
                else {
                    ctag.medastid = '0';
                }
            }
            else {
                ctag.medastid = cms === tm.PLATFORM_CMS ? '595': '0';
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _setCMSDependentValues medastid, adastid', ctag.medastid, atag.adastid);
        },

        /**
         * Get data from the ConfigDataObject.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _loadConfigParams: function () {
            // Shortcut to CDO getModule method.
            var getParam = this.cviModel.getModuleParam.bind(this.cviModel, this._moduleName);

            // ConfigDataObject overrides to check.
            var params = [
                'adastid',
                'assetguid',
                'edid',
                'host',
                'medastid',
                'omnicookie',
                'onid',
                'pagetype',
                'ptid',
                'siteid',
                'topic',
                'topicbrcrm',
                'viewguid'
            ], i = params.length, type, key, param;

            while(i--) {
                key = params[i];
                type = this._getTagType(key);
                param = getParam(key);

                if (_.isUndefined(type) || _.isEmpty(param)) {
                    continue;
                }

                this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _loadConfigParams key', key, param);

                this._tags[type][key] = param;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _loadConfigParams this._tags updated', this._tags);
        },

        /**
         * Populate DW page parameters. Picks up page params from dw_global.js and dw_site.js
         *
         * @memberof uvpjs.DWAgent#
         *
         * @private
         */
        _loadDWPageParams: function () {
            var params = window.DW && window.DW.pageParams || {},
                key, type, param;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _loadDWPageParams');

            for (key in params) {

                if (!params.hasOwnProperty(key)) {
                    continue;
                }

                param = params[key];

                if ( _.isEmpty(param)) {
                    continue;
                }

                // Add to page params object.
                this._pageParams[key] = param;

                // Check tags object type.
                type = this._getTagType(key);

                if (_.isUndefined(type)) {
                    continue;
                }

                this._tags[type][key] = param;
            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'DWAgent _loadDWPageParams this._tags updated', this._tags);
                uvpjs.log(this.DEBUG_ID, 'DWAgent _loadDWPageParams this._pageParams updated', this._pageParams);
            }
        },

        /**
         * Assigns callbacks to specified events and registers them with the Tracking Manager.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _setupEventCallbacks: function () {
            var evtTypes = this.eventsMgr.eventTypes,
                evtCbs = {};

            evtCbs[evtTypes.AD_BLOCKED] = this._onAdBlocked.bind(this);
            evtCbs[evtTypes.AD_START] = this._onAdStart.bind(this);
            evtCbs[evtTypes.AD_END] = this._onAdEnd.bind(this);
            evtCbs[evtTypes.AD_QUARTILE] = this._onAdQuartile.bind(this);
            evtCbs[evtTypes.AD_ERROR] = this._onAdError.bind(this);
            evtCbs[evtTypes.CONTENT_START] = this._onContentStart.bind(this);
            evtCbs[evtTypes.CONTENT_END] = this._onContentEnd.bind(this);
            evtCbs[evtTypes.CONTROL_PAUSE] = this._onControlPause.bind(this);
            evtCbs[evtTypes.CONTROL_PLAY] = this._onControlPlay.bind(this);
            evtCbs[evtTypes.SEEK_DONE] = this._onSeekDone.bind(this);
            evtCbs[evtTypes.USER_GESTURE] = this._onUserGesture.bind(this);

            // Update playhead.
            evtCbs[evtTypes.VIDEO_PROGRESS] = this._onVideoProgress.bind(this);

            this.trackingMgr.registerEventCallbacks(evtCbs);

            // Detect if user stops the video prematurely.
            window && (window.onbeforeunload = this._onContentStop.bind(this));
        },

        /**
         * Listen for video playback progress events.
         * @memberof uvpjs.DWAgent#
         * @returns {Undefined} Undefined
         * @private
         */
        _registerProgressEvents: function () {
            var prgEvts = this.trackingMgr.progressEvents,
                evtCbs = {};

            evtCbs[prgEvts.FIRST_QUARTILE] = this._onProgressEvent.bind(this, prgEvts.FIRST_QUARTILE);
            evtCbs[prgEvts.MID_QUARTILE] = this._onProgressEvent.bind(this, prgEvts.MID_QUARTILE);
            evtCbs[prgEvts.THIRD_QUARTILE] = this._onProgressEvent.bind(this, prgEvts.THIRD_QUARTILE);
            evtCbs[prgEvts.TIMED] = this._onProgressEvent.bind(this, prgEvts.TIMED);

            this.trackingMgr.registerProgressEvents(evtCbs);
        },

        /**
         * Send DW event.
         * @param {Boolean} isAd - Parameter to indicate if an ad is playing.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _sendDWEvent: function (isAd) {
            var ctag = this._tags.content,
                evt = ctag.event,
                url = evt === this.events.BEACON ? this.RESUME_BEACON_URL : this.BASE_URL;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _sendDWEvent');

            // append this.gestureInfoStr or create gestval string.
            ctag.gestval = uvpjs.util.isDefinedString(this.gestureInfoStr) ? this.gestureInfoStr : _tagsToStr(this._gestval);

            // Update player time.
            (evt !== this.events.INIT) && (ctag.playertime = this._getPlayerTime());

            // Update timestamp.
            ctag.ts = +(new Date());

            // Append tags.
            url += _paramsToStr(ctag);

            // Append ad tags.
            isAd && (url += '&' + _paramsToStr(this._tags.ad));

            this.trackingMgr.fireTrackingPixel(url);

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _sendDWEvent url = ', url);

            // Cleanup.
            this._gestval = {};
            ctag.gestval = '';
            ctag.eventdur = 0;
            this.gestureInfoStr = '';
        },

        /**
         * On init.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onInit: function () {
            var location = window.location,
                mc = uvpjs.mediaCapabilities,
                omnicookie = mc.isMobile() ? 'mobile%20web' : 'desktop%20web',
                userStatus = this.cviModel.getSessionOption('userStatus'),
                userId = this.cviModel.getSessionOption('userId'),
                ctag = this._tags.content,
                pp = this._pageParams;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onInit');

            this._agentStartTime = new Date();

            ctag.event = this.events.INIT;
            ctag.mso = this.trackingMgr.mso;
            ctag.pageurl = location.href;
            ctag.srchost = location.host;
            ctag.ursuid = userId;
            ctag.v16 = pp.viewguid;
            ctag.v17 = pp.topic;
            ctag.v18 = pp.topicbrcrm;
            ctag.v19 = pp.pagetype;
            ctag.v20 = pp.assetguid;
            ctag.v21 = mc.isChromecast() ? 'chromecast' : omnicookie;
            ctag.v23 = pp.rsid;
            ctag.v25 = _.isEmpty(userStatus) ? 'anon' : userStatus;

            this._onInitDone = true;
            this._sendDWEvent();
        },

        /**
         * On progress event.
         * @param {String} progressEvt The progress event that fired.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onProgressEvent: function (progressEvt) {
            var evt = this.trackingMgr.progressEvents,
                ctag = this._tags.content,
                gval = this._gestval;

            // Don't fire play before init.
            if (!this._onInitDone || !this._setStartTagsDone) {
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onProgressEvent progressEvt', progressEvt);

            if (progressEvt) {
                switch (progressEvt) {
                    case evt.FIRST_QUARTILE:
                        gval.pct = 25;
                        break;
                    case evt.MID_QUARTILE:
                        gval.pct = 50;
                        break;
                    case evt.THIRD_QUARTILE:
                        gval.pct = 75;
                        break;
                }
            }

            ctag.event = this.events.PLAY;

            this._sendDWEvent();

            delete gval.pct;
        },

        // VTG-246 Add ad block event detection.
        /**
         * On ad blocked.
         * @param {Object} evtObj - Event object data.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onAdBlocked: function (evtObj) {
            var atag = this._tags.ad;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onAdBlocked', evtObj);

            this._setCMSDependentValues();
            this._setStartTags(evtObj);
            this._updateTimeTags();

            this._tags.content.event = this.events.AD_BLOCK;

            this._sendDWEvent(true);
        },

        /**
         * On ad start.
         * @param {Object} evtObj - Event object data.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onAdStart: function (evtObj) {
            var atag = this._tags.ad,
                data = evtObj.payload.adData,
                clipId = data.adClipID.split('_');

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onAdStart', evtObj);

            this._setCMSDependentValues();
            this._setStartTags(evtObj);
            this._updateTimeTags();

            atag.adid = !_.isEmpty(data.adVideoId) ? data.adVideoId : '999';
            atag.adnum = this.cviModel.adNum;
            atag.adtime = 0;
            atag.adtitle = data.adVideoTitle;
            atag.adtype = data.isLinear ? 1 : 2;

            atag.adlength = Math.floor(this.trackingMgr.getAdLength() / 1000); // Convert to seconds
            atag.adbreak = '';
            atag.adpos = clipId[0];
            atag.adpod = clipId[1];
            atag.adpodpos = clipId[2];

            this._sendDWEvent(true);
        },

        /**
         * On ad progress.
         * @param {Object} evtObj - Event object data.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onAdQuartile: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onAdQuartile', evtObj);

            this._tags.content.event = this.events.PLAY;
            this._tags.ad.adtime = this.cviModel.adPlaybackState.currentTime;
            this._sendDWEvent(true);
        },

        /**
         * On ad end.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onAdEnd: function (evtObj) {
            var data = evtObj.payload.adData;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onAdEnd', evtObj);

            this._tags.content.event = this.events.END;
            this._tags.ad.adtime = data.duration;
            this._sendDWEvent(true);
        },

        /**
         * On ad error.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onAdError: function (evtObj) {
            var errorCode = evtObj.payload.errorInfo.errorCode;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onAdError', evtObj);
            if (errorCode === uvpjs.ErrorInfo.errorCodes.STUCK_AD_ERROR) {
                this._tags.content.event = this.events.AD_STUCK;
                this._sendDWEvent(true);
            }
        },

        /**
         * Set content or ad start data.
         * @param {Object} evtObj - Event object data.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _setStartTags: function (evtObj) {
            var mdl = this.cviModel,
                vs = mdl.getContentVideoState(),
                ctag = this._tags.content,
                gval = this._gestval;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _setStartTags', evtObj);

            ctag.event = this.events.START;
            ctag.codec = vs.fileType;
            ctag.distntwrk = mdl.getSessionOption('netwk');
            ctag.playersz = this._getPlayerSize();
            ctag.sdlvrytype = this._getStreamType();
            ctag.v22 = vs.cmsRefGuid;

            ctag.medid = vs.mediaId;
            ctag.medlength = this.trackingMgr.getContentLength() / 1000; // Convert to seconds
            ctag.mednum = mdl.medNum;
            ctag.medrls = vs.pid;
            ctag.medtitle = vs.videoTitle;
            ctag.contsessid = vs.previousSessionId;

            if (!_.isEmpty(vs.contPlayState)){
                gval.autoplay = vs.contPlayState;
            }

            gval.paywall = vs.isPaidContent ? '1' : '0';
            gval.caption_available = vs.closedCaptionPath? '1' : '0';

            this._setStartTagsDone = true;
        },

        /**
         * On content start.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onContentStart: function (evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onContentStart', evtObj);

            this._setCMSDependentValues();
            this._updateTimeTags();
            this._setStartTags(evtObj);
            this._sendDWEvent();
        },

        /**
         * On content end.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onContentEnd: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onContentEnd');

            this._tags.content.event = this.events.END;

            this._sendDWEvent();
        },

        /**
         * On content stop.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onContentStop: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onContentStop');

            this._tags.content.event = this.events.STOP;

            this._sendDWEvent();
        },

        /**
         * On control pause.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onControlPause: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onControlPause');

            this._tags.content.event = this.events.PAUSE;

            this._gestval.action = 'pause';
            this._pauseStart = new Date().getTime();

            this._sendDWEvent();
        },

        /**
         * On control play (unpause).
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onControlPlay: function () {
            var ctag = this._tags.content;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onControlPlay');

            // Don't fire play before init.
            if (!this._onInitDone || !this._setStartTagsDone || this._pauseStart <= 0) {
                return;
            }

            ctag.eventdur = Math.floor((new Date().getTime() - this._pauseStart)/1000);
            ctag.event = this.events.UNPAUSE;

            this._gestval.action = 'resume';
            this._pauseStart = 0;

            this._sendDWEvent();
        },

        /**
         * On control seek.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onSeekDone: function (evtObj) {
            var payload = evtObj && evtObj.payload,
                seekFromTime = payload && payload.seekFromTime,
                seekToTime = payload && payload.seekToTime,
                seekDuration = seekToTime - seekFromTime,
                ctag = this._tags.content;

            // Seeking complete.
            ctag.eventdur = Math.floor(Math.abs(seekDuration));
            ctag.event = seekDuration > 0 ? this.events.FORWARD : this.events.REWIND;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onSeekDone ' + JSON.stringify({
                seekFromTime: seekFromTime,
                seekToTime: seekToTime,
                seekDuration: seekDuration,
                event: ctag.event,
                eventdur: ctag.eventdur
            }, null, 2));

            this._updateTimeTags();
            this._sendDWEvent();
        },

        /**
         * On video progress.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _onVideoProgress: function () {
            this._updateTimeTags();
        },

        /**
         * User Gesture event.
         *
         * @memberof uvpjs.DWAgent
         * @param {Object} evtObj - UVPJS Event Object.
         * @private
         */
        _onUserGesture: function (evtObj) {
            var ctag = this._tags.content,
                gval = this._gestval,
                gestInfo = evtObj.payload.gestureInfo, // Array [gestureType, info1, info2, ...] or String 'event=someEvent&gestval=someGestVal:getValAttribute...'
                cvs = this.cviModel.contentVideoState,
                time = cvs.elapsedTime,
                gest = '',
                gestTypes = uvpjs.Type.Gesture,
                addressArray, sender, recipient, regex, match, event, gestval;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _onUserGesture evtObj = ', evtObj);

            // test for string argument case and return if it doesn't contain 'event=' which is required.
            if (typeof gestInfo === 'string' && gestInfo.indexOf('event=') === -1) {
                uvpjs.log(this.DEBUG_ID, 'DWAgent _onUserGesture gestureInfo is a String and missing event=, RETURN.');
                return;
            }

            if (_.isArray(gestInfo)) {

                if (gestInfo.length < 1) {
                    uvpjs.log(this.DEBUG_ID, 'DWAgent _onUserGesture gestureInfo is an empty Array, RETURN.');
                    return;
                } else {
                    gest = gestInfo[0];
                }

            }

            cvs = this.cviModel.contentVideoState;

            if (typeof gestInfo === 'string') {

                regex = /event=([^&]*)(?:&gestval=(.*))?/;
                match = regex.exec(gestInfo);
                event = match[1];
                gestval = match[2];

                // console.log('event = ' + event + '\ngestval = ' + gestval);

                ctag.event = event;
                ctag.medtime = this.cviModel.contentPlaybackState.currentTime;

                this.gestureInfoStr = typeof gestval === 'undefined' ? '' : gestval;

            } else if (gest === gestTypes.GLOBAL_RESUME || gest === gestTypes.LOCAL_RESUME) {

                gval.prevcomponentid = cvs.previousSessionId;
                gval.eventdur = time > 0 ? Math.round(time / 1000) : 0;
                gval.paywall = cvs.isPaidContent ? '1' : '0';
                ctag.event = this.events.RESUME;
                ctag.medtime = cvs.resumeContentTime;

            } else if (gest === gestTypes.CONT_CANCEL) {

                gval.action = this.events.PROMPT;

            } else {

                ctag.medtime = this.cviModel.contentPlaybackState.currentTime;

                switch (gest) {

                    case gestTypes.RELATED_OVERLAY:
                        ctag.event = gestTypes.RELATED_OVERLAY;
                        break;

                    case gestTypes.RELATED_CLICK_GESTURE:

                        if (gestInfo.length >= 2  ) {
                            gval.related_pid = gestInfo[1];
                        }
                        ctag.event = gestTypes.RELATED_CLICK_GESTURE;
                        break;

                    case gestTypes.SHARE_OVERLAY:
                        ctag.event = gestTypes.SHARE_OVERLAY;
                        break;

                    case gestTypes.SHARE_NETWORK_GESTURE:

                        if (gestInfo.length >= 2  ) {
                            gval.network = gestInfo[1];
                        }
                        ctag.event = gestTypes.SHARE_NETWORK_GESTURE;
                        break;

                    case gestTypes.SEND_GESTURE:

                        if (gestInfo.length >= 2  ) {
                            addressArray = gestInfo[1].split(",");
                            sender = addressArray.shift();
                            recipient =  addressArray.join(",");
                            gval.sender = sender;
                            gval.recipient = recipient;
                        }
                        ctag.event = gestTypes.SEND_GESTURE;
                        break;

                    case gestTypes.EMBED_GESTURE:
                        ctag.event = gestTypes.EMBED_GESTURE;
                        break;

                    case gestTypes.LINK_GESTURE:
                        ctag.event = gestTypes.LINK_GESTURE;
                        break;

                    case gestTypes.REPLAY_GESTURE:
                        ctag.event = gestTypes.REPLAY_GESTURE;
                        break;

                    case gestTypes.END_CARD_OVERLAY:
                        ctag.event = gestTypes.END_CARD_OVERLAY;
                        break;

                    case gestTypes.ERROR_OVERLAY:
                        ctag.event = gestTypes.ERROR_OVERLAY;
                        break;

                    case gestTypes.RECOMMEND_NOW:

                        if (gestInfo.length >= 3  ) {
                            gval.mediaid = gestInfo[1];
                            gval.pid = gestInfo[2];
                        } else {
                            gval.mediaid = '';
                            gval.pid = '';
                        }
                        ctag.event = gestTypes.RECOMMEND_NOW;
                        break;

                    case gestTypes.RECOMMEND_NEXT:

                        if (gestInfo.length >= 3  ) {
                            gval.mediaid = gestInfo[1];
                            gval.pid = gestInfo[2];
                        } else {
                            gval.mediaid = '';
                            gval.pid = '';
                        }
                        ctag.event = gestTypes.RECOMMEND_NEXT;
                        break;

                    case gestTypes.RECOMMEND_CLOSE:
                        ctag.event = gestTypes.RECOMMEND_CLOSE;
                        break;

                    default:
                        uvpjs.warn(this.DEBUG_ID, 'DWAgent _onUserGesture untrapped GESTURE Type = ', gest);
                        return;
                        break;
                }

            }

            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'DWAgent _onUserGesture ctag = ',ctag);
                uvpjs.log(this.DEBUG_ID, 'DWAgent _onUserGesture gval = ',gval);
            }

            this._sendDWEvent();
        },

        /**
         * On video state change.
         * @todo This may not be needed or used.
         * @memberof uvpjs.DWAgent#
         * @private
         */
        _updateTimeTags: function () {
            this._tags.content.medtime = this.trackingMgr.getContentPlayhead();
        },


        ////////////////
        // Getters

        /**
         * Get the type of tag.
         * @param {String} tag Tag to lookup.
         * @memberof uvpjs.DWAgent#
         * @returns {String} Parent object name.
         * @private
         */
        _getTagType: function (tag) {
            if (_.has(this._tags.ad, tag)) {
                return 'ad';
            }

            if (_.has(this._tags.content, tag)) {
                return 'content';
            }
        },

        /**
         * Get the type of video stream. Possible return values:
         *     1 - On Demand streaming
         *     2 - Live streaming
         *     3 - Progressive download ( http file download)
         *     4 - HTTP Streaming (Apple Proprietary M3U8) //not currently used by desktop
         *     5 - HTTP Streaming (Live)
         *     6 - Live Streaming segment (Live Channel) //only set on LIVE_SEGMENT_START events
         *     7 - DVR Streaming segment (Live Channel)
         * @memberof uvpjs.DWAgent#
         * @returns {Number} Number used to identify stream type.
         * @todo This is only a partial implementation.
         * @private
         */
        _getStreamType: function () {
            var vs = this.cviModel.getContentVideoState(),
                mc = uvpjs.mediaCapabilities,
                deliveryType = vs.deliveryType,
                isLive = vs.isLive;

            if (deliveryType === mc.STREAMING) {
                if (isLive) {
                    return 5;
                }
                return 4;
            }

            if (deliveryType === mc.PROGRESSIVE) {
                return 3;
            }
        },

        /**
         * Return the time in seconds since the DW 'init' event.
         * @memberof uvpjs.DWAgent#
         * @returns {Number} Elapsed time in seconds.
         * @private
         */
        _getPlayerTime: function () {
            var st = this._agentStartTime,
                nt = (_.isDate(st) && parseInt(((new Date()) - st) / 1000)) || 0;

            this.debug && uvpjs.log(this.DEBUG_ID, 'DWAgent _getPlayerTime nt', nt);

            return nt;
        },

        /**
         * Returns an initialized set of DW tags
         *
         * @memberof uvpjs.DWAgent#
         *
         * @private
         *
         * @returns {Object}
         */
        _getDefaultTagsObj: function () {
            // Tags from Data Warehouse 'Lite Event Media Streaming Tag Definitions' page.
            // https://sites.google.com/a/cbsinteractive.com/dw/tracking-central/video-tracking/3rd-party-video-audio-stream-tracking/lite-event-media-streaming-tag-definitions
            return {
                ad: {
                    adastid: 0,         // Ad Asset Type of the streaming asset described by adid. This represent the source of the Ad content system. The list of Asset Type IDs are maintained by the DW group. For CAN or Sports Ads using Dart, the adastid=43, for Madison Video Ads the adastid=400
                    adbreak: '',        // A comma delimited set of timecodes where ads will appear during the stream.
                    adid: 0,            // Ad Asset ID, the Creative ID of the Ad being played.
                    adlength: 0,        // Ad Length, duration length of an Ad being streamed in seconds.
                    adnum: 0,           // The count of number of ads that have been played in this piece of content. For each ad the adnum would increment by 1
                    adpod: 0,           // The number that identifies a Unique Ad Pod occurrence within a media stream. .
                    adpodpos: 0,        // The poisition of an ad stream within an Ad Pod
                    adpos: '',          // Ad Position, The position of the ad as it relates to the video. Valid values are 'pre'.'mid', and 'post'
                    adtime: 0,          // The current position in the ad. Value is marked in seconds
                    adtitle: '',        // Ad Asset Title of the streaming ad.
                    adtype: 0           // Ad Type, dentoes if an AD is a linear type Ad or a non linear type. See below for values.
                },
                content: {
                    bitrate: 0,         // Numeric Video bitrate of the Media Stream
                    blockcntry: '',     // Value of the blocked country passed during a blocked event
                    codec: '',          // Name of the codec used for the Media Stream flv, mp4
                    componentid: '',    // Player ID, Unique MD5 value that identifies an instance of a player. This ID needs to be generated by the player.
                    contsessid: '',     // Continuous Session ID. Unique MD5 value that identifies a video as belonging to a continuous play session.
                    device: '',         // Delimited name value pair that contains information about the device. i.e. Type, OS, ScreenSize?
                    distntwrk: '',      // A distribution network identifies a media publishing system that can cross web sites/properties through distributed players or feeds. See below section for possible values.
                    encodeprfl: '',     // Encoding Profile, Name of the encoding profile of the stream. (240p, 360p, 480p, 720p, 1020p)   240p, 360p, 480p, 720p, 1020p
                    event: '',          // Type of event/action being tracked. For Video the events are (init, start, play, end, forward, rewind, fullScreen, normalScreen, pause, unpause, volume, geoblock, adblock). See Tracking spec for a complete list of supported evetns
                    eventdur: 0,        // Event Duration. the time in seconds an event took place. Evenets that would have a duration would be Forward, Rewind, Pause. Fast forward/Reverse duration is equal to difference between the Asset Time - New positioned Asset Time. Pause/Unpause equal the amount of time between a Pause and Unpause event
                    gestval: '',        // Gesture Value. Used to store nvp of customized attributes associated with a user gesture.
                    ip: '',             // IP Override
                    mapp: '',           // The Media App tag is used to capture the media player the video/audio stream was played in. It consists of the Player name followed by the version of the player with a semi colon delimiting the values. i.e. CANWIN;9.0.159
                    medastid: 0,        // Asset Type of the streaming asset described by medid. This represent the source of the video/audio content system or CMS. The list of Asset Type IDs are maintained by the DW group.
                    medid: 0,           // Media ID, is the unique Video/Media ID of the media being played as defined by the source content system.
                    medlength: 0,       // Media Length, duration length of the content media being streamed in seconds. This is needed for calculating stream percentages.
                    mednum: 0,          // Media num, the count of pieces of content that have been played in this instance of the player. For each video played the mednum would increment.
                    medrls: '',         // Media Release Identifier, is a unique identifer used for release level meta data. It's specific to videos sourced from the CAN Platform or any cms where the release concept is used.
                    medtime: 0,         // Media Time, the current position in the stream. Value is marked in seconds
                    medtitle: '',       // Media Title of the streaming content video/audio. The title gives insight to video consumption for Executive level reporting without relying on customized ETL from the various CMS.
                    medtype: 0,         // Identifier of media type.
                    mso: '',            // Authentication multiple system operator code. Identifies the MSO used for authentication for a video stream.
                    pageurl: '',        // URL of the page the player is located on
                    part: '',           // A unique alphanumeric identifier for the partner. For Referring Partners, the identifier must be registered in advance for proper processing. Otherwise, it will be ignored. Note: for video tracking this is used to track the distribution partner and will map to the referring parter as well as the partner_cd
                    playerembed: 0,     // Player Embed flag, denotes whether the player is embeded. Values are 1 for true, 0 for false    1,0
                    // playerloc: '',   // Location of player on page. -- 2014-10-08 - Deprecated and no longer used
                    playersz: '',       // Player Size, the width and height of the player in pixels.
                    playertime: 0,      // Player Time, elapsed time in seconds since the player was initiated (for the init event this will be set zero).
                    qosnum: 0,          // QOS (Quality of Service)Event Number use to tie QOS Events together such as a start an complete event.
                    recommend: '',      // Indicates that the Media stream being played is a recommend/related video. It either can be manual or auto selected. NOTE:TAG IS NOT IMPLEMENTED. WAITING ON FULL REQUIRMENTS.  auto/man
                    relsessid: '',      // Related Session ID. A unique MD5 hash value used to link continuous media streams together. NOTE:TAG IS NOT IMPLEMENTED. WAITING ON FULL REQUIRMENTS.
                    sdlvrytype: '',     // Stream Delivery Type of streaming video/audio i.e. Progressive download ( http file download) , On Demand streaming, Live streaming. 1 - On Demand streaming, 2 - Live streaming.
                    siteid: 0,          // The siteid is the DW assigned site ID of theinternal CBSi site initiating or distributing the video stream. If the site id is passed or set in the player config, then the UVP player will default the site id to a value of 17.
                    sponsored: '',      // Indicates that the Media stream is being sponsered. NOTE:TAG IS NOT IMPLEMENTED. WAITING ON FULL REQUIRMENTS.   1,0
                    srchost: '',        // The host name of the site on which the event is being tracked. For Video tracking this would be the site containing the player. Note that this is required and is important for tracking embedded videos
                    subj: '',           // Free-form string (30 characters or less). Can be used to pass additional identifying information about the incoming link or referring site.
                    ts: '',             // Time stamp used as a Cache Buster. Could also be a radom generated number
                    ua: '',             // User Agent Override
                    ursuid: 0,          // Registered user unique ID.
                    usrbndwdth: 0,      // Users initial bandwidth. This will allow insightinto what bandwidth the audience is capable of. If there is value in seeing bandwidth changes during a stream may pass on all event calls
                    v16: '',            // View Guid
                    v17: '',            // Topic Guid
                    v18: '',            // Topic Hierarchy Path
                    v19: '',            // Page Type Desc
                    v20: '',            // Page Asset Guid
                    v21: '',            // Experience (Omniture eVar3)
                    v22: '',            // v22, is the unique Video/Media GUID or Alphanumeric Identifier of the media being played as defined by the source content system. This is required if there is no medid tag being passed.
                    v23: '',            // Omniture Report Suite ID
                    v25: '',            // User Subscription Status (Subway)
                    v26: '',            // Subscription Package (Subway)
                    videosz: '',        // Video Size in pixel in the format Width x Height (videosz=640x360)
                    volume: 0           // Adjusted volume value. Value is a decimal value ranging from 1 to 0
                }
            };
        },

        /**
         * Returns an initialized set of DW page params.
         *
         * @memberof uvpjs.DWAgent#
         *
         * @private
         *
         * @returns {Object}
         */
        _getDefaultPageParamsObj: function () {
            return {
                asid: 0,            // Asset ID of the source page that contains the video
                astid: 0,           // Asset Type of the asset described by asid.
                cid: 0,             // Content ID.
                edid: 0,            // Edition ID.
                onid: 0,            // Ontology Node ID. Same as ontid for leads and non-leads.
                pguid: '',          // Page GUID is a unique identifier for a page load (generated & filled into the c.gif call by Apache Vars). It is sent to madison so that any ad that showed up on the page will have the same guid which links to that page impression.'
                pid: 0,             // Product ID.
                ptid: 0,            // Pagetype ID that the video stream appeared on.
                siteid: 0,          // The CBS site initiating or distributing the video stream.
                testgroup: '',      // The test bucket this event falls into
                testname: '',       // Denotes the overarching name of the test being performed on the live site
                testversion: '',    // The version of the test being run
                ursuid: 0,          // Registered user unique ID.

                // From Hi5, but not in Keric's notes.
                assetguid: 0,
                omnicookie: '',
                pagetype: '',
                rsid: 0,
                topicbrcrm: '',
                topicguid: '',
                viewguid: 0
            };
        },

        /**
         * Get device string.
         * @memberof uvpjs.DWAgent#
         * @returns {String} Device string for this._tags.content.device.
         * @private
         */
        _getDevice: function () {
            var mc = uvpjs.mediaCapabilities,
                sn = window.screen;

            var params = {
                type: (mc.getDevice() || '').toLowerCase(),
                os: (mc.getOS() || '').toLowerCase(),
                ver: mc.getOSVersion(),
                screensz: [sn.width, sn.height].join('x')
            };

            return _tagsToStr(params);
        },

        /**
         * Get player size.
         * @memberof uvpjs.DWAgent#
         * @returns {String} Player size for this._tags.content.playersz.
         * @private
         */
        _getPlayerSize: function () {
            var vs = this.cviModel.getContentVideoState();
            return [vs.sourceWidth, vs.sourceHeight].join('x');
        },
    });


    ////////////////
    // Helpers

    /**
     * Convert object of key-value pairs to a string.
     * @param {Object} items Object to convert.
     * @param {String} innerDelim Delimiter between key-value pairs.
     * @param {String} outerDelim Delimiter between items.
     * @returns {String} Key-value pair delimited string.
     * @private
     */
    _objToStr = function (items, innerDelim, outerDelim) {
        var output = [], p, val;
        for (p in items) {
            if (items.hasOwnProperty(p)) {
                val = !_.isUndefined(items[p]) ? encodeURIComponent(items[p]) : '';
                output.push([p, val].join(innerDelim));
            }
        }

        return output.join(outerDelim);
    };

    /**
     * Shortcut function for converting multiple params into a deilmited string.
     * @param {Object} items Object to convert.
     * @returns {String} Key-value pair delimited string.
     * @private
     */
    _paramsToStr = function (items) {
        return _objToStr(items, '=', '&');
    };

    /**
     * Shortcut function for converting multiple tags into a delimited string.
     * @param {Object} items Object to convert.
     * @returns {String} Key-value pair delimited string.
     * @private
     */
    _tagsToStr = function (items) {
        return _objToStr(items, ':', ';');
    };

}(uvpjs.register('uvpjs')));

/**
 * Created by ldoyle on 10/5/16.
 */


'use strict';

(function (obj) {

    var _isPluginAbsent,
        _;

    _ = obj._;

    /**
     * @constructor uvpjs.AkamaiAnalyticsAgent
     * @extends uvpjs
     *
     * add ?AkamaiAnalytics_debug=1 to the test page url to enable debugging
     * //control.akamai.com/dl/MediaAnalytics/IntWebHelp/Output/JSInteg_GenAPIs/JS_Integration_UsingGenericAPIs.htm
     *
     */

    obj.AkamaiAnalyticsAgent = uvpjs.Class.subClass({

        debug: uvpjs.Configuration.env !== 'production',

        LIB_PATH: '//79423.analytics.edgesuite.net/js/csma.js',
        CONFIG_FILE_PATH:'//ma61-r.analytics.edgekey.net/config/beacon-16339.xml?enableGenericAPI=1',
        AKAMAI_ANALYTICS_MODULE_NAME: 'AkamaiQOSPluginJS',

        /**
         * @constructor uvpjs.AkamaiAnalyticsAgent
         *
         * @param {Object}                  options
         * @param {uvpjs.TrackingManager}   options.trackingMgr TrackingManager instance.
         * @param {uvpjs.CVI_Model}         options.cviModel    CVIModel instance.
         * @param {uvpjs.EventsManager}     options.eventTypes  EventsManager event types.
         * @param {String}                  options.moduleName  Config module name.
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            this.DEBUG_ID = uvpjs.DebugManager.configParams.TRACKING_MANAGER;

            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent init');

            this.trackingMgr = options.trackingMgr;
            this.cviModel = options.cviModel;
            this.eventsMgr = options.eventsMgr;
            this._moduleName = options.moduleName;

            this.isPluginLoaded = false;
            this.buffering = false;
            this.pluginLoadedCB = Function.prototype;
            this.akamaiPlugin = null;
        },

        /**
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        destroy: function() {
            this.trackingMgr = null;
            this.eventsMgr = null;
            this.cviModel = null;
            this._moduleName = null;
            this.isPluginLoaded = false;
            this.buffering = false;
            this.pluginLoadedCB = Function.prototype;
            this.akamaiPlugin = null;
        },

        /**
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        initialize: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent initialize');

            this.buffering = false;
            this.loadPlugin(this._initializePlugin.bind(this));
        },

        /**
         * Load plugin into the page.
         * @param {Function} callback - Plugin loaded callback.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        loadPlugin: function(callback, CDO) {
            var libpath = (CDO && CDO.getModuleParam(this._moduleName, 'libpath')) || this.LIB_PATH;

            if (uvpjs.mediaCapabilities.isSecure()) {
                libpath = libpath.replace('edgesuite', 'edgekey');
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent loadPlugin CDO = ', CDO);

            if (!_.isFunction(callback)) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'AkamaiAnalyticsAgent loadPlugin no callback supplied.');
                return;
            }

            this.pluginLoadedCB = function () {
                this.isPluginLoaded = true;
                callback();
            }.bind(this);

            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent loadPlugin libpath = ', libpath);

            // Grab SDK scripts if they're not loaded into the page.
            if (_isPluginAbsent() && !this.isPluginLoaded) {
                this.codeLoader = new uvpjs.CodeLoader();
                this.codeLoader.loadScript(libpath, this.pluginLoadedCB);
                return;
            }

            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent loadPlugin plugin already loaded into the page');

            this.pluginLoadedCB();
        },

        /**
         * Assigns callbacks to specified events and registers them with the Tracking Manager.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        _setupEventCallbacks: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _setupEventCallbacks');

            var eventTypes = this.eventsMgr.eventTypes,
                callbackObj = {};

            callbackObj[eventTypes.CONTENT_DATA_LOADED] = this._onContentDataLoaded.bind(this);
            callbackObj[eventTypes.AD_START] = this._onAdStart.bind(this);
            callbackObj[eventTypes.AD_END] = this._onAdEnd.bind(this);
            callbackObj[eventTypes.CONTENT_START] = this._onContentStart.bind(this);
            callbackObj[eventTypes.AD_QUARTILE] = this._onAdQuartile.bind(this);
            callbackObj[eventTypes.CONTENT_END] = this._onContentEnd.bind(this);
            callbackObj[eventTypes.CONTROL_PLAY] = this._onControlPlay.bind(this);
            callbackObj[eventTypes.CONTROL_PAUSE] = this._onControlPause.bind(this);
            callbackObj[eventTypes.VIDEO_STATE_CHANGE] = this._onVideoStateChange.bind(this);
            callbackObj[eventTypes.RESOURCE_END] = this._onResourceEnd.bind(this);
            callbackObj[eventTypes.QOS_METADATA] = this._onQosMetadata.bind(this);

            this.trackingMgr.registerEventCallbacks(callbackObj);
        },

        /**
         * LoadPlugin callback. Setup instance of the Akamai Analytics plugin.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        _initializePlugin: function() {
            var akamaiPluginCallBack = {};

            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _initializePlugin loadPlugin callback');

            // Sanity check for possible error conditions grabbing scripts.
            if (_isPluginAbsent()) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'AkamaiAnalyticsAgent SDK not properly loaded.');
                return;
            }

            akamaiPluginCallBack.configPath = this.cviModel.getModuleParam(this._moduleName, 'configpath') || this.CONFIG_FILE_PATH;
            akamaiPluginCallBack.streamHeadPosition = this.getStreamHeadPosition.bind(this);
            akamaiPluginCallBack.streamLength = this.getStreamLength.bind(this);
            akamaiPluginCallBack.streamURL = this.getStreamURL.bind(this);

            this.akamaiPlugin = new AkaHTML5MediaAnalytics(akamaiPluginCallBack);

            this._setupEventCallbacks();
        },

        /**
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         *
         */
        setAdMetaData: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent setAdMetaData'); // Akamai Documentation props   adDuration, adTitle, adCategory, adPartnerId, adServer, adDaypart, adIndustryCategory, adEvent

            var avs = this.cviModel.adVideoState;
            var adObject = {};
            adObject.adTitle = avs.adVideoTitle;
            adObject.adDuration = avs.duration;
            adObject.id = avs.adVideoId;
            adObject.adPartnerId = this.cviModel.sessionOptions.partner;
            adObject.adServer = avs.adServerName;

            this.akamaiPlugin.handleAdLoaded(adObject);
        },

        /**
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         *
         */
        setContentMetaData: function() {
            var mdl = this.cviModel,
                opts = mdl.sessionOptions,
                plugin = this.akamaiPlugin,
                vs = mdl.getContentVideoState(),
                ps = mdl.getContentPlaybackState();

            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent setContentMetaData');

            // VTG-328: This may be a preferred approach at some point, but not now. See ticket for details.
            //akamaiSetViewerId(mdl.getModuleParam(this._moduleName, 'viewerID'));

            plugin.setData('viewerId', mdl.getModuleParam(this._moduleName, 'viewerID'));
            plugin.setData('partnerId', opts.partner);
            plugin.setData('playerId', this.trackingMgr.getPlayerName('|'));
            plugin.setData('Host', opts.host);
            plugin.setData('Referrer', opts.referrer);
            plugin.setData('title', vs.title);
            plugin.setData('category', vs.category);
            plugin.setData('subCategory', vs.sourceOwner);
            plugin.setData('show', vs.title);
            plugin.setData('contentLength', ps.duration * 1000);
        },


        //              Akamai Analytics Plugin Callbacks          //


        /**
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @returns {String} The content asset url.
         */
        getStreamHeadPosition: function() {
            // uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent getStreamHeadPosition return this.cviModel.contentPlaybackState.currentTime ', this.cviModel.contentPlaybackState.currentTime);// warning high console output log statement
            return this.cviModel.contentPlaybackState.currentTime;
        },

        /**
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @returns {String} Video stream duration.
         */
        getStreamLength: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent getStreamLength this.cviModel.contentPlaybackState.duration ', this.cviModel.contentPlaybackState.duration);

            return this.cviModel.contentPlaybackState.duration;
        },

        /**
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @returns {String} The content asset url.
         */
        getStreamURL: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent getStreamURL this.cviModel.contentVideoState.assetURL ', this.cviModel.contentVideoState.assetURL);

            return this.cviModel.contentVideoState.assetURL;
        },

        // todo this.akamaiPlugin.handleBitRateSwitch(newBitRate); //newBitRate in bits/sec


        //              UVPJS Event Callbacks                    //


        /**
         * On content data loaded.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @param {Object} evtObj UVPJS event object.
         * @returns {Undefined} Undefined
         */
        _onContentDataLoaded: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onContentDataLoaded evtObj = ', evtObj);

            if (!this.akamaiPlugin) {return;}

            this.akamaiPlugin.handleSessionInit();
            this.setContentMetaData();
        },

        /**
         * On ad start.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        _onAdStart: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onAdStart');

            if (!this.akamaiPlugin) {return;}

            this.setAdMetaData();
            this.akamaiPlugin.handlePlaying();
            this.akamaiPlugin.handleAdStarted();
        },

        /**
         * Ad Quartiles
         * @param {Object} evtObj UVPJS event object.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        _onAdQuartile: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onAdQuartile this.akamaiPlugin.handleAdFirstQuartile() evtObj.payload ', evtObj.payload);

            if (!this.akamaiPlugin) {return;}

            if (evtObj.payload) {
                switch (evtObj.payload.percent) {
                    case 25:
                        this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent this.akamaiPlugin.handleAdFirstQuartile()');
                        this.akamaiPlugin.handleAdFirstQuartile();
                        break;
                    case 50:
                        this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent this.akamaiPlugin.handleAdMidPoint()');
                        this.akamaiPlugin.handleAdMidPoint();
                        break;
                    case 75:
                        this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent this.akamaiPlugin.handleAdThirdQuartile()');
                        this.akamaiPlugin.handleAdThirdQuartile();
                        break;
                }
            }
        },

        /**
         * On ad end.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        _onAdEnd: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onAdEnd this.akamaiPlugin.handleAdCompleted()  this.akamaiPlugin.handleAdStopped();');

            if (!this.akamaiPlugin) {return;}

            this.akamaiPlugin.handleAdCompleted();
            this.akamaiPlugin.handleAdStopped();
        },

        /**
         * On ad error. (unimplmented)
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         */
        _onAdError: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onAdError this.akamaiPlugin.handleAdError() this.akamaiPlugin.handleAdStopped();');

            if (!this.akamaiPlugin) {return;}

            this.akamaiPlugin.handleAdError();
            this.akamaiPlugin.handleAdStopped();
        },

        /**
         * On content start.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @returns {Undefined} Undefined
         */
        _onContentStart: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onContentStart');

            if (!this.akamaiPlugin) {return;}

            this.akamaiPlugin.handlePlaying();
        },

        /**
         * On content end.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @returns {Undefined} Undefined
         */
        _onContentEnd: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onContentEnd');
        },

        /**
         * On control play.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @returns {Undefined} Undefined
         */
        _onControlPlay: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onControlPlay this.akamaiPlugin.handleResume()');

            if (!this.akamaiPlugin) {return;}

            this.akamaiPlugin.handleResume();
        },

        /**
         * On control pause.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @returns {Undefined} Undefined
         */
        _onControlPause: function() {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onControlPause  this.akamaiPlugin.handlePause()');

            if (!this.akamaiPlugin) {return;}

            this.akamaiPlugin.handlePause();
        },

        /**
         * On video state change.
         * newState can be EMPTY:-2, LOADING:-1, STOPPED:0, PLAYING:1, PAUSED:2, BUFFERING:3, DATA_LOADING_ERROR_STATE:130, VIDEO_NOT_AVAILABLE_ERROR_STATE:110, GEO_BLOCK_ERROR_STATE:120
         * @param {Object} evtObj UVPJS event object.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         * @returns {Undefined} Undefined
         */
        _onVideoStateChange: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onVideoStateChange evtObj = ', evtObj);

            if (!this.akamaiPlugin) {return;}

            var newState = evtObj.payload.newState;

            if (newState === uvpjs.mediaCapabilities.BUFFERING && !this.buffering){
                this.buffering = true;
                this.akamaiPlugin.handleBufferStart();
            }

            if (newState === uvpjs.mediaCapabilities.PLAYING && this.buffering){
                this.buffering = false;
                this.akamaiPlugin.handleBufferEnd();
            }

        },

        /**
         *
         * @param {Object} evtObj UVPJS event object.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         *
         */

        _onResourceEnd: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onResourceEnd evtObj = ', evtObj);

            if (!this.akamaiPlugin) {return;}

            var endReasonCode = 'Play.End.Detected';
            this.akamaiPlugin.handlePlayEnd(endReasonCode);
            //this.akamaiPlugin.handleError(errorCode);
        },

        /**
         *
         * @param {Object} evtObj UVPJS event object.
         * @memberof uvpjs.AkamaiAnalyticsAgent#
         *
         */

        _onQosMetadata: function(evtObj) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'AkamaiAnalyticsAgent _onQosMetadata evtObj = ', evtObj);
            var name, params;

            if (!this.akamaiPlugin) {return;}

            // check this is intended for Akamai
            if (evtObj.payload.vendorArray.indexOf(uvpjs.Type.QOSVendor.AKAMAI) === -1) {return;}

            // set metadata
            params = evtObj.payload.paramsObj;

            for (name in params){
                this.akamaiPlugin.setData(name, params[name]);
            }
        }

    });

    _isPluginAbsent = function() {
        return typeof AkaHTML5MediaAnalytics === 'undefined';
    };

}(uvpjs.register('uvpjs')));
(function (obj) {
    'use strict';

    var _ = obj._;

    obj.MuxAgent = uvpjs.Class.subClass({
        MUX_AD_EVENTS: {
            AD_BREAK_START: 'adbreakstart',
            AD_BREAK_END: 'adbreakend',
            AD_PLAY: 'adplay',
            AD_PLAYING: 'adplaying',
            //AD_RESUMED
            AD_PAUSE: 'adpause',
            //AD_SKIPPED
            AD_ENDED: 'adended',
            AD_ERROR: 'aderror',
            AD_REQUEST: 'adrequest',
            AD_RESPONSE: 'adresponse',
            AD_FIRST_QUARTILE: 'adfirstquartile',
            AD_MIDPOINT: 'admidpoint',
            AD_THIRD_QUARTILE: 'adthirdquartile'
        },
        MUX_EVENTS: {
            PAUSE: 'pause',
            PLAY: 'play',
            PLAYING: 'playing'
        },
        MUX_DEFAULT_PROPERTY_KEY: 'ec83cce4c209447a2af3d62f2',

        /**
         * Performs Quality of Service (QOS) monitoring using Mux SDK.
         * @constructor uvpjs.MuxAgent
         *
         * @param {Object}                  options
         * @param {uvpjs.TrackingManager}   options.trackingMgr TrackingManager instance.
         *                                  NOTE: Remove in the future to decouple parent from child.
         * @param {uvpjs.CVI_Model}         options.cviModel    CVIModel instance.
         * @param {uvpjs.EventsManager}     options.eventTypes  EventsManager event types.
         * @param {String}                  options.moduleName  Mux config module name.
         * @param {String}                  options.playerName  UVPJS player name.
         * @param {String}                  options.playerVersion  UVPJS player version.
         * @param {String}                  options.useDefaultProperty If the default propertyKey should be used instead of the value from UVPC
         */
        init: function (options) {
            this.cviModel = options.cviModel;
            this.debug = this._isDebugEnabled();
            this.DEBUG_ID = uvpjs.DebugManager.configParams.MUX_DEBUG;

            this.debug && uvpjs.log(this.DEBUG_ID, 'MuxAgent: construct', options);

            this.trackingMgr = options.trackingMgr;

            // eventsMgr is null on "first" instantiation (will go away when SDK loader in play)
            this.eventTypes = (options.eventsMgr && options.eventsMgr.eventTypes) || null;
            this.moduleName = options.moduleName;
            this.playerName = options.playerName;
            this.playerVersion = options.playerVersion;
            this.useDefaultProperty = options.useDefaultProperty;

            this.moduleParams = null;

            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;

            this.vidContId = this.trackingMgr.vidContId;
            this.videoElement = null;
            this.muxMonitor = null;

            this.mc = uvpjs.mediaCapabilities;
        },

        /**
         * Destroys agent and Mux client, if active
         * @memberof uvpjs.MuxAgent#
         */
        destroy: function () {
            this.muxMonitor && this.muxMonitor.destroy();

            this.trackingMgr = null;
            this.cviModel = null;
            this.eventTypes = null;
            this.moduleParams = null;

            this.isPluginLoaded = false;
            this.pluginLoadedCB = Function.prototype;
        },

        /**
         * Initialize agent
         * @memberof uvpjs.MuxAgent#
         */
        initialize: function () {
            this.debug && uvpjs.log(this.DEBUG_ID, 'MuxAgent initialize()');

            this.moduleParams = this._gatherModuleParams(this.moduleName);

            this.loadPlugin(this._initializePlugin.bind(this));
        },

        /**
         * Load plugin into the page.
         * @memberof uvpjs.MuxAgent#
         */
        loadPlugin: function (callback) {
            if (typeof callback !== 'function') {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'MuxAgent loadPlugin: no callback supplied.');

                return;
            }

            this.pluginLoadedCB = function () {
                this.isPluginLoaded = true;
                callback();
            }.bind(this);

            // Load if SDK not loaded
            if (window.mux === undefined && !this.muxMonitor) {
                this.codeLoader = new uvpjs.CodeLoader();
                this.codeLoader.loadScript(uvpjs.MuxAgent.SDK_PATH, this.pluginLoadedCB);

                return;
            }

            this.pluginLoadedCB();
        },

        //////////////////
        // Private

        /**
         * Checks if debug logging is enabled for Mux in UVPJSDebug module
         * @private
         *
         * @memberof uvpjs.MuxAgent#
         */
        _isDebugEnabled: function() {
            if (!this.cviModel) return uvpjs.debug;
            var debugParams = this._gatherModuleParams(uvpjs.DebugManager.CONFIG_MODULE_NAME);
            if (!debugParams) return false;
            return debugParams[uvpjs.DebugManager.configParams.MUX_DEBUG] === true;
        },

        /**
         * Creates Mux monitor
         * @private
         *
         * @memberof uvpjs.MuxAgent#
         */
        _initializePlugin: function () {
            if (window.mux === undefined) {
                this.debug && uvpjs.warn(this.DEBUG_ID, 'MuxAgent _initializePlugin Mux SDK not properly loaded.');

                return;
            }

            if (this.cviModel) {
                this._setupEventCallbacks();
                // Delay Mux monitor create until first CONTENT_LOAD event
            }
        },

        // Mux initialization
        /**
         * @private
         *
         * @returns {Mux.monitor}
         *
         * @memberof uvpjs.MuxAgent#
         */
        _createMuxMonitor: function() {
            this.videoElement = document.getElementById('video_' + this.vidContId);

            var mdl = this.cviModel,
                mp = this.moduleParams;

            var muxData = _.assign({
                page_type: '', // (see docs) 'watchpage', 'iframe', or leave empty
                viewer_user_id: mdl.getSessionOption('userId'), // ex: '12345'
                experiment_name: mp && !uvpjs.util.isEmpty(mp.experimentName) ? mp.experimentName : '', // ex: 'player_test_A'
                sub_property_id: (this.useDefaultProperty === false && !uvpjs.util.isEmpty(mp.subPropertyId)) ? mp.subPropertyId : mdl.getSessionOption('partner'),

                // Player Metadata
                player_name: this.playerName, // ex: 'My Main Player'
                player_version: this.playerVersion, // ex: '1.0.0'
                player_init_time: mdl.initTime, // ex: 1451606400000
            }, this._getMuxVideoData());

            // Setup the propertyKey
            if (this.useDefaultProperty) {
                muxData.property_key = this.MUX_DEFAULT_PROPERTY_KEY;
            } else {
                muxData.property_key = mp.propertyKey;
            }

            window.mux.monitor(this.videoElement, {
                debug: this.debug,
                data: muxData
            });

            return this.videoElement.mux;
        },

        /**
         * Returns an object descibing the current asset/video in the format expected by Mux
         * @private
         *
         * @returns {Object} Muc formatted video data object
         *
         * @memberof uvpjs.MuxAgent#
         */
        _getMuxVideoData: function() {
            var videoState = this.cviModel.contentVideoState;
            return {
                // Video Metadata (cleared with 'videochange' event)
                video_id: this._validateStr(videoState.cmsRefGuid, ''), // ex: 'abcd123'
                video_title: this._validateStr(videoState.videoTitle, ''), // ex: 'My Great Video'
                video_series: this._validateStr(videoState.seriesTitle, ''), // ex: 'Weekly Great Videos'
                video_producer: '', // ex: 'Bob the Producer'
                video_content_type: !!videoState.episodeFlag ? 'episode' : 'clip', // 'short', 'movie', 'episode', 'clip', 'trailer', or 'event'
                video_language_code: '', // ex: 'en'
                video_variant_name: '', // ex: 'Spanish Hard Subs'
                video_variant_id: '', // ex: 'abcd1234'
                video_duration: videoState.duration, // in milliseconds, ex: 120000
                video_stream_type: videoState.isLive ? 'live' : 'on-demand', // 'live' or 'on-demand'
                video_encoding_variant: '', // ex: 'Variant 1'
                video_cdn: this._validateStr(videoState.cdn, ''), // ex: 'Fastly', 'Akamai',
                video_source_url: this._validateStr(videoState.assetURL, '')
            };
        },

        /**
         * Emits an event indicating the current video has changed to Mux
         * @private
         *
         *
         * @memberof uvpjs.MuxAgent#
         */
        _emitMuxVideoChange: function() {
            window.mux.emit(this.videoElement, 'videochange', this._getMuxVideoData());
        },

        /**
         * @private
         *
         * @param {String} str
         *
         * @returns {Boolean}
         *
         * @memberof uvpjs.MuxAgent#
         */
        _isValidStr: function(str) {
            return uvpjs.util.isDefinedString(str);
        },

        /**
         * If supplied string (str) is valid, return string, otherwise return the supplied default value (defValue)
         * @private
         *
         * @param {String} str
         * @param {String} defValue
         *
         * @returns {*}
         *
         * @memberof uvpjs.MuxAgent#
         */
        _validateStr: function(str, defValue) {
            return this._isValidStr(str) ? str : defValue;
        },

        // Event Handling

        /**
         * @private
         *
         * @param {Object} e Event data object.
         *
         * @memberof uvpjs.MuxAgent#
         */
        _onContentEvent: function(e) {
            if (e.type === this.eventTypes.CONTENT_DATA_LOADED) {
                if (this.muxMonitor === null) {
                    this.muxMonitor = this._createMuxMonitor();

                    if (this.muxMonitor !== null) {
                        this.debug && uvpjs.log(this.DEBUG_ID, "MuxAgent: created Mux monitor.");
                    }
                } else {
                    this._emitMuxVideoChange();
                }
            }
        },

        /**
         * Handle all errors.
         * @param {Object} e event object with payload property
         * @memberof uvpjs.MuxAgent#
         * @private
         */
        _onError: function(e) {
            var errorInfo = e.payload.errorInfo;
            // Currently Mux only supports Fatal error tracking
            if (!errorInfo || !errorInfo.isFatal) return;

            // Make sure that the muxMonitor has been setup before emitting the error
            if (this.muxMonitor === null) {
                this.muxMonitor = this._createMuxMonitor();
            }

            window.mux.emit(this.videoElement, 'error', {
                player_error_code: errorInfo.errorCode,
                player_error_message: errorInfo.message
            });
        },

        /**
         * Module params hold Mux property key
         * @private
         *
         * @memberof uvpjs.MuxAgent#
         */
        _gatherModuleParams: function (moduleName) {
            var model = this.cviModel,
                module = model.getModule(moduleName),
                mp = module.params,
                params = {}, p;

            if (!mp) return null;
            var i = mp.length;

            while (i--) {
                p = mp[i];
                params[p.name] = p.value;
            }

            return params;
        },

        /**
         * Assigns callbacks to specified events and registers them with the Tracking Manager.
         *
         * @private
         *
         * @memberof uvpjs.MuxAgent#
         */
        _setupEventCallbacks: function () {
            var types = this.eventTypes,
                evtCbs = {},
                hc = this._onContentEvent.bind(this),
                he = this._onError.bind(this),
                ha = this._onAdEvent.bind(this);

            evtCbs[types.CONTENT_DATA_LOADED] = hc;

            evtCbs[types.PLAYER_START_ERROR] = he;
            evtCbs[types.VIDEO_START_ERROR] = he;
            evtCbs[types.VIDEO_PLAYBACK_ERROR] = he;
            evtCbs[types.AD_ERROR] = he;

            evtCbs[types.AD_PLUGIN_CONTENT_PAUSE_REQUEST] = ha; // adbreakstart
            evtCbs[types.AD_PLUGIN_CONTENT_RESUME_REQUEST] = ha; // adbreakend

            evtCbs[types.AD_LOADED] = ha; // adplay
            evtCbs[types.AD_START] = ha; // adplaying
            // AdEvent.Type.RESUMED - emit `adplay` followed (immediately) by `adplaying`.
            // adpause
            evtCbs[types.VIDEO_STATE_CHANGE] = ha;
            evtCbs[types.AD_SKIPPED] = ha; // adended (skip)
            evtCbs[types.AD_END] = ha; // adended (complete)
            evtCbs[types.AD_ERROR] = ha; // aderror
            evtCbs[types.AD_REQUEST] = ha; // adrequest
            evtCbs[types.AD_RESPONSE] = ha; // adresponse

            evtCbs[types.AD_QUARTILE] = ha; // adfirstquartile, admidpoint, adthirdquartile

            this.trackingMgr.registerEventCallbacks(evtCbs);
        },

        // Ad Tracking integration
        /**
         * Returns an object containing the current ad tag & ad asset url for Mux ad events
         * @private
         *
         * @returns {Object} Object containing ad tag url & ad asset url
         *
         * @memberof uvpjs.MuxAgent#
         */
        _getMuxAdData: function(e) {
            var adAssetUrl = e.payload.adData ? e.payload.adData.adAssetUrl : e.payload.adAssetUrl;
            return {
                ad_tag_url: e.payload.adCallUrl,
                ad_asset_url: adAssetUrl
            };
        },

        /**
         * Dispatches an event to Mux for an Ad Event
         * @private
         * @param {string} eventName Name of the event to fire
         * @param {Object} data Data object to pass only with the event
         *
         * @memberof uvpjs.MuxAgent#
         */
        _dispatchMuxAdEvent: function(eventName, data) {
            if (!eventName) return;
            if (!data) {
                data = {
                    ad_tag_url: '',
                    ad_asset_url: ''
                };
            }
            if (!data.ad_tag_url) {
                data.ad_tag_url = '';
            }
            if (!data.ad_asset_url) {
                data.ad_asset_url = '';
            }
            window.mux.emit(this.videoElement, eventName, data);
        },

        /**
         * Dispatches an event to Mux for an non-Ad (pause or play) event
         * @private
         * @param {string} eventName Name of the event to fire
         *
         * @memberof uvpjs.MuxAgent#
         */
        _dispatchMuxEvent: function(eventName) {
            window.mux.emit(this.videoElement, eventName);
        },

        /**
         * Handles uvpjs ad events and dispatches the corresponding Mux events
         * @private
         * @param {Object} e uvpjs Ad Event object
         *
         * @memberof uvpjs.MuxAgent#
         */
        _onAdEvent: function(e) {
            var types = this.eventTypes,
            muxAdEvents = this.MUX_AD_EVENTS,
            muxEvents = this.MUX_EVENTS;

            switch(e.type) {
                case types.AD_PLUGIN_CONTENT_PAUSE_REQUEST:
                    if (this.cviModel.contentPlaybackState.playbackState === uvpjs.mediaCapabilities.PLAYING) {
                        this._dispatchMuxEvent(muxEvents.PAUSE);
                    }
                    this._dispatchMuxAdEvent(muxAdEvents.AD_BREAK_START);
                    break;
                case types.AD_PLUGIN_CONTENT_RESUME_REQUEST:
                    this._dispatchMuxAdEvent(muxAdEvents.AD_BREAK_END);
                    if (this.cviModel.contentPlaybackState.playbackState === uvpjs.mediaCapabilities.PLAYING) {
                        this._dispatchMuxEvent(muxEvents.PLAY);
                        this._dispatchMuxEvent(muxEvents.PLAYING);
                    }
                    break;
                case types.AD_LOADED:
                    this._dispatchMuxAdEvent(muxAdEvents.AD_PLAY, this._getMuxAdData(e));
                    break;
                case types.AD_START:
                    this._dispatchMuxAdEvent(muxAdEvents.AD_PLAYING, this._getMuxAdData(e));
                    break;
                case types.VIDEO_STATE_CHANGE:
                    if (!e.payload.isAd) return;
                    var newState = e.payload.newState,
                        currentState = e.payload.currentState;
                    if (newState === this.mc.PAUSED) {
                        this._dispatchMuxAdEvent(muxAdEvents.AD_PAUSE, this._getMuxAdData(e));
                    }
                    else if (currentState == this.mc.PAUSED && newState === this.mc.PLAYING) {
                        this._dispatchMuxAdEvent(muxAdEvents.AD_PLAY, this._getMuxAdData(e));
                        this._dispatchMuxAdEvent(muxAdEvents.AD_PLAYING, this._getMuxAdData(e));
                    }
                    break;
                case types.AD_SKIPPED:
                    this._dispatchMuxAdEvent(muxAdEvents.AD_ENDED, this._getMuxAdData(e));
                    break;
                case types.AD_END:
                    this._dispatchMuxAdEvent(muxAdEvents.AD_ENDED, this._getMuxAdData(e));
                    break;
                case types.AD_ERROR:
                    this._dispatchMuxAdEvent(muxAdEvents.AD_ERROR, this._getMuxAdData(e));
                    break;
                case types.AD_REQUEST:
                    this._dispatchMuxAdEvent(muxAdEvents.AD_REQUEST, this._getMuxAdData(e));
                    break;
                case types.AD_RESPONSE:
                    this._dispatchMuxAdEvent(muxAdEvents.AD_RESPONSE, this._getMuxAdData(e));
                    break;
                case types.AD_QUARTILE:
                    var percent = e.payload.percent;
                    switch (percent) {
                        case 25:
                            this._dispatchMuxAdEvent(muxAdEvents.AD_FIRST_QUARTILE, this._getMuxAdData(e));
                            break;
                        case 50:
                            this._dispatchMuxAdEvent(muxAdEvents.AD_MIDPOINT, this._getMuxAdData(e));
                            break;
                        case 75:
                            this._dispatchMuxAdEvent(muxAdEvents.AD_THIRD_QUARTILE, this._getMuxAdData(e));
                            break;
                    }
                    break;
            }
        },
    });

    obj.MuxAgent.SDK_PATH = uvpjs.Configuration.path + 'lib/tracking/mux.js';

}(uvpjs.register('uvpjs')));
/**
 * BeaconBuilder is a utility class used to assemble arbitrary key value pairs
 * into a formatted beacon url.
 * To support additional beacon end points, be sure to declare uri options
 * in "beaconUri" for the new beacon and create a setter for the new options.
 * See "concurrencyBeacon" uri options and accompanying method for usage.
 */

'use strict';

(function (obj) {
    /**
     * An object containing URI options for different beacon types.
     * @var {Object} beaconUri
     * @private
     */
    var beaconUri = {
        concurrencyBeacon: {
            prodUrl: '//sparrow.cbs.com',
            stageUrl: '//stage-sparrow.cbs.com',
            path: '/streamer/v1.0/ingest/beacon.json'
        }
    },

    /**
     * Used to determine Production vs. Staging environments.
     * @var {Boolean} isDevMode
     * @private
     */
    isDevMode = false,

    /**
     * The value of the query string after it is assembled.
     * @var {String} queryString
     * @private
     */
    queryString = null,

    /**
     * Object representing the uri options for the current beacon.
     * @var {Object} uriOptions
     * @private
     */
    uriOptions = null,

    /**
     * Safety check for end points not containing forwardslashes.
     * Also trims spaces. Ex: '//sparrow.cbsallaccess.ca'
     * @param {Object} url
     * @memberof uvpjs.BeaconBuilder
     * @returns {String}
     * @private
     */
    fixForwardSlashes = function(url) {
        url = url.replace(/\s/g, '');

        if (url.search(/^\/\//) > -1) {
            return url;
        }

        return '//' + url;
    };

    /**
     * Creates a new instance of BeaconBuilder.
     * @constructor uvpjs.BeaconBuilder
     * @extends uvpjs
     * @since 2.8.2
     */
    obj.BeaconBuilder = uvpjs.Class.subClass({
        /**
         * Sets the uri options for the concurrency beacon.
         * @memberof uvpjs.BeaconBuilder#
         * @returns {Object}
         */
        concurrencyBeacon: function(options) {
            uriOptions = beaconUri.concurrencyBeacon;

            if (options && options.prodUrl && options.stageUrl) {
                uriOptions.prodUrl  = fixForwardSlashes(options.prodUrl);
                uriOptions.stageUrl = fixForwardSlashes(options.stageUrl);
            }

            return this;
        },

        /**
         * Assembles the query string with the supplied parameters.
         * @param {Object} params - parameters for the query string.
         * @memberof uvpjs.BeaconBuilder#
         * @returns {Object}
         */
        queryParams: function(params) {
            queryString = obj.util.queryStrFromObj(params, false);

            return this;
        },

        /**
         * Sets the dev mode using the debug flag.
         * @param {Boolean} devMode - debug flag.
         * @memberof uvpjs.BeaconBuilder#
         * @returns {Object}
         */
        devMode: function(devMode) {
            isDevMode = devMode;
            return this;
        },

        /**
         * Assembles the beacon url using the uri options and query string.
         * @memberof uvpjs.BeaconBuilder#
         * @returns {String}
         */
        buildUrl: function() {
            if (uriOptions === null) {
                return "Unable to build url.";
            }

            return (isDevMode ? uriOptions.stageUrl : uriOptions.prodUrl)
                    + uriOptions.path
                    + (queryString === null ? '' : '?' + queryString) ;
        }
    });
} (uvpjs.register('uvpjs')));

/**
 * Implements Apple FairPlay DRM
 * For Safari Desktop 9+ on OS X 10.10+
 */

'use strict';

(function (obj) {

    var _ = obj._;

    obj.FairPlayDRM = uvpjs.Class.subClass({
        DEBUG_ID: uvpjs.DebugManager.configParams.FAIRPLAY_DRM,

        /**
         * Initialize FairPlayDRM and register events
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {Object} options Options object
         * @param {Object} options.drm DRM configuration object
         * @param {Object} options.videoTagRef Reference to the <video> element for the current player
         * @param {Object} options.eventTypes Object of eventTypes for uvpjs
         * @param {Function} options.errorCallback Callback function to call when an error is encountered
         */
        init: function (options) {
            this.debug = uvpjs.debug;
            if (this.debug) {
                uvpjs.log(this.DEBUG_ID, 'FairPlayDRM Init');
            }

            this.drm = options.drm;
            this.videoTagRef = options.videoTagRef;
            this.eventTypes = options.eventTypes;
            this.errorCallback = options.errorCallback;

            this.appCertData = null;
            this.appCertLoaded = false;

            this.webKitNeedKeyCalled = false;
            this.initData = null;

            this._loadAppCert();
            this._addEvents();
        },

        /**
         * Cleanup FairPlayDRM and de-register events
         * @memberof uvpjs.FairPlayDRM#
         */
        destroy: function() {
            this._removeEvents();
            this.drm = null;
            this.videoTagRef = null;
            this.eventTypes = null;
            this.errorCallback = null;
            this.appCertData = null;
            this.initData = null;
        },

        // Private

        /**
         * Makes an XHR request to load the FairPlay Application Certificate
         * Registers handlers _onAppCertLoaded/Error to handle response/errors
         * @memberof uvpjs.FairPlayDRM#
         */
        _loadAppCert: function() {
            var appCertURL = this.drm.fairplay.appCertURL;
            if (!appCertURL) return;

            var cl = new uvpjs.CodeLoader();
            cl.loadArrayBuffer(appCertURL,  this._onAppCertLoaded.bind(this),  this._onAppCertError.bind(this));
        },

        /**
         * Registers an event handler for the 'webkitneedkey' event
         * This event fires after an HLS manifest with FairPlay signaling
         * has been loaded as a src on a <video> element.
         * @memberof uvpjs.FairPlayDRM#
         */
        _addEvents: function() {
            this._onWebKitNeedKeyBound = this._onWebKitNeedKey.bind(this);
            this.videoTagRef.addEventListener(this.eventTypes.HTML5.WEBKIT_NEED_KEY, this._onWebKitNeedKeyBound, false);
        },

        /**
         * De-registers an event handler for the 'webkitneeskey' event
         * @memberof uvpjs.FairPlayDRM#
         */
        _removeEvents: function() {
            this.videoTagRef.removeEventListener(this.eventTypes.HTML5.WEBKIT_NEED_KEY, this._onWebKitNeedKeyBound, false);
            this._onWebKitNeedKeyBound = null;
        },

        /**
         * Handles 'webkitneedkey event'
         * Extracts/builds license server URL & content id.
         * Registers WebKitMediaKeys with correct Key System(com.apple.fps.1_0)
         * Creates webkitKeys sessions and pass in the combined initData(initData, contentId, appCertData)
         * Registers event handlers on the keySession
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {Object} event Event object
         * @param {Uint16Array} event.initData Initialization data for FairPlay CDM, includes URI from #EXT-X-KEY in HLS manifest
         */
        _onWebKitNeedKey: function(event) {
            this.webKitNeedKeyCalled = true;
            this.initData = event.initData;
            if (this.appCertLoaded) {
                this._initializeFairPlayCDM();
            }
        },

        _initializeFairPlayCDM: function() {
            var licenseServerUrl = this._getLicenseServerUrl(this.initData),
                contentId = this._getContentId(licenseServerUrl);
            this.debug && uvpjs.log(this.DEBUG_ID, 'FairPlayDRM _onWebKitNeedKey. licenseServerUrl = ' + licenseServerUrl + ', contentId = ' + contentId, event);
            if (!contentId) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'FairPlayDRM _onWebKitNeedKey. No ContentId in URI');
                this.errorCallback && this.errorCallback(uvpjs.ErrorInfo.errorCodes.FAIRPLAY_LIC_ERROR, uvpjs.ErrorInfo.messages.FAIRPLAY_NO_CONTENTID);
                return;
            }

            if (!this.videoTagRef.webkitKeys) {
                var keySystem;
                if (WebKitMediaKeys.isTypeSupported('com.apple.fps.1_0', 'video/mp4')) {
                    keySystem = 'com.apple.fps.1_0';
                } else {
                    this.debug && uvpjs.error(this.DEBUG_ID, 'FairPlayDRM _onWebKitNeedKey. Key System not supported');
                    this.errorCallback && this.errorCallback(uvpjs.ErrorInfo.errorCodes.FAIRPLAY_LIC_ERROR, uvpjs.ErrorInfo.messages.FAIRPLAY_KEYSYSTEM_NOT_SUPPORTED);
                    return;
                }
                this.videoTagRef.webkitSetMediaKeys(new WebKitMediaKeys(keySystem));
            }

            if (!this.videoTagRef.webkitKeys) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'FairPlayDRM _onWebKitNeedKey. Could not create MediaKeys');
                this.errorCallback && this.errorCallback(uvpjs.ErrorInfo.errorCodes.FAIRPLAY_LIC_ERROR, uvpjs.ErrorInfo.messages.FAIRPLAY_CREATE_MEDIAKEYS);
                return;
            }

            var initData = this._concatInitDataIdAndCertificate(this.initData, contentId, this.appCertData);
            var keySession = this.videoTagRef.webkitKeys.createSession('video/mp4', initData);
            if (!keySession) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'FairPlayDRM _onWebKitNeedKey. Could not create key session');
                this.errorCallback && this.errorCallback(uvpjs.ErrorInfo.errorCodes.FAIRPLAY_LIC_ERROR, uvpjs.ErrorInfo.messages.FAIRPLAY_CREATE_SESSION);
                return;
            }

            keySession.contentId = contentId;

            keySession.addEventListener('webkitkeymessage', this._onLicenseRequestReady.bind(this, licenseServerUrl), false);
            keySession.addEventListener('webkitkeyadded', this._onKeyAdded.bind(this), false);
            keySession.addEventListener('webkitkeyerror', this._onKeyError.bind(this), false);
        },

        /**
         * Handles Application Certificate successfully loading and stores the response
         * Binary data will be returned here so this.appCertData is a Uint8Array
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {Object} event Event object
         */
        _onAppCertLoaded: function(request) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'FairPlayDRM _onAppCertLoaded', request);
            this.appCertData = new Uint8Array(request.response);
            this.appCertLoaded = true;
            if (this.webKitNeedKeyCalled) {
                this._initializeFairPlayCDM();
            }
        },

        /**
         * Handles Application Certificate failing to load
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {Object} event Event object
         */
        _onAppCertError: function(request) {
            this.debug && uvpjs.error(this.DEBUG_ID, 'FairPlayDRM _onAppCertError', request);
            this.errorCallback && this.errorCallback(uvpjs.ErrorInfo.errorCodes.FAIRPLAY_APP_CERT_ERROR, uvpjs.ErrorInfo.messages.FAIRPLAY_APP_CERT_LOAD);
        },

        /**
         * Concats initData, contentId & appCert into single Uint8Array payload for video.webkitKeys.createSession
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {Uint8Array} initData Initialization data from webkitneedkey event
         * @param {String} id Content ID for the current asset
         * @param {Uint8Array} cert Application Certificate data
         *
         * @returns {Uint8Array} Initialization payload
         */
        _concatInitDataIdAndCertificate: function(initData, id, cert) {
            if (typeof id === 'string') {
                var string = id;
                var buffer = new ArrayBuffer(string.length*2); // 2 bytes for each char
                var array = new Uint16Array(buffer);
                for (var i=0, strLen=string.length; i<strLen; i++) {
                    array[i] = string.charCodeAt(i);
                }
                id = array;
            }
            // layout is [initData][4 byte: idLength][idLength byte: id][4 byte:certLength][certLength byte: cert]
            var offset = 0;
            var buffer = new ArrayBuffer(initData.byteLength + 4 + id.byteLength + 4 + cert.byteLength);
            var dataView = new DataView(buffer);

            var initDataArray = new Uint8Array(buffer, offset, initData.byteLength);
            initDataArray.set(initData);
            offset += initData.byteLength;

            dataView.setUint32(offset, id.byteLength, true);
            offset += 4;

            var idArray = new Uint16Array(buffer, offset, id.length);
            idArray.set(id);
            offset += idArray.byteLength;

            dataView.setUint32(offset, cert.byteLength, true);
            offset += 4;

            var certArray = new Uint8Array(buffer, offset, cert.byteLength);
            certArray.set(cert);

            return new Uint8Array(buffer, 0, buffer.byteLength);
        },

        /**
         * When FairPlay CDM is ready, build the SPC payload and send it to license server to get CKC for playback
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {String} licenseServerUrl URL of license server to send SPC to, for Irdecto, usually at the /getckc path
         * @param {Object} event Event object
         */
        _onLicenseRequestReady: function(licenseServerUrl, event) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'FairPlayDRM _onLicenseRequestReady, licenseServerUrl = ' + licenseServerUrl, event);

            var session = event.target;
            var message = event.message;

            var request = new XMLHttpRequest();
            var sessionId = event.sessionId;
            request.responseType = 'arraybuffer';
            request.session = session;

            request.addEventListener('load', this._onLicenseRequestLoaded.bind(this), false);
            request.addEventListener('error', this._onLicenseRequestError.bind(this), false);

            // Build the SPC payload, binary message data must be Base64 encoded and then URL escaped
            var params = 'spc=' + encodeURIComponent(this._base64EncodeUint8Array(message));
            request.open('POST', licenseServerUrl, true);
            request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');

            request.send(params);
        },

        /**
         * Encode a Uint8Aray of data as a Base 64 string
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {Uint8Array} input Unit8Array data
         *
         * @returns {String} Base64 encoded string
         */
        _base64EncodeUint8Array: function(input) {
            var str = String.fromCharCode.apply(null, input);
            return btoa(str);
        },

        /**
         * Handles CKC being returned and passes it on to the FairPlay session
         * Calls session.update with a Uint8Array representing the binary data returned as the CKC
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {event} event Event object
         */
        _onLicenseRequestLoaded: function(event) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'FairPlayDRM _onLicenseRequestLoaded', event);
            var request = event.target;

            if (!_.inRange(request.status, 200, 400)) {
                this.debug && uvpjs.error(this.DEBUG_ID, 'FairPlayDRM _onLicenseRequestLoaded, error response code for license request', request.status);
                this.errorCallback && this.errorCallback(uvpjs.ErrorInfo.errorCodes.FAIRPLAY_LIC_ERROR, uvpjs.ErrorInfo.messages.FAIRPLAY_LIC_RESPONSE_CODE);
            }

            var session = request.session;
            session.update(new Uint8Array(request.response));
        },

        /**
         * Handles an error while loading the CKC
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {event} event Event object
         */
        _onLicenseRequestError: function(event) {
            this.debug && uvpjs.error(this.DEBUG_ID, 'FairPlayDRM _onLicenseRequestError', event);
            this.errorCallback && this.errorCallback(uvpjs.ErrorInfo.errorCodes.FAIRPLAY_LIC_ERROR, uvpjs.ErrorInfo.messages.FAIRPLAY_LIC_REQUEST);
        },

        /**
         * Handles a new key/CKC successfully being loaded into the FairPlay CDM
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {event} event Event object
         */
        _onKeyAdded: function(event) {
            this.debug && uvpjs.log(this.DEBUG_ID, 'FairPlayDRM _onKeyAdded', event);
        },

        /**
         * Handles an error while trying to load a key/CKC into the FairPlay CDM
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {event} event Event object
         */
        _onKeyError: function(event) {
            this.debug && uvpjs.error(this.DEBUG_ID, 'FairPlayDRM _onKeyError', event);
            this.errorCallback && this.errorCallback(uvpjs.ErrorInfo.errorCodes.FAIRPLAY_LIC_ERROR, uvpjs.ErrorInfo.messages.FAIRPLAY_KEY_ERROR);
        },

        /**
         * Parses the FairPlay initData and constructs a license server URL
         * skd:// is swapped to https://
         * If sessionID or ticket are set on the contentVideoState.drm they are appened to the URL
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {Uint16Array} initData Inititialization data from webkitneedkey, usually contains the URI from HLS manifest
         *
         * @returns {String} URL for the license server, this is usually a /getckc URL for Irdeto
         */
        _getLicenseServerUrl: function(initData) {
            var initDataString = String.fromCharCode.apply(null, new Uint16Array(initData.buffer));

            var splitString = initDataString.split('://');
            var url = 'https://' + splitString[1];

            var sessionId = this.drm.sessionId,
                ticket = this.drm.ticket;

            if (sessionId) {
                url += '&SessionId=' + sessionId;
            }

            if (ticket) {
                url += '&Ticket=' + ticket;
            }

            return url;
        },

        /**
         * Extracts the ContentId value from a license server URL
         * @memberof uvpjs.FairPlayDRM#
         *
         * @param {String} licenseServerUrl License server URL
         *
         * @returns {String} Content Id value
         */
        _getContentId: function(licenseServerUrl) {
            var qObj = uvpjs.util.objFromQueryStr(licenseServerUrl);
            return qObj.ContentId || null;
        }
    });

}(uvpjs.register('uvpjs')));
})();
